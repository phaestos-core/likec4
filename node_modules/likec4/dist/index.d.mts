import { LiteralUnion, Tagged, TupleToUnion, NonEmptyTuple, Class, IsNumericLiteral, IfNever, Simplify, SetRequired, ValueOf, ConditionalPick } from 'type-fest';

type NonEmptyArray<T> = [T, ...T[]];
type IconUrl = Tagged<string, 'IconUrl'> | 'none';
type CustomColor$1 = string;
type Point = readonly [x: number, y: number];
interface XYPoint {
    x: number;
    y: number;
}

declare const ThemeColors: readonly ["amber", "blue", "gray", "slate", "green", "indigo", "muted", "primary", "red", "secondary", "sky"];
type ThemeColor$1 = typeof ThemeColors[number];
type HexColorLiteral = `#${string}`;
type ColorLiteral = HexColorLiteral;
type Color$1 = LiteralUnion<ThemeColor$1, string>;
interface ElementThemeColorValues {
    fill: ColorLiteral;
    stroke: ColorLiteral;
    hiContrast: ColorLiteral;
    loContrast: ColorLiteral;
}
interface RelationshipThemeColorValues {
    lineColor: ColorLiteral;
    labelBgColor: ColorLiteral;
    labelColor: ColorLiteral;
}
interface ThemeColorValues {
    elements: ElementThemeColorValues;
    relationships: RelationshipThemeColorValues;
}

type Fqn$1<Id extends string = string> = Tagged<Id, 'Fqn'>;
declare const BorderStyles: readonly ["solid", "dashed", "dotted", "none"];
type BorderStyle = TupleToUnion<typeof BorderStyles>;
type ElementKind$1<Kinds extends string = string> = Tagged<Kinds, 'ElementKind'>;
declare namespace ElementKind$1 {
    const Group: ElementKind$1;
}
declare const ElementShapes: readonly ["rectangle", "person", "browser", "mobile", "cylinder", "storage", "queue"];
type ElementShape$1 = TupleToUnion<typeof ElementShapes>;
interface ElementStyle {
    border?: BorderStyle;
    opacity?: number;
}
type Tag$1<Tags extends string = string> = Tagged<Tags, 'Tag'>;
interface Link {
    readonly title?: string;
    readonly url: string;
    readonly relative?: string;
}
interface TypedElement<Ids extends string, Kinds extends string, Tags extends string, MetadataKeys extends string = never> {
    readonly id: Fqn$1<Ids>;
    readonly kind: ElementKind$1<Kinds>;
    readonly title: string;
    readonly description: string | null;
    readonly technology: string | null;
    readonly tags: NonEmptyArray<Tag$1<Tags>> | null;
    readonly links: NonEmptyArray<Link> | null;
    readonly icon?: IconUrl;
    readonly shape?: ElementShape$1;
    readonly color?: Color$1;
    readonly style?: ElementStyle;
    readonly notation?: string;
    readonly metadata?: Record<MetadataKeys, string>;
}
interface Element$1 extends TypedElement<string, string, string, string> {
}
interface ElementKindSpecificationStyle {
    shape?: ElementShape$1;
    icon?: IconUrl;
    color?: Color$1;
    border?: BorderStyle;
    opacity?: number;
}
interface ElementKindSpecification {
    readonly technology?: string;
    readonly notation?: string;
    readonly style: ElementKindSpecificationStyle;
}

type EqualOperator<V> = {
    eq: V;
    neq?: never;
} | {
    eq?: never;
    neq: V;
};
type AllNever = {
    not?: never;
    and?: never;
    or?: never;
    tag?: never;
    kind?: never;
};
type TagEqual<Tag> = Omit<AllNever, 'tag'> & {
    tag: EqualOperator<Tag>;
};
type KindEqual<Kind> = Omit<AllNever, 'kind'> & {
    kind: EqualOperator<Kind>;
};
type NotOperator<Tag, Kind> = Omit<AllNever, 'not'> & {
    not: WhereOperator<Tag, Kind>;
};
type AndOperator<Tag, Kind> = Omit<AllNever, 'and'> & {
    and: NonEmptyArray<WhereOperator<Tag, Kind>>;
};
type OrOperator<Tag, Kind> = Omit<AllNever, 'or'> & {
    or: NonEmptyArray<WhereOperator<Tag, Kind>>;
};
type WhereOperator<Tag, Kind> = TagEqual<Tag> | KindEqual<Kind> | NotOperator<Tag, Kind> | AndOperator<Tag, Kind> | OrOperator<Tag, Kind>;

type GlobalPredicateId = Tagged<string, 'GlobalPredicateId'>;
type GlobalPredicates = NonEmptyArray<ViewRulePredicate$1>;
type GlobalDynamicPredicates = NonEmptyArray<DynamicViewIncludeRule>;
type GlobalStyleID = Tagged<string, 'GlobalStyleID'>;
type GlobalStyles = NonEmptyTuple<ViewRuleStyle$1>;
interface ModelGlobals {
    predicates: Record<GlobalPredicateId, GlobalPredicates>;
    dynamicPredicates: Record<GlobalPredicateId, GlobalDynamicPredicates>;
    styles: Record<GlobalStyleID, GlobalStyles>;
}

type ElementNotation = {
    kinds: ElementKind$1[];
    shape: ElementShape$1;
    color: Color$1;
    title: string;
};

type ViewID$1<Id extends string = string> = Tagged<Id, 'ViewID'>;
type ViewRulePredicate$1 = {
    include: Expression$1[];
    exclude?: never;
} | {
    include?: never;
    exclude: Expression$1[];
};
interface ViewRuleGlobalPredicateRef$1 {
    predicateId: GlobalPredicateId;
}
interface ViewRuleStyle$1 {
    targets: ElementExpression$1[];
    notation?: string;
    style: ElementStyle & {
        color?: Color$1;
        shape?: ElementShape$1;
        icon?: IconUrl;
    };
}
interface ViewRuleGlobalStyle$1 {
    styleId: GlobalStyleID;
}
type AutoLayoutDirection = 'TB' | 'BT' | 'LR' | 'RL';
interface ViewRuleAutoLayout$1 {
    direction: AutoLayoutDirection;
    nodeSep?: number;
    rankSep?: number;
}
interface ViewRuleGroup$1 {
    groupRules: Array<ViewRulePredicate$1 | ViewRuleGroup$1>;
    title: string | null;
    color?: Color$1;
    border?: BorderStyle;
    opacity?: number;
}
type ViewRule$1 = ViewRulePredicate$1 | ViewRuleGlobalPredicateRef$1 | ViewRuleGroup$1 | ViewRuleStyle$1 | ViewRuleGlobalStyle$1 | ViewRuleAutoLayout$1;
interface BasicView<ViewType extends 'element' | 'dynamic', ViewIDs extends string, Tags extends string> {
    readonly __?: ViewType;
    readonly id: ViewID$1<ViewIDs>;
    readonly title: string | null;
    readonly description: string | null;
    readonly tags: NonEmptyArray<Tag$1<Tags>> | null;
    readonly links: NonEmptyArray<Link> | null;
    /**
     * URI to the source file of this view.
     * Undefined if the view is auto-generated.
     */
    readonly docUri?: string;
    /**
     * For all views we find common ancestor path.
     * This is used to generate relative paths, i.e.:
     * - "/home/project/index.c4" becomes "index.c4"
     * - "/home/project/subdir/views.c4" becomes "subdir/views.c4"
     *
     * Undefined if the view is auto-generated.
     */
    readonly relativePath?: string;
    /**
     * If the view is changed manually this field contains the layout data.
     */
    readonly manualLayout?: ViewManualLayout | undefined;
    readonly customColorDefinitions: CustomColorDefinitions;
}
interface BasicElementView<ViewIDs extends string, Tags extends string> extends BasicView<'element', ViewIDs, Tags> {
    readonly viewOf?: Fqn$1;
    readonly rules: ViewRule$1[];
}
interface ScopedElementView<ViewIDs extends string, Tags extends string> extends BasicElementView<ViewIDs, Tags> {
    readonly viewOf: Fqn$1;
}
interface ExtendsElementView<ViewIDs extends string, Tags extends string> extends BasicElementView<ViewIDs, Tags> {
    readonly extends: ViewID$1<ViewIDs>;
}
type ElementView$1<ViewIDs extends string = string, Tags extends string = string> = ScopedElementView<ViewIDs, Tags> | ExtendsElementView<ViewIDs, Tags> | BasicElementView<ViewIDs, Tags>;
interface DynamicViewStep$1 {
    readonly source: Fqn$1;
    readonly target: Fqn$1;
    readonly title: string | null;
    readonly description?: string;
    readonly technology?: string;
    readonly notation?: string;
    readonly notes?: string;
    readonly color?: Color$1;
    readonly line?: RelationshipLineType;
    readonly head?: RelationshipArrowType;
    readonly tail?: RelationshipArrowType;
    readonly isBackward?: boolean;
    readonly navigateTo?: ViewID$1;
    __parallel?: never;
}
interface DynamicViewParallelSteps$1 {
    readonly __parallel: DynamicViewStep$1[];
}
type DynamicViewStepOrParallel = DynamicViewStep$1 | DynamicViewParallelSteps$1;
type DynamicViewIncludeRule = {
    include: ElementPredicateExpression[];
};
type DynamicViewRule$1 = DynamicViewIncludeRule | ViewRuleGlobalPredicateRef$1 | ViewRuleStyle$1 | ViewRuleGlobalStyle$1 | ViewRuleAutoLayout$1;
interface DynamicView$1<ViewIDs extends string = string, Tags extends string = string> extends BasicView<'dynamic', ViewIDs, Tags> {
    readonly __: 'dynamic';
    readonly steps: DynamicViewStepOrParallel[];
    readonly rules: DynamicViewRule$1[];
}
type CustomColorDefinitions = {
    [key: string]: ThemeColorValues;
};
type LikeC4View$1<ViewIDs extends string = string, Tags extends string = string> = ElementView$1<ViewIDs, Tags> | DynamicView$1<ViewIDs, Tags>;
type NodeId<IDs extends string = string> = Tagged<IDs, 'Fqn'>;
type EdgeId$1 = Tagged<string, 'EdgeId'>;
type StepEdgeIdLiteral = `step-${number}` | `step-${number}.${number}`;
type StepEdgeId = Tagged<StepEdgeIdLiteral, 'EdgeId'>;
declare function StepEdgeId(step: number, parallelStep?: number): StepEdgeId;
declare function isStepEdgeId(id: string): id is StepEdgeId;
declare function extractStep(id: EdgeId$1): number;
interface ComputedNode {
    id: NodeId;
    kind: ElementKind$1;
    parent: NodeId | null;
    title: string;
    description: string | null;
    technology: string | null;
    notation?: string;
    tags: NonEmptyArray<Tag$1> | null;
    links: NonEmptyArray<Link> | null;
    children: NodeId[];
    inEdges: EdgeId$1[];
    outEdges: EdgeId$1[];
    shape: ElementShape$1;
    /**
     * @deprecated Use `style` instead
     */
    color: Color$1;
    /**
     * @deprecated Use `style` instead
     */
    icon?: IconUrl;
    style: ElementStyle;
    navigateTo?: ViewID$1;
    level: number;
    depth?: number;
    /**
     * If this node was customized in the view
     */
    isCustomized?: boolean;
}
declare namespace ComputedNode {
    /**
     * Nodes group is a special kind of node, exisiting only in view
     */
    function isNodesGroup(node: ComputedNode): boolean;
}
interface ComputedEdge {
    id: EdgeId$1;
    parent: NodeId | null;
    source: NodeId;
    target: NodeId;
    label: string | null;
    description?: string;
    technology?: string;
    relations: RelationID$1[];
    kind?: RelationshipKind$1;
    notation?: string;
    notes?: string;
    color?: Color$1;
    line?: RelationshipLineType;
    head?: RelationshipArrowType;
    tail?: RelationshipArrowType;
    tags?: NonEmptyArray<Tag$1>;
    navigateTo?: ViewID$1;
    /**
     * If this edge is derived from custom relationship predicate
     */
    isCustomized?: boolean;
    /**
     * For layouting purposes
     * @default 'forward'
     */
    dir?: 'forward' | 'back';
}
interface ViewWithHash {
    /**
     * Hash of the view object.
     * This is used to detect changes in layout
     */
    hash: string;
}
interface ViewWithNotation {
    notation?: {
        elements: ElementNotation[];
    };
}
interface ViewAutoLayout {
    direction: ViewRuleAutoLayout$1['direction'];
    rankSep?: number;
    nodeSep?: number;
}
interface ComputedElementView<ViewIDs extends string = string, Tags extends string = string> extends Omit<ElementView$1<ViewIDs, Tags>, 'rules' | 'docUri'>, ViewWithHash, ViewWithNotation {
    readonly extends?: ViewID$1<ViewIDs>;
    readonly autoLayout: ViewAutoLayout;
    readonly nodes: ComputedNode[];
    readonly edges: ComputedEdge[];
    rules?: never;
    docUri?: never;
}
interface ComputedDynamicView<ViewIDs extends string = string, Tags extends string = string> extends Omit<DynamicView$1<ViewIDs, Tags>, 'rules' | 'steps' | 'docUri'>, ViewWithHash, ViewWithNotation {
    readonly autoLayout: ViewAutoLayout;
    readonly nodes: ComputedNode[];
    readonly edges: ComputedEdge[];
    steps?: never;
    rules?: never;
    docUri?: never;
}
declare function isComputedDynamicView(view: ComputedView): view is ComputedDynamicView;
type ComputedView<ViewIDs extends string = string, Tags extends string = string> = ComputedElementView<ViewIDs, Tags> | ComputedDynamicView<ViewIDs, Tags>;
type BBox = {
    x: number;
    y: number;
    width: number;
    height: number;
};
interface DiagramNode extends ComputedNode {
    width: number;
    height: number;
    position: Point;
    labelBBox: BBox;
}
declare namespace DiagramNode {
    /**
     * Nodes group is a special kind of node, exisiting only in view
     */
    function isNodesGroup(node: DiagramNode): boolean;
}
interface DiagramEdge extends ComputedEdge {
    points: NonEmptyArray<Point>;
    controlPoints?: NonEmptyArray<XYPoint>;
    labelBBox?: BBox | null;
    dotpos?: string;
}
interface DiagramView<ViewIDs extends string = string, Tags extends string = string> extends Omit<ComputedView<ViewIDs, Tags>, 'nodes' | 'edges' | 'manualLayout'> {
    readonly nodes: DiagramNode[];
    readonly edges: DiagramEdge[];
    readonly bounds: BBox;
    /**
     * If diagram has manual layout
     * But was changed and layout should be recalculated
     */
    hasLayoutDrift?: boolean;
    manualLayout?: never;
}
type ViewManualLayout = {
    readonly hash: string;
    readonly x: number;
    readonly y: number;
    readonly width: number;
    readonly height: number;
    readonly autoLayout: ViewAutoLayout;
    readonly nodes: Record<string, {
        isCompound: boolean;
        x: number;
        y: number;
        width: number;
        height: number;
    }>;
    readonly edges: Record<string, {
        dotpos?: string;
        points: NonEmptyArray<Point>;
        controlPoints?: NonEmptyArray<XYPoint>;
        labelBBox?: BBox;
    }>;
};

type RelationID$1 = Tagged<string, 'RelationID'>;
type RelationshipKind$1<Kinds extends string = string> = Tagged<Kinds, 'RelationshipKind'>;
type RelationshipLineType = 'dashed' | 'solid' | 'dotted';
type RelationshipArrowType = 'none' | 'normal' | 'onormal' | 'dot' | 'odot' | 'diamond' | 'odiamond' | 'crow' | 'open' | 'vee';
interface Relation$1 {
    readonly id: RelationID$1;
    readonly source: Fqn$1;
    readonly target: Fqn$1;
    readonly title: string;
    readonly description?: string;
    readonly technology?: string;
    readonly tags?: NonEmptyArray<Tag$1>;
    readonly kind?: RelationshipKind$1;
    readonly color?: Color$1;
    readonly line?: RelationshipLineType;
    readonly head?: RelationshipArrowType;
    readonly tail?: RelationshipArrowType;
    readonly links?: NonEmptyArray<Link>;
    readonly navigateTo?: ViewID$1;
    readonly metadata?: {
        [key: string]: string;
    };
}
interface RelationshipKindSpecification {
    readonly technology?: string;
    readonly notation?: string;
    readonly color?: Color$1;
    readonly line?: RelationshipLineType;
    readonly head?: RelationshipArrowType;
    readonly tail?: RelationshipArrowType;
}

interface BaseExpr {
    where?: never;
    element?: never;
    custom?: never;
    expanded?: never;
    elementKind?: never;
    elementTag?: never;
    isEqual?: never;
    isDescedants?: never;
    wildcard?: never;
    source?: never;
    target?: never;
    inout?: never;
    incoming?: never;
    outgoing?: never;
    customRelation?: never;
}
interface ElementRefExpr extends Omit<BaseExpr, 'element' | 'isDescedants'> {
    element: Fqn$1;
    isDescedants?: boolean;
}
interface ExpandedElementExpr extends Omit<BaseExpr, 'expanded'> {
    expanded: Fqn$1;
}
interface CustomElementExpr extends Omit<BaseExpr, 'custom'> {
    custom: {
        expr: ElementExpression$1 | ElementWhereExpr;
        title?: string;
        description?: string;
        technology?: string;
        notation?: string;
        shape?: ElementShape$1;
        color?: Color$1;
        icon?: IconUrl;
        border?: BorderStyle;
        opacity?: number;
        navigateTo?: ViewID$1;
    };
}
interface WildcardExpr extends Omit<BaseExpr, 'wildcard'> {
    wildcard: true;
}
interface ElementKindExpr extends Omit<BaseExpr, 'elementKind' | 'isEqual'> {
    elementKind: ElementKind$1;
    isEqual: boolean;
}
interface ElementTagExpr extends Omit<BaseExpr, 'elementTag' | 'isEqual'> {
    elementTag: Tag$1;
    isEqual: boolean;
}
type ElementExpression$1 = ElementRefExpr | WildcardExpr | ElementKindExpr | ElementTagExpr | ExpandedElementExpr;
interface ElementWhereExpr extends Omit<BaseExpr, 'where'> {
    where: {
        expr: ElementExpression$1;
        condition: WhereOperator<string, string>;
    };
}
type ElementPredicateExpression = ElementExpression$1 | ElementWhereExpr | CustomElementExpr;
interface RelationExpr extends Omit<BaseExpr, 'source' | 'target'> {
    source: ElementExpression$1;
    target: ElementExpression$1;
    isBidirectional?: boolean;
}
interface InOutExpr extends Omit<BaseExpr, 'inout'> {
    inout: ElementExpression$1;
}
interface IncomingExpr extends Omit<BaseExpr, 'incoming'> {
    incoming: ElementExpression$1;
}
interface OutgoingExpr extends Omit<BaseExpr, 'outgoing'> {
    outgoing: ElementExpression$1;
}
type RelationExpression$1 = RelationExpr | InOutExpr | IncomingExpr | OutgoingExpr;
interface RelationWhereExpr extends Omit<BaseExpr, 'where'> {
    where: {
        expr: RelationExpression$1;
        condition: WhereOperator<string, string>;
    };
}
interface CustomRelationExpr extends Omit<BaseExpr, 'customRelation'> {
    customRelation: {
        relation: RelationExpression$1 | RelationWhereExpr;
        title?: string;
        description?: string;
        technology?: string;
        notation?: string;
        navigateTo?: ViewID$1;
        notes?: string;
        color?: Color$1;
        line?: RelationshipLineType;
        head?: RelationshipArrowType;
        tail?: RelationshipArrowType;
    };
}
type RelationPredicateExpression = RelationExpression$1 | RelationWhereExpr | CustomRelationExpr;
type Expression$1 = ElementPredicateExpression | RelationPredicateExpression;

/**
 * Parsed elements, relations, and views.
 */
interface ParsedLikeC4Model<ElementKinds extends string = string, RelationKinds extends string = string, Tags extends string = string, Fqns extends string = string, Views extends string = string> {
    specification: {
        tags: Tag$1<Tags>[];
        elements: Record<ElementKinds, ElementKindSpecification>;
        relationships: Record<RelationKinds, RelationshipKindSpecification>;
    };
    elements: Record<Fqns, TypedElement<Fqns, ElementKinds, Tags>>;
    relations: Record<RelationID$1, Relation$1>;
    globals: ModelGlobals;
    views: Record<Views, LikeC4View$1<Views, Tags>>;
}
/**
 * Same as `ParsedLikeC4Model` but with computed views.
 */
interface ComputedLikeC4Model extends Omit<ParsedLikeC4Model, 'views'> {
    __?: never;
    views: Record<ViewID$1, ComputedView>;
}
/**
 * Same as `ParsedLikeC4Model` but with layouted views (DiagramView)
 */
interface LayoutedLikeC4Model extends Omit<ParsedLikeC4Model, 'views'> {
    __: 'layouted';
    views: Record<ViewID$1, DiagramView>;
}

/**
 * OverviewGraph is a graph representation of all views in a model
 */
declare namespace OverviewGraph {
    type Node = {
        id: string;
        type: 'folder' | 'file';
        path: string;
        label: string;
        parentId: string | null;
        position: XYPoint;
        width: number;
        height: number;
    } | {
        id: string;
        type: 'view';
        viewId: ViewID$1;
        label: string;
        parentId: string | null;
        position: XYPoint;
        width: number;
        height: number;
    };
    /**
     * Edge represents a navigational link from one view to another
     */
    type Edge = {
        id: string;
        source: string;
        target: string;
        points: NonEmptyArray<Point>;
    };
}
interface OverviewGraph {
    nodes: OverviewGraph.Node[];
    edges: OverviewGraph.Edge[];
    bounds: BBox;
}

declare namespace ViewChange {
    interface ChangeElementStyle {
        op: 'change-element-style';
        style: {
            border?: BorderStyle;
            opacity?: number;
            shape?: ElementShape$1;
            color?: ThemeColor$1;
        };
        targets: NonEmptyArray<Fqn$1>;
    }
    interface SaveManualLayout {
        op: 'save-manual-layout';
        layout: ViewManualLayout;
    }
    interface ChangeAutoLayout {
        op: 'change-autolayout';
        layout: {
            direction: AutoLayoutDirection;
            nodeSep?: number | null;
            rankSep?: number | null;
        };
    }
}
type ViewChange = ViewChange.ChangeElementStyle | ViewChange.SaveManualLayout | ViewChange.ChangeAutoLayout;

type KeysOf<T> = keyof T extends infer K extends string ? K : never;
type BuilderSpecification = {
    elements: {
        [kind: string]: Partial<ElementKindSpecification>;
    };
    relationships?: Record<string, Partial<RelationshipKindSpecification>>;
    tags?: [string, ...string[]];
    metadataKeys?: [string, ...string[]];
};
type Metadata<MetadataKey extends string> = IfNever<MetadataKey, never, Record<MetadataKey, string>>;
type NewElementProps<Tag, Metadata> = {
    title?: string;
    description?: string;
    technology?: string;
    tags?: IfNever<Tag, never, [Tag, ...Tag[]]>;
    metadata?: Metadata;
    icon?: string;
    shape?: ElementShape$1;
    color?: Color$1;
    links?: Array<string | {
        title?: string;
        url: string;
    }>;
    style?: {
        border?: BorderStyle;
        opacity?: number;
    };
};
type NewViewProps<Tag> = {
    title?: string;
    description?: string;
    tags?: IfNever<Tag, never, [Tag, ...Tag[]]>;
    links?: Array<string | {
        title?: string;
        url: string;
    }>;
};
type NewRelationProps<Kind, Tag, Metadata> = {
    kind?: Kind;
    title?: string;
    description?: string;
    technology?: string;
    tags?: IfNever<Tag, never, [Tag, ...Tag[]]>;
    metadata?: Metadata;
    head?: RelationshipArrowType;
    tail?: RelationshipArrowType;
    line?: RelationshipLineType;
    color?: Color$1;
    links?: Array<string | {
        title?: string;
        url: string;
    }>;
};
type Invalid<Message extends string> = Tagged<Message, 'Error'>;
/**
 * When building nested objects
 */
interface TypesNested<Parent extends string, ElementKind extends string, Fqn extends string, ViewId extends string, RelationshipKind extends string, Tag extends string, MetadataKey extends string> extends Types<ElementKind, Fqn, ViewId, RelationshipKind, Tag, MetadataKey> {
    Parent: Parent;
}
type AnyTypes = Types<any, any, any, any, any, any>;
type AnyTypesNested = TypesNested<any, any, any, any, any, any, any>;
/**
 * Auxilary type to keep track of the types in builder
 */
interface Types<ElementKind extends string, Fqn extends string, ViewId extends string, RelationshipKind extends string, Tag extends string, MetadataKey extends string> {
    ElementKind: ElementKind;
    Fqn: Fqn;
    ViewId: ViewId;
    RelationshipKind: RelationshipKind;
    Tag: Tag;
    MetadataKey: MetadataKey;
    Tags: IfNever<Tag, never, [Tag, ...Tag[]]>;
    NewElementProps: NewElementProps<Tag, Metadata<MetadataKey>>;
    NewRelationshipProps: NewRelationProps<RelationshipKind, Tag, Metadata<MetadataKey>>;
    NewViewProps: NewViewProps<Tag>;
}
declare namespace Types {
    type FromSpecification<Spec> = Spec extends BuilderSpecification ? Types<KeysOf<Spec['elements']>, never, never, KeysOf<Spec['relationships']>, TupleToUnion<Spec['tags']>, TupleToUnion<Spec['metadataKeys']>> : never;
    type AddFqn<T, Id extends string> = T extends TypesNested<infer P, any, any, any, any, any, any> ? TypesNested<P, T['ElementKind'], `${P}.${Id}` | T['Fqn'], T['ViewId'], T['RelationshipKind'], T['Tag'], T['MetadataKey']> : T extends AnyTypes ? Types<T['ElementKind'], Id | T['Fqn'], T['ViewId'], T['RelationshipKind'], T['Tag'], T['MetadataKey']> : never;
    type AddView<T, Id extends string> = T extends TypesNested<infer P, any, any, any, any, any, any> ? TypesNested<P, T['ElementKind'], T['Fqn'], Id | T['ViewId'], T['RelationshipKind'], T['Tag'], T['MetadataKey']> : T extends AnyTypes ? Types<T['ElementKind'], T['Fqn'], Id | T['ViewId'], T['RelationshipKind'], T['Tag'], T['MetadataKey']> : never;
    type ToParsedLikeC4Model<T> = T extends AnyTypes ? ParsedLikeC4Model<T['ElementKind'], T['RelationshipKind'], T['Tag'], T['Fqn'], T['ViewId']> : never;
}

type ToNested<T, Id extends string> = T extends TypesNested<infer P, any, infer F, any, any, any, any> ? TypesNested<`${P}.${Id}`, T['ElementKind'], `${P}.${Id}` | F, T['ViewId'], T['RelationshipKind'], T['Tag'], T['MetadataKey']> : T extends AnyTypes ? TypesNested<Id, T['ElementKind'], Id | T['Fqn'], T['ViewId'], T['RelationshipKind'], T['Tag'], T['MetadataKey']> : never;
type FromNested<T extends AnyTypes, N> = N extends TypesNested<any, any, infer F, any, any, any, any> ? T extends TypesNested<infer P, any, any, any, any, any, any> ? TypesNested<P, T['ElementKind'], F, T['ViewId'], T['RelationshipKind'], T['Tag'], T['MetadataKey']> : T extends AnyTypes ? Types<T['ElementKind'], F, T['ViewId'], T['RelationshipKind'], T['Tag'], T['MetadataKey']> : never : never;
/**
 * Chainable builder to create element
 */
interface AddElement<Id extends string> {
    <T extends AnyTypes>(builder: ModelBuilder<T>): ModelBuilder<Types.AddFqn<T, Id>>;
    with<T extends AnyTypes, A extends AnyTypes>(op1: (input: ModelBuilder<ToNested<T, Id>>) => ModelBuilder<A>): (builder: ModelBuilder<T>) => ModelBuilder<FromNested<T, A>>;
    with<T extends AnyTypes, A extends AnyTypes, B extends AnyTypes>(op1: (input: ModelBuilder<ToNested<T, Id>>) => ModelBuilder<A>, op2: (input: ModelBuilder<A>) => ModelBuilder<B>): (builder: ModelBuilder<T>) => ModelBuilder<FromNested<T, B>>;
    with<T extends AnyTypes, A extends AnyTypes, B extends AnyTypes, C extends AnyTypes>(op1: (input: ModelBuilder<ToNested<T, Id>>) => ModelBuilder<A>, op2: (input: ModelBuilder<A>) => ModelBuilder<B>, op3: (input: ModelBuilder<B>) => ModelBuilder<C>): (builder: ModelBuilder<T>) => ModelBuilder<FromNested<T, C>>;
    with<T extends AnyTypes, A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes>(op1: (input: ModelBuilder<ToNested<T, Id>>) => ModelBuilder<A>, op2: (input: ModelBuilder<A>) => ModelBuilder<B>, op3: (input: ModelBuilder<B>) => ModelBuilder<C>, op4: (input: ModelBuilder<C>) => ModelBuilder<D>): (builder: ModelBuilder<T>) => ModelBuilder<FromNested<T, D>>;
    with<T extends AnyTypes, A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes>(op1: (input: ModelBuilder<ToNested<T, Id>>) => ModelBuilder<A>, op2: (input: ModelBuilder<A>) => ModelBuilder<B>, op3: (input: ModelBuilder<B>) => ModelBuilder<C>, op4: (input: ModelBuilder<C>) => ModelBuilder<D>, op5: (input: ModelBuilder<D>) => ModelBuilder<E>): (builder: ModelBuilder<T>) => ModelBuilder<FromNested<T, E>>;
    with<T extends AnyTypes, A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes>(op1: (input: ModelBuilder<ToNested<T, Id>>) => ModelBuilder<A>, op2: (input: ModelBuilder<A>) => ModelBuilder<B>, op3: (input: ModelBuilder<B>) => ModelBuilder<C>, op4: (input: ModelBuilder<C>) => ModelBuilder<D>, op5: (input: ModelBuilder<D>) => ModelBuilder<E>, op6: (input: ModelBuilder<E>) => ModelBuilder<F>): (builder: ModelBuilder<T>) => ModelBuilder<FromNested<T, F>>;
    with<T extends AnyTypes, A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes>(op1: (input: ModelBuilder<ToNested<T, Id>>) => ModelBuilder<A>, op2: (input: ModelBuilder<A>) => ModelBuilder<B>, op3: (input: ModelBuilder<B>) => ModelBuilder<C>, op4: (input: ModelBuilder<C>) => ModelBuilder<D>, op5: (input: ModelBuilder<D>) => ModelBuilder<E>, op6: (input: ModelBuilder<E>) => ModelBuilder<F>, op7: (input: ModelBuilder<F>) => ModelBuilder<G>): (builder: ModelBuilder<T>) => ModelBuilder<FromNested<T, G>>;
    with<T extends AnyTypes, A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes>(op1: (input: ModelBuilder<ToNested<T, Id>>) => ModelBuilder<A>, op2: (input: ModelBuilder<A>) => ModelBuilder<B>, op3: (input: ModelBuilder<B>) => ModelBuilder<C>, op4: (input: ModelBuilder<C>) => ModelBuilder<D>, op5: (input: ModelBuilder<D>) => ModelBuilder<E>, op6: (input: ModelBuilder<E>) => ModelBuilder<F>, op7: (input: ModelBuilder<F>) => ModelBuilder<G>, op8: (input: ModelBuilder<G>) => ModelBuilder<H>): (builder: ModelBuilder<T>) => ModelBuilder<FromNested<T, H>>;
    with<T extends AnyTypes, A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes>(op1: (input: ModelBuilder<ToNested<T, Id>>) => ModelBuilder<A>, op2: (input: ModelBuilder<A>) => ModelBuilder<B>, op3: (input: ModelBuilder<B>) => ModelBuilder<C>, op4: (input: ModelBuilder<C>) => ModelBuilder<D>, op5: (input: ModelBuilder<D>) => ModelBuilder<E>, op6: (input: ModelBuilder<E>) => ModelBuilder<F>, op7: (input: ModelBuilder<F>) => ModelBuilder<G>, op8: (input: ModelBuilder<G>) => ModelBuilder<H>, op9: (input: ModelBuilder<H>) => ModelBuilder<I>): (builder: ModelBuilder<T>) => ModelBuilder<FromNested<T, I>>;
    with<T extends AnyTypes, A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes>(op1: (input: ModelBuilder<ToNested<T, Id>>) => ModelBuilder<A>, op2: (input: ModelBuilder<A>) => ModelBuilder<B>, op3: (input: ModelBuilder<B>) => ModelBuilder<C>, op4: (input: ModelBuilder<C>) => ModelBuilder<D>, op5: (input: ModelBuilder<D>) => ModelBuilder<E>, op6: (input: ModelBuilder<E>) => ModelBuilder<F>, op7: (input: ModelBuilder<F>) => ModelBuilder<G>, op8: (input: ModelBuilder<G>) => ModelBuilder<H>, op9: (input: ModelBuilder<H>) => ModelBuilder<I>, op10: (input: ModelBuilder<I>) => ModelBuilder<J>): (builder: ModelBuilder<T>) => ModelBuilder<FromNested<T, J>>;
}
type AddElementHelper<T = unknown> = <const Id extends string>(id: Id, titleOrProps?: string | T) => AddElement<Id>;
type AddElementHelpers<T extends AnyTypes> = T extends Types<infer Kinds extends string, any, any, any, any, any> ? {
    [Kind in Kinds]: AddElementHelper<T['NewElementProps']>;
} : Invalid<'No Element Kinds'>;

interface ModelBuilder<T extends AnyTypes> {
    addElement(element: Element$1): Builder<T>;
    addRelation(relation: Omit<Relation$1, 'id'>): Builder<T>;
    /**
     * Create a fully qualified name from an id (for nested models)
     */
    fqn(id: string): Fqn$1;
    addSourcelessRelation(relation: Omit<Relation$1, 'id' | 'source'>): Builder<T>;
}
declare function model<A extends AnyTypes, B extends AnyTypes>(op1: (input: ModelBuilder<A>) => ModelBuilder<B>): (input: Builder<A>) => Builder<B>;
declare function model<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes>(op1: (input: ModelBuilder<A>) => ModelBuilder<B>, op2: (input: ModelBuilder<B>) => ModelBuilder<C>): (input: Builder<A>) => Builder<C>;
declare function model<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes>(op1: (input: ModelBuilder<A>) => ModelBuilder<B>, op2: (input: ModelBuilder<B>) => ModelBuilder<C>, op3: (input: ModelBuilder<C>) => ModelBuilder<D>): (input: Builder<A>) => Builder<D>;
declare function model<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes>(op1: (input: ModelBuilder<A>) => ModelBuilder<B>, op2: (input: ModelBuilder<B>) => ModelBuilder<C>, op3: (input: ModelBuilder<C>) => ModelBuilder<D>, op4: (input: ModelBuilder<D>) => ModelBuilder<E>): (input: Builder<A>) => Builder<E>;
declare function model<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes>(op1: (input: ModelBuilder<A>) => ModelBuilder<B>, op2: (input: ModelBuilder<B>) => ModelBuilder<C>, op3: (input: ModelBuilder<C>) => ModelBuilder<D>, op4: (input: ModelBuilder<D>) => ModelBuilder<E>, op5: (input: ModelBuilder<E>) => ModelBuilder<F>): (input: Builder<A>) => Builder<F>;
declare function model<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes>(op1: (input: ModelBuilder<A>) => ModelBuilder<B>, op2: (input: ModelBuilder<B>) => ModelBuilder<C>, op3: (input: ModelBuilder<C>) => ModelBuilder<D>, op4: (input: ModelBuilder<D>) => ModelBuilder<E>, op5: (input: ModelBuilder<E>) => ModelBuilder<F>, op6: (input: ModelBuilder<F>) => ModelBuilder<G>): (input: Builder<A>) => Builder<G>;
declare function model<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes>(op1: (input: ModelBuilder<A>) => ModelBuilder<B>, op2: (input: ModelBuilder<B>) => ModelBuilder<C>, op3: (input: ModelBuilder<C>) => ModelBuilder<D>, op4: (input: ModelBuilder<D>) => ModelBuilder<E>, op5: (input: ModelBuilder<E>) => ModelBuilder<F>, op6: (input: ModelBuilder<F>) => ModelBuilder<G>, op7: (input: ModelBuilder<G>) => ModelBuilder<H>): (input: Builder<A>) => Builder<H>;
declare function model<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes>(op1: (input: ModelBuilder<A>) => ModelBuilder<B>, op2: (input: ModelBuilder<B>) => ModelBuilder<C>, op3: (input: ModelBuilder<C>) => ModelBuilder<D>, op4: (input: ModelBuilder<D>) => ModelBuilder<E>, op5: (input: ModelBuilder<E>) => ModelBuilder<F>, op6: (input: ModelBuilder<F>) => ModelBuilder<G>, op7: (input: ModelBuilder<G>) => ModelBuilder<H>, op8: (input: ModelBuilder<H>) => ModelBuilder<I>): (input: Builder<A>) => Builder<I>;
declare function model<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes>(op1: (input: ModelBuilder<A>) => ModelBuilder<B>, op2: (input: ModelBuilder<B>) => ModelBuilder<C>, op3: (input: ModelBuilder<C>) => ModelBuilder<D>, op4: (input: ModelBuilder<D>) => ModelBuilder<E>, op5: (input: ModelBuilder<E>) => ModelBuilder<F>, op6: (input: ModelBuilder<F>) => ModelBuilder<G>, op7: (input: ModelBuilder<G>) => ModelBuilder<H>, op8: (input: ModelBuilder<H>) => ModelBuilder<I>, op9: (input: ModelBuilder<I>) => ModelBuilder<J>): (input: Builder<A>) => Builder<J>;
declare function model<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes, K extends AnyTypes>(op1: (input: ModelBuilder<A>) => ModelBuilder<B>, op2: (input: ModelBuilder<B>) => ModelBuilder<C>, op3: (input: ModelBuilder<C>) => ModelBuilder<D>, op4: (input: ModelBuilder<D>) => ModelBuilder<E>, op5: (input: ModelBuilder<E>) => ModelBuilder<F>, op6: (input: ModelBuilder<F>) => ModelBuilder<G>, op7: (input: ModelBuilder<G>) => ModelBuilder<H>, op8: (input: ModelBuilder<H>) => ModelBuilder<I>, op9: (input: ModelBuilder<I>) => ModelBuilder<J>, op10: (input: ModelBuilder<J>) => ModelBuilder<K>): (input: Builder<A>) => Builder<K>;
declare function model<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes, K extends AnyTypes, L extends AnyTypes>(op1: (input: ModelBuilder<A>) => ModelBuilder<B>, op2: (input: ModelBuilder<B>) => ModelBuilder<C>, op3: (input: ModelBuilder<C>) => ModelBuilder<D>, op4: (input: ModelBuilder<D>) => ModelBuilder<E>, op5: (input: ModelBuilder<E>) => ModelBuilder<F>, op6: (input: ModelBuilder<F>) => ModelBuilder<G>, op7: (input: ModelBuilder<G>) => ModelBuilder<H>, op8: (input: ModelBuilder<H>) => ModelBuilder<I>, op9: (input: ModelBuilder<I>) => ModelBuilder<J>, op10: (input: ModelBuilder<J>) => ModelBuilder<K>, op11: (input: ModelBuilder<K>) => ModelBuilder<L>): (input: Builder<A>) => Builder<L>;
declare function model<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes, K extends AnyTypes, L extends AnyTypes, M extends AnyTypes>(op1: (input: ModelBuilder<A>) => ModelBuilder<B>, op2: (input: ModelBuilder<B>) => ModelBuilder<C>, op3: (input: ModelBuilder<C>) => ModelBuilder<D>, op4: (input: ModelBuilder<D>) => ModelBuilder<E>, op5: (input: ModelBuilder<E>) => ModelBuilder<F>, op6: (input: ModelBuilder<F>) => ModelBuilder<G>, op7: (input: ModelBuilder<G>) => ModelBuilder<H>, op8: (input: ModelBuilder<H>) => ModelBuilder<I>, op9: (input: ModelBuilder<I>) => ModelBuilder<J>, op10: (input: ModelBuilder<J>) => ModelBuilder<K>, op11: (input: ModelBuilder<K>) => ModelBuilder<L>, op12: (input: ModelBuilder<L>) => ModelBuilder<M>): (input: Builder<A>) => Builder<M>;
declare function model<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes, K extends AnyTypes, L extends AnyTypes, M extends AnyTypes, N extends AnyTypes>(op1: (input: ModelBuilder<A>) => ModelBuilder<B>, op2: (input: ModelBuilder<B>) => ModelBuilder<C>, op3: (input: ModelBuilder<C>) => ModelBuilder<D>, op4: (input: ModelBuilder<D>) => ModelBuilder<E>, op5: (input: ModelBuilder<E>) => ModelBuilder<F>, op6: (input: ModelBuilder<F>) => ModelBuilder<G>, op7: (input: ModelBuilder<G>) => ModelBuilder<H>, op8: (input: ModelBuilder<H>) => ModelBuilder<I>, op9: (input: ModelBuilder<I>) => ModelBuilder<J>, op10: (input: ModelBuilder<J>) => ModelBuilder<K>, op11: (input: ModelBuilder<K>) => ModelBuilder<L>, op12: (input: ModelBuilder<L>) => ModelBuilder<M>, op13: (input: ModelBuilder<M>) => ModelBuilder<N>): (input: Builder<A>) => Builder<N>;
declare function model<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes, K extends AnyTypes, L extends AnyTypes, M extends AnyTypes, N extends AnyTypes, O extends AnyTypes>(op1: (input: ModelBuilder<A>) => ModelBuilder<B>, op2: (input: ModelBuilder<B>) => ModelBuilder<C>, op3: (input: ModelBuilder<C>) => ModelBuilder<D>, op4: (input: ModelBuilder<D>) => ModelBuilder<E>, op5: (input: ModelBuilder<E>) => ModelBuilder<F>, op6: (input: ModelBuilder<F>) => ModelBuilder<G>, op7: (input: ModelBuilder<G>) => ModelBuilder<H>, op8: (input: ModelBuilder<H>) => ModelBuilder<I>, op9: (input: ModelBuilder<I>) => ModelBuilder<J>, op10: (input: ModelBuilder<J>) => ModelBuilder<K>, op11: (input: ModelBuilder<K>) => ModelBuilder<L>, op12: (input: ModelBuilder<L>) => ModelBuilder<M>, op13: (input: ModelBuilder<M>) => ModelBuilder<N>, op14: (input: ModelBuilder<N>) => ModelBuilder<O>): (input: Builder<A>) => Builder<O>;
declare function model<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes, K extends AnyTypes, L extends AnyTypes, M extends AnyTypes, N extends AnyTypes, O extends AnyTypes, P extends AnyTypes>(op1: (input: ModelBuilder<A>) => ModelBuilder<B>, op2: (input: ModelBuilder<B>) => ModelBuilder<C>, op3: (input: ModelBuilder<C>) => ModelBuilder<D>, op4: (input: ModelBuilder<D>) => ModelBuilder<E>, op5: (input: ModelBuilder<E>) => ModelBuilder<F>, op6: (input: ModelBuilder<F>) => ModelBuilder<G>, op7: (input: ModelBuilder<G>) => ModelBuilder<H>, op8: (input: ModelBuilder<H>) => ModelBuilder<I>, op9: (input: ModelBuilder<I>) => ModelBuilder<J>, op10: (input: ModelBuilder<J>) => ModelBuilder<K>, op11: (input: ModelBuilder<K>) => ModelBuilder<L>, op12: (input: ModelBuilder<L>) => ModelBuilder<M>, op13: (input: ModelBuilder<M>) => ModelBuilder<N>, op14: (input: ModelBuilder<N>) => ModelBuilder<O>, op15: (input: ModelBuilder<O>) => ModelBuilder<P>): (input: Builder<A>) => Builder<P>;
type RelationshipHelper<Props = unknown> = <T extends AnyTypes, From extends string & T['Fqn'], To extends string & T['Fqn']>(from: From, to: To, titleOrProps?: string | Props) => (builder: ModelBuilder<T>) => ModelBuilder<T>;
type NestedRelationshipHelper<Props = unknown> = <T extends AnyTypesNested, To extends string & T['Fqn']>(to: To, titleOrProps?: string | Props) => (builder: ModelBuilder<T>) => ModelBuilder<T>;
type ModelHelpers<T extends AnyTypes> = AddElementHelpers<T> & {
    model: typeof model;
    rel: RelationshipHelper<T['NewRelationshipProps']>;
    relTo: NestedRelationshipHelper<T['NewRelationshipProps']>;
};

interface ViewsBuilder<T extends AnyTypes> {
    addView(view: LikeC4View$1): Builder<T>;
}
declare function views<A extends AnyTypes, B extends AnyTypes>(op1: (input: ViewsBuilder<A>) => ViewsBuilder<B>): (input: Builder<A>) => Builder<B>;
declare function views<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes>(op1: (input: ViewsBuilder<A>) => ViewsBuilder<B>, op2: (input: ViewsBuilder<B>) => ViewsBuilder<C>): (input: Builder<A>) => Builder<C>;
declare function views<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes>(op1: (input: ViewsBuilder<A>) => ViewsBuilder<B>, op2: (input: ViewsBuilder<B>) => ViewsBuilder<C>, op3: (input: ViewsBuilder<C>) => ViewsBuilder<D>): (input: Builder<A>) => Builder<D>;
declare function views<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes>(op1: (input: ViewsBuilder<A>) => ViewsBuilder<B>, op2: (input: ViewsBuilder<B>) => ViewsBuilder<C>, op3: (input: ViewsBuilder<C>) => ViewsBuilder<D>, op4: (input: ViewsBuilder<D>) => ViewsBuilder<E>): (input: Builder<A>) => Builder<E>;
declare function views<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes>(op1: (input: ViewsBuilder<A>) => ViewsBuilder<B>, op2: (input: ViewsBuilder<B>) => ViewsBuilder<C>, op3: (input: ViewsBuilder<C>) => ViewsBuilder<D>, op4: (input: ViewsBuilder<D>) => ViewsBuilder<E>, op5: (input: ViewsBuilder<E>) => ViewsBuilder<F>): (input: Builder<A>) => Builder<F>;
declare function views<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes>(op1: (input: ViewsBuilder<A>) => ViewsBuilder<B>, op2: (input: ViewsBuilder<B>) => ViewsBuilder<C>, op3: (input: ViewsBuilder<C>) => ViewsBuilder<D>, op4: (input: ViewsBuilder<D>) => ViewsBuilder<E>, op5: (input: ViewsBuilder<E>) => ViewsBuilder<F>, op6: (input: ViewsBuilder<F>) => ViewsBuilder<G>): (input: Builder<A>) => Builder<G>;
declare function views<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes>(op1: (input: ViewsBuilder<A>) => ViewsBuilder<B>, op2: (input: ViewsBuilder<B>) => ViewsBuilder<C>, op3: (input: ViewsBuilder<C>) => ViewsBuilder<D>, op4: (input: ViewsBuilder<D>) => ViewsBuilder<E>, op5: (input: ViewsBuilder<E>) => ViewsBuilder<F>, op6: (input: ViewsBuilder<F>) => ViewsBuilder<G>, op7: (input: ViewsBuilder<G>) => ViewsBuilder<H>): (input: Builder<A>) => Builder<H>;
declare function views<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes>(op1: (input: ViewsBuilder<A>) => ViewsBuilder<B>, op2: (input: ViewsBuilder<B>) => ViewsBuilder<C>, op3: (input: ViewsBuilder<C>) => ViewsBuilder<D>, op4: (input: ViewsBuilder<D>) => ViewsBuilder<E>, op5: (input: ViewsBuilder<E>) => ViewsBuilder<F>, op6: (input: ViewsBuilder<F>) => ViewsBuilder<G>, op7: (input: ViewsBuilder<G>) => ViewsBuilder<H>, op8: (input: ViewsBuilder<H>) => ViewsBuilder<I>): (input: Builder<A>) => Builder<I>;
declare function views<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes>(op1: (input: ViewsBuilder<A>) => ViewsBuilder<B>, op2: (input: ViewsBuilder<B>) => ViewsBuilder<C>, op3: (input: ViewsBuilder<C>) => ViewsBuilder<D>, op4: (input: ViewsBuilder<D>) => ViewsBuilder<E>, op5: (input: ViewsBuilder<E>) => ViewsBuilder<F>, op6: (input: ViewsBuilder<F>) => ViewsBuilder<G>, op7: (input: ViewsBuilder<G>) => ViewsBuilder<H>, op8: (input: ViewsBuilder<H>) => ViewsBuilder<I>, op9: (input: ViewsBuilder<I>) => ViewsBuilder<J>): (input: Builder<A>) => Builder<J>;
declare function views<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes, K extends AnyTypes>(op1: (input: ViewsBuilder<A>) => ViewsBuilder<B>, op2: (input: ViewsBuilder<B>) => ViewsBuilder<C>, op3: (input: ViewsBuilder<C>) => ViewsBuilder<D>, op4: (input: ViewsBuilder<D>) => ViewsBuilder<E>, op5: (input: ViewsBuilder<E>) => ViewsBuilder<F>, op6: (input: ViewsBuilder<F>) => ViewsBuilder<G>, op7: (input: ViewsBuilder<G>) => ViewsBuilder<H>, op8: (input: ViewsBuilder<H>) => ViewsBuilder<I>, op9: (input: ViewsBuilder<I>) => ViewsBuilder<J>, op10: (input: ViewsBuilder<J>) => ViewsBuilder<K>): (input: Builder<A>) => Builder<K>;
declare function views<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes, K extends AnyTypes, L extends AnyTypes>(op1: (input: ViewsBuilder<A>) => ViewsBuilder<B>, op2: (input: ViewsBuilder<B>) => ViewsBuilder<C>, op3: (input: ViewsBuilder<C>) => ViewsBuilder<D>, op4: (input: ViewsBuilder<D>) => ViewsBuilder<E>, op5: (input: ViewsBuilder<E>) => ViewsBuilder<F>, op6: (input: ViewsBuilder<F>) => ViewsBuilder<G>, op7: (input: ViewsBuilder<G>) => ViewsBuilder<H>, op8: (input: ViewsBuilder<H>) => ViewsBuilder<I>, op9: (input: ViewsBuilder<I>) => ViewsBuilder<J>, op10: (input: ViewsBuilder<J>) => ViewsBuilder<K>, op11: (input: ViewsBuilder<K>) => ViewsBuilder<L>): (input: Builder<A>) => Builder<L>;
declare function views<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes, K extends AnyTypes, L extends AnyTypes, M extends AnyTypes>(op1: (input: ViewsBuilder<A>) => ViewsBuilder<B>, op2: (input: ViewsBuilder<B>) => ViewsBuilder<C>, op3: (input: ViewsBuilder<C>) => ViewsBuilder<D>, op4: (input: ViewsBuilder<D>) => ViewsBuilder<E>, op5: (input: ViewsBuilder<E>) => ViewsBuilder<F>, op6: (input: ViewsBuilder<F>) => ViewsBuilder<G>, op7: (input: ViewsBuilder<G>) => ViewsBuilder<H>, op8: (input: ViewsBuilder<H>) => ViewsBuilder<I>, op9: (input: ViewsBuilder<I>) => ViewsBuilder<J>, op10: (input: ViewsBuilder<J>) => ViewsBuilder<K>, op11: (input: ViewsBuilder<K>) => ViewsBuilder<L>, op12: (input: ViewsBuilder<L>) => ViewsBuilder<M>): (input: Builder<A>) => Builder<M>;
declare function views<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes, K extends AnyTypes, L extends AnyTypes, M extends AnyTypes, N extends AnyTypes>(op1: (input: ViewsBuilder<A>) => ViewsBuilder<B>, op2: (input: ViewsBuilder<B>) => ViewsBuilder<C>, op3: (input: ViewsBuilder<C>) => ViewsBuilder<D>, op4: (input: ViewsBuilder<D>) => ViewsBuilder<E>, op5: (input: ViewsBuilder<E>) => ViewsBuilder<F>, op6: (input: ViewsBuilder<F>) => ViewsBuilder<G>, op7: (input: ViewsBuilder<G>) => ViewsBuilder<H>, op8: (input: ViewsBuilder<H>) => ViewsBuilder<I>, op9: (input: ViewsBuilder<I>) => ViewsBuilder<J>, op10: (input: ViewsBuilder<J>) => ViewsBuilder<K>, op11: (input: ViewsBuilder<K>) => ViewsBuilder<L>, op12: (input: ViewsBuilder<L>) => ViewsBuilder<M>, op13: (input: ViewsBuilder<M>) => ViewsBuilder<N>): (input: Builder<A>) => Builder<N>;
declare function views<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes, K extends AnyTypes, L extends AnyTypes, M extends AnyTypes, N extends AnyTypes, O extends AnyTypes>(op1: (input: ViewsBuilder<A>) => ViewsBuilder<B>, op2: (input: ViewsBuilder<B>) => ViewsBuilder<C>, op3: (input: ViewsBuilder<C>) => ViewsBuilder<D>, op4: (input: ViewsBuilder<D>) => ViewsBuilder<E>, op5: (input: ViewsBuilder<E>) => ViewsBuilder<F>, op6: (input: ViewsBuilder<F>) => ViewsBuilder<G>, op7: (input: ViewsBuilder<G>) => ViewsBuilder<H>, op8: (input: ViewsBuilder<H>) => ViewsBuilder<I>, op9: (input: ViewsBuilder<I>) => ViewsBuilder<J>, op10: (input: ViewsBuilder<J>) => ViewsBuilder<K>, op11: (input: ViewsBuilder<K>) => ViewsBuilder<L>, op12: (input: ViewsBuilder<L>) => ViewsBuilder<M>, op13: (input: ViewsBuilder<M>) => ViewsBuilder<N>, op14: (input: ViewsBuilder<N>) => ViewsBuilder<O>): (input: Builder<A>) => Builder<O>;
declare function views<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes, K extends AnyTypes, L extends AnyTypes, M extends AnyTypes, N extends AnyTypes, O extends AnyTypes, P extends AnyTypes>(op1: (input: ViewsBuilder<A>) => ViewsBuilder<B>, op2: (input: ViewsBuilder<B>) => ViewsBuilder<C>, op3: (input: ViewsBuilder<C>) => ViewsBuilder<D>, op4: (input: ViewsBuilder<D>) => ViewsBuilder<E>, op5: (input: ViewsBuilder<E>) => ViewsBuilder<F>, op6: (input: ViewsBuilder<F>) => ViewsBuilder<G>, op7: (input: ViewsBuilder<G>) => ViewsBuilder<H>, op8: (input: ViewsBuilder<H>) => ViewsBuilder<I>, op9: (input: ViewsBuilder<I>) => ViewsBuilder<J>, op10: (input: ViewsBuilder<J>) => ViewsBuilder<K>, op11: (input: ViewsBuilder<K>) => ViewsBuilder<L>, op12: (input: ViewsBuilder<L>) => ViewsBuilder<M>, op13: (input: ViewsBuilder<M>) => ViewsBuilder<N>, op14: (input: ViewsBuilder<N>) => ViewsBuilder<O>, op15: (input: ViewsBuilder<O>) => ViewsBuilder<P>): (input: Builder<A>) => Builder<P>;

interface ViewBuilder<T extends AnyTypes> {
    include(...exprs: Expression$1[]): ViewBuilder<T>;
    exclude(...exprs: Expression$1[]): ViewBuilder<T>;
    style(rule: ViewRuleStyle$1): ViewBuilder<T>;
    autoLayout(layout: AutoLayoutDirection): ViewBuilder<T>;
}
declare namespace ViewPredicate {
    export type ElementExpr<Fqn extends string> = '*' | Fqn | `${Fqn}.*` | `${Fqn}._`;
    type AllExpression<ElementExpr extends string> = ElementExpr | `-> ${ElementExpr} ->` | `-> ${ElementExpr}` | `${ElementExpr} ->` | `${ElementExpr} ${'->' | '<->'} ${ElementExpr}`;
    export type Expression<T extends AnyTypes> = T extends Types<any, infer F extends string, any, any, any, any> ? AllExpression<ViewPredicate.ElementExpr<F>> : never;
    export type WhereTag<Tag extends string> = `tag ${'is' | 'is not'} #${Tag}`;
    export type WhereKind<Kind extends string> = `kind ${'is' | 'is not'} ${Kind}`;
    export type WhereEq<Types extends AnyTypes> = ViewPredicate.WhereTag<Types['Tag']> | ViewPredicate.WhereKind<Types['ElementKind']>;
    export type WhereOperator<Types extends AnyTypes> = ViewPredicate.WhereEq<Types> | {
        and: NonEmptyArray<ViewPredicate.WhereOperator<Types>>;
        or?: never;
        not?: never;
    } | {
        or: NonEmptyArray<ViewPredicate.WhereOperator<Types>>;
        and?: never;
        not?: never;
    } | {
        not: ViewPredicate.WhereOperator<Types>;
        and?: never;
        or?: never;
    };
    export type Custom<Types extends AnyTypes> = {
        where?: ViewPredicate.WhereOperator<Types>;
        with?: Simplify<Omit<CustomElementExpr['custom'] & CustomRelationExpr['customRelation'], 'expr' | 'relation' | 'navigateTo'> & {
            navigateTo?: Types['ViewId'];
        }>;
    };
    export {  };
}
type ViewRuleBuilderOp<Types extends AnyTypes> = (b: ViewBuilder<Types>) => ViewBuilder<Types>;
interface AddViewHelper<Props = unknown> {
    <const Id extends string, T extends AnyTypes>(id: Id, builder: (b: ViewBuilder<T>) => ViewBuilder<T>): (builder: ViewsBuilder<T>) => ViewsBuilder<Types.AddView<T, Id>>;
    <const Id extends string, T extends AnyTypes>(id: Id, propsOrTitle: Props | string): (builder: ViewsBuilder<T>) => ViewsBuilder<Types.AddView<T, Id>>;
    <const Id extends string, T extends AnyTypes>(id: Id, propsOrTitle: Props | string | undefined, builder: (b: ViewBuilder<T>) => ViewBuilder<T>): (builder: ViewsBuilder<T>) => ViewsBuilder<Types.AddView<T, Id>>;
}
interface AddViewOfHelper<Props = unknown> {
    <const Id extends string, T extends AnyTypes, Of extends string & T['Fqn']>(id: Id, of: Of): (builder: ViewsBuilder<T>) => ViewsBuilder<Types.AddView<T, Id>>;
    <const Id extends string, T extends AnyTypes, Of extends string & T['Fqn']>(id: Id, of: Of, builder: (b: ViewBuilder<T>) => ViewBuilder<T>): (builder: ViewsBuilder<T>) => ViewsBuilder<Types.AddView<T, Id>>;
    <const Id extends string, T extends AnyTypes, Of extends string & T['Fqn']>(id: Id, of: Of, propsOrTitle: Props | string): (builder: ViewsBuilder<T>) => ViewsBuilder<Types.AddView<T, Id>>;
    <const Id extends string, T extends AnyTypes, Of extends string & T['Fqn']>(id: Id, of: Of, propsOrTitle: Props | string | undefined, builder: (b: ViewBuilder<T>) => ViewBuilder<T>): (builder: ViewsBuilder<T>) => ViewsBuilder<Types.AddView<T, Id>>;
}
type TypedC4Expression<Types extends AnyTypes> = Tagged<Expression$1, 'typed', Types>;
declare function $include<Types extends AnyTypes>(...args: [ViewPredicate.Expression<Types>] | [TypedC4Expression<Types>] | [ViewPredicate.Expression<Types>, ViewPredicate.Custom<Types>]): (b: ViewBuilder<Types>) => ViewBuilder<Types>;
declare function $exclude<Types extends AnyTypes>(...args: [ViewPredicate.Expression<Types>] | [TypedC4Expression<Types>] | [ViewPredicate.Expression<Types>, ViewPredicate.Custom<Types>]): (b: ViewBuilder<Types>) => ViewBuilder<Types>;
declare function $style<Types extends AnyTypes>(element: ViewPredicate.ElementExpr<Types['Fqn']> | NonEmptyArray<ViewPredicate.ElementExpr<Types['Fqn']>>, { notation, ...style }: ViewRuleStyle$1['style'] & {
    notation?: string;
}): (b: ViewBuilder<Types>) => ViewBuilder<Types>;
declare function $autoLayout<Types extends AnyTypes>(layout: AutoLayoutDirection): (b: ViewBuilder<Types>) => ViewBuilder<Types>;
declare function $rules<T extends AnyTypes>(...rules: ViewRuleBuilderOp<T>[]): (b: ViewBuilder<T>) => ViewBuilder<T>;

type ViewHelpers<T = unknown> = {
    views: typeof views;
    view: AddViewHelper<T>;
    viewOf: AddViewOfHelper<T>;
    $include: typeof $include;
    $exclude: typeof $exclude;
    $style: typeof $style;
    $rules: typeof $rules;
    $autoLayout: typeof $autoLayout;
};

interface Builder<T extends AnyTypes> {
    /**
     * Only available in compile time
     */
    readonly Types: T;
    clone(): Builder<T>;
    /**
     * Builders for each element kind
     */
    helpers(): {
        model: ModelHelpers<T>;
        views: ViewHelpers<T['NewViewProps']>;
    };
    __model(): ModelBuilder<T>;
    __views(): ViewsBuilder<T>;
    build(): ParsedLikeC4Model<T['ElementKind'], T['RelationshipKind'], T['Tag'], T['Fqn'], T['ViewId']>;
    with<A extends AnyTypes>(op1: (input: Builder<T>) => Builder<A>): Builder<A>;
    with<A extends AnyTypes, B extends AnyTypes>(op1: (input: Builder<T>) => Builder<A>, op2: (input: Builder<A>) => Builder<B>): Builder<B>;
    with<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes>(op1: (input: Builder<T>) => Builder<A>, op2: (input: Builder<A>) => Builder<B>, op3: (input: Builder<B>) => Builder<C>): Builder<C>;
    with<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes>(op1: (input: Builder<T>) => Builder<A>, op2: (input: Builder<A>) => Builder<B>, op3: (input: Builder<B>) => Builder<C>, op4: (input: Builder<C>) => Builder<D>): Builder<D>;
    with<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes>(op1: (input: Builder<T>) => Builder<A>, op2: (input: Builder<A>) => Builder<B>, op3: (input: Builder<B>) => Builder<C>, op4: (input: Builder<C>) => Builder<D>, op5: (input: Builder<D>) => Builder<E>): Builder<E>;
    with<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes>(op1: (input: Builder<T>) => Builder<A>, op2: (input: Builder<A>) => Builder<B>, op3: (input: Builder<B>) => Builder<C>, op4: (input: Builder<C>) => Builder<D>, op5: (input: Builder<D>) => Builder<E>, op6: (input: Builder<E>) => Builder<F>): Builder<F>;
    with<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes>(op1: (input: Builder<T>) => Builder<A>, op2: (input: Builder<A>) => Builder<B>, op3: (input: Builder<B>) => Builder<C>, op4: (input: Builder<C>) => Builder<D>, op5: (input: Builder<D>) => Builder<E>, op6: (input: Builder<E>) => Builder<F>, op7: (input: Builder<F>) => Builder<G>): Builder<G>;
    with<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes>(op1: (input: Builder<T>) => Builder<A>, op2: (input: Builder<A>) => Builder<B>, op3: (input: Builder<B>) => Builder<C>, op4: (input: Builder<C>) => Builder<D>, op5: (input: Builder<D>) => Builder<E>, op6: (input: Builder<E>) => Builder<F>, op7: (input: Builder<F>) => Builder<G>, op8: (input: Builder<G>) => Builder<H>): Builder<H>;
    with<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes>(op1: (input: Builder<T>) => Builder<A>, op2: (input: Builder<A>) => Builder<B>, op3: (input: Builder<B>) => Builder<C>, op4: (input: Builder<C>) => Builder<D>, op5: (input: Builder<D>) => Builder<E>, op6: (input: Builder<E>) => Builder<F>, op7: (input: Builder<F>) => Builder<G>, op8: (input: Builder<G>) => Builder<H>, op9: (input: Builder<H>) => Builder<I>): Builder<I>;
    with<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes>(op1: (input: Builder<T>) => Builder<A>, op2: (input: Builder<A>) => Builder<B>, op3: (input: Builder<B>) => Builder<C>, op4: (input: Builder<C>) => Builder<D>, op5: (input: Builder<D>) => Builder<E>, op6: (input: Builder<E>) => Builder<F>, op7: (input: Builder<F>) => Builder<G>, op8: (input: Builder<G>) => Builder<H>, op9: (input: Builder<H>) => Builder<I>, op10: (input: Builder<I>) => Builder<J>): Builder<J>;
}
declare namespace Builder {
    function forSpecification<const Spec extends BuilderSpecification>(spec: Spec): {
        builder: Builder<Types.FromSpecification<Spec>>;
        model: ModelHelpers<Types.FromSpecification<Spec>>;
        views: ViewHelpers<Types.FromSpecification<Spec>['NewViewProps']>;
    };
}

declare const ElementColors: {
    readonly primary: {
        fill: "#3b82f6";
        stroke: "#2563eb";
        hiContrast: "#eff6ff";
        loContrast: "#bfdbfe";
    };
    readonly blue: {
        fill: "#3b82f6";
        stroke: "#2563eb";
        hiContrast: "#eff6ff";
        loContrast: "#bfdbfe";
    };
    readonly secondary: {
        fill: "#0284c7";
        stroke: "#0369a1";
        hiContrast: "#f0f9ff";
        loContrast: "#B6ECF7";
    };
    readonly sky: {
        fill: "#0284c7";
        stroke: "#0369a1";
        hiContrast: "#f0f9ff";
        loContrast: "#B6ECF7";
    };
    readonly muted: {
        fill: "#64748b";
        stroke: "#475569";
        hiContrast: "#f8fafc";
        loContrast: "#cbd5e1";
    };
    readonly slate: {
        fill: "#64748b";
        stroke: "#475569";
        hiContrast: "#f8fafc";
        loContrast: "#cbd5e1";
    };
    readonly gray: {
        readonly fill: "#737373";
        readonly stroke: "#525252";
        readonly hiContrast: "#fafafa";
        readonly loContrast: "#d4d4d4";
    };
    readonly red: {
        readonly fill: "#AC4D39";
        readonly stroke: "#853A2D";
        readonly hiContrast: "#FBD3CB";
        readonly loContrast: "#f5b2a3";
    };
    readonly green: {
        readonly fill: "#428a4f";
        readonly stroke: "#2d5d39";
        readonly hiContrast: "#f8fafc";
        readonly loContrast: "#c2f0c2";
    };
    readonly amber: {
        readonly fill: "#A35829";
        readonly stroke: "#7E451D";
        readonly hiContrast: "#FFE0C2";
        readonly loContrast: "#f9b27c";
    };
    readonly indigo: {
        readonly fill: "#6366f1";
        readonly stroke: "#4f46e5";
        readonly hiContrast: "#eef2ff";
        readonly loContrast: "#c7d2fe";
    };
};

declare const RelationshipColors: {
    amber: {
        lineColor: "#b45309";
        labelBgColor: "#78350f";
        labelColor: "#FFE0C2";
    };
    blue: {
        lineColor: "#3b82f6";
        labelBgColor: "#172554";
        labelColor: "#60a5fa";
    };
    gray: {
        lineColor: "#6E6E6E";
        labelBgColor: "#18191b";
        labelColor: "#C6C6C6";
    };
    green: {
        lineColor: "#15803d";
        labelBgColor: "#052e16";
        labelColor: "#22c55e";
    };
    indigo: {
        lineColor: "#6366f1";
        labelBgColor: "#1e1b4b";
        labelColor: "#818cf8";
    };
    muted: {
        lineColor: "#64748b";
        labelBgColor: "#0f172a";
        labelColor: "#cbd5e1";
    };
    primary: {
        lineColor: "#3b82f6";
        labelBgColor: "#172554";
        labelColor: "#60a5fa";
    };
    red: {
        lineColor: "#AC4D39";
        labelBgColor: "#b91c1c";
        labelColor: "#f5b2a3";
    };
    secondary: {
        lineColor: "#0ea5e9";
        labelBgColor: "#082f49";
        labelColor: "#38bdf8";
    };
    sky: {
        lineColor: "#0ea5e9";
        labelBgColor: "#082f49";
        labelColor: "#38bdf8";
    };
    slate: {
        lineColor: "#64748b";
        labelBgColor: "#0f172a";
        labelColor: "#cbd5e1";
    };
};

declare const defaultTheme: {
    elements: {
        readonly primary: {
            fill: "#3b82f6";
            stroke: "#2563eb";
            hiContrast: "#eff6ff";
            loContrast: "#bfdbfe";
        };
        readonly blue: {
            fill: "#3b82f6";
            stroke: "#2563eb";
            hiContrast: "#eff6ff";
            loContrast: "#bfdbfe";
        };
        readonly secondary: {
            fill: "#0284c7";
            stroke: "#0369a1";
            hiContrast: "#f0f9ff";
            loContrast: "#B6ECF7";
        };
        readonly sky: {
            fill: "#0284c7";
            stroke: "#0369a1";
            hiContrast: "#f0f9ff";
            loContrast: "#B6ECF7";
        };
        readonly muted: {
            fill: "#64748b";
            stroke: "#475569";
            hiContrast: "#f8fafc";
            loContrast: "#cbd5e1";
        };
        readonly slate: {
            fill: "#64748b";
            stroke: "#475569";
            hiContrast: "#f8fafc";
            loContrast: "#cbd5e1";
        };
        readonly gray: {
            readonly fill: "#737373";
            readonly stroke: "#525252";
            readonly hiContrast: "#fafafa";
            readonly loContrast: "#d4d4d4";
        };
        readonly red: {
            readonly fill: "#AC4D39";
            readonly stroke: "#853A2D";
            readonly hiContrast: "#FBD3CB";
            readonly loContrast: "#f5b2a3";
        };
        readonly green: {
            readonly fill: "#428a4f";
            readonly stroke: "#2d5d39";
            readonly hiContrast: "#f8fafc";
            readonly loContrast: "#c2f0c2";
        };
        readonly amber: {
            readonly fill: "#A35829";
            readonly stroke: "#7E451D";
            readonly hiContrast: "#FFE0C2";
            readonly loContrast: "#f9b27c";
        };
        readonly indigo: {
            readonly fill: "#6366f1";
            readonly stroke: "#4f46e5";
            readonly hiContrast: "#eef2ff";
            readonly loContrast: "#c7d2fe";
        };
    };
    relationships: {
        amber: {
            lineColor: "#b45309";
            labelBgColor: "#78350f";
            labelColor: "#FFE0C2";
        };
        blue: {
            lineColor: "#3b82f6";
            labelBgColor: "#172554";
            labelColor: "#60a5fa";
        };
        gray: {
            lineColor: "#6E6E6E";
            labelBgColor: "#18191b";
            labelColor: "#C6C6C6";
        };
        green: {
            lineColor: "#15803d";
            labelBgColor: "#052e16";
            labelColor: "#22c55e";
        };
        indigo: {
            lineColor: "#6366f1";
            labelBgColor: "#1e1b4b";
            labelColor: "#818cf8";
        };
        muted: {
            lineColor: "#64748b";
            labelBgColor: "#0f172a";
            labelColor: "#cbd5e1";
        };
        primary: {
            lineColor: "#3b82f6";
            labelBgColor: "#172554";
            labelColor: "#60a5fa";
        };
        red: {
            lineColor: "#AC4D39";
            labelBgColor: "#b91c1c";
            labelColor: "#f5b2a3";
        };
        secondary: {
            lineColor: "#0ea5e9";
            labelBgColor: "#082f49";
            labelColor: "#38bdf8";
        };
        sky: {
            lineColor: "#0ea5e9";
            labelBgColor: "#082f49";
            labelColor: "#38bdf8";
        };
        slate: {
            lineColor: "#64748b";
            labelBgColor: "#0f172a";
            labelColor: "#cbd5e1";
        };
    };
    font: "Arial";
    shadow: "#0a0a0a";
};

declare function nonNullable<T>(value: T, message?: string): NonNullable<T>;
declare function invariant(condition: any, message?: string): asserts condition;
declare function nonexhaustive(value: never): never;

type Fqn = LiteralUnion<Fqn$1, string>;
type RelationID = LiteralUnion<RelationID$1, string>;
type ViewID = LiteralUnion<ViewID$1, string>;
type EdgeId = LiteralUnion<EdgeId$1, string>;
type IncomingFilter = 'all' | 'direct' | 'to-descendants';
type OutgoingFilter = 'all' | 'direct' | 'from-descendants';
type ElementOrFqn = Fqn | {
    id: Fqn;
};

/**
 * All methods are view-scoped, i.e. only return elements and connections in the view.
 */
declare class LikeC4ViewModel {
    readonly view: ComputedView;
    readonly model: LikeC4Model<LikeC4ViewModel>;
    private readonly _rootElements;
    private readonly _elements;
    private readonly _connections;
    constructor(view: ComputedView, model: LikeC4Model<LikeC4ViewModel>);
    get id(): ViewID$1<string>;
    get title(): string;
    get viewOf(): LikeC4Model.ElementModel<LikeC4ViewModel>;
    get tags(): Tag$1[];
    roots(): ReadonlyArray<LikeC4ViewModel.Element>;
    elements(): ReadonlyArray<LikeC4ViewModel.Element>;
    element(id: Fqn): LikeC4ViewModel.Element;
    hasElement(id: Fqn): boolean;
    connections(): ReadonlyArray<LikeC4ViewModel.Connection>;
    connection(id: EdgeId): LikeC4ViewModel.Connection;
    findConnections(source: ElementOrFqn, target: ElementOrFqn, direction?: 'both' | 'direct'): ReadonlyArray<LikeC4ViewModel.Connection>;
    parent(element: ElementOrFqn): LikeC4ViewModel.Element | null;
    children(element: ElementOrFqn): ReadonlyArray<LikeC4ViewModel.Element>;
    siblings(element: ElementOrFqn): ReadonlyArray<LikeC4ViewModel.Element>;
    /**
     * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
     * (from closest to root)
     */
    ancestors(element: ElementOrFqn): ReadonlyArray<LikeC4ViewModel.Element>;
    descendants(element: ElementOrFqn): ReadonlyArray<LikeC4ViewModel.Element>;
    incoming(element: ElementOrFqn, filter?: IncomingFilter): ReadonlyArray<LikeC4ViewModel.Connection>;
    incomers(element: ElementOrFqn, filter?: IncomingFilter): ReadonlyArray<LikeC4ViewModel.Element>;
    /**
     * Outgoing relationships from the element and its descendants
     */
    outgoing(element: ElementOrFqn, filter?: OutgoingFilter): ReadonlyArray<LikeC4ViewModel.Connection>;
    outgoers(element: ElementOrFqn, filter?: OutgoingFilter): ReadonlyArray<LikeC4ViewModel.Element>;
}
declare namespace LikeC4ViewModel {
    /**
     * Represents an element in the view. (Diagram node)
     * All methods are view-scoped, i.e. `children` returns only children of the element in the view.
     */
    class Element {
        readonly node: ComputedNode;
        private readonly viewmodel;
        constructor(node: ComputedNode, viewmodel: LikeC4ViewModel);
        get id(): NodeId<string>;
        get title(): string;
        get kind(): ElementKind$1;
        get isRoot(): boolean;
        get hasNested(): boolean;
        get shape(): ElementShape$1;
        get color(): Color$1;
        get tags(): Tag$1[];
        model(): LikeC4Model.ElementModel<LikeC4ViewModel>;
        parent(): LikeC4ViewModel.Element | null;
        metadata(key: string): string | undefined;
        metadata(key: string, defaultValue: string): string;
        hasMetadata(key: string): boolean;
        ancestors(): ReadonlyArray<LikeC4ViewModel.Element>;
        siblings(): ReadonlyArray<LikeC4ViewModel.Element>;
        descendants(): ReadonlyArray<LikeC4ViewModel.Element>;
        children(): ReadonlyArray<LikeC4ViewModel.Element>;
        incoming(filter?: 'all' | 'direct' | 'to-descendants'): ReadonlyArray<LikeC4ViewModel.Connection>;
        incomers(filter?: 'all' | 'direct' | 'to-descendants'): ReadonlyArray<LikeC4ViewModel.Element>;
        outgoing(filter?: OutgoingFilter): ReadonlyArray<LikeC4ViewModel.Connection>;
        outgoers(filter?: OutgoingFilter): ReadonlyArray<LikeC4ViewModel.Element>;
        connectionsTo(target: Fqn | LikeC4ViewModel.Element): ReadonlyArray<LikeC4ViewModel.Connection>;
    }
    /**
     * Represents a connection between two elements.
     * May be source from multiple model relationships.
     */
    class Connection {
        readonly edge: ComputedEdge;
        private readonly viewmodel;
        constructor(edge: ComputedEdge, viewmodel: LikeC4ViewModel);
        get id(): EdgeId$1;
        get source(): LikeC4ViewModel.Element;
        get target(): LikeC4ViewModel.Element;
        get tags(): Tag$1[];
        /**
         * Model relationships
         */
        relationships(): ReadonlyArray<LikeC4Model.Relationship<LikeC4ViewModel>>;
    }
}

type PickBySource<Source> = Source extends LikeC4Model.Layouted.SourceModel ? LikeC4Model.Layouted : Source extends LikeC4Model.Computed.SourceModel ? LikeC4Model.Computed : never;
declare class LikeC4Model<M extends LikeC4Model.ViewModel = LikeC4Model.ViewModel> {
    readonly type: LikeC4Model.ModelType<M>;
    readonly sourcemodel: LikeC4Model.SourceModel<M>;
    private _elements;
    private _parents;
    private _children;
    private _rootElements;
    private _relations;
    private _incoming;
    private _outgoing;
    private _internal;
    private _cacheAscendingSiblings;
    private _views;
    constructor(type: LikeC4Model.ModelType<M>, sourcemodel: LikeC4Model.SourceModel<M>, elements: Element$1[], relations: Relation$1[], views: LikeC4Model.SourceModel<M>['views'], ViewModelClass: Class<M>);
    /**
     * Returns the root elements of the model.
     */
    roots(): ReadonlyArray<LikeC4Model.ElementModel<M>>;
    /**
     * Returns all elements in the model.
     */
    elements(): ReadonlyArray<LikeC4Model.ElementModel<M>>;
    /**
     * Returns a specific element by its FQN.
     */
    element(id: Fqn): LikeC4Model.ElementModel<M>;
    /**
     * Returns all relationships in the model.
     */
    relationships(): ReadonlyArray<LikeC4Model.Relationship<M>>;
    /**
     * Returns a specific relationship by its ID.
     */
    relationship(id: RelationID): LikeC4Model.Relationship<M>;
    /**
     * Returns all views in the model.
     */
    views(): ReadonlyArray<M>;
    /**
     * Returns a specific view by its ID.
     */
    view(viewId: ViewID): M;
    /**
     * Returns the parent element of given element.
     * @see ancestors
     */
    parent(element: ElementOrFqn): LikeC4Model.ElementModel<M> | null;
    /**
     * Get all children of the element (only direct children),
     * @see descendants
     */
    children(element: ElementOrFqn): ReadonlyArray<LikeC4Model.ElementModel<M>>;
    /**
     * Get all sibling (i.e. same parent)
     */
    siblings(element: ElementOrFqn): ReadonlyArray<LikeC4Model.ElementModel<M>>;
    /**
     * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
     * (from closest to root)
     */
    ancestors(element: ElementOrFqn): ReadonlyArray<LikeC4Model.ElementModel<M>>;
    /**
     * Get all descendant elements (i.e. children, children’s children, etc.)
     */
    descendants(element: ElementOrFqn): ReadonlyArray<LikeC4Model.ElementModel<M>>;
    /**
     * Incoming relationships to the element and its descendants
     * @see incomers
     */
    incoming(element: ElementOrFqn, filter?: IncomingFilter): ReadonlyArray<LikeC4Model.Relationship<M>>;
    /**
     * Source elements of incoming relationships
     */
    incomers(element: ElementOrFqn, filter?: IncomingFilter): ReadonlyArray<LikeC4Model.ElementModel<M>>;
    /**
     * Outgoing relationships from the element and its descendants
     * @see outgoers
     */
    outgoing(element: ElementOrFqn, filter?: OutgoingFilter): ReadonlyArray<LikeC4Model.Relationship<M>>;
    /**
     * Target elements of outgoing relationships
     */
    outgoers(element: ElementOrFqn, filter?: OutgoingFilter): ReadonlyArray<LikeC4Model.ElementModel<M>>;
    /**
     * Relationships inside the element, among descendants
     */
    internal(element: ElementOrFqn): ReadonlyArray<LikeC4Model.Relationship<M>>;
    /**
     * Resolve siblings of the element and siblings of ancestors
     *  (from closest to root)
     */
    ascendingSiblings(element: ElementOrFqn): ReadonlyArray<LikeC4Model.ElementModel<M>>;
    /**
     * Resolve all views that contain the element
     */
    viewsWithElement(element: ElementOrFqn): ReadonlyArray<M>;
    private addElement;
    private addRelation;
    private _childrenOf;
    private _incomingTo;
    private _outgoingFrom;
    private _internalOf;
}
declare namespace LikeC4Model {
    function create(source: LikeC4Model.SourceModel): PickBySource<typeof source>;
    function computed(source: ComputedLikeC4Model): LikeC4Model<LikeC4ViewModel>;
    function layouted(source: LayoutedLikeC4Model): LikeC4Model<LikeC4DiagramModel>;
    function isModel(model: any): model is LikeC4Model;
    type SourceModel<M extends ViewModel = ViewModel> = M extends LikeC4DiagramModel ? LayoutedLikeC4Model : ComputedLikeC4Model;
    type ViewModel = LikeC4ViewModel | LikeC4DiagramModel;
    namespace ViewModel {
        type ElementModel = LikeC4ViewModel.Element | LikeC4DiagramModel.Element;
        type Relationship = LikeC4Model.Relationship<ViewModel>;
        function isLayouted(model: ViewModel): model is LikeC4DiagramModel;
    }
    type Computed = LikeC4Model<LikeC4ViewModel>;
    namespace Computed {
        type ViewModel = LikeC4ViewModel;
        type SourceModel = LikeC4Model.SourceModel<ViewModel>;
    }
    type Layouted = LikeC4Model<LikeC4DiagramModel>;
    namespace Layouted {
        type ViewModel = LikeC4DiagramModel;
        type SourceModel = LikeC4Model.SourceModel<ViewModel>;
    }
    type ModelType<M extends ViewModel = ViewModel> = M extends LikeC4DiagramModel ? 'layouted' : M extends LikeC4ViewModel ? 'computed' : never;
    function isLayouted(model: LikeC4Model): model is Layouted;
    class Relationship<M extends ViewModel = ViewModel> {
        readonly relationship: Relation$1;
        private readonly model;
        constructor(relationship: Relation$1, model: LikeC4Model<M>);
        get id(): RelationID$1;
        get title(): string;
        get kind(): RelationshipKind$1<string>;
        get tags(): Tag$1[];
        get source(): ElementModel<M>;
        get target(): ElementModel<M>;
        metadata(key: string): string | undefined;
        metadata(key: string, defaultValue: string): string;
        hasMetadata(key: string): boolean;
    }
    class ElementModel<M extends ViewModel = ViewModel> {
        readonly element: Element$1;
        private readonly model;
        constructor(element: Element$1, model: LikeC4Model<M>);
        get id(): Fqn$1<string>;
        get title(): string;
        get kind(): ElementKind$1;
        get isRoot(): boolean;
        get hasNested(): boolean;
        get shape(): ElementShape$1;
        get color(): Color$1;
        get tags(): Tag$1[];
        parent(): ElementModel<M> | null;
        metadata(key: string): string | undefined;
        metadata(key: string, defaultValue: string): string;
        hasMetadata(key: string): boolean;
        ancestors(): readonly ElementModel<M>[];
        siblings(): readonly ElementModel<M>[];
        descendants(): readonly ElementModel<M>[];
        children(): readonly ElementModel<M>[];
        /**
         * First 'view of' current element
         */
        viewOf(): M;
        /**
         * All views 'view of' current element
         */
        viewsOf(): M[];
        /**
         * Views that contain this element
         */
        views(): readonly M[];
        incoming(filter?: IncomingFilter): readonly Relationship<M>[];
        incomers(filter?: IncomingFilter): readonly ElementModel<M>[];
        outgoing(filter?: OutgoingFilter): readonly Relationship<M>[];
        outgoers(filter?: OutgoingFilter): readonly ElementModel<M>[];
        internal(): readonly Relationship<M>[];
        /**
         * Resolve siblings of the element and siblings of ancestors
         *  (from closest to root)
         */
        ascendingSiblings(): readonly ElementModel<M>[];
    }
}

/**
 * All methods are view-scoped, i.e. only return elements and connections in the view.
 */
declare class LikeC4DiagramModel {
    readonly view: DiagramView;
    readonly model: LikeC4Model.Layouted;
    private readonly _rootElements;
    private readonly _elements;
    private readonly _connections;
    constructor(view: DiagramView, model: LikeC4Model.Layouted);
    get isDynamic(): boolean;
    get id(): ViewID$1<string>;
    get title(): string;
    get viewOf(): LikeC4Model.ElementModel<LikeC4DiagramModel>;
    get tags(): Tag$1[];
    roots(): ReadonlyArray<LikeC4DiagramModel.Element>;
    elements(): ReadonlyArray<LikeC4DiagramModel.Element>;
    element(id: Fqn): LikeC4DiagramModel.Element;
    hasElement(id: Fqn): boolean;
    connections(): ReadonlyArray<LikeC4DiagramModel.Connection>;
    connection(id: EdgeId): LikeC4DiagramModel.Connection;
    findConnections(source: ElementOrFqn, target: ElementOrFqn, direction?: 'both' | 'direct'): ReadonlyArray<LikeC4DiagramModel.Connection>;
    parent(element: ElementOrFqn): LikeC4DiagramModel.Element | null;
    children(element: ElementOrFqn): ReadonlyArray<LikeC4DiagramModel.Element>;
    siblings(element: ElementOrFqn): ReadonlyArray<LikeC4DiagramModel.Element>;
    /**
     * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
     * (from closest to root)
     */
    ancestors(element: ElementOrFqn): ReadonlyArray<LikeC4DiagramModel.Element>;
    descendants(element: ElementOrFqn): ReadonlyArray<LikeC4DiagramModel.Element>;
    incoming(element: ElementOrFqn, filter?: IncomingFilter): ReadonlyArray<LikeC4DiagramModel.Connection>;
    incomers(element: ElementOrFqn, filter?: IncomingFilter): ReadonlyArray<LikeC4DiagramModel.Element>;
    /**
     * Outgoing relationships from the element and its descendants
     */
    outgoing(element: ElementOrFqn, filter?: OutgoingFilter): ReadonlyArray<LikeC4DiagramModel.Connection>;
    outgoers(element: ElementOrFqn, filter?: OutgoingFilter): ReadonlyArray<LikeC4DiagramModel.Element>;
}
declare namespace LikeC4DiagramModel {
    /**
     * Represents an element in the view. (Diagram node)
     * All methods are view-scoped, i.e. `children` returns only children of the element in the view.
     */
    class Element {
        readonly node: DiagramNode;
        private readonly view;
        constructor(node: DiagramNode, view: LikeC4DiagramModel);
        get id(): NodeId<string>;
        get title(): string;
        get kind(): ElementKind$1;
        get isRoot(): boolean;
        get hasNested(): boolean;
        get shape(): ElementShape$1;
        get color(): Color$1;
        get tags(): Tag$1[];
        get level(): number;
        get depth(): number;
        model(): LikeC4Model.ElementModel<LikeC4DiagramModel>;
        parent(): LikeC4DiagramModel.Element | null;
        metadata(key: string): string | undefined;
        metadata(key: string, defaultValue: string): string;
        hasMetadata(key: string): boolean;
        ancestors(): ReadonlyArray<LikeC4DiagramModel.Element>;
        siblings(): ReadonlyArray<LikeC4DiagramModel.Element>;
        descendants(): ReadonlyArray<LikeC4DiagramModel.Element>;
        children(): ReadonlyArray<LikeC4DiagramModel.Element>;
        incoming(filter?: IncomingFilter): ReadonlyArray<LikeC4DiagramModel.Connection>;
        incomers(filter?: IncomingFilter): ReadonlyArray<LikeC4DiagramModel.Element>;
        outgoing(filter?: OutgoingFilter): ReadonlyArray<LikeC4DiagramModel.Connection>;
        outgoers(filter?: OutgoingFilter): ReadonlyArray<LikeC4DiagramModel.Element>;
        connectionsTo(target: Fqn | LikeC4DiagramModel.Element): ReadonlyArray<LikeC4DiagramModel.Connection>;
    }
    /**
     * Represents a connection between two elements.
     * May be source from multiple model relationships.
     */
    class Connection {
        readonly edge: DiagramEdge;
        private readonly view;
        constructor(edge: DiagramEdge, view: LikeC4DiagramModel);
        get id(): EdgeId$1;
        get source(): LikeC4DiagramModel.Element;
        get target(): LikeC4DiagramModel.Element;
        get tags(): Tag$1[];
        get color(): Color$1;
        /**
         * Model relationships
         */
        relationships(): ReadonlyArray<LikeC4Model.Relationship<LikeC4DiagramModel>>;
    }
}
declare function nameFromFqn(fqn: LiteralUnion<Fqn$1, string>): string;
declare function isAncestor<E extends {
    id: Fqn$1;
}>(...args: [ancestor: string, another: string] | [ancestor: E, another: E]): boolean;
declare function isSameHierarchy<E extends {
    id: Fqn$1;
}>(one: E | Fqn$1, another: E | Fqn$1): boolean;
declare function isDescendantOf<E extends {
    id: Fqn$1;
}>(ancestors: E[]): (e: E) => boolean;
declare function commonAncestor<IDs extends string>(first: Fqn$1<IDs>, second: Fqn$1<IDs>): Fqn$1<IDs>;
declare function parentFqn<IDs extends string>(fqn: Fqn$1<IDs>): Fqn$1<IDs> | null;
/**
 * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
 * (from closest to root)
 */
declare function ancestorsFqn<IDs extends string>(fqn: Fqn$1<IDs>): Fqn$1<IDs>[];
/**
 * Compares two fully qualified names (fqns) hierarchically based on their depth.
 * From parent nodes to leaves
 *
 * @param {string} a - The first fqn to compare.
 * @param {string} b - The second fqn to compare.
 * @returns {number} - 0 if the fqns have the same depth.
 *                    - Positive number if a is deeper than b.
 *                    - Negative number if b is deeper than a.
 */
declare function compareFqnHierarchically<T extends string = string>(a: T, b: T): -1 | 0 | 1;
declare function compareByFqnHierarchically<T extends {
    id: string;
}>(a: T, b: T): 0 | 1 | -1;

/**
 * This should only be used for defining generics which extend any kind of JS
 * array under the hood, this includes arrays *AND* tuples (of the form [x, y],
 * and of the form [x, ...y[]], etc...), and their readonly equivalent. This
 * allows us to be more inclusive to what functions can process.
 *
 * @example
 *   function map<T extends IterableContainer>(items: T) { ... }
 *
 * We would've named this `ArrayLike`, but that's already used by typescript...
 * @see This was inspired by the type-definition of Promise.all (https://github.com/microsoft/TypeScript/blob/1df5717b120cddd325deab8b0f2b2c3eecaf2b01/src/lib/es2015.promise.d.ts#L21)
 */
type IterableContainer<T = unknown> = ReadonlyArray<T> | readonly [];

type ArraySetRequired<T extends IterableContainer, Min extends number, Iteration extends ReadonlyArray<unknown> = []> = number extends Min ? never : Iteration["length"] extends Min ? T : T extends readonly [] ? never : T extends [infer Head, ...infer Rest] ? [
    Head,
    ...ArraySetRequired<Rest, Min, [unknown, ...Iteration]>
] : T extends readonly [infer Head, ...infer Rest] ? readonly [
    Head,
    ...ArraySetRequired<Rest, Min, [unknown, ...Iteration]>
] : T extends Array<infer Item> ? [
    Item,
    ...ArraySetRequired<T, Min, [unknown, ...Iteration]>
] : T extends ReadonlyArray<infer Item> ? readonly [
    Item,
    ...ArraySetRequired<T, Min, [unknown, ...Iteration]>
] : never;
/**
 * Checks if the given array has at least the defined number of elements. When
 * the minimum used is a literal (e.g. `3`) the output is refined accordingly so
 * that those indices are defined when accessing the array even when using
 * typescript's 'noUncheckedIndexAccess'.
 *
 * @param data - The input array.
 * @param minimum - The minimum number of elements the array must have.
 * @returns True if the array's length is *at least* `minimum`. When `minimum`
 * is a literal value, the output is narrowed to ensure the first items are
 * guaranteed.
 * @signature
 *   R.hasAtLeast(data, minimum)
 * @example
 *   R.hasAtLeast([], 4); // => false
 *
 *   const data: number[] = [1,2,3,4];
 *   R.hasAtLeast(data, 1); // => true
 *   data[0]; // 1, with type `number`
 * @dataFirst
 * @category Array
 */
declare function hasAtLeast<T extends IterableContainer, N extends number>(data: IterableContainer | T, minimum: IsNumericLiteral<N> extends true ? N : never): data is ArraySetRequired<T, N>;
declare function hasAtLeast(data: IterableContainer, minimum: number): boolean;
/**
 * Checks if the given array has at least the defined number of elements. When
 * the minimum used is a literal (e.g. `3`) the output is refined accordingly so
 * that those indices are defined when accessing the array even when using
 * typescript's 'noUncheckedIndexAccess'.
 *
 * @param minimum - The minimum number of elements the array must have.
 * @returns True if the array's length is *at least* `minimum`. When `minimum`
 * is a literal value, the output is narrowed to ensure the first items are
 * guaranteed.
 * @signature
 *   R.hasAtLeast(minimum)(data)
 * @example
 *   R.pipe([], R.hasAtLeast(4)); // => false
 *
 *   const data = [[1,2], [3], [4,5]];
 *   R.pipe(
 *     data,
 *     R.filter(R.hasAtLeast(2)),
 *     R.map(([, second]) => second),
 *   ); // => [2,5], with type `number[]`
 * @dataLast
 * @category Array
 */
declare function hasAtLeast<N extends number>(minimum: IsNumericLiteral<N> extends true ? N : never): <T extends IterableContainer>(data: IterableContainer | T) => data is ArraySetRequired<T, N>;
declare function hasAtLeast(minimum: number): (data: IterableContainer) => boolean;

/**
 * Compares two relations hierarchically.
 * From the most general (implicit) to the most specific.
 */
declare const compareRelations: <T extends {
    source: string;
    target: string;
}>(a: T, b: T) => 0 | 1 | -1;

/**
 * A tagging type for string properties that are actually document URIs.
 */
type DocumentUri$1 = string;
declare namespace DocumentUri$1 {
    function is(value: any): value is DocumentUri$1;
}
/**
 * A tagging type for string properties that are actually URIs
 *
 * @since 3.16.0
 */
type URI$1 = string;
declare namespace URI$1 {
    function is(value: any): value is URI$1;
}
/**
 * Defines an integer in the range of -2^31 to 2^31 - 1.
 */
type integer = number;
declare namespace integer {
    const MIN_VALUE = -2147483648;
    const MAX_VALUE = 2147483647;
    function is(value: any): value is integer;
}
/**
 * Defines an unsigned integer in the range of 0 to 2^31 - 1.
 */
type uinteger = number;
declare namespace uinteger {
    const MIN_VALUE = 0;
    const MAX_VALUE = 2147483647;
    function is(value: any): value is uinteger;
}
/**
 * Defines a decimal number. Since decimal numbers are very
 * rare in the language server specification we denote the
 * exact range with every decimal using the mathematics
 * interval notations (e.g. [0, 1] denotes all decimals d with
 * 0 <= d <= 1.
 */
type decimal = number;
/**
 * The LSP any type.
 *
 * In the current implementation we map LSPAny to any. This is due to the fact
 * that the TypeScript compilers can't infer string access signatures for
 * interface correctly (it can though for types). See the following issue for
 * details: https://github.com/microsoft/TypeScript/issues/15300.
 *
 * When the issue is addressed LSPAny can be defined as follows:
 *
 * ```ts
 * export type LSPAny = LSPObject | LSPArray | string | integer | uinteger | decimal | boolean | null | undefined;
 * export type LSPObject = { [key: string]: LSPAny };
 * export type LSPArray = LSPAny[];
 * ```
 *
 * Please note that strictly speaking a property with the value `undefined`
 * can't be converted into JSON preserving the property name. However for
 * convenience it is allowed and assumed that all these properties are
 * optional as well.
 *
 * @since 3.17.0
 */
type LSPAny = any;
type LSPObject = object;
/**
 * Position in a text document expressed as zero-based line and character
 * offset. Prior to 3.17 the offsets were always based on a UTF-16 string
 * representation. So a string of the form `a𐐀b` the character offset of the
 * character `a` is 0, the character offset of `𐐀` is 1 and the character
 * offset of b is 3 since `𐐀` is represented using two code units in UTF-16.
 * Since 3.17 clients and servers can agree on a different string encoding
 * representation (e.g. UTF-8). The client announces it's supported encoding
 * via the client capability [`general.positionEncodings`](https://microsoft.github.io/language-server-protocol/specifications/specification-current/#clientCapabilities).
 * The value is an array of position encodings the client supports, with
 * decreasing preference (e.g. the encoding at index `0` is the most preferred
 * one). To stay backwards compatible the only mandatory encoding is UTF-16
 * represented via the string `utf-16`. The server can pick one of the
 * encodings offered by the client and signals that encoding back to the
 * client via the initialize result's property
 * [`capabilities.positionEncoding`](https://microsoft.github.io/language-server-protocol/specifications/specification-current/#serverCapabilities). If the string value
 * `utf-16` is missing from the client's capability `general.positionEncodings`
 * servers can safely assume that the client supports UTF-16. If the server
 * omits the position encoding in its initialize result the encoding defaults
 * to the string value `utf-16`. Implementation considerations: since the
 * conversion from one encoding into another requires the content of the
 * file / line the conversion is best done where the file is read which is
 * usually on the server side.
 *
 * Positions are line end character agnostic. So you can not specify a position
 * that denotes `\r|\n` or `\n|` where `|` represents the character offset.
 *
 * @since 3.17.0 - support for negotiated position encoding.
 */
interface Position$2 {
    /**
     * Line position in a document (zero-based).
     *
     * If a line number is greater than the number of lines in a document, it defaults back to the number of lines in the document.
     * If a line number is negative, it defaults to 0.
     */
    line: uinteger;
    /**
     * Character offset on a line in a document (zero-based).
     *
     * The meaning of this offset is determined by the negotiated
     * `PositionEncodingKind`.
     *
     * If the character value is greater than the line length it defaults back to the
     * line length.
     */
    character: uinteger;
}
/**
 * The Position namespace provides helper functions to work with
 * {@link Position} literals.
 */
declare namespace Position$2 {
    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */
    function create(line: uinteger, character: uinteger): Position$2;
    /**
     * Checks whether the given literal conforms to the {@link Position} interface.
     */
    function is(value: any): value is Position$2;
}
/**
 * A range in a text document expressed as (zero-based) start and end positions.
 *
 * If you want to specify a range that contains a line including the line ending
 * character(s) then use an end position denoting the start of the next line.
 * For example:
 * ```ts
 * {
 *     start: { line: 5, character: 23 }
 *     end : { line 6, character : 0 }
 * }
 * ```
 */
interface Range$1 {
    /**
     * The range's start position.
     */
    start: Position$2;
    /**
     * The range's end position.
     */
    end: Position$2;
}
/**
 * The Range namespace provides helper functions to work with
 * {@link Range} literals.
 */
declare namespace Range$1 {
    /**
     * Create a new Range literal.
     * @param start The range's start position.
     * @param end The range's end position.
     */
    function create(start: Position$2, end: Position$2): Range$1;
    /**
     * Create a new Range literal.
     * @param startLine The start line number.
     * @param startCharacter The start character.
     * @param endLine The end line number.
     * @param endCharacter The end character.
     */
    function create(startLine: uinteger, startCharacter: uinteger, endLine: uinteger, endCharacter: uinteger): Range$1;
    /**
     * Checks whether the given literal conforms to the {@link Range} interface.
     */
    function is(value: any): value is Range$1;
}
/**
 * Represents a location inside a resource, such as a line
 * inside a text file.
 */
interface Location {
    uri: DocumentUri$1;
    range: Range$1;
}
/**
 * The Location namespace provides helper functions to work with
 * {@link Location} literals.
 */
declare namespace Location {
    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */
    function create(uri: DocumentUri$1, range: Range$1): Location;
    /**
     * Checks whether the given literal conforms to the {@link Location} interface.
     */
    function is(value: any): value is Location;
}
/**
     * Represents the connection of two locations. Provides additional metadata over normal {@link Location locations},
     * including an origin range.
 */
interface LocationLink {
    /**
     * Span of the origin of this link.
     *
     * Used as the underlined span for mouse interaction. Defaults to the word range at
     * the definition position.
     */
    originSelectionRange?: Range$1;
    /**
     * The target resource identifier of this link.
     */
    targetUri: DocumentUri$1;
    /**
     * The full target range of this link. If the target for example is a symbol then target range is the
     * range enclosing this symbol not including leading/trailing whitespace but everything else
     * like comments. This information is typically used to highlight the range in the editor.
     */
    targetRange: Range$1;
    /**
     * The range that should be selected and revealed when this link is being followed, e.g the name of a function.
     * Must be contained by the `targetRange`. See also `DocumentSymbol#range`
     */
    targetSelectionRange: Range$1;
}
/**
 * The LocationLink namespace provides helper functions to work with
 * {@link LocationLink} literals.
 */
declare namespace LocationLink {
    /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */
    function create(targetUri: DocumentUri$1, targetRange: Range$1, targetSelectionRange: Range$1, originSelectionRange?: Range$1): LocationLink;
    /**
     * Checks whether the given literal conforms to the {@link LocationLink} interface.
     */
    function is(value: any): value is LocationLink;
}
/**
 * Represents a color in RGBA space.
 */
interface Color {
    /**
     * The red component of this color in the range [0-1].
     */
    readonly red: decimal;
    /**
     * The green component of this color in the range [0-1].
     */
    readonly green: decimal;
    /**
     * The blue component of this color in the range [0-1].
     */
    readonly blue: decimal;
    /**
     * The alpha component of this color in the range [0-1].
     */
    readonly alpha: decimal;
}
/**
 * The Color namespace provides helper functions to work with
 * {@link Color} literals.
 */
declare namespace Color {
    /**
     * Creates a new Color literal.
     */
    function create(red: decimal, green: decimal, blue: decimal, alpha: decimal): Color;
    /**
     * Checks whether the given literal conforms to the {@link Color} interface.
     */
    function is(value: any): value is Color;
}
/**
 * Represents a color range from a document.
 */
interface ColorInformation {
    /**
     * The range in the document where this color appears.
     */
    range: Range$1;
    /**
     * The actual color value for this color range.
     */
    color: Color;
}
/**
 * The ColorInformation namespace provides helper functions to work with
 * {@link ColorInformation} literals.
 */
declare namespace ColorInformation {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(range: Range$1, color: Color): ColorInformation;
    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */
    function is(value: any): value is ColorInformation;
}
interface ColorPresentation {
    /**
     * The label of this color presentation. It will be shown on the color
     * picker header. By default this is also the text that is inserted when selecting
     * this color presentation.
     */
    label: string;
    /**
     * An {@link TextEdit edit} which is applied to a document when selecting
     * this presentation for the color.  When `falsy` the {@link ColorPresentation.label label}
     * is used.
     */
    textEdit?: TextEdit$1;
    /**
     * An optional array of additional {@link TextEdit text edits} that are applied when
     * selecting this color presentation. Edits must not overlap with the main {@link ColorPresentation.textEdit edit} nor with themselves.
     */
    additionalTextEdits?: TextEdit$1[];
}
/**
 * The Color namespace provides helper functions to work with
 * {@link ColorPresentation} literals.
 */
declare namespace ColorPresentation {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(label: string, textEdit?: TextEdit$1, additionalTextEdits?: TextEdit$1[]): ColorPresentation;
    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */
    function is(value: any): value is ColorPresentation;
}
/**
 * A set of predefined range kinds.
 */
declare namespace FoldingRangeKind {
    /**
     * Folding range for a comment
     */
    const Comment = "comment";
    /**
     * Folding range for an import or include
     */
    const Imports = "imports";
    /**
     * Folding range for a region (e.g. `#region`)
     */
    const Region = "region";
}
/**
 * A predefined folding range kind.
 *
 * The type is a string since the value set is extensible
 */
type FoldingRangeKind = string;
/**
 * Represents a folding range. To be valid, start and end line must be bigger than zero and smaller
 * than the number of lines in the document. Clients are free to ignore invalid ranges.
 */
interface FoldingRange {
    /**
     * The zero-based start line of the range to fold. The folded area starts after the line's last character.
     * To be valid, the end must be zero or larger and smaller than the number of lines in the document.
     */
    startLine: uinteger;
    /**
     * The zero-based character offset from where the folded range starts. If not defined, defaults to the length of the start line.
     */
    startCharacter?: uinteger;
    /**
     * The zero-based end line of the range to fold. The folded area ends with the line's last character.
     * To be valid, the end must be zero or larger and smaller than the number of lines in the document.
     */
    endLine: uinteger;
    /**
     * The zero-based character offset before the folded range ends. If not defined, defaults to the length of the end line.
     */
    endCharacter?: uinteger;
    /**
     * Describes the kind of the folding range such as `comment' or 'region'. The kind
     * is used to categorize folding ranges and used by commands like 'Fold all comments'.
     * See {@link FoldingRangeKind} for an enumeration of standardized kinds.
     */
    kind?: FoldingRangeKind;
    /**
     * The text that the client should show when the specified range is
     * collapsed. If not defined or not supported by the client, a default
     * will be chosen by the client.
     *
     * @since 3.17.0
     */
    collapsedText?: string;
}
/**
 * The folding range namespace provides helper functions to work with
 * {@link FoldingRange} literals.
 */
declare namespace FoldingRange {
    /**
     * Creates a new FoldingRange literal.
     */
    function create(startLine: uinteger, endLine: uinteger, startCharacter?: uinteger, endCharacter?: uinteger, kind?: FoldingRangeKind, collapsedText?: string): FoldingRange;
    /**
     * Checks whether the given literal conforms to the {@link FoldingRange} interface.
     */
    function is(value: any): value is FoldingRange;
}
/**
 * Represents a related message and source code location for a diagnostic. This should be
 * used to point to code locations that cause or related to a diagnostics, e.g when duplicating
 * a symbol in a scope.
 */
interface DiagnosticRelatedInformation {
    /**
     * The location of this related diagnostic information.
     */
    location: Location;
    /**
     * The message of this related diagnostic information.
     */
    message: string;
}
/**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * {@link DiagnosticRelatedInformation} literals.
 */
declare namespace DiagnosticRelatedInformation {
    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */
    function create(location: Location, message: string): DiagnosticRelatedInformation;
    /**
     * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.
     */
    function is(value: any): value is DiagnosticRelatedInformation;
}
/**
 * The diagnostic's severity.
 */
declare namespace DiagnosticSeverity {
    /**
     * Reports an error.
     */
    const Error: 1;
    /**
     * Reports a warning.
     */
    const Warning: 2;
    /**
     * Reports an information.
     */
    const Information: 3;
    /**
     * Reports a hint.
     */
    const Hint: 4;
}
type DiagnosticSeverity = 1 | 2 | 3 | 4;
/**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */
declare namespace DiagnosticTag {
    /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */
    const Unnecessary: 1;
    /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */
    const Deprecated: 2;
}
type DiagnosticTag = 1 | 2;
/**
 * Structure to capture a description for an error code.
 *
 * @since 3.16.0
 */
interface CodeDescription {
    /**
     * An URI to open with more information about the diagnostic error.
     */
    href: URI$1;
}
/**
 * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.
 *
 * @since 3.16.0
 */
declare namespace CodeDescription {
    function is(value: any): value is CodeDescription;
}
/**
 * Represents a diagnostic, such as a compiler error or warning. Diagnostic objects
 * are only valid in the scope of a resource.
 */
interface Diagnostic {
    /**
     * The range at which the message applies
     */
    range: Range$1;
    /**
     * The diagnostic's severity. Can be omitted. If omitted it is up to the
     * client to interpret diagnostics as error, warning, info or hint.
     */
    severity?: DiagnosticSeverity;
    /**
     * The diagnostic's code, which usually appear in the user interface.
     */
    code?: integer | string;
    /**
     * An optional property to describe the error code.
     * Requires the code field (above) to be present/not null.
     *
     * @since 3.16.0
     */
    codeDescription?: CodeDescription;
    /**
     * A human-readable string describing the source of this
     * diagnostic, e.g. 'typescript' or 'super lint'. It usually
     * appears in the user interface.
     */
    source?: string;
    /**
     * The diagnostic's message. It usually appears in the user interface
     */
    message: string;
    /**
     * Additional metadata about the diagnostic.
     *
     * @since 3.15.0
     */
    tags?: DiagnosticTag[];
    /**
     * An array of related diagnostic information, e.g. when symbol-names within
     * a scope collide all definitions can be marked via this property.
     */
    relatedInformation?: DiagnosticRelatedInformation[];
    /**
     * A data entry field that is preserved between a `textDocument/publishDiagnostics`
     * notification and `textDocument/codeAction` request.
     *
     * @since 3.16.0
     */
    data?: LSPAny;
}
/**
 * The Diagnostic namespace provides helper functions to work with
 * {@link Diagnostic} literals.
 */
declare namespace Diagnostic {
    /**
     * Creates a new Diagnostic literal.
     */
    function create(range: Range$1, message: string, severity?: DiagnosticSeverity, code?: integer | string, source?: string, relatedInformation?: DiagnosticRelatedInformation[]): Diagnostic;
    /**
     * Checks whether the given literal conforms to the {@link Diagnostic} interface.
     */
    function is(value: any): value is Diagnostic;
}
/**
 * Represents a reference to a command. Provides a title which
 * will be used to represent a command in the UI and, optionally,
 * an array of arguments which will be passed to the command handler
 * function when invoked.
 */
interface Command {
    /**
     * Title of the command, like `save`.
     */
    title: string;
    /**
     * The identifier of the actual command handler.
     */
    command: string;
    /**
     * Arguments that the command handler should be
     * invoked with.
     */
    arguments?: LSPAny[];
}
/**
 * The Command namespace provides helper functions to work with
 * {@link Command} literals.
 */
declare namespace Command {
    /**
     * Creates a new Command literal.
     */
    function create(title: string, command: string, ...args: any[]): Command;
    /**
     * Checks whether the given literal conforms to the {@link Command} interface.
     */
    function is(value: any): value is Command;
}
/**
 * A text edit applicable to a text document.
 */
interface TextEdit$1 {
    /**
     * The range of the text document to be manipulated. To insert
     * text into a document create a range where start === end.
     */
    range: Range$1;
    /**
     * The string to be inserted. For delete operations use an
     * empty string.
     */
    newText: string;
}
/**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */
declare namespace TextEdit$1 {
    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */
    function replace(range: Range$1, newText: string): TextEdit$1;
    /**
     * Creates an insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */
    function insert(position: Position$2, newText: string): TextEdit$1;
    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */
    function del(range: Range$1): TextEdit$1;
    function is(value: any): value is TextEdit$1;
}
/**
 * Additional information that describes document changes.
 *
 * @since 3.16.0
 */
interface ChangeAnnotation {
    /**
     * A human-readable string describing the actual change. The string
     * is rendered prominent in the user interface.
     */
    label: string;
    /**
     * A flag which indicates that user confirmation is needed
     * before applying the change.
     */
    needsConfirmation?: boolean;
    /**
     * A human-readable string which is rendered less prominent in
     * the user interface.
     */
    description?: string;
}
declare namespace ChangeAnnotation {
    function create(label: string, needsConfirmation?: boolean, description?: string): ChangeAnnotation;
    function is(value: any): value is ChangeAnnotation;
}
declare namespace ChangeAnnotationIdentifier {
    function is(value: any): value is ChangeAnnotationIdentifier;
}
/**
 * An identifier to refer to a change annotation stored with a workspace edit.
 */
type ChangeAnnotationIdentifier = string;
/**
 * A special text edit with an additional change annotation.
 *
 * @since 3.16.0.
 */
interface AnnotatedTextEdit extends TextEdit$1 {
    /**
     * The actual identifier of the change annotation
     */
    annotationId: ChangeAnnotationIdentifier;
}
declare namespace AnnotatedTextEdit {
    /**
     * Creates an annotated replace text edit.
     *
     * @param range The range of text to be replaced.
     * @param newText The new text.
     * @param annotation The annotation.
     */
    function replace(range: Range$1, newText: string, annotation: ChangeAnnotationIdentifier): AnnotatedTextEdit;
    /**
     * Creates an annotated insert text edit.
     *
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     * @param annotation The annotation.
     */
    function insert(position: Position$2, newText: string, annotation: ChangeAnnotationIdentifier): AnnotatedTextEdit;
    /**
     * Creates an annotated delete text edit.
     *
     * @param range The range of text to be deleted.
     * @param annotation The annotation.
     */
    function del(range: Range$1, annotation: ChangeAnnotationIdentifier): AnnotatedTextEdit;
    function is(value: any): value is AnnotatedTextEdit;
}
/**
 * Describes textual changes on a text document. A TextDocumentEdit describes all changes
 * on a document version Si and after they are applied move the document to version Si+1.
 * So the creator of a TextDocumentEdit doesn't need to sort the array of edits or do any
 * kind of ordering. However the edits must be non overlapping.
 */
interface TextDocumentEdit {
    /**
     * The text document to change.
     */
    textDocument: OptionalVersionedTextDocumentIdentifier;
    /**
     * The edits to be applied.
     *
     * @since 3.16.0 - support for AnnotatedTextEdit. This is guarded using a
     * client capability.
     */
    edits: (TextEdit$1 | AnnotatedTextEdit)[];
}
/**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */
declare namespace TextDocumentEdit {
    /**
     * Creates a new `TextDocumentEdit`
     */
    function create(textDocument: OptionalVersionedTextDocumentIdentifier, edits: (TextEdit$1 | AnnotatedTextEdit)[]): TextDocumentEdit;
    function is(value: any): value is TextDocumentEdit;
}
/**
 * A generic resource operation.
 */
interface ResourceOperation {
    /**
     * The resource operation kind.
     */
    kind: string;
    /**
     * An optional annotation identifier describing the operation.
     *
     * @since 3.16.0
     */
    annotationId?: ChangeAnnotationIdentifier;
}
/**
 * Options to create a file.
 */
interface CreateFileOptions {
    /**
     * Overwrite existing file. Overwrite wins over `ignoreIfExists`
     */
    overwrite?: boolean;
    /**
     * Ignore if exists.
     */
    ignoreIfExists?: boolean;
}
/**
 * Create file operation.
 */
interface CreateFile extends ResourceOperation {
    /**
     * A create
     */
    kind: 'create';
    /**
     * The resource to create.
     */
    uri: DocumentUri$1;
    /**
     * Additional options
     */
    options?: CreateFileOptions;
}
declare namespace CreateFile {
    function create(uri: DocumentUri$1, options?: CreateFileOptions, annotation?: ChangeAnnotationIdentifier): CreateFile;
    function is(value: any): value is CreateFile;
}
/**
 * Rename file options
 */
interface RenameFileOptions {
    /**
     * Overwrite target if existing. Overwrite wins over `ignoreIfExists`
     */
    overwrite?: boolean;
    /**
     * Ignores if target exists.
     */
    ignoreIfExists?: boolean;
}
/**
 * Rename file operation
 */
interface RenameFile extends ResourceOperation {
    /**
     * A rename
     */
    kind: 'rename';
    /**
     * The old (existing) location.
     */
    oldUri: DocumentUri$1;
    /**
     * The new location.
     */
    newUri: DocumentUri$1;
    /**
     * Rename options.
     */
    options?: RenameFileOptions;
}
declare namespace RenameFile {
    function create(oldUri: DocumentUri$1, newUri: DocumentUri$1, options?: RenameFileOptions, annotation?: ChangeAnnotationIdentifier): RenameFile;
    function is(value: any): value is RenameFile;
}
/**
 * Delete file options
 */
interface DeleteFileOptions {
    /**
     * Delete the content recursively if a folder is denoted.
     */
    recursive?: boolean;
    /**
     * Ignore the operation if the file doesn't exist.
     */
    ignoreIfNotExists?: boolean;
}
/**
 * Delete file operation
 */
interface DeleteFile extends ResourceOperation {
    /**
     * A delete
     */
    kind: 'delete';
    /**
     * The file to delete.
     */
    uri: DocumentUri$1;
    /**
     * Delete options.
     */
    options?: DeleteFileOptions;
}
declare namespace DeleteFile {
    function create(uri: DocumentUri$1, options?: DeleteFileOptions, annotation?: ChangeAnnotationIdentifier): DeleteFile;
    function is(value: any): value is DeleteFile;
}
/**
 * A workspace edit represents changes to many resources managed in the workspace. The edit
 * should either provide `changes` or `documentChanges`. If documentChanges are present
 * they are preferred over `changes` if the client can handle versioned document edits.
 *
 * Since version 3.13.0 a workspace edit can contain resource operations as well. If resource
 * operations are present clients need to execute the operations in the order in which they
 * are provided. So a workspace edit for example can consist of the following two changes:
 * (1) a create file a.txt and (2) a text document edit which insert text into file a.txt.
 *
 * An invalid sequence (e.g. (1) delete file a.txt and (2) insert text into file a.txt) will
 * cause failure of the operation. How the client recovers from the failure is described by
 * the client capability: `workspace.workspaceEdit.failureHandling`
 */
interface WorkspaceEdit {
    /**
     * Holds changes to existing resources.
     */
    changes?: {
        [uri: DocumentUri]: TextEdit$1[];
    };
    /**
     * Depending on the client capability `workspace.workspaceEdit.resourceOperations` document changes
     * are either an array of `TextDocumentEdit`s to express changes to n different text documents
     * where each text document edit addresses a specific version of a text document. Or it can contain
     * above `TextDocumentEdit`s mixed with create, rename and delete file / folder operations.
     *
     * Whether a client supports versioned document edits is expressed via
     * `workspace.workspaceEdit.documentChanges` client capability.
     *
     * If a client neither supports `documentChanges` nor `workspace.workspaceEdit.resourceOperations` then
     * only plain `TextEdit`s using the `changes` property are supported.
     */
    documentChanges?: (TextDocumentEdit | CreateFile | RenameFile | DeleteFile)[];
    /**
     * A map of change annotations that can be referenced in `AnnotatedTextEdit`s or create, rename and
     * delete file / folder operations.
     *
     * Whether clients honor this property depends on the client capability `workspace.changeAnnotationSupport`.
     *
     * @since 3.16.0
     */
    changeAnnotations?: {
        [id: ChangeAnnotationIdentifier]: ChangeAnnotation;
    };
}
declare namespace WorkspaceEdit {
    function is(value: any): value is WorkspaceEdit;
}
/**
 * A literal to identify a text document in the client.
 */
interface TextDocumentIdentifier {
    /**
     * The text document's uri.
     */
    uri: DocumentUri$1;
}
/**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * {@link TextDocumentIdentifier} literals.
 */
declare namespace TextDocumentIdentifier {
    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */
    function create(uri: DocumentUri$1): TextDocumentIdentifier;
    /**
     * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.
     */
    function is(value: any): value is TextDocumentIdentifier;
}
/**
 * A text document identifier to denote a specific version of a text document.
 */
interface VersionedTextDocumentIdentifier extends TextDocumentIdentifier {
    /**
     * The version number of this document.
     */
    version: integer;
}
/**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link VersionedTextDocumentIdentifier} literals.
 */
declare namespace VersionedTextDocumentIdentifier {
    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */
    function create(uri: DocumentUri$1, version: integer): VersionedTextDocumentIdentifier;
    /**
     * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.
     */
    function is(value: any): value is VersionedTextDocumentIdentifier;
}
/**
 * A text document identifier to optionally denote a specific version of a text document.
 */
interface OptionalVersionedTextDocumentIdentifier extends TextDocumentIdentifier {
    /**
     * The version number of this document. If a versioned text document identifier
     * is sent from the server to the client and the file is not open in the editor
     * (the server has not received an open notification before) the server can send
     * `null` to indicate that the version is unknown and the content on disk is the
     * truth (as specified with document content ownership).
     */
    version: integer | null;
}
/**
 * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link OptionalVersionedTextDocumentIdentifier} literals.
 */
declare namespace OptionalVersionedTextDocumentIdentifier {
    /**
     * Creates a new OptionalVersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */
    function create(uri: DocumentUri$1, version: integer | null): OptionalVersionedTextDocumentIdentifier;
    /**
     * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.
     */
    function is(value: any): value is OptionalVersionedTextDocumentIdentifier;
}
/**
 * An item to transfer a text document from the client to the
 * server.
 */
interface TextDocumentItem {
    /**
     * The text document's uri.
     */
    uri: DocumentUri$1;
    /**
     * The text document's language identifier.
     */
    languageId: string;
    /**
     * The version number of this document (it will increase after each
     * change, including undo/redo).
     */
    version: integer;
    /**
     * The content of the opened text document.
     */
    text: string;
}
/**
 * The TextDocumentItem namespace provides helper functions to work with
 * {@link TextDocumentItem} literals.
 */
declare namespace TextDocumentItem {
    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */
    function create(uri: DocumentUri$1, languageId: string, version: integer, text: string): TextDocumentItem;
    /**
     * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.
     */
    function is(value: any): value is TextDocumentItem;
}
/**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */
declare namespace MarkupKind {
    /**
     * Plain text is supported as a content format
     */
    const PlainText: 'plaintext';
    /**
     * Markdown is supported as a content format
     */
    const Markdown: 'markdown';
    /**
     * Checks whether the given value is a value of the {@link MarkupKind} type.
     */
    function is(value: any): value is MarkupKind;
}
type MarkupKind = 'plaintext' | 'markdown';
/**
 * A `MarkupContent` literal represents a string value which content is interpreted base on its
 * kind flag. Currently the protocol supports `plaintext` and `markdown` as markup kinds.
 *
 * If the kind is `markdown` then the value can contain fenced code blocks like in GitHub issues.
 * See https://help.github.com/articles/creating-and-highlighting-code-blocks/#syntax-highlighting
 *
 * Here is an example how such a string can be constructed using JavaScript / TypeScript:
 * ```ts
 * let markdown: MarkdownContent = {
 *  kind: MarkupKind.Markdown,
 *  value: [
 *    '# Header',
 *    'Some text',
 *    '```typescript',
 *    'someCode();',
 *    '```'
 *  ].join('\n')
 * };
 * ```
 *
 * *Please Note* that clients might sanitize the return markdown. A client could decide to
 * remove HTML from the markdown to avoid script execution.
 */
interface MarkupContent {
    /**
     * The type of the Markup
     */
    kind: MarkupKind;
    /**
     * The content itself
     */
    value: string;
}
declare namespace MarkupContent {
    /**
     * Checks whether the given value conforms to the {@link MarkupContent} interface.
     */
    function is(value: any): value is MarkupContent;
}
/**
 * The kind of a completion entry.
 */
declare namespace CompletionItemKind {
    const Text: 1;
    const Method: 2;
    const Function: 3;
    const Constructor: 4;
    const Field: 5;
    const Variable: 6;
    const Class: 7;
    const Interface: 8;
    const Module: 9;
    const Property: 10;
    const Unit: 11;
    const Value: 12;
    const Enum: 13;
    const Keyword: 14;
    const Snippet: 15;
    const Color: 16;
    const File: 17;
    const Reference: 18;
    const Folder: 19;
    const EnumMember: 20;
    const Constant: 21;
    const Struct: 22;
    const Event: 23;
    const Operator: 24;
    const TypeParameter: 25;
}
type CompletionItemKind = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25;
/**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */
declare namespace InsertTextFormat {
    /**
     * The primary text to be inserted is treated as a plain string.
     */
    const PlainText: 1;
    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
     */
    const Snippet: 2;
}
type InsertTextFormat = 1 | 2;
/**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */
declare namespace CompletionItemTag {
    /**
     * Render a completion as obsolete, usually using a strike-out.
     */
    const Deprecated = 1;
}
type CompletionItemTag = 1;
/**
 * A special text edit to provide an insert and a replace operation.
 *
 * @since 3.16.0
 */
interface InsertReplaceEdit {
    /**
     * The string to be inserted.
     */
    newText: string;
    /**
     * The range if the insert is requested
     */
    insert: Range$1;
    /**
     * The range if the replace is requested.
     */
    replace: Range$1;
}
/**
 * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.
 *
 * @since 3.16.0
 */
declare namespace InsertReplaceEdit {
    /**
     * Creates a new insert / replace edit
     */
    function create(newText: string, insert: Range$1, replace: Range$1): InsertReplaceEdit;
    /**
     * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.
     */
    function is(value: TextEdit$1 | InsertReplaceEdit): value is InsertReplaceEdit;
}
/**
 * How whitespace and indentation is handled during completion
 * item insertion.
 *
 * @since 3.16.0
 */
declare namespace InsertTextMode {
    /**
     * The insertion or replace strings is taken as it is. If the
     * value is multi line the lines below the cursor will be
     * inserted using the indentation defined in the string value.
     * The client will not apply any kind of adjustments to the
     * string.
     */
    const asIs: 1;
    /**
     * The editor adjusts leading whitespace of new lines so that
     * they match the indentation up to the cursor of the line for
     * which the item is accepted.
     *
     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
     * multi line completion item is indented using 2 tabs and all
     * following lines inserted will be indented using 2 tabs as well.
     */
    const adjustIndentation: 2;
}
type InsertTextMode = 1 | 2;
/**
 * Additional details for a completion item label.
 *
 * @since 3.17.0
 */
interface CompletionItemLabelDetails {
    /**
     * An optional string which is rendered less prominently directly after {@link CompletionItem.label label},
     * without any spacing. Should be used for function signatures and type annotations.
     */
    detail?: string;
    /**
     * An optional string which is rendered less prominently after {@link CompletionItem.detail}. Should be used
     * for fully qualified names and file paths.
     */
    description?: string;
}
declare namespace CompletionItemLabelDetails {
    function is(value: any): value is CompletionItemLabelDetails;
}
/**
 * A completion item represents a text snippet that is
 * proposed to complete text that is being typed.
 */
interface CompletionItem {
    /**
     * The label of this completion item.
     *
     * The label property is also by default the text that
     * is inserted when selecting this completion.
     *
     * If label details are provided the label itself should
     * be an unqualified name of the completion item.
     */
    label: string;
    /**
     * Additional details for the label
     *
     * @since 3.17.0
     */
    labelDetails?: CompletionItemLabelDetails;
    /**
     * The kind of this completion item. Based of the kind
     * an icon is chosen by the editor.
     */
    kind?: CompletionItemKind;
    /**
     * Tags for this completion item.
     *
     * @since 3.15.0
     */
    tags?: CompletionItemTag[];
    /**
     * A human-readable string with additional information
     * about this item, like type or symbol information.
     */
    detail?: string;
    /**
     * A human-readable string that represents a doc-comment.
     */
    documentation?: string | MarkupContent;
    /**
     * Indicates if this item is deprecated.
     * @deprecated Use `tags` instead.
     */
    deprecated?: boolean;
    /**
     * Select this item when showing.
     *
     * *Note* that only one completion item can be selected and that the
     * tool / client decides which item that is. The rule is that the *first*
     * item of those that match best is selected.
     */
    preselect?: boolean;
    /**
     * A string that should be used when comparing this item
     * with other items. When `falsy` the {@link CompletionItem.label label}
     * is used.
     */
    sortText?: string;
    /**
     * A string that should be used when filtering a set of
     * completion items. When `falsy` the {@link CompletionItem.label label}
     * is used.
     */
    filterText?: string;
    /**
     * A string that should be inserted into a document when selecting
     * this completion. When `falsy` the {@link CompletionItem.label label}
     * is used.
     *
     * The `insertText` is subject to interpretation by the client side.
     * Some tools might not take the string literally. For example
     * VS Code when code complete is requested in this example
     * `con<cursor position>` and a completion item with an `insertText` of
     * `console` is provided it will only insert `sole`. Therefore it is
     * recommended to use `textEdit` instead since it avoids additional client
     * side interpretation.
     */
    insertText?: string;
    /**
     * The format of the insert text. The format applies to both the
     * `insertText` property and the `newText` property of a provided
     * `textEdit`. If omitted defaults to `InsertTextFormat.PlainText`.
     *
     * Please note that the insertTextFormat doesn't apply to
     * `additionalTextEdits`.
     */
    insertTextFormat?: InsertTextFormat;
    /**
     * How whitespace and indentation is handled during completion
     * item insertion. If not provided the clients default value depends on
     * the `textDocument.completion.insertTextMode` client capability.
     *
     * @since 3.16.0
     */
    insertTextMode?: InsertTextMode;
    /**
     * An {@link TextEdit edit} which is applied to a document when selecting
     * this completion. When an edit is provided the value of
     * {@link CompletionItem.insertText insertText} is ignored.
     *
     * Most editors support two different operations when accepting a completion
     * item. One is to insert a completion text and the other is to replace an
     * existing text with a completion text. Since this can usually not be
     * predetermined by a server it can report both ranges. Clients need to
     * signal support for `InsertReplaceEdits` via the
     * `textDocument.completion.insertReplaceSupport` client capability
     * property.
     *
     * *Note 1:* The text edit's range as well as both ranges from an insert
     * replace edit must be a [single line] and they must contain the position
     * at which completion has been requested.
     * *Note 2:* If an `InsertReplaceEdit` is returned the edit's insert range
     * must be a prefix of the edit's replace range, that means it must be
     * contained and starting at the same position.
     *
     * @since 3.16.0 additional type `InsertReplaceEdit`
     */
    textEdit?: TextEdit$1 | InsertReplaceEdit;
    /**
     * The edit text used if the completion item is part of a CompletionList and
     * CompletionList defines an item default for the text edit range.
     *
     * Clients will only honor this property if they opt into completion list
     * item defaults using the capability `completionList.itemDefaults`.
     *
     * If not provided and a list's default range is provided the label
     * property is used as a text.
     *
     * @since 3.17.0
     */
    textEditText?: string;
    /**
     * An optional array of additional {@link TextEdit text edits} that are applied when
     * selecting this completion. Edits must not overlap (including the same insert position)
     * with the main {@link CompletionItem.textEdit edit} nor with themselves.
     *
     * Additional text edits should be used to change text unrelated to the current cursor position
     * (for example adding an import statement at the top of the file if the completion item will
     * insert an unqualified type).
     */
    additionalTextEdits?: TextEdit$1[];
    /**
     * An optional set of characters that when pressed while this completion is active will accept it first and
     * then type that character. *Note* that all commit characters should have `length=1` and that superfluous
     * characters will be ignored.
     */
    commitCharacters?: string[];
    /**
     * An optional {@link Command command} that is executed *after* inserting this completion. *Note* that
     * additional modifications to the current document should be described with the
     * {@link CompletionItem.additionalTextEdits additionalTextEdits}-property.
     */
    command?: Command;
    /**
     * A data entry field that is preserved on a completion item between a
     * {@link CompletionRequest} and a {@link CompletionResolveRequest}.
     */
    data?: LSPAny;
}
/**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */
declare namespace CompletionItem {
    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */
    function create(label: string): CompletionItem;
}
/**
 * Represents a collection of {@link CompletionItem completion items} to be presented
 * in the editor.
 */
interface CompletionList {
    /**
     * This list it not complete. Further typing results in recomputing this list.
     *
     * Recomputed lists have all their items replaced (not appended) in the
     * incomplete completion sessions.
     */
    isIncomplete: boolean;
    /**
     * In many cases the items of an actual completion result share the same
     * value for properties like `commitCharacters` or the range of a text
     * edit. A completion list can therefore define item defaults which will
     * be used if a completion item itself doesn't specify the value.
     *
     * If a completion list specifies a default value and a completion item
     * also specifies a corresponding value the one from the item is used.
     *
     * Servers are only allowed to return default values if the client
     * signals support for this via the `completionList.itemDefaults`
     * capability.
     *
     * @since 3.17.0
     */
    itemDefaults?: {
        /**
         * A default commit character set.
         *
         * @since 3.17.0
         */
        commitCharacters?: string[];
        /**
         * A default edit range.
         *
         * @since 3.17.0
         */
        editRange?: Range$1 | {
            insert: Range$1;
            replace: Range$1;
        };
        /**
         * A default insert text format.
         *
         * @since 3.17.0
         */
        insertTextFormat?: InsertTextFormat;
        /**
         * A default insert text mode.
         *
         * @since 3.17.0
         */
        insertTextMode?: InsertTextMode;
        /**
         * A default data value.
         *
         * @since 3.17.0
         */
        data?: LSPAny;
    };
    /**
     * The completion items.
     */
    items: CompletionItem[];
}
/**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */
declare namespace CompletionList {
    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */
    function create(items?: CompletionItem[], isIncomplete?: boolean): CompletionList;
}
/**
 * MarkedString can be used to render human readable text. It is either a markdown string
 * or a code-block that provides a language and a code snippet. The language identifier
 * is semantically equal to the optional language identifier in fenced code blocks in GitHub
 * issues. See https://help.github.com/articles/creating-and-highlighting-code-blocks/#syntax-highlighting
 *
 * The pair of a language and a value is an equivalent to markdown:
 * ```${language}
 * ${value}
 * ```
 *
 * Note that markdown strings will be sanitized - that means html will be escaped.
 * @deprecated use MarkupContent instead.
 */
type MarkedString = string | {
    language: string;
    value: string;
};
declare namespace MarkedString {
    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */
    function fromPlainText(plainText: string): string;
    /**
     * Checks whether the given value conforms to the {@link MarkedString} type.
     */
    function is(value: any): value is MarkedString;
}
/**
 * The result of a hover request.
 */
interface Hover {
    /**
     * The hover's content
     */
    contents: MarkupContent | MarkedString | MarkedString[];
    /**
     * An optional range inside the text document that is used to
     * visualize the hover, e.g. by changing the background color.
     */
    range?: Range$1;
}
declare namespace Hover {
    /**
     * Checks whether the given value conforms to the {@link Hover} interface.
     */
    function is(value: any): value is Hover;
}
/**
 * Represents a parameter of a callable-signature. A parameter can
 * have a label and a doc-comment.
 */
interface ParameterInformation {
    /**
     * The label of this parameter information.
     *
     * Either a string or an inclusive start and exclusive end offsets within its containing
     * signature label. (see SignatureInformation.label). The offsets are based on a UTF-16
     * string representation as `Position` and `Range` does.
     *
     * *Note*: a label of type string should be a substring of its containing signature label.
     * Its intended use case is to highlight the parameter label part in the `SignatureInformation.label`.
     */
    label: string | [uinteger, uinteger];
    /**
     * The human-readable doc-comment of this parameter. Will be shown
     * in the UI but can be omitted.
     */
    documentation?: string | MarkupContent;
}
/**
 * The ParameterInformation namespace provides helper functions to work with
 * {@link ParameterInformation} literals.
 */
declare namespace ParameterInformation {
    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */
    function create(label: string | [uinteger, uinteger], documentation?: string): ParameterInformation;
}
/**
 * Represents the signature of something callable. A signature
 * can have a label, like a function-name, a doc-comment, and
 * a set of parameters.
 */
interface SignatureInformation {
    /**
     * The label of this signature. Will be shown in
     * the UI.
     */
    label: string;
    /**
     * The human-readable doc-comment of this signature. Will be shown
     * in the UI but can be omitted.
     */
    documentation?: string | MarkupContent;
    /**
     * The parameters of this signature.
     */
    parameters?: ParameterInformation[];
    /**
     * The index of the active parameter.
     *
     * If provided, this is used in place of `SignatureHelp.activeParameter`.
     *
     * @since 3.16.0
     */
    activeParameter?: uinteger;
}
/**
 * The SignatureInformation namespace provides helper functions to work with
 * {@link SignatureInformation} literals.
 */
declare namespace SignatureInformation {
    function create(label: string, documentation?: string, ...parameters: ParameterInformation[]): SignatureInformation;
}
/**
 * Signature help represents the signature of something
 * callable. There can be multiple signature but only one
 * active and only one active parameter.
 */
interface SignatureHelp {
    /**
     * One or more signatures.
     */
    signatures: SignatureInformation[];
    /**
     * The active signature. If omitted or the value lies outside the
     * range of `signatures` the value defaults to zero or is ignored if
     * the `SignatureHelp` has no signatures.
     *
     * Whenever possible implementors should make an active decision about
     * the active signature and shouldn't rely on a default value.
     *
     * In future version of the protocol this property might become
     * mandatory to better express this.
     */
    activeSignature?: uinteger;
    /**
     * The active parameter of the active signature. If omitted or the value
     * lies outside the range of `signatures[activeSignature].parameters`
     * defaults to 0 if the active signature has parameters. If
     * the active signature has no parameters it is ignored.
     * In future version of the protocol this property might become
     * mandatory to better express the active parameter if the
     * active signature does have any.
     */
    activeParameter?: uinteger;
}
/**
 * The definition of a symbol represented as one or many {@link Location locations}.
 * For most programming languages there is only one location at which a symbol is
 * defined.
 *
 * Servers should prefer returning `DefinitionLink` over `Definition` if supported
 * by the client.
 */
type Definition = Location | Location[];
/**
 * Information about where a symbol is defined.
 *
 * Provides additional metadata over normal {@link Location location} definitions, including the range of
 * the defining symbol
 */
type DefinitionLink = LocationLink;
/**
 * The declaration of a symbol representation as one or many {@link Location locations}.
 */
type Declaration$1 = Location | Location[];
/**
 * Information about where a symbol is declared.
 *
 * Provides additional metadata over normal {@link Location location} declarations, including the range of
 * the declaring symbol.
 *
 * Servers should prefer returning `DeclarationLink` over `Declaration` if supported
 * by the client.
 */
type DeclarationLink = LocationLink;
/**
 * Value-object that contains additional information when
 * requesting references.
 */
interface ReferenceContext {
    /**
     * Include the declaration of the current symbol.
     */
    includeDeclaration: boolean;
}
/**
 * A document highlight kind.
 */
declare namespace DocumentHighlightKind {
    /**
     * A textual occurrence.
     */
    const Text: 1;
    /**
     * Read-access of a symbol, like reading a variable.
     */
    const Read: 2;
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    const Write: 3;
}
type DocumentHighlightKind = 1 | 2 | 3;
/**
 * A document highlight is a range inside a text document which deserves
 * special attention. Usually a document highlight is visualized by changing
 * the background color of its range.
 */
interface DocumentHighlight {
    /**
     * The range this highlight applies to.
     */
    range: Range$1;
    /**
     * The highlight kind, default is {@link DocumentHighlightKind.Text text}.
     */
    kind?: DocumentHighlightKind;
}
/**
 * DocumentHighlight namespace to provide helper functions to work with
 * {@link DocumentHighlight} literals.
 */
declare namespace DocumentHighlight {
    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     * @param kind The highlight kind
     */
    function create(range: Range$1, kind?: DocumentHighlightKind): DocumentHighlight;
}
/**
 * A symbol kind.
 */
declare namespace SymbolKind {
    const File: 1;
    const Module: 2;
    const Namespace: 3;
    const Package: 4;
    const Class: 5;
    const Method: 6;
    const Property: 7;
    const Field: 8;
    const Constructor: 9;
    const Enum: 10;
    const Interface: 11;
    const Function: 12;
    const Variable: 13;
    const Constant: 14;
    const String: 15;
    const Number: 16;
    const Boolean: 17;
    const Array: 18;
    const Object: 19;
    const Key: 20;
    const Null: 21;
    const EnumMember: 22;
    const Struct: 23;
    const Event: 24;
    const Operator: 25;
    const TypeParameter: 26;
}
type SymbolKind = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26;
/**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 *
 * @since 3.16
 */
declare namespace SymbolTag {
    /**
     * Render a symbol as obsolete, usually using a strike-out.
     */
    const Deprecated: 1;
}
type SymbolTag = 1;
/**
 * A base for all symbol information.
 */
interface BaseSymbolInformation {
    /**
     * The name of this symbol.
     */
    name: string;
    /**
     * The kind of this symbol.
     */
    kind: SymbolKind;
    /**
     * Tags for this symbol.
     *
     * @since 3.16.0
     */
    tags?: SymbolTag[];
    /**
     * The name of the symbol containing this symbol. This information is for
     * user interface purposes (e.g. to render a qualifier in the user interface
     * if necessary). It can't be used to re-infer a hierarchy for the document
     * symbols.
     */
    containerName?: string;
}
/**
 * Represents information about programming constructs like variables, classes,
 * interfaces etc.
 */
interface SymbolInformation extends BaseSymbolInformation {
    /**
     * Indicates if this symbol is deprecated.
     *
     * @deprecated Use tags instead
     */
    deprecated?: boolean;
    /**
     * The location of this symbol. The location's range is used by a tool
     * to reveal the location in the editor. If the symbol is selected in the
     * tool the range's start information is used to position the cursor. So
     * the range usually spans more than the actual symbol's name and does
     * normally include things like visibility modifiers.
     *
     * The range doesn't have to denote a node range in the sense of an abstract
     * syntax tree. It can therefore not be used to re-construct a hierarchy of
     * the symbols.
     */
    location: Location;
}
declare namespace SymbolInformation {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol.
     * @param containerName The name of the symbol containing the symbol.
     */
    function create(name: string, kind: SymbolKind, range: Range$1, uri: DocumentUri$1, containerName?: string): SymbolInformation;
}
/**
 * A special workspace symbol that supports locations without a range.
 *
 * See also SymbolInformation.
 *
 * @since 3.17.0
 */
interface WorkspaceSymbol extends BaseSymbolInformation {
    /**
     * The location of the symbol. Whether a server is allowed to
     * return a location without a range depends on the client
     * capability `workspace.symbol.resolveSupport`.
     *
     * See SymbolInformation#location for more details.
     */
    location: Location | {
        uri: DocumentUri$1;
    };
    /**
     * A data entry field that is preserved on a workspace symbol between a
     * workspace symbol request and a workspace symbol resolve request.
     */
    data?: LSPAny;
}
declare namespace WorkspaceSymbol {
    /**
     * Create a new workspace symbol.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param uri The resource of the location of the symbol.
     * @param range An options range of the location.
     * @returns A WorkspaceSymbol.
     */
    function create(name: string, kind: SymbolKind, uri: DocumentUri$1, range?: Range$1): WorkspaceSymbol;
}
/**
 * Represents programming constructs like variables, classes, interfaces etc.
 * that appear in a document. Document symbols can be hierarchical and they
 * have two ranges: one that encloses its definition and one that points to
 * its most interesting range, e.g. the range of an identifier.
 */
interface DocumentSymbol {
    /**
     * The name of this symbol. Will be displayed in the user interface and therefore must not be
     * an empty string or a string only consisting of white spaces.
     */
    name: string;
    /**
     * More detail for this symbol, e.g the signature of a function.
     */
    detail?: string;
    /**
     * The kind of this symbol.
     */
    kind: SymbolKind;
    /**
     * Tags for this document symbol.
     *
     * @since 3.16.0
     */
    tags?: SymbolTag[];
    /**
     * Indicates if this symbol is deprecated.
     *
     * @deprecated Use tags instead
     */
    deprecated?: boolean;
    /**
     * The range enclosing this symbol not including leading/trailing whitespace but everything else
     * like comments. This information is typically used to determine if the clients cursor is
     * inside the symbol to reveal in the symbol in the UI.
     */
    range: Range$1;
    /**
     * The range that should be selected and revealed when this symbol is being picked, e.g the name of a function.
     * Must be contained by the `range`.
     */
    selectionRange: Range$1;
    /**
     * Children of this symbol, e.g. properties of a class.
     */
    children?: DocumentSymbol[];
}
declare namespace DocumentSymbol {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */
    function create(name: string, detail: string | undefined, kind: SymbolKind, range: Range$1, selectionRange: Range$1, children?: DocumentSymbol[]): DocumentSymbol;
    /**
     * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.
     */
    function is(value: any): value is DocumentSymbol;
}
/**
 * The kind of a code action.
 *
 * Kinds are a hierarchical list of identifiers separated by `.`, e.g. `"refactor.extract.function"`.
 *
 * The set of kinds is open and client needs to announce the kinds it supports to the server during
 * initialization.
 */
type CodeActionKind = string;
/**
 * A set of predefined code action kinds
 */
declare namespace CodeActionKind {
    /**
     * Empty kind.
     */
    const Empty: '';
    /**
     * Base kind for quickfix actions: 'quickfix'
     */
    const QuickFix: 'quickfix';
    /**
     * Base kind for refactoring actions: 'refactor'
     */
    const Refactor: 'refactor';
    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */
    const RefactorExtract: 'refactor.extract';
    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */
    const RefactorInline: 'refactor.inline';
    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */
    const RefactorRewrite: 'refactor.rewrite';
    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */
    const Source: 'source';
    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */
    const SourceOrganizeImports: 'source.organizeImports';
    /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */
    const SourceFixAll: 'source.fixAll';
}
/**
 * The reason why code actions were requested.
 *
 * @since 3.17.0
 */
declare namespace CodeActionTriggerKind {
    /**
     * Code actions were explicitly requested by the user or by an extension.
     */
    const Invoked: 1;
    /**
     * Code actions were requested automatically.
     *
     * This typically happens when current selection in a file changes, but can
     * also be triggered when file content changes.
     */
    const Automatic: 2;
}
type CodeActionTriggerKind = 1 | 2;
/**
 * Contains additional diagnostic information about the context in which
 * a {@link CodeActionProvider.provideCodeActions code action} is run.
 */
interface CodeActionContext {
    /**
     * An array of diagnostics known on the client side overlapping the range provided to the
     * `textDocument/codeAction` request. They are provided so that the server knows which
     * errors are currently presented to the user for the given range. There is no guarantee
     * that these accurately reflect the error state of the resource. The primary parameter
     * to compute code actions is the provided range.
     */
    diagnostics: Diagnostic[];
    /**
     * Requested kind of actions to return.
     *
     * Actions not of this kind are filtered out by the client before being shown. So servers
     * can omit computing them.
     */
    only?: CodeActionKind[];
    /**
     * The reason why code actions were requested.
     *
     * @since 3.17.0
     */
    triggerKind?: CodeActionTriggerKind;
}
/**
 * The CodeActionContext namespace provides helper functions to work with
 * {@link CodeActionContext} literals.
 */
declare namespace CodeActionContext {
    /**
     * Creates a new CodeActionContext literal.
     */
    function create(diagnostics: Diagnostic[], only?: CodeActionKind[], triggerKind?: CodeActionTriggerKind): CodeActionContext;
    /**
     * Checks whether the given literal conforms to the {@link CodeActionContext} interface.
     */
    function is(value: any): value is CodeActionContext;
}
/**
 * A code action represents a change that can be performed in code, e.g. to fix a problem or
 * to refactor code.
 *
 * A CodeAction must set either `edit` and/or a `command`. If both are supplied, the `edit` is applied first, then the `command` is executed.
 */
interface CodeAction {
    /**
     * A short, human-readable, title for this code action.
     */
    title: string;
    /**
     * The kind of the code action.
     *
     * Used to filter code actions.
     */
    kind?: CodeActionKind;
    /**
     * The diagnostics that this code action resolves.
     */
    diagnostics?: Diagnostic[];
    /**
     * Marks this as a preferred action. Preferred actions are used by the `auto fix` command and can be targeted
     * by keybindings.
     *
     * A quick fix should be marked preferred if it properly addresses the underlying error.
     * A refactoring should be marked preferred if it is the most reasonable choice of actions to take.
     *
     * @since 3.15.0
     */
    isPreferred?: boolean;
    /**
     * Marks that the code action cannot currently be applied.
     *
     * Clients should follow the following guidelines regarding disabled code actions:
     *
     *   - Disabled code actions are not shown in automatic [lightbulbs](https://code.visualstudio.com/docs/editor/editingevolved#_code-action)
     *     code action menus.
     *
     *   - Disabled actions are shown as faded out in the code action menu when the user requests a more specific type
     *     of code action, such as refactorings.
     *
     *   - If the user has a [keybinding](https://code.visualstudio.com/docs/editor/refactoring#_keybindings-for-code-actions)
     *     that auto applies a code action and only disabled code actions are returned, the client should show the user an
     *     error message with `reason` in the editor.
     *
     * @since 3.16.0
     */
    disabled?: {
        /**
         * Human readable description of why the code action is currently disabled.
         *
         * This is displayed in the code actions UI.
         */
        reason: string;
    };
    /**
     * The workspace edit this code action performs.
     */
    edit?: WorkspaceEdit;
    /**
     * A command this code action executes. If a code action
     * provides an edit and a command, first the edit is
     * executed and then the command.
     */
    command?: Command;
    /**
     * A data entry field that is preserved on a code action between
     * a `textDocument/codeAction` and a `codeAction/resolve` request.
     *
     * @since 3.16.0
     */
    data?: LSPAny;
}
declare namespace CodeAction {
    /**
     * Creates a new code action.
     *
     * @param title The title of the code action.
     * @param kind The kind of the code action.
     */
    function create(title: string, kind?: CodeActionKind): CodeAction;
    /**
     * Creates a new code action.
     *
     * @param title The title of the code action.
     * @param command The command to execute.
     * @param kind The kind of the code action.
     */
    function create(title: string, command: Command, kind?: CodeActionKind): CodeAction;
    /**
     * Creates a new code action.
     *
     * @param title The title of the code action.
     * @param edit The edit to perform.
     * @param kind The kind of the code action.
     */
    function create(title: string, edit: WorkspaceEdit, kind?: CodeActionKind): CodeAction;
    function is(value: any): value is CodeAction;
}
/**
 * A code lens represents a {@link Command command} that should be shown along with
 * source text, like the number of references, a way to run tests, etc.
 *
 * A code lens is _unresolved_ when no command is associated to it. For performance
 * reasons the creation of a code lens and resolving should be done in two stages.
 */
interface CodeLens {
    /**
     * The range in which this code lens is valid. Should only span a single line.
     */
    range: Range$1;
    /**
     * The command this code lens represents.
     */
    command?: Command;
    /**
     * A data entry field that is preserved on a code lens item between
     * a {@link CodeLensRequest} and a {@link CodeLensResolveRequest}
     */
    data?: LSPAny;
}
/**
 * The CodeLens namespace provides helper functions to work with
 * {@link CodeLens} literals.
 */
declare namespace CodeLens {
    /**
     * Creates a new CodeLens literal.
     */
    function create(range: Range$1, data?: LSPAny): CodeLens;
    /**
     * Checks whether the given literal conforms to the {@link CodeLens} interface.
     */
    function is(value: any): value is CodeLens;
}
/**
 * Value-object describing what options formatting should use.
 */
interface FormattingOptions {
    /**
     * Size of a tab in spaces.
     */
    tabSize: uinteger;
    /**
     * Prefer spaces over tabs.
     */
    insertSpaces: boolean;
    /**
     * Trim trailing whitespace on a line.
     *
     * @since 3.15.0
     */
    trimTrailingWhitespace?: boolean;
    /**
     * Insert a newline character at the end of the file if one does not exist.
     *
     * @since 3.15.0
     */
    insertFinalNewline?: boolean;
    /**
     * Trim all newlines after the final newline at the end of the file.
     *
     * @since 3.15.0
     */
    trimFinalNewlines?: boolean;
    /**
     * Signature for further properties.
     */
    [key: string]: boolean | integer | string | undefined;
}
/**
 * The FormattingOptions namespace provides helper functions to work with
 * {@link FormattingOptions} literals.
 */
declare namespace FormattingOptions {
    /**
     * Creates a new FormattingOptions literal.
     */
    function create(tabSize: uinteger, insertSpaces: boolean): FormattingOptions;
    /**
     * Checks whether the given literal conforms to the {@link FormattingOptions} interface.
     */
    function is(value: any): value is FormattingOptions;
}
/**
 * A document link is a range in a text document that links to an internal or external resource, like another
 * text document or a web site.
 */
interface DocumentLink {
    /**
     * The range this link applies to.
     */
    range: Range$1;
    /**
     * The uri this link points to. If missing a resolve request is sent later.
     */
    target?: URI$1;
    /**
     * The tooltip text when you hover over this link.
     *
     * If a tooltip is provided, is will be displayed in a string that includes instructions on how to
     * trigger the link, such as `{0} (ctrl + click)`. The specific instructions vary depending on OS,
     * user settings, and localization.
     *
     * @since 3.15.0
     */
    tooltip?: string;
    /**
     * A data entry field that is preserved on a document link between a
     * DocumentLinkRequest and a DocumentLinkResolveRequest.
     */
    data?: LSPAny;
}
/**
 * The DocumentLink namespace provides helper functions to work with
 * {@link DocumentLink} literals.
 */
declare namespace DocumentLink {
    /**
     * Creates a new DocumentLink literal.
     */
    function create(range: Range$1, target?: string, data?: LSPAny): DocumentLink;
    /**
     * Checks whether the given literal conforms to the {@link DocumentLink} interface.
     */
    function is(value: any): value is DocumentLink;
}
/**
 * A selection range represents a part of a selection hierarchy. A selection range
 * may have a parent selection range that contains it.
 */
interface SelectionRange {
    /**
     * The {@link Range range} of this selection range.
     */
    range: Range$1;
    /**
     * The parent selection range containing this range. Therefore `parent.range` must contain `this.range`.
     */
    parent?: SelectionRange;
}
/**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */
declare namespace SelectionRange {
    /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */
    function create(range: Range$1, parent?: SelectionRange): SelectionRange;
    function is(value: any): value is SelectionRange;
}
/**
 * Represents programming constructs like functions or constructors in the context
 * of call hierarchy.
 *
 * @since 3.16.0
 */
interface CallHierarchyItem {
    /**
     * The name of this item.
     */
    name: string;
    /**
     * The kind of this item.
     */
    kind: SymbolKind;
    /**
     * Tags for this item.
     */
    tags?: SymbolTag[];
    /**
     * More detail for this item, e.g. the signature of a function.
     */
    detail?: string;
    /**
     * The resource identifier of this item.
     */
    uri: DocumentUri$1;
    /**
     * The range enclosing this symbol not including leading/trailing whitespace but everything else, e.g. comments and code.
     */
    range: Range$1;
    /**
     * The range that should be selected and revealed when this symbol is being picked, e.g. the name of a function.
     * Must be contained by the {@link CallHierarchyItem.range `range`}.
     */
    selectionRange: Range$1;
    /**
     * A data entry field that is preserved between a call hierarchy prepare and
     * incoming calls or outgoing calls requests.
     */
    data?: LSPAny;
}
/**
 * Represents an incoming call, e.g. a caller of a method or constructor.
 *
 * @since 3.16.0
 */
interface CallHierarchyIncomingCall {
    /**
     * The item that makes the call.
     */
    from: CallHierarchyItem;
    /**
     * The ranges at which the calls appear. This is relative to the caller
     * denoted by {@link CallHierarchyIncomingCall.from `this.from`}.
     */
    fromRanges: Range$1[];
}
/**
 * Represents an outgoing call, e.g. calling a getter from a method or a method from a constructor etc.
 *
 * @since 3.16.0
 */
interface CallHierarchyOutgoingCall {
    /**
     * The item that is called.
     */
    to: CallHierarchyItem;
    /**
     * The range at which this item is called. This is the range relative to the caller, e.g the item
     * passed to {@link CallHierarchyItemProvider.provideCallHierarchyOutgoingCalls `provideCallHierarchyOutgoingCalls`}
     * and not {@link CallHierarchyOutgoingCall.to `this.to`}.
     */
    fromRanges: Range$1[];
}
/**
 * @since 3.16.0
 */
interface SemanticTokensLegend {
    /**
     * The token types a server uses.
     */
    tokenTypes: string[];
    /**
     * The token modifiers a server uses.
     */
    tokenModifiers: string[];
}
/**
 * @since 3.16.0
 */
interface SemanticTokens {
    /**
     * An optional result id. If provided and clients support delta updating
     * the client will include the result id in the next semantic token request.
     * A server can then instead of computing all semantic tokens again simply
     * send a delta.
     */
    resultId?: string;
    /**
     * The actual tokens.
     */
    data: uinteger[];
}
/**
 * @since 3.16.0
 */
declare namespace SemanticTokens {
    function is(value: any): value is SemanticTokens;
}
/**
 * @since 3.16.0
 */
interface SemanticTokensEdit {
    /**
     * The start offset of the edit.
     */
    start: uinteger;
    /**
     * The count of elements to remove.
     */
    deleteCount: uinteger;
    /**
     * The elements to insert.
     */
    data?: uinteger[];
}
/**
 * @since 3.16.0
 */
interface SemanticTokensDelta {
    readonly resultId?: string;
    /**
     * The semantic token edits to transform a previous result into a new result.
     */
    edits: SemanticTokensEdit[];
}
/**
 * @since 3.17.0
 */
type TypeHierarchyItem = {
    /**
     * The name of this item.
     */
    name: string;
    /**
     * The kind of this item.
     */
    kind: SymbolKind;
    /**
     * Tags for this item.
     */
    tags?: SymbolTag[];
    /**
     * More detail for this item, e.g. the signature of a function.
     */
    detail?: string;
    /**
     * The resource identifier of this item.
     */
    uri: DocumentUri$1;
    /**
     * The range enclosing this symbol not including leading/trailing whitespace
     * but everything else, e.g. comments and code.
     */
    range: Range$1;
    /**
     * The range that should be selected and revealed when this symbol is being
     * picked, e.g. the name of a function. Must be contained by the
     * {@link TypeHierarchyItem.range `range`}.
     */
    selectionRange: Range$1;
    /**
     * A data entry field that is preserved between a type hierarchy prepare and
     * supertypes or subtypes requests. It could also be used to identify the
     * type hierarchy in the server, helping improve the performance on
     * resolving supertypes and subtypes.
     */
    data?: LSPAny;
};
/**
 * Provide inline value as text.
 *
 * @since 3.17.0
 */
type InlineValueText = {
    /**
     * The document range for which the inline value applies.
     */
    range: Range$1;
    /**
     * The text of the inline value.
     */
    text: string;
};
/**
 * The InlineValueText namespace provides functions to deal with InlineValueTexts.
 *
 * @since 3.17.0
 */
declare namespace InlineValueText {
    /**
     * Creates a new InlineValueText literal.
     */
    function create(range: Range$1, text: string): InlineValueText;
    function is(value: InlineValue | undefined | null): value is InlineValueText;
}
/**
 * Provide inline value through a variable lookup.
 * If only a range is specified, the variable name will be extracted from the underlying document.
 * An optional variable name can be used to override the extracted name.
 *
 * @since 3.17.0
 */
type InlineValueVariableLookup = {
    /**
     * The document range for which the inline value applies.
     * The range is used to extract the variable name from the underlying document.
     */
    range: Range$1;
    /**
     * If specified the name of the variable to look up.
     */
    variableName?: string;
    /**
     * How to perform the lookup.
     */
    caseSensitiveLookup: boolean;
};
/**
 * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.
 *
 * @since 3.17.0
 */
declare namespace InlineValueVariableLookup {
    /**
     * Creates a new InlineValueText literal.
     */
    function create(range: Range$1, variableName: string | undefined, caseSensitiveLookup: boolean): InlineValueVariableLookup;
    function is(value: InlineValue | undefined | null): value is InlineValueVariableLookup;
}
/**
 * Provide an inline value through an expression evaluation.
 * If only a range is specified, the expression will be extracted from the underlying document.
 * An optional expression can be used to override the extracted expression.
 *
 * @since 3.17.0
 */
type InlineValueEvaluatableExpression = {
    /**
     * The document range for which the inline value applies.
     * The range is used to extract the evaluatable expression from the underlying document.
     */
    range: Range$1;
    /**
     * If specified the expression overrides the extracted expression.
     */
    expression?: string;
};
/**
 * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.
 *
 * @since 3.17.0
 */
declare namespace InlineValueEvaluatableExpression {
    /**
     * Creates a new InlineValueEvaluatableExpression literal.
     */
    function create(range: Range$1, expression: string | undefined): InlineValueEvaluatableExpression;
    function is(value: InlineValue | undefined | null): value is InlineValueEvaluatableExpression;
}
/**
 * Inline value information can be provided by different means:
 * - directly as a text value (class InlineValueText).
 * - as a name to use for a variable lookup (class InlineValueVariableLookup)
 * - as an evaluatable expression (class InlineValueEvaluatableExpression)
 * The InlineValue types combines all inline value types into one type.
 *
 * @since 3.17.0
 */
type InlineValue = InlineValueText | InlineValueVariableLookup | InlineValueEvaluatableExpression;
/**
 * @since 3.17.0
 */
type InlineValueContext = {
    /**
     * The stack frame (as a DAP Id) where the execution has stopped.
     */
    frameId: integer;
    /**
     * The document range where execution has stopped.
     * Typically the end position of the range denotes the line where the inline values are shown.
     */
    stoppedLocation: Range$1;
};
/**
 * The InlineValueContext namespace provides helper functions to work with
 * {@link InlineValueContext} literals.
 *
 * @since 3.17.0
 */
declare namespace InlineValueContext {
    /**
     * Creates a new InlineValueContext literal.
     */
    function create(frameId: integer, stoppedLocation: Range$1): InlineValueContext;
    /**
     * Checks whether the given literal conforms to the {@link InlineValueContext} interface.
     */
    function is(value: any): value is InlineValueContext;
}
/**
 * Inlay hint kinds.
 *
 * @since 3.17.0
 */
declare namespace InlayHintKind {
    /**
     * An inlay hint that for a type annotation.
     */
    const Type = 1;
    /**
     * An inlay hint that is for a parameter.
     */
    const Parameter = 2;
    function is(value: number): value is InlayHintKind;
}
type InlayHintKind = 1 | 2;
/**
 * An inlay hint label part allows for interactive and composite labels
 * of inlay hints.
 *
 * @since 3.17.0
 */
type InlayHintLabelPart = {
    /**
     * The value of this label part.
     */
    value: string;
    /**
     * The tooltip text when you hover over this label part. Depending on
     * the client capability `inlayHint.resolveSupport` clients might resolve
     * this property late using the resolve request.
     */
    tooltip?: string | MarkupContent;
    /**
     * An optional source code location that represents this
     * label part.
     *
     * The editor will use this location for the hover and for code navigation
     * features: This part will become a clickable link that resolves to the
     * definition of the symbol at the given location (not necessarily the
     * location itself), it shows the hover that shows at the given location,
     * and it shows a context menu with further code navigation commands.
     *
     * Depending on the client capability `inlayHint.resolveSupport` clients
     * might resolve this property late using the resolve request.
     */
    location?: Location;
    /**
     * An optional command for this label part.
     *
     * Depending on the client capability `inlayHint.resolveSupport` clients
     * might resolve this property late using the resolve request.
     */
    command?: Command;
};
declare namespace InlayHintLabelPart {
    function create(value: string): InlayHintLabelPart;
    function is(value: any): value is InlayHintLabelPart;
}
/**
 * Inlay hint information.
 *
 * @since 3.17.0
 */
type InlayHint = {
    /**
     * The position of this hint.
     */
    position: Position$2;
    /**
     * The label of this hint. A human readable string or an array of
     * InlayHintLabelPart label parts.
     *
     * *Note* that neither the string nor the label part can be empty.
     */
    label: string | InlayHintLabelPart[];
    /**
     * The kind of this hint. Can be omitted in which case the client
     * should fall back to a reasonable default.
     */
    kind?: InlayHintKind;
    /**
     * Optional text edits that are performed when accepting this inlay hint.
     *
     * *Note* that edits are expected to change the document so that the inlay
     * hint (or its nearest variant) is now part of the document and the inlay
     * hint itself is now obsolete.
     */
    textEdits?: TextEdit$1[];
    /**
     * The tooltip text when you hover over this item.
     */
    tooltip?: string | MarkupContent;
    /**
     * Render padding before the hint.
     *
     * Note: Padding should use the editor's background color, not the
     * background color of the hint itself. That means padding can be used
     * to visually align/separate an inlay hint.
     */
    paddingLeft?: boolean;
    /**
     * Render padding after the hint.
     *
     * Note: Padding should use the editor's background color, not the
     * background color of the hint itself. That means padding can be used
     * to visually align/separate an inlay hint.
     */
    paddingRight?: boolean;
    /**
     * A data entry field that is preserved on an inlay hint between
     * a `textDocument/inlayHint` and a `inlayHint/resolve` request.
     */
    data?: LSPAny;
};
declare namespace InlayHint {
    function create(position: Position$2, label: string | InlayHintLabelPart[], kind?: InlayHintKind): InlayHint;
    function is(value: any): value is InlayHint;
}
/**
 * A workspace folder inside a client.
 */
interface WorkspaceFolder {
    /**
     * The associated URI for this workspace folder.
     */
    uri: URI$1;
    /**
     * The name of the workspace folder. Used to refer to this
     * workspace folder in the user interface.
     */
    name: string;
}
declare namespace WorkspaceFolder {
    function is(value: any): value is WorkspaceFolder;
}

type ParserMethod<ARGS extends unknown[], R> = (...args: ARGS) => R;

/**
 * This class does not actually exist nor is exposed at runtime.
 * This is just a helper to avoid duplications in the Type Definitions
 * Of `CstParser` and `EmbeddedActionsParser`
 */
declare abstract class BaseParser$1 {
  /**
   * This must be called at the end of a Parser constructor.
   * See: http://chevrotain.io/docs/tutorial/step2_parsing.html#under-the-hood
   */
  protected performSelfAnalysis(): void;

  /**
   * It is recommended to reuse the same Parser instance
   * by passing an empty array to the input argument
   * and only later setting the input by using the input property.
   * See: http://chevrotain.io/docs/FAQ.html#major-performance-benefits
   *
   * @param tokenVocabulary - A data structure containing all the Tokens used by the Parser.
   * @param config - The Parser's configuration.
   */
  constructor(tokenVocabulary: TokenVocabulary, config?: IParserConfig);

  errors: IRecognitionException[];

  /**
   * Flag indicating the Parser is at the recording phase.
   * Can be used to implement methods similar to {@link BaseParser.ACTION}
   * Or any other logic to requires knowledge of the recording phase.
   * See:
   *   - https://chevrotain.io/docs/guide/internals.html#grammar-recording
   * to learn more on the recording phase and how Chevrotain works.
   */
  RECORDING_PHASE: boolean;

  /**
   * Resets the parser state, should be overridden for custom parsers which "carry" additional state.
   * When overriding, remember to also invoke the super implementation!
   */
  reset(): void;

  getBaseCstVisitorConstructor<IN = any, OUT = any>(): {
    new (...args: any[]): ICstVisitor<IN, OUT>;
  };

  getBaseCstVisitorConstructorWithDefaults<IN = any, OUT = any>(): {
    new (...args: any[]): ICstVisitor<IN, OUT>;
  };

  getGAstProductions(): Record<string, Rule>;

  getSerializedGastProductions(): ISerializedGast[];

  /**
   * @param startRuleName
   * @param precedingInput - The token vector up to (not including) the content assist point
   */
  computeContentAssist(
    startRuleName: string,
    precedingInput: IToken[],
  ): ISyntacticContentAssistPath[];

  /**
   * @param grammarRule - The rule to try and parse in backtracking mode.
   * @param args - argument to be passed to the grammar rule execution
   *
   * @return a lookahead function that will try to parse the given grammarRule and will return true if succeed.
   */
  protected BACKTRACK<T>(
    grammarRule: (...args: any[]) => T,
    args?: any[],
  ): () => boolean;

  /**
   * The Semantic Actions wrapper.
   * Should be used to wrap semantic actions that either:
   * - May fail when executing in "recording phase".
   * - Have global side effects that should be avoided during "recording phase".
   *
   * For more information see:
   *   - https://chevrotain.io/docs/guide/internals.html#grammar-recording
   */
  protected ACTION<T>(impl: () => T): T;

  /**
   * Like `CONSUME` with the numerical suffix as a parameter, e.g:
   * consume(0, X) === CONSUME(X)
   * consume(1, X) === CONSUME1(X)
   * consume(2, X) === CONSUME2(X)
   * ...
   * @see CONSUME
   */
  protected consume(
    idx: number,
    tokType: TokenType,
    options?: ConsumeMethodOpts,
  ): IToken;

  /**
   * Like `OPTION` with the numerical suffix as a parameter, e.g:
   * option(0, X) === OPTION(X)
   * option(1, X) === OPTION1(X)
   * option(2, X) === OPTION2(X)
   * ...
   * @see OPTION
   */
  protected option<OUT>(
    idx: number,
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * Like `OR` with the numerical suffix as a parameter, e.g:
   * or(0, X) === OR(X)
   * or(1, X) === OR1(X)
   * or(2, X) === OR2(X)
   * ...
   * @see OR
   */
  protected or(idx: number, altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;
  protected or<T>(idx: number, altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;

  /**
   * Like `MANY` with the numerical suffix as a parameter, e.g:
   * many(0, X) === MANY(X)
   * many(1, X) === MANY1(X)
   * many(2, X) === MANY2(X)
   * ...
   * @see MANY
   */
  protected many(
    idx: number,
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * Like `AT_LEAST_ONE` with the numerical suffix as a parameter, e.g:
   * atLeastOne(0, X) === AT_LEAST_ONE(X)
   * atLeastOne(1, X) === AT_LEAST_ONE1(X)
   * atLeastOne(2, X) === AT_LEAST_ONE2(X)
   * ...
   * @see AT_LEAST_ONE
   */
  protected atLeastOne(
    idx: number,
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   *
   * A Parsing DSL method use to consume a single Token.
   * In EBNF terms this is equivalent to a Terminal.
   *
   * A Token will be consumed, IFF the next token in the token vector matches `tokType`.
   * otherwise the parser may attempt to perform error recovery (if enabled).
   *
   * The index in the method name indicates the unique occurrence of a terminal consumption
   * inside a the top level rule. What this means is that if a terminal appears
   * more than once in a single rule, each appearance must have a **different** index.
   *
   * For example:
   * ```
   *   this.RULE("qualifiedName", () => {
   *   this.CONSUME1(Identifier);
   *     this.MANY(() => {
   *       this.CONSUME1(Dot);
   *       // here we use CONSUME2 because the terminal
   *       // 'Identifier' has already appeared previously in the
   *       // the rule 'parseQualifiedName'
   *       this.CONSUME2(Identifier);
   *     });
   *   })
   * ```
   *
   * - See more details on the [unique suffixes requirement](http://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES).
   *
   * @param tokType - The Type of the token to be consumed.
   * @param options - optional properties to modify the behavior of CONSUME.
   */
  protected CONSUME(tokType: TokenType, options?: ConsumeMethodOpts): IToken;

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME1(tokType: TokenType, options?: ConsumeMethodOpts): IToken;

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME2(tokType: TokenType, options?: ConsumeMethodOpts): IToken;

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME3(tokType: TokenType, options?: ConsumeMethodOpts): IToken;

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME4(tokType: TokenType, options?: ConsumeMethodOpts): IToken;

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME5(tokType: TokenType, options?: ConsumeMethodOpts): IToken;

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME6(tokType: TokenType, options?: ConsumeMethodOpts): IToken;

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME7(tokType: TokenType, options?: ConsumeMethodOpts): IToken;

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME8(tokType: TokenType, options?: ConsumeMethodOpts): IToken;

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME9(tokType: TokenType, options?: ConsumeMethodOpts): IToken;

  /**
   * Parsing DSL Method that Indicates an Optional production.
   * in EBNF notation this is equivalent to: "[...]".
   *
   * Note that there are two syntax forms:
   * - Passing the grammar action directly:
   *   ```
   *     this.OPTION(() => {
   *       this.CONSUME(Digit)}
   *     );
   *   ```
   *
   * - using an "options" object:
   *   ```
   *     this.OPTION({
   *       GATE:predicateFunc,
   *       DEF: () => {
   *         this.CONSUME(Digit)
   *     }});
   *   ```
   *
   * The optional 'GATE' property in "options" object form can be used to add constraints
   * to invoking the grammar action.
   *
   * As in CONSUME the index in the method name indicates the occurrence
   * of the optional production in it's top rule.
   *
   * @param  actionORMethodDef - The grammar action to optionally invoke once
   *                             or an "OPTIONS" object describing the grammar action and optional properties.
   *
   * @returns The `GrammarAction` return value (OUT) if the optional syntax is encountered
   *          or `undefined` if not.
   */
  protected OPTION<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION1<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION2<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION3<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION4<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION5<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION6<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION7<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION8<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION9<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * Parsing DSL method that indicates a choice between a set of alternatives must be made.
   * This is equivalent to an EBNF alternation (A | B | C | D ...), except
   * that the alternatives are ordered like in a PEG grammar.
   * This means that the **first** matching alternative is always chosen.
   *
   * There are several forms for the inner alternatives array:
   *
   * - Passing alternatives array directly:
   *   ```
   *     this.OR([
   *       { ALT:() => { this.CONSUME(One) }},
   *       { ALT:() => { this.CONSUME(Two) }},
   *       { ALT:() => { this.CONSUME(Three) }}
   *     ])
   *   ```
   *
   * - Passing alternative array directly with predicates (GATE):
   *   ```
   *     this.OR([
   *       { GATE: predicateFunc1, ALT:() => { this.CONSUME(One) }},
   *       { GATE: predicateFuncX, ALT:() => { this.CONSUME(Two) }},
   *       { GATE: predicateFuncX, ALT:() => { this.CONSUME(Three) }}
   *     ])
   *   ```
   *
   * - These syntax forms can also be mixed:
   *   ```
   *     this.OR([
   *       {
   *         GATE: predicateFunc1,
   *         ALT:() => { this.CONSUME(One) }
   *       },
   *       { ALT:() => { this.CONSUME(Two) }},
   *       { ALT:() => { this.CONSUME(Three) }}
   *     ])
   *   ```
   *
   * - Additionally an "options" object may be used:
   *   ```
   *     this.OR({
   *       DEF:[
   *         { ALT:() => { this.CONSUME(One) }},
   *         { ALT:() => { this.CONSUME(Two) }},
   *         { ALT:() => { this.CONSUME(Three) }}
   *       ],
   *       // OPTIONAL property
   *       ERR_MSG: "A Number"
   *     })
   *   ```
   *
   * The 'predicateFuncX' in the long form can be used to add constraints to choosing the alternative.
   *
   * As in CONSUME the index in the method name indicates the occurrence
   * of the alternation production in it's top rule.
   *
   * @param altsOrOpts - A set of alternatives or an "OPTIONS" object describing the alternatives and optional properties.
   *
   * @returns The result of invoking the chosen alternative.
   */
  protected OR<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;
  protected OR(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;

  /**
   * @see OR
   * @hidden
   */
  protected OR1<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;
  protected OR1(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;

  /**
   * @see OR
   * @hidden
   */
  protected OR2<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;
  protected OR2(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;

  /**
   * @see OR
   * @hidden
   */
  protected OR3<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;
  protected OR3(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;

  /**
   * @see OR
   * @hidden
   */
  protected OR4<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;
  protected OR4(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;

  /**
   * @see OR
   * @hidden
   */
  protected OR5<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;
  protected OR5(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;

  /**
   * @see OR
   * @hidden
   */
  protected OR6<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;
  protected OR6(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;

  /**
   * @see OR
   * @hidden
   */
  protected OR7<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;
  protected OR7(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;

  /**
   * @see OR
   * @hidden
   */
  protected OR8<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;
  protected OR8(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;

  /**
   * @see OR
   * @hidden
   */
  protected OR9<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;
  protected OR9(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;

  /**
   * Parsing DSL method, that indicates a repetition of zero or more.
   * This is equivalent to EBNF repetition \{...\}.
   *
   * Note that there are two syntax forms:
   * - Passing the grammar action directly:
   *   ```
   *     this.MANY(() => {
   *       this.CONSUME(Comma)
   *       this.CONSUME(Digit)
   *      })
   *   ```
   *
   * - using an "options" object:
   *   ```
   *     this.MANY({
   *       GATE: predicateFunc,
   *       DEF: () => {
   *              this.CONSUME(Comma)
   *              this.CONSUME(Digit)
   *            }
   *     });
   *   ```
   *
   * The optional 'GATE' property in "options" object form can be used to add constraints
   * to invoking the grammar action.
   *
   * As in CONSUME the index in the method name indicates the occurrence
   * of the repetition production in it's top rule.
   *
   * @param actionORMethodDef - The grammar action to optionally invoke multiple times
   *                             or an "OPTIONS" object describing the grammar action and optional properties.
   *
   */
  protected MANY(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * @see MANY
   * @hidden
   */
  protected MANY1(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * @see MANY
   * @hidden
   */
  protected MANY2(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * @see MANY
   * @hidden
   */
  protected MANY3(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * @see MANY
   * @hidden
   */
  protected MANY4(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * @see MANY
   * @hidden
   */
  protected MANY5(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * @see MANY
   * @hidden
   */
  protected MANY6(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * @see MANY
   * @hidden
   */
  protected MANY7(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * @see MANY
   * @hidden
   */
  protected MANY8(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * @see MANY
   * @hidden
   */
  protected MANY9(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * Parsing DSL method, that indicates a repetition of zero or more with a separator
   * Token between the repetitions.
   *
   * Example:
   *
   * ```
   *     this.MANY_SEP({
   *         SEP:Comma,
   *         DEF: () => {
   *             this.CONSUME(Number};
   *             // ...
   *         })
   * ```
   *
   * Note that because this DSL method always requires more than one argument the options object is always required
   * and it is not possible to use a shorter form like in the MANY DSL method.
   *
   * Note that for the purposes of deciding on whether or not another iteration exists
   * Only a single Token is examined (The separator). Therefore if the grammar being implemented is
   * so "crazy" to require multiple tokens to identify an item separator please use the more basic DSL methods
   * to implement it.
   *
   * As in CONSUME the index in the method name indicates the occurrence
   * of the repetition production in it's top rule.
   *
   * @param options - An object defining the grammar of each iteration and the separator between iterations
   *
   */
  protected MANY_SEP(options: ManySepMethodOpts<any>): void;

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP1(options: ManySepMethodOpts<any>): void;

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP2(options: ManySepMethodOpts<any>): void;

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP3(options: ManySepMethodOpts<any>): void;

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP4(options: ManySepMethodOpts<any>): void;

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP5(options: ManySepMethodOpts<any>): void;

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP6(options: ManySepMethodOpts<any>): void;

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP7(options: ManySepMethodOpts<any>): void;

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP8(options: ManySepMethodOpts<any>): void;

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP9(options: ManySepMethodOpts<any>): void;

  /**
   * Convenience method, same as MANY but the repetition is of one or more.
   * failing to match at least one repetition will result in a parsing error and
   * cause a parsing error.
   *
   * @see MANY
   *
   * @param actionORMethodDef  - The grammar action to optionally invoke multiple times
   *                             or an "OPTIONS" object describing the grammar action and optional properties.
   *
   */
  protected AT_LEAST_ONE(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE1(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE2(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE3(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE4(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE5(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE6(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE7(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE8(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE9(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   * Convenience method, same as MANY_SEP but the repetition is of one or more.
   * failing to match at least one repetition will result in a parsing error and
   * cause the parser to attempt error recovery.
   *
   * Note that an additional optional property ERR_MSG can be used to provide custom error messages.
   *
   * @see MANY_SEP
   *
   * @param options - An object defining the grammar of each iteration and the separator between iterations
   *
   * @return {ISeparatedIterationResult<OUT>}
   */
  protected AT_LEAST_ONE_SEP(options: AtLeastOneSepMethodOpts<any>): void;

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP1(options: AtLeastOneSepMethodOpts<any>): void;

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP2(options: AtLeastOneSepMethodOpts<any>): void;

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP3(options: AtLeastOneSepMethodOpts<any>): void;

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP4(options: AtLeastOneSepMethodOpts<any>): void;

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP5(options: AtLeastOneSepMethodOpts<any>): void;

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP6(options: AtLeastOneSepMethodOpts<any>): void;

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP7(options: AtLeastOneSepMethodOpts<any>): void;

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP8(options: AtLeastOneSepMethodOpts<any>): void;

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP9(options: AtLeastOneSepMethodOpts<any>): void;

  /**
   * Returns an "imaginary" Token to insert when Single Token Insertion is done
   * Override this if you require special behavior in your grammar.
   * For example if an IntegerToken is required provide one with the image '0' so it would be valid syntactically.
   */
  protected getTokenToInsert(tokType: TokenType): IToken;

  /**
   * By default, all tokens type may be inserted. This behavior may be overridden in inheriting Recognizers
   * for example: One may decide that only punctuation tokens may be inserted automatically as they have no additional
   * semantic value. (A mandatory semicolon has no additional semantic meaning, but an Integer may have additional meaning
   * depending on its int value and context (Inserting an integer 0 in cardinality: "[1..]" will cause semantic issues
   * as the max of the cardinality will be greater than the min value (and this is a false error!).
   */
  protected canTokenTypeBeInsertedInRecovery(tokType: TokenType): boolean;

  /**
   * By default, all token types may be deleted. This behavior may be overridden in inheriting parsers.
   * The method receives the expected token type. The token that would be deleted can be received with {@link LA}.
   */
  protected canTokenTypeBeDeletedInRecovery(tokType: TokenType): boolean;

  /**
   * @deprecated - will be removed in the future
   */
  protected getNextPossibleTokenTypes(
    grammarPath: ITokenGrammarPath,
  ): TokenType[];

  input: IToken[];

  /**
   * Will consume a single token and return the **next** token, meaning
   * the token **after** the skipped token.
   */
  protected SKIP_TOKEN(): IToken;

  /**
   * Look-Ahead for the Token Vector
   * LA(1) is the next Token ahead.
   * LA(n) is the nth Token ahead.
   * LA(0) is the previously consumed Token.
   *
   * Looking beyond the end of the Token Vector or before its begining
   * will return in an IToken of type EOF {@link EOF}.
   * This behavior can be used to avoid infinite loops.
   *
   * This is often used to implement custom lookahead logic for GATES.
   * https://chevrotain.io/docs/features/gates.html
   */
  protected LA(howMuch: number): IToken;
}

/**
 * A Parser that relies on end user's embedded actions to control its output.
 * For more details see:
 *   - https://chevrotain.io/docs/tutorial/step3_adding_actions_root.html#alternatives
 *   - https://chevrotain.io/docs/tutorial/step3b_adding_actions_embedded.html#simple-example
 */
declare class EmbeddedActionsParser extends BaseParser$1 {
  /**
   * Creates a Grammar Rule
   *
   * Note that any parameters of your implementation must be optional as it will
   * be called without parameters during the grammar recording phase.
   */
  protected RULE<F extends (...args: any[]) => any>(
    name: string,
    implementation: F,
    config?: IRuleConfig<ReturnType<F>>,
  ): ParserMethod<Parameters<F>, ReturnType<F>>;

  /**
   * Overrides a Grammar Rule
   * See usage example in: https://github.com/chevrotain/chevrotain/blob/master/examples/parser/versioning/versioning.js
   */
  protected OVERRIDE_RULE<F extends (...args: any[]) => any>(
    name: string,
    implementation: F,
    config?: IRuleConfig<ReturnType<F>>,
  ): ParserMethod<Parameters<F>, ReturnType<F>>;

  /**
   * Like `SUBRULE` with the numerical suffix as a parameter, e.g:
   * subrule(0, X) === SUBRULE(X)
   * subrule(1, X) === SUBRULE1(X)
   * subrule(2, X) === SUBRULE2(X)
   * ...
   * @see SUBRULE
   */
  protected subrule<ARGS extends unknown[], R>(
    idx: number,
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;

  /**
   * The Parsing DSL Method is used by one rule to call another.
   * It is equivalent to a non-Terminal in EBNF notation.
   *
   * This may seem redundant as it does not actually do much.
   * However using it is **mandatory** for all sub rule invocations.
   *
   * Calling another rule without wrapping in SUBRULE(...)
   * will cause errors/mistakes in the Parser's self analysis phase,
   * which will lead to errors in error recovery/automatic lookahead calculation
   * and any other functionality relying on the Parser's self analysis
   * output.
   *
   * As in CONSUME the index in the method name indicates the occurrence
   * of the sub rule invocation in its rule.
   *
   */
  protected SUBRULE<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE1<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE2<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE3<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE4<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE5<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE6<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE7<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE8<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE9<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;
}

interface ILexingError {
  offset: number;
  line: number | undefined;
  column: number | undefined;
  length: number;
  message: string;
}

interface ILexerErrorMessageProvider {
  /**
   * An Unexpected Character Error occurs when the lexer is unable to match a range of one or more
   * characters in the input text against any of the Token Types in it's Lexer definition
   *
   * @param fullText - Full original input text.
   *
   * @param startOffset - Offset in input text where error starts.
   *
   * @param length - Error length.
   *
   * @param line - Line number where the error occurred. (optional)
   *                    Will not be provided when lexer is not defined to track lines/columns
   *
   * @param column - Column number where the error occurred. (optional)
   *                    Will not be provided when lexer is not defined to track lines/columns
   */
  buildUnexpectedCharactersMessage(
    fullText: string,
    startOffset: number,
    length: number,
    line?: number,
    column?: number,
  ): string;

  /**
   * Unable To Pop Lexer Mode Error happens when lexer tries to pop the last remaining mode from the mode stack
   * so that there is no longer any active lexer mode
   * This error only relevant for multi-mode lexers
   *
   * @param token - The Token that requested pop mode.
   */
  buildUnableToPopLexerModeMessage(token: IToken): string;
}

type TokenPattern =
  | RegExp
  | string
  | CustomPatternMatcherFunc
  | ICustomPattern;

/**
 *  API #1 [Custom Token Patterns](http://chevrotain.io/docs/guide/custom_token_patterns.html).
 */
declare type CustomPatternMatcherFunc = (
  /**
   * The full input string.
   */
  text: string,
  /**
   * The offset at which to attempt a match
   */
  offset: number,
  /**
   * Previously scanned Tokens
   */
  tokens: IToken[],
  /**
   * Token Groups
   */
  groups: {
    [groupName: string]: IToken[];
  },
) => CustomPatternMatcherReturn | RegExpExecArray | null; // RegExpExecArray included for legacy reasons

type CustomPatternMatcherReturn = [string] & { payload?: any };

interface TokenType {
  name: string;
  GROUP?: string;
  PATTERN?: TokenPattern;
  LABEL?: string;
  LONGER_ALT?: TokenType | TokenType[];
  POP_MODE?: boolean;
  PUSH_MODE?: string;
  LINE_BREAKS?: boolean;
  CATEGORIES?: TokenType[];
  tokenTypeIdx?: number;
  categoryMatches?: number[];
  categoryMatchesMap?: {
    [tokType: number]: boolean;
  };
  isParent?: boolean;
  START_CHARS_HINT?: (string | number)[];
}

/**
 *  API #2 for [Custom Token Patterns](http://chevrotain.io/docs/guide/custom_token_patterns.html).
 */
interface ICustomPattern {
  exec: CustomPatternMatcherFunc;
}

/**
 * Things to note:
 *  - The offset range is inclusive to exclusive.
 *
 * - A lineTerminator as the last character does not effect the Token's line numbering.
 *   In other words a new line only starts **after** a line terminator.
 *
 * - A Token's image is it's **literal** text.
 *   e.g unicode escaping is untouched.
 */
interface IToken {
  /** The textual representation of the Token as it appeared in the text. */
  image: string;
  /** Offset of the first character of the Token. 0-indexed. */
  startOffset: number;
  /** Line of the first character of the Token. 1-indexed. */
  startLine?: number;
  /**
   * Column of the first character of the Token. 1-indexed.
   *
   * For token foo in the following line, startColumn will be 3 and endColumn will be 5.
   * ```
   * a foo
   * 123456
   * ```
   */
  startColumn?: number;
  /**
   * Offset of the last character of the Token. 0-indexed.
   * Note that this points at the last character, not the end of the token, so the original image would be
   * `input.substring(token.startOffset, token.endOffset + 1)`.
   */
  endOffset?: number;
  /** Line of the last character of the Token. 1-indexed. Will be the same as startLine for single-line tokens.*/
  endLine?: number;
  /** Column of the last character of the Token. 1-indexed. See also startColumn. */
  endColumn?: number;
  /** this marks if a Token does not really exist and has been inserted "artificially" during parsing in rule error recovery. */
  isInsertedInRecovery?: boolean;
  /** An number index representing the type of the Token use <getTokenConstructor> to get the Token Type from a token "instance"  */
  tokenTypeIdx: number;
  /**
   * The actual Token Type of this Token "instance"
   * This is the same Object returned by the "createToken" API.
   * This property is very useful for debugging the Lexing and Parsing phases.
   */
  tokenType: TokenType;

  /**
   * Custom Payload value, this is an optional feature of Custom Token Patterns
   * For additional details see the docs:
   * https://chevrotain.io/docs/guide/custom_token_patterns.html#custom-payloads
   */
  payload?: any;
}

declare type MultiModesDefinition = {
  [modeName: string]: TokenType[];
};

interface IMultiModeLexerDefinition {
  modes: MultiModesDefinition;
  defaultMode: string;
}

type TokenTypeDictionary = { [tokenName: string]: TokenType };

declare type TokenVocabulary =
  | TokenTypeDictionary
  | TokenType[]
  | IMultiModeLexerDefinition;

interface IRuleConfig<T> {
  /**
   * The function which will be invoked to produce the returned value for a production that have not been
   * successfully executed and the parser recovered from.
   */
  recoveryValueFunc?: (e: IRecognitionException) => T;
  /**
   * Enable/Disable re-sync error recovery for this specific production.
   */
  resyncEnabled?: boolean;
}

interface DSLMethodOpts<T> {
  /**
   * The Grammar to process in this method.
   */
  DEF: GrammarAction<T>;
  /**
   * A semantic constraint on this DSL method
   * @see https://github.com/chevrotain/chevrotain/blob/master/examples/parser/predicate_lookahead/predicate_lookahead.js
   * For farther details.
   */
  GATE?: () => boolean;

  /**
   * Maximum number of "following tokens" which would be used to
   * Choose between the alternatives.
   *
   * By default this value is determined by the {@link IParserConfig.maxLookahead} value.
   * A Higher value may be used for a specific DSL method to resolve ambiguities
   * And a lower value may be used to resolve slow initialization times issues.
   *
   * TODO: create full docs and link
   */
  MAX_LOOKAHEAD?: number;
}

interface DSLMethodOptsWithErr<T> extends DSLMethodOpts<T> {
  /**
   *  Short title/classification to what is being matched.
   *  Will be used in the error message,.
   *  If none is provided, the error message will include the names of the expected
   *  Tokens sequences which start the method's inner grammar
   */
  ERR_MSG?: string;
}

interface OrMethodOpts<T> {
  /**
   * The set of alternatives,
   * See detailed description in {@link BaseParser.OR}
   */
  DEF: IOrAlt<T>[];
  /**
   * A description for the alternatives used in error messages
   * If none is provided, the error message will include the names of the expected
   * Tokens sequences which may start each alternative.
   */
  ERR_MSG?: string;

  /**
   * A Flag indicating that **all** ambiguities in this alternation should
   * be ignored.
   *
   * This flag should only be used in rare circumstances,
   * As normally alternation ambiguities should be resolved in other ways:
   * - Re-ordering the alternatives.
   * - Re-factoring the grammar to extract common prefixes before alternation.
   * - Using gates {@link IOrAlt.GATE} to implement custom lookahead logic.
   * - Using the more granular {@link IOrAlt.IGNORE_AMBIGUITIES} on a **specific** alternative.
   */
  IGNORE_AMBIGUITIES?: boolean;

  /**
   * Maximum number of "following tokens" which would be used to
   * Choose between the alternatives.
   *
   * By default this value is determined by the {@link IParserConfig.maxLookahead} value.
   * A Higher value may be used for a specific DSL method to resolve ambiguities
   * And a lower value may be used to resolve slow initialization times issues.
   *
   * TODO: create full docs and link
   */
  MAX_LOOKAHEAD?: number;
}

interface ManySepMethodOpts<T> {
  /**
   * The grammar to process in each iteration.
   */
  DEF: GrammarAction<T>;
  /**
   * The separator between each iteration.
   */
  SEP: TokenType;

  /**
   * @see DSLMethodOpts.MAX_LOOKAHEAD
   */
  MAX_LOOKAHEAD?: number;
}

interface AtLeastOneSepMethodOpts<T> extends ManySepMethodOpts<T> {
  /**
   *  Short title/classification to what is being matched.
   *  Will be used in the error message,.
   *  If none is provided, the error message will include the names of the expected
   *  Tokens sequences which start the method's inner grammar.
   */
  ERR_MSG?: string;
}

interface ConsumeMethodOpts {
  /**
   *  A custom Error message if the Token could not be consumed.
   *  This will override any error message provided by the parser's "errorMessageProvider"
   */
  ERR_MSG?: string;
  /**
   * A label to be used instead of the TokenType name in the created CST.
   */
  LABEL?: string;
}

interface SubruleMethodOpts<ARGS> {
  /**
   * The arguments to parameterized rules, see:
   * https://github.com/chevrotain/chevrotain/blob/master/examples/parser/parametrized_rules/parametrized.js
   */
  ARGS?: ARGS;
  /**
   * A label to be used instead of the subrule's name in the created CST.
   */
  LABEL?: string;
}

declare type GrammarAction<OUT> = () => OUT;

interface IOrAlt<T> {
  GATE?: () => boolean;
  ALT: () => T;
  /**
   * A Flag indicating that any ambiguities involving this
   * specific alternative Should be ignored.
   *
   * This flag will be **implicitly** enabled if a GATE is used
   * as the assumption is that the GATE is used to resolve an ambiguity.
   */
  IGNORE_AMBIGUITIES?: boolean;
}

interface ICstVisitor<IN, OUT> {
  visit(cstNode: CstNode$1 | CstNode$1[], param?: IN): OUT;

  /**
   * Will throw an error if the visitor is missing any required methods
   * - `visitXYZ` for each `XYZ` grammar rule.
   */
  validateVisitor(): void;
}

/**
 * A [Concrete Syntax Tree](http://chevrotain.io/docs/guide/concrete_syntax_tree.html) Node.
 * This structure represents the whole parse tree of the grammar
 * This means that information on each and every Token is present.
 * This is unlike an AST (Abstract Syntax Tree) where some of the syntactic information is missing.
 *
 * For example given an ECMAScript grammar, an AST would normally not contain information on the location
 * of Commas, Semi colons, redundant parenthesis ect, however a CST would have that information.
 */
interface CstNode$1 {
  readonly name: string;
  readonly children: CstChildrenDictionary;
  /**
   * A flag indicating the whole CSTNode has been recovered during **re-sync** error recovery.
   * This means that some of the node's children may be missing.
   * - Note that single token insertion/deletion recovery would not activate this flag.
   *   This flag would only be activated in **re-sync** recovery when the rule's
   *   grammar cannot be fully parsed.
   * - See: https://chevrotain.io/docs/tutorial/step4_fault_tolerance.html
   *   for more info on error recovery and fault tolerance.
   */
  readonly recoveredNode?: boolean;

  /**
   * Will only be present if the {@link IParserConfig.nodeLocationTracking} is
   * **not** set to "none".
   * See: https://chevrotain.io/docs/guide/concrete_syntax_tree.html#cstnodes-location
   * For more details.
   */
  readonly location?: CstNodeLocation;
}

/**
 *  The Column/Line properties will only be present when
 *  The {@link IParserConfig.nodeLocationTracking} is set to "full".
 */
interface CstNodeLocation {
  startOffset: number;
  startLine?: number;
  startColumn?: number;
  endOffset?: number;
  endLine?: number;
  endColumn?: number;
}

declare type CstChildrenDictionary = {
  [identifier: string]: CstElement[];
};

declare type CstElement = IToken | CstNode$1;

declare type nodeLocationTrackingOptions =
  | "full"
  | "onlyOffset"
  | "none";

interface IParserConfig {
  /**
   * Is the error recovery / fault tolerance of the Chevrotain Parser enabled.
   */
  recoveryEnabled?: boolean;
  /**
   * Maximum number of tokens the parser will use to choose between alternatives.
   * By default this value is `4`.
   * In the future it may be reduced to `3` due to performance considerations.
   */
  maxLookahead?: number;
  /**
   * Enable This Flag to to support Dynamically defined Tokens.
   * This will disable performance optimizations which cannot work if the whole Token vocabulary is not known
   * During Parser initialization.
   *
   * See [runnable example](https://github.com/chevrotain/chevrotain/tree/master/examples/parser/dynamic_tokens)
   */
  dynamicTokensEnabled?: boolean;
  /**
   * Enable computation of CST nodes location.
   * By default this is set to "none", meaning this feature is disabled.
   * See: http://chevrotain.io/docs/guide/concrete_syntax_tree.html#cstnode-location
   * For more details.
   */
  nodeLocationTracking?: nodeLocationTrackingOptions;
  /**
   * A custom error message provider.
   * Can be used to override the default error messages.
   * For example:
   *   - Translating the error messages to a different languages.
   *   - Changing the formatting.
   *   - Providing special error messages under certain conditions, e.g: missing semicolons.
   */
  errorMessageProvider?: IParserErrorMessageProvider;
  /**
   * Enabling this flag will print performance tracing logs during parser
   * Initialization (constructor invocation), this is useful to narrow down the cause
   * of the initialization performance problem.
   *
   * You can also pass a numerical value which affects the verbosity
   * of the traces, this number is the maximum nesting level of the traces, e.g:
   * 0: Traces disabled === 'false'
   * 1: Top Level traces only.
   * 2: One level of nested inner traces.
   * ...
   *
   * Note that passing the boolean `true` is identical to passing the numerical value `infinity`
   */
  traceInitPerf?: boolean | number;
  /**
   * This flag will avoid running the grammar validations during Parser initialization.
   *
   * This can substantially improve the Parser's initialization (constructor) time.
   * @see IParserConfig.traceInitPerf to measure the grammar validations cost for your parser.
   *
   * Note that the grammar validations are **extremely useful** during development time,
   * e.g: detecting ambiguities / left recursion.
   * So they should not be skipped during development flows.
   *   - For example: via a conditional that checks an env variable.
   */
  skipValidations?: boolean;
  /**
   * @experimental
   *
   * A custom lookahead strategy.
   * Can be used to override the default LL(*k*) lookahead behavior.
   *
   * Note that the default lookahead strategy is very well optimized and using a custom lookahead
   * strategy might lead to massively reduced performance.
   */
  lookaheadStrategy?: ILookaheadStrategy;
}

/**
 * A set of methods used to customize parsing error messages.
 * Call {@link defaultParserErrorProvider} to implement the default behavior
 */
interface IParserErrorMessageProvider {
  /**
   * Mismatched Token Error happens when the parser attempted to consume a terminal and failed.
   * It corresponds to a failed {@link BaseParser.CONSUME} in Chevrotain DSL terms.
   *
   * @param options.expected - The expected Token Type.
   *
   * @param options.actual - The actual Token "instance".
   *
   * @param options.previous - The previous Token "instance".
   *                                This is useful if options.actual[0] is of type chevrotain.EOF and you need to know the last token parsed.
   *
   * @param options.ruleName - The rule in which the error occurred.
   */
  buildMismatchTokenMessage(options: {
    expected: TokenType;
    actual: IToken;
    previous: IToken;
    ruleName: string;
  }): string;
  /**
   * A Redundant Input Error happens when the parser has completed parsing but there
   * is still unprocessed input remaining.
   *
   * @param options.firstRedundant - The first unprocessed token "instance".
   *
   * @param options.ruleName - The rule in which the error occurred.
   */
  buildNotAllInputParsedMessage(options: {
    firstRedundant: IToken;
    ruleName: string;
  }): string;
  /**
   * A No Viable Alternative Error happens when the parser cannot detect any valid alternative in an alternation.
   * It corresponds to a failed {@link BaseParser.OR} in Chevrotain DSL terms.
   *
   * @param options.expectedPathsPerAlt - First level of the array represents each alternative
   *                           The next two levels represent valid (expected) paths in each alternative.
   *
   * @param options.actual - The actual sequence of tokens encountered.
   *
   * @param options.previous - The previous Token "instance".
   *                                This is useful if options.actual[0] is of type chevrotain.EOF and you need to know the last token parsed.
   *
   * @param options.customUserDescription - A user may provide custom error message descriptor in the {@link BaseParser.AT_LEAST_ONE_SEP} DSL method
   *                                        options parameter, this is that custom message.
   *
   * @param options.ruleName - The rule in which the error occurred.
   */
  buildNoViableAltMessage(options: {
    expectedPathsPerAlt: TokenType[][][];
    actual: IToken[];
    previous: IToken;
    customUserDescription?: string;
    ruleName: string;
  }): string;
  /**
   * An Early Exit Error happens when the parser cannot detect the first mandatory iteration of a repetition.
   * It corresponds to a failed {@link BaseParser.AT_LEAST_ONE_SEP} or {@link BaseParser.AT_LEAST_ONE_SEP} in Chevrotain DSL terms.
   *
   * @param options.expectedIterationPaths - The valid (expected) paths in the first iteration.
   *
   * @param options.actual - The actual sequence of tokens encountered.
   *
   * @param options.previous - The previous Token "instance".
   *                                This is useful if options.actual[0] is of type chevrotain.EOF and you need to know the last token parsed.
   *
   * @param options.customUserDescription - A user may provide custom error message descriptor in the {@link BaseParser.AT_LEAST_ONE_SEP} DSL method
   *                                        options parameter, this is that custom message.
   *
   * @param options.ruleName - The rule in which the error occurred.
   */
  buildEarlyExitMessage(options: {
    expectedIterationPaths: TokenType[][];
    actual: IToken[];
    previous: IToken;
    customUserDescription?: string;
    ruleName: string;
  }): string;
}

/**
 * @experimental
 */
interface ILookaheadStrategy {
  /**
   * Performs validations on the grammar specific to this lookahead strategy.
   * This method is not called if parser validations are disabled.
   *
   * @param options.rules All parser rules of the grammar.
   *
   * @param options.tokenTypes All token types of the grammar.
   *
   * @param options.grammarName The name of the grammar.
   */
  validate(options: {
    rules: Rule[];
    tokenTypes: TokenType[];
    grammarName: string;
  }): ILookaheadValidationError[];

  /**
   * Initializes the lookahead for a grammar.
   *
   * Note that this method does not build the lookahead functions.
   * It only initializes the internal state of the strategy based on all grammar rules.
   *
   * @param options.rules All parser rules of the grammar.
   */
  initialize?(options: { rules: Rule[] }): void;

  /**
   * Builds a lookahead function for alternations/`OR` parser methods.
   *
   * @param options.prodOccurrence The occurrence number of this `OR` within its rule.
   *
   * @param options.rule The rule that contains this `OR`.
   *
   * @param options.maxLookahead The maximum amount of lookahead for this `OR`.
   *
   * @param options.hasPredicates Whether any of the alternatives contain a predicate.
   *
   * @param options.dynamicTokensEnabled Whether dynamic tokens are enabled for this parser.
   *
   * @returns A function that is able to compute which of the alternatives to choose while parsing.
   */
  buildLookaheadForAlternation(options: {
    prodOccurrence: number;
    rule: Rule;
    maxLookahead: number;
    hasPredicates: boolean;
    dynamicTokensEnabled: boolean;
  }): (orAlts?: IOrAlt<any>[] | undefined) => number | undefined;

  /**
   * Builds a lookahead function for optional productions.
   *
   * @param options.prodOccurrence The occurrence number of this production within its rule.
   *
   * @param options.prodType The type of this production.
   *
   * @param options.rule The rule that contains this production.
   *
   * @param options.maxLookahead The maximum amount of lookahead for this production.
   *
   * @param options.dynamicTokensEnabled Whether dynamic tokens are enabled for this parser.
   *
   * @returns A function is able to compute whether to parse the production or to continue with the rest of the parser rule.
   */
  buildLookaheadForOptional(options: {
    prodOccurrence: number;
    prodType: OptionalProductionType;
    rule: Rule;
    maxLookahead: number;
    dynamicTokensEnabled: boolean;
  }): () => boolean;
}

interface ILookaheadValidationError {
  message: string;
  ruleName?: string;
}

type OptionalProductionType =
  | "Option"
  | "RepetitionMandatory"
  | "RepetitionMandatoryWithSeparator"
  | "Repetition"
  | "RepetitionWithSeparator";

type LookaheadProductionType = OptionalProductionType | "Alternation";

interface IRecognizerContext {
  /**
   * A copy of the parser's rule stack at the "time" the RecognitionException occurred.
   * This can be used to help debug parsing errors (How did we get here?).
   */
  ruleStack: string[];
  /**
   * A copy of the parser's rule occurrence stack at the "time" the RecognitionException occurred.
   * This can be used to help debug parsing errors (How did we get here?).
   */
  ruleOccurrenceStack: number[];
}

interface ISerializedGast {
  type: ProductionType;
  definition?: ISerializedGast[];
}

type ProductionType =
  | LookaheadProductionType
  | "NonTerminal"
  | "Alternative"
  | "Terminal"
  | "Rule";

/**
 * Structure for the path the parser "took" to reach a certain position
 * in the grammar.
 */
interface IGrammarPath {
  /**
   * The Grammar rules invoked and still unterminated to reach this Grammar Path.
   */
  ruleStack: string[];
  /**
   * The occurrence index (SUBRULE1/2/3/5/...) of each Grammar rule invoked and still unterminated.
   * Used to distinguish between **different** invocations of the same subrule at the same top level rule.
   */
  occurrenceStack: number[];
}

interface ISyntacticContentAssistPath extends IGrammarPath {
  nextTokenType: TokenType;
  nextTokenOccurrence: number;
}

interface ITokenGrammarPath extends IGrammarPath {
  lastTok: TokenType;
  lastTokOccurrence: number;
}

/**
 * A Chevrotain Parser runtime exception.
 */
interface IRecognitionException extends Error {
  name: string;
  message: string;
  /**
   * The token which caused the parser error.
   */
  token: IToken;
  /**
   * Additional tokens which have been re-synced in error recovery due to the original error.
   * This information can be used the calculate the whole text area which has been skipped due to an error.
   * For example for displaying with a red underline in a text editor.
   */
  resyncedTokens: IToken[];
  context: IRecognizerContext;
}

interface IProduction {
  accept(visitor: IGASTVisitor): void;
}

/**
 * The Grammar AST class representing a top level {@link CstParser.RULE} or {@link EmbeddedActionsParser.RULE} call.
 */
declare class Rule {
  name: string;
  orgText: string;
  definition: IProduction[];

  constructor(options: {
    name: string;
    definition: IProduction[];
    orgText?: string;
  });

  accept(visitor: IGASTVisitor): void;
}

interface IGASTVisitor {
  visit(prod: IProduction): any;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface GrammarConfig {
    /**
     * Lists all rule names which are classified as multiline comment rules
     */
    multilineCommentRules: string[];
    /**
     * A regular expression which matches characters of names
     */
    nameRegexp: RegExp;
}

/**
 * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.
 * This class is a simple parser which creates the basic component parts
 * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation
 * and encoding.
 *
 * ```txt
 *       foo://example.com:8042/over/there?name=ferret#nose
 *       \_/   \______________/\_________/ \_________/ \__/
 *        |           |            |            |        |
 *     scheme     authority       path        query   fragment
 *        |   _____________________|__
 *       / \ /                        \
 *       urn:example:animal:ferret:nose
 * ```
 */
declare class URI implements UriComponents {
    static isUri(thing: any): thing is URI;
    /**
     * scheme is the 'http' part of 'http://www.example.com/some/path?query#fragment'.
     * The part before the first colon.
     */
    readonly scheme: string;
    /**
     * authority is the 'www.example.com' part of 'http://www.example.com/some/path?query#fragment'.
     * The part between the first double slashes and the next slash.
     */
    readonly authority: string;
    /**
     * path is the '/some/path' part of 'http://www.example.com/some/path?query#fragment'.
     */
    readonly path: string;
    /**
     * query is the 'query' part of 'http://www.example.com/some/path?query#fragment'.
     */
    readonly query: string;
    /**
     * fragment is the 'fragment' part of 'http://www.example.com/some/path?query#fragment'.
     */
    readonly fragment: string;
    /**
     * @internal
     */
    protected constructor(scheme: string, authority?: string, path?: string, query?: string, fragment?: string, _strict?: boolean);
    /**
     * @internal
     */
    protected constructor(components: UriComponents);
    /**
     * Returns a string representing the corresponding file system path of this URI.
     * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
     * platform specific path separator.
     *
     * * Will *not* validate the path for invalid characters and semantics.
     * * Will *not* look at the scheme of this URI.
     * * The result shall *not* be used for display purposes but for accessing a file on disk.
     *
     *
     * The *difference* to `URI#path` is the use of the platform specific separator and the handling
     * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
     *
     * ```ts
        const u = URI.parse('file://server/c$/folder/file.txt')
        u.authority === 'server'
        u.path === '/shares/c$/file.txt'
        u.fsPath === '\\server\c$\folder\file.txt'
    ```
     *
     * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
     * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
     * with URIs that represent files on disk (`file` scheme).
     */
    get fsPath(): string;
    with(change: {
        scheme?: string;
        authority?: string | null;
        path?: string | null;
        query?: string | null;
        fragment?: string | null;
    }): URI;
    /**
     * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,
     * `file:///usr/home`, or `scheme:with/path`.
     *
     * @param value A string which represents an URI (see `URI#toString`).
     */
    static parse(value: string, _strict?: boolean): URI;
    /**
     * Creates a new URI from a file system path, e.g. `c:\my\files`,
     * `/usr/home`, or `\\server\share\some\path`.
     *
     * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
     * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
     * `URI.parse('file://' + path)` because the path might contain characters that are
     * interpreted (# and ?). See the following sample:
     * ```ts
    const good = URI.file('/coding/c#/project1');
    good.scheme === 'file';
    good.path === '/coding/c#/project1';
    good.fragment === '';
    const bad = URI.parse('file://' + '/coding/c#/project1');
    bad.scheme === 'file';
    bad.path === '/coding/c'; // path is now broken
    bad.fragment === '/project1';
    ```
     *
     * @param path A file system path (see `URI#fsPath`)
     */
    static file(path: string): URI;
    static from(components: {
        scheme: string;
        authority?: string;
        path?: string;
        query?: string;
        fragment?: string;
    }): URI;
    /**
     * Creates a string representation for this URI. It's guaranteed that calling
     * `URI.parse` with the result of this function creates an URI which is equal
     * to this URI.
     *
     * * The result shall *not* be used for display purposes but for externalization or transport.
     * * The result will be encoded using the percentage encoding and encoding happens mostly
     * ignore the scheme-specific encoding rules.
     *
     * @param skipEncoding Do not encode the result, default is `false`
     */
    toString(skipEncoding?: boolean): string;
    toJSON(): UriComponents;
    static revive(data: UriComponents | URI): URI;
    static revive(data: UriComponents | URI | undefined): URI | undefined;
    static revive(data: UriComponents | URI | null): URI | null;
    static revive(data: UriComponents | URI | undefined | null): URI | undefined | null;
}
interface UriComponents {
    scheme: string;
    authority: string;
    path: string;
    query: string;
    fragment: string;
}

/******************************************************************************
 * This file was generated by langium-cli 3.3.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

type AbstractRule = ParserRule | TerminalRule;
declare const AbstractRule = "AbstractRule";
type AbstractType = InferredType | Interface | ParserRule | Type;
declare const AbstractType = "AbstractType";
type Condition = BooleanLiteral | Conjunction | Disjunction | Negation | ParameterReference;
declare const Condition = "Condition";
type FeatureName = 'current' | 'entry' | 'extends' | 'false' | 'fragment' | 'grammar' | 'hidden' | 'import' | 'infer' | 'infers' | 'interface' | 'returns' | 'terminal' | 'true' | 'type' | 'with' | PrimitiveType | string;
type PrimitiveType = 'Date' | 'bigint' | 'boolean' | 'number' | 'string';
type TypeDefinition = ArrayType | ReferenceType | SimpleType | UnionType;
declare const TypeDefinition = "TypeDefinition";
type ValueLiteral = ArrayLiteral | BooleanLiteral | NumberLiteral | StringLiteral;
declare const ValueLiteral = "ValueLiteral";
interface AbstractElement extends AstNode {
    readonly $type: 'AbstractElement' | 'Action' | 'Alternatives' | 'Assignment' | 'CharacterRange' | 'CrossReference' | 'EndOfFile' | 'Group' | 'Keyword' | 'NegatedToken' | 'RegexToken' | 'RuleCall' | 'TerminalAlternatives' | 'TerminalGroup' | 'TerminalRuleCall' | 'UnorderedGroup' | 'UntilToken' | 'Wildcard';
    cardinality?: '*' | '+' | '?';
    lookahead?: '?!' | '?<!' | '?<=' | '?=';
}
declare const AbstractElement = "AbstractElement";
interface ArrayLiteral extends AstNode {
    readonly $container: ArrayLiteral | TypeAttribute;
    readonly $type: 'ArrayLiteral';
    elements: Array<ValueLiteral>;
}
declare const ArrayLiteral = "ArrayLiteral";
interface ArrayType extends AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'ArrayType';
    elementType: TypeDefinition;
}
declare const ArrayType = "ArrayType";
interface BooleanLiteral extends AstNode {
    readonly $container: ArrayLiteral | Conjunction | Disjunction | Group | NamedArgument | Negation | TypeAttribute;
    readonly $type: 'BooleanLiteral';
    true: boolean;
}
declare const BooleanLiteral = "BooleanLiteral";
interface Conjunction extends AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'Conjunction';
    left: Condition;
    right: Condition;
}
declare const Conjunction = "Conjunction";
interface Disjunction extends AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'Disjunction';
    left: Condition;
    right: Condition;
}
declare const Disjunction = "Disjunction";
interface Grammar extends AstNode {
    readonly $type: 'Grammar';
    definesHiddenTokens: boolean;
    hiddenTokens: Array<Reference<AbstractRule>>;
    imports: Array<GrammarImport>;
    interfaces: Array<Interface>;
    isDeclared: boolean;
    name?: string;
    rules: Array<AbstractRule>;
    types: Array<Type>;
    usedGrammars: Array<Reference<Grammar>>;
}
declare const Grammar = "Grammar";
interface GrammarImport extends AstNode {
    readonly $container: Grammar;
    readonly $type: 'GrammarImport';
    path: string;
}
declare const GrammarImport = "GrammarImport";
interface InferredType extends AstNode {
    readonly $container: Action | ParserRule;
    readonly $type: 'InferredType';
    name: string;
}
declare const InferredType = "InferredType";
interface Interface extends AstNode {
    readonly $container: Grammar;
    readonly $type: 'Interface';
    attributes: Array<TypeAttribute>;
    name: string;
    superTypes: Array<Reference<AbstractType>>;
}
declare const Interface = "Interface";
interface NamedArgument extends AstNode {
    readonly $container: RuleCall;
    readonly $type: 'NamedArgument';
    calledByName: boolean;
    parameter?: Reference<Parameter>;
    value: Condition;
}
declare const NamedArgument = "NamedArgument";
interface Negation extends AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'Negation';
    value: Condition;
}
declare const Negation = "Negation";
interface NumberLiteral extends AstNode {
    readonly $container: ArrayLiteral | TypeAttribute;
    readonly $type: 'NumberLiteral';
    value: number;
}
declare const NumberLiteral = "NumberLiteral";
interface Parameter extends AstNode {
    readonly $container: ParserRule;
    readonly $type: 'Parameter';
    name: string;
}
declare const Parameter = "Parameter";
interface ParameterReference extends AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'ParameterReference';
    parameter: Reference<Parameter>;
}
declare const ParameterReference = "ParameterReference";
interface ParserRule extends AstNode {
    readonly $container: Grammar;
    readonly $type: 'ParserRule';
    dataType?: PrimitiveType;
    definesHiddenTokens: boolean;
    definition: AbstractElement;
    entry: boolean;
    fragment: boolean;
    hiddenTokens: Array<Reference<AbstractRule>>;
    inferredType?: InferredType;
    name: string;
    parameters: Array<Parameter>;
    returnType?: Reference<AbstractType>;
    wildcard: boolean;
}
declare const ParserRule = "ParserRule";
interface ReferenceType extends AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'ReferenceType';
    referenceType: TypeDefinition;
}
declare const ReferenceType = "ReferenceType";
interface ReturnType$1 extends AstNode {
    readonly $container: TerminalRule;
    readonly $type: 'ReturnType';
    name: PrimitiveType | string;
}
declare const ReturnType$1 = "ReturnType";
interface SimpleType extends AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'SimpleType';
    primitiveType?: PrimitiveType;
    stringType?: string;
    typeRef?: Reference<AbstractType>;
}
declare const SimpleType = "SimpleType";
interface StringLiteral extends AstNode {
    readonly $container: ArrayLiteral | TypeAttribute;
    readonly $type: 'StringLiteral';
    value: string;
}
declare const StringLiteral = "StringLiteral";
interface TerminalRule extends AstNode {
    readonly $container: Grammar;
    readonly $type: 'TerminalRule';
    definition: AbstractElement;
    fragment: boolean;
    hidden: boolean;
    name: string;
    type?: ReturnType$1;
}
declare const TerminalRule = "TerminalRule";
interface Type extends AstNode {
    readonly $container: Grammar;
    readonly $type: 'Type';
    name: string;
    type: TypeDefinition;
}
declare const Type = "Type";
interface TypeAttribute extends AstNode {
    readonly $container: Interface;
    readonly $type: 'TypeAttribute';
    defaultValue?: ValueLiteral;
    isOptional: boolean;
    name: FeatureName;
    type: TypeDefinition;
}
declare const TypeAttribute = "TypeAttribute";
interface UnionType extends AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'UnionType';
    types: Array<TypeDefinition>;
}
declare const UnionType = "UnionType";
interface Action extends AbstractElement {
    readonly $type: 'Action';
    feature?: FeatureName;
    inferredType?: InferredType;
    operator?: '+=' | '=';
    type?: Reference<AbstractType>;
}
declare const Action = "Action";
interface CharacterRange extends AbstractElement {
    readonly $type: 'CharacterRange';
    left: Keyword;
    right?: Keyword;
}
declare const CharacterRange = "CharacterRange";
interface CrossReference extends AbstractElement {
    readonly $type: 'CrossReference';
    deprecatedSyntax: boolean;
    terminal?: AbstractElement;
    type: Reference<AbstractType>;
}
declare const CrossReference = "CrossReference";
interface Group extends AbstractElement {
    readonly $type: 'Group';
    elements: Array<AbstractElement>;
    guardCondition?: Condition;
}
declare const Group = "Group";
interface Keyword extends AbstractElement {
    readonly $container: CharacterRange;
    readonly $type: 'Keyword';
    value: string;
}
declare const Keyword = "Keyword";
interface RuleCall extends AbstractElement {
    readonly $type: 'RuleCall';
    arguments: Array<NamedArgument>;
    rule: Reference<AbstractRule>;
}
declare const RuleCall = "RuleCall";

/**
 * A tagging type for string properties that are actually URIs.
 */
type DocumentUri = string;
/**
 * Position in a text document expressed as zero-based line and character offset.
 * The offsets are based on a UTF-16 string representation. So a string of the form
 * `a𐐀b` the character offset of the character `a` is 0, the character offset of `𐐀`
 * is 1 and the character offset of b is 3 since `𐐀` is represented using two code
 * units in UTF-16.
 *
 * Positions are line end character agnostic. So you can not specify a position that
 * denotes `\r|\n` or `\n|` where `|` represents the character offset.
 */
interface Position$1 {
    /**
     * Line position in a document (zero-based).
     *
     * If a line number is greater than the number of lines in a document, it
     * defaults back to the number of lines in the document.
     * If a line number is negative, it defaults to 0.
     *
     * The above two properties are implementation specific.
     */
    line: number;
    /**
     * Character offset on a line in a document (zero-based).
     *
     * The meaning of this offset is determined by the negotiated
     * `PositionEncodingKind`.
     *
     * If the character value is greater than the line length it defaults back
     * to the line length. This property is implementation specific.
     */
    character: number;
}
/**
 * A range in a text document expressed as (zero-based) start and end positions.
 *
 * If you want to specify a range that contains a line including the line ending
 * character(s) then use an end position denoting the start of the next line.
 * For example:
 * ```ts
 * {
 *     start: { line: 5, character: 23 }
 *     end : { line 6, character : 0 }
 * }
 * ```
 */
interface Range {
    /**
     * The range's start position.
     */
    start: Position$1;
    /**
     * The range's end position.
     */
    end: Position$1;
}
/**
 * A text edit applicable to a text document.
 */
interface TextEdit {
    /**
     * The range of the text document to be manipulated. To insert
     * text into a document create a range where start === end.
     */
    range: Range;
    /**
     * The string to be inserted. For delete operations use an
     * empty string.
     */
    newText: string;
}
/**
 * An event describing a change to a text document. If range and rangeLength are omitted
 * the new text is considered to be the full content of the document.
 */
type TextDocumentContentChangeEvent$1 = {
    /**
     * The range of the document that changed.
     */
    range: Range;
    /**
     * The optional length of the range that got replaced.
     *
     * @deprecated use range instead.
     */
    rangeLength?: number;
    /**
     * The new text for the provided range.
     */
    text: string;
} | {
    /**
     * The new text of the whole document.
     */
    text: string;
};
/**
 * A simple text document. Not to be implemented. The document keeps the content
 * as string.
 */
interface TextDocument {
    /**
     * The associated URI for this document. Most documents have the __file__-scheme, indicating that they
     * represent files on disk. However, some documents may have other schemes indicating that they are not
     * available on disk.
     *
     * @readonly
     */
    readonly uri: DocumentUri;
    /**
     * The identifier of the language associated with this document.
     *
     * @readonly
     */
    readonly languageId: string;
    /**
     * The version number of this document (it will increase after each
     * change, including undo/redo).
     *
     * @readonly
     */
    readonly version: number;
    /**
     * Get the text of this document. A substring can be retrieved by
     * providing a range.
     *
     * @param range (optional) An range within the document to return.
     * If no range is passed, the full content is returned.
     * Invalid range positions are adjusted as described in {@link Position.line}
     * and {@link Position.character}.
     * If the start range position is greater than the end range position,
     * then the effect of getText is as if the two positions were swapped.

     * @return The text of this document or a substring of the text if a
     *         range is provided.
     */
    getText(range?: Range): string;
    /**
     * Converts a zero-based offset to a position.
     *
     * @param offset A zero-based offset.
     * @return A valid {@link Position position}.
     * @example The text document "ab\ncd" produces:
     * * position { line: 0, character: 0 } for `offset` 0.
     * * position { line: 0, character: 1 } for `offset` 1.
     * * position { line: 0, character: 2 } for `offset` 2.
     * * position { line: 1, character: 0 } for `offset` 3.
     * * position { line: 1, character: 1 } for `offset` 4.
     */
    positionAt(offset: number): Position$1;
    /**
     * Converts the position to a zero-based offset.
     * Invalid positions are adjusted as described in {@link Position.line}
     * and {@link Position.character}.
     *
     * @param position A position.
     * @return A valid zero-based offset.
     */
    offsetAt(position: Position$1): number;
    /**
     * The number of lines in this document.
     *
     * @readonly
     */
    readonly lineCount: number;
}
declare namespace TextDocument {
    /**
     * Creates a new text document.
     *
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param version The document's initial version number.
     * @param content The document's content.
     */
    function create(uri: DocumentUri, languageId: string, version: number, content: string): TextDocument;
    /**
     * Updates a TextDocument by modifying its content.
     *
     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.
     * @param changes the changes to apply to the document.
     * @param version the changes version for the document.
     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.
     *
     */
    function update(document: TextDocument, changes: TextDocumentContentChangeEvent$1[], version: number): TextDocument;
    function applyEdits(document: TextDocument, edits: TextEdit[]): string;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface FileSystemNode {
    readonly isFile: boolean;
    readonly isDirectory: boolean;
    readonly uri: URI;
}
/**
 * Provides methods to interact with an abstract file system. The default implementation is based on the node.js `fs` API.
 */
interface FileSystemProvider {
    /**
     * Reads a document asynchronously from a given URI.
     * @returns The string content of the file with the specified URI.
     */
    readFile(uri: URI): Promise<string>;
    /**
     * Reads the directory information for the given URI.
     * @returns The list of file system entries that are contained within the specified directory.
     */
    readDirectory(uri: URI): Promise<FileSystemNode[]>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
/**
 * A stream is a read-only sequence of values. While the contents of an array can be accessed
 * both sequentially and randomly (via index), a stream allows only sequential access.
 *
 * The advantage of this is that a stream can be evaluated lazily, so it does not require
 * to store intermediate values. This can boost performance when a large sequence is
 * processed via filtering, mapping etc. and accessed at most once. However, lazy
 * evaluation means that all processing is repeated when you access the sequence multiple
 * times; in such a case, it may be better to store the resulting sequence into an array.
 */
interface Stream<T> extends Iterable<T> {
    /**
     * Returns an iterator for this stream. This is the same as calling the `Symbol.iterator` function property.
     */
    iterator(): IterableIterator<T>;
    /**
     * Determines whether this stream contains no elements.
     */
    isEmpty(): boolean;
    /**
     * Determines the number of elements in this stream.
     */
    count(): number;
    /**
     * Collects all elements of this stream into an array.
     */
    toArray(): T[];
    /**
     * Collects all elements of this stream into a Set.
     */
    toSet(): Set<T>;
    /**
     * Collects all elements of this stream into a Map, applying the provided functions to determine keys and values.
     *
     * @param keyFn The function to derive map keys. If omitted, the stream elements are used as keys.
     * @param valueFn The function to derive map values. If omitted, the stream elements are used as values.
     */
    toMap<K = T, V = T>(keyFn?: (e: T) => K, valueFn?: (e: T) => V): Map<K, V>;
    /**
     * Returns a string representation of a stream.
     */
    toString(): string;
    /**
     * Combines two streams by returning a new stream that yields all elements of this stream and the other stream.
     *
     * @param other Stream to be concatenated with this one.
     */
    concat<T2>(other: Iterable<T2>): Stream<T | T2>;
    /**
     * Adds all elements of the stream into a string, separated by the specified separator string.
     *
     * @param separator A string used to separate one element of the stream from the next in the resulting string.
     *        If omitted, the steam elements are separated with a comma.
     */
    join(separator?: string): string;
    /**
     * Returns the index of the first occurrence of a value in the stream, or -1 if it is not present.
     *
     * @param searchElement The value to locate in the array.
     * @param fromIndex The stream index at which to begin the search. If fromIndex is omitted, the search
     *        starts at index 0.
     */
    indexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Determines whether all members of the stream satisfy the specified test.
     *
     * @param predicate This method calls the predicate function for each element in the stream until the
     *        predicate returns a value which is coercible to the Boolean value `false`, or until the end
     *        of the stream.
     */
    every<S extends T>(predicate: (value: T) => value is S): this is Stream<S>;
    every(predicate: (value: T) => unknown): boolean;
    /**
     * Determines whether any member of the stream satisfies the specified test.
     *
     * @param predicate This method calls the predicate function for each element in the stream until the
     *        predicate returns a value which is coercible to the Boolean value `true`, or until the end
     *        of the stream.
     */
    some(predicate: (value: T) => unknown): boolean;
    /**
     * Performs the specified action for each element in the stream.
     *
     * @param callbackfn Function called once for each element in the stream.
     */
    forEach(callbackfn: (value: T, index: number) => void): void;
    /**
     * Returns a stream that yields the results of calling the specified callback function on each element
     * of the stream. The function is called when the resulting stream elements are actually accessed, so
     * accessing the resulting stream multiple times means the function is also called multiple times for
     * each element of the stream.
     *
     * @param callbackfn Lazily evaluated function mapping stream elements.
     */
    map<U>(callbackfn: (value: T) => U): Stream<U>;
    /**
     * Returns the elements of the stream that meet the condition specified in a callback function.
     * The function is called when the resulting stream elements are actually accessed, so accessing the
     * resulting stream multiple times means the function is also called multiple times for each element
     * of the stream.
     *
     * @param predicate Lazily evaluated function checking a condition on stream elements.
     */
    filter<S extends T>(predicate: (value: T) => value is S): Stream<S>;
    filter(predicate: (value: T) => unknown): Stream<T>;
    /**
     * Returns the elements of the stream that are _non-nullable_, which means they are neither `undefined`
     * nor `null`.
     */
    nonNullable(): Stream<NonNullable<T>>;
    /**
     * Calls the specified callback function for all elements in the stream. The return value of the
     * callback function is the accumulated result, and is provided as an argument in the next call to
     * the callback function.
     *
     * @param callbackfn This method calls the function once for each element in the stream, providing
     *        the previous and current values of the reduction.
     * @param initialValue If specified, `initialValue` is used as the initial value to start the
     *        accumulation. The first call to the function provides this value as an argument instead
     *        of a stream value.
     */
    reduce(callbackfn: (previousValue: T, currentValue: T) => T): T | undefined;
    reduce<U = T>(callbackfn: (previousValue: U, currentValue: T) => U, initialValue: U): U;
    /**
     * Calls the specified callback function for all elements in the stream, in descending order.
     * The return value of the callback function is the accumulated result, and is provided as an
     * argument in the next call to the callback function.
     *
     * @param callbackfn This method calls the function once for each element in the stream, providing
     *        the previous and current values of the reduction.
     * @param initialValue If specified, `initialValue` is used as the initial value to start the
     *        accumulation. The first call to the function provides this value as an argument instead
     *        of an array value.
     */
    reduceRight(callbackfn: (previousValue: T, currentValue: T) => T): T | undefined;
    reduceRight<U = T>(callbackfn: (previousValue: U, currentValue: T) => U, initialValue: U): U;
    /**
     * Returns the value of the first element in the stream that meets the condition, or `undefined`
     * if there is no such element.
     *
     * @param predicate This method calls `predicate` once for each element of the stream, in ascending
     *        order, until it finds one where `predicate` returns a value which is coercible to the
     *        Boolean value `true`.
     */
    find<S extends T>(predicate: (value: T) => value is S): S | undefined;
    find(predicate: (value: T) => unknown): T | undefined;
    /**
     * Returns the index of the first element in the stream that meets the condition, or `-1`
     * if there is no such element.
     *
     * @param predicate This method calls `predicate` once for each element of the stream, in ascending
     *        order, until it finds one where `predicate` returns a value which is coercible to the
     *        Boolean value `true`.
     */
    findIndex(predicate: (value: T) => unknown): number;
    /**
     * Determines whether the stream includes a certain element, returning `true` or `false` as appropriate.
     *
     * @param searchElement The element to search for.
     */
    includes(searchElement: T): boolean;
    /**
     * Calls a defined callback function on each element of the stream and then flattens the result into
     * a new stream. This is identical to a `map` followed by `flat` with depth 1.
     *
     * @param callbackfn Lazily evaluated function mapping stream elements.
     */
    flatMap<U>(callbackfn: (value: T) => U | Iterable<U>): Stream<U>;
    /**
     * Returns a new stream with all sub-stream or sub-array elements concatenated into it recursively up
     * to the specified depth.
     *
     * @param depth The maximum recursion depth. Defaults to 1.
     */
    flat<D extends number = 1>(depth?: D): FlatStream<T, D>;
    /**
     * Returns the first element in the stream, or `undefined` if the stream is empty.
     */
    head(): T | undefined;
    /**
     * Returns a stream that skips the first `skipCount` elements from this stream.
     *
     * @param skipCount The number of elements to skip. If this is larger than the number of elements in
     *        the stream, an empty stream is returned. Defaults to 1.
     */
    tail(skipCount?: number): Stream<T>;
    /**
     * Returns a stream consisting of the elements of this stream, truncated to be no longer than `maxSize`
     * in length.
     *
     * @param maxSize The number of elements the stream should be limited to
     */
    limit(maxSize: number): Stream<T>;
    /**
     * Returns a stream containing only the distinct elements from this stream.
     * Equality is determined with the same rules as a standard `Set`.
     *
     * @param by A function returning the key used to check equality with a previous stream element.
     *        If omitted, the stream elements themselves are used for comparison.
     */
    distinct<Key = T>(by?: (element: T) => Key): Stream<T>;
    /**
     * Returns a stream that contains all elements that don't exist in the {@link other} iterable.
     * Equality is determined with the same rules as a standard `Set`.
     * @param other The elements that should be exluded from this stream.
     * @param key A function returning the key used to check quality.
     *        If omitted, the stream elements themselves are used for comparison.
     */
    exclude<Key = T>(other: Iterable<T>, key?: (element: T) => Key): Stream<T>;
}
type FlatStream<T, Depth extends number> = {
    'done': Stream<T>;
    'recur': T extends Iterable<infer Content> ? FlatStream<Content, MinusOne<Depth>> : Stream<T>;
}[Depth extends 0 ? 'done' : 'recur'];
type MinusOne<N extends number> = [-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20][N];

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface TokenBuilderOptions {
    caseInsensitive?: boolean;
}
interface TokenBuilder {
    buildTokens(grammar: Grammar, options?: TokenBuilderOptions): TokenVocabulary;
    /**
     * Produces a lexing report for the given text that was just tokenized using the tokens provided by this builder.
     *
     * @param text The text that was tokenized.
     */
    flushLexingReport?(text: string): LexingReport;
}
/**
 * A custom lexing report that can be produced by the token builder during the lexing process.
 * Adopters need to ensure that the any custom fields are serializable so they can be sent across worker threads.
 */
interface LexingReport {
    diagnostics: LexingDiagnostic[];
}
type LexingDiagnosticSeverity = 'error' | 'warning' | 'info' | 'hint';
interface LexingDiagnostic extends ILexingError {
    severity?: LexingDiagnosticSeverity;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface LexerResult {
    /**
     * A list of all tokens that were lexed from the input.
     *
     * Note that Langium requires the optional properties
     * `startLine`, `startColumn`, `endOffset`, `endLine` and `endColumn` to be set on each token.
     */
    tokens: IToken[];
    /**
     * Contains hidden tokens, usually comments.
     */
    hidden: IToken[];
    errors: ILexingError[];
    report?: LexingReport;
}
type TokenizeMode = 'full' | 'partial';
interface TokenizeOptions {
    mode?: TokenizeMode;
}
interface Lexer {
    readonly definition: TokenTypeDictionary;
    tokenize(text: string, options?: TokenizeOptions): LexerResult;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

type ParseResult<T = AstNode> = {
    value: T;
    parserErrors: IRecognitionException[];
    lexerErrors: ILexingError[];
    lexerReport?: LexingReport;
};
type RuleResult = (args: Args) => any;
type Args = Record<string, boolean>;
type RuleImpl = (args: Args) => any;
/**
 * Base interface for all parsers. Mainly used by the `parser-builder-base.ts` to perform work on different kinds of parsers.
 * The main use cases are:
 * * AST parser: Based on a string, create an AST for the current grammar
 * * Completion parser: Based on a partial string, identify the current position of the input within the grammar
 */
interface BaseParser {
    /**
     * Adds a new parser rule to the parser
     */
    rule(rule: ParserRule, impl: RuleImpl): RuleResult;
    /**
     * Returns the executable rule function for the specified rule name
     */
    getRule(name: string): RuleResult | undefined;
    /**
     * Performs alternatives parsing (the `|` operation in EBNF/Langium)
     */
    alternatives(idx: number, choices: Array<IOrAlt<any>>): void;
    /**
     * Parses the callback as optional (the `?` operation in EBNF/Langium)
     */
    optional(idx: number, callback: DSLMethodOpts<unknown>): void;
    /**
     * Parses the callback 0 or more times (the `*` operation in EBNF/Langium)
     */
    many(idx: number, callback: DSLMethodOpts<unknown>): void;
    /**
     * Parses the callback 1 or more times (the `+` operation in EBNF/Langium)
     */
    atLeastOne(idx: number, callback: DSLMethodOpts<unknown>): void;
    /**
     * Consumes a specific token type from the token input stream.
     * Requires a unique index within the rule for a specific token type.
     */
    consume(idx: number, tokenType: TokenType, feature: AbstractElement): void;
    /**
     * Invokes the executable function for a given parser rule.
     * Requires a unique index within the rule for a specific sub rule.
     * Arguments can be supplied to the rule invocation for semantic predicates
     */
    subrule(idx: number, rule: RuleResult, feature: AbstractElement, args: Args): void;
    /**
     * Executes a grammar action that modifies the currently active AST node
     */
    action($type: string, action: Action): void;
    /**
     * Finishes construction of the current AST node. Only used by the AST parser.
     */
    construct(): unknown;
    /**
     * Whether the parser is currently actually in use or in "recording mode".
     * Recording mode is activated once when the parser is analyzing itself.
     * During this phase, no input exists and therefore no AST should be constructed
     */
    isRecording(): boolean;
    /**
     * Current state of the unordered groups
     */
    get unorderedGroups(): Map<string, boolean[]>;
    /**
     * The rule stack indicates the indices of rules that are currently invoked,
     * in order of their invocation.
     */
    getRuleStack(): number[];
}
declare abstract class AbstractLangiumParser implements BaseParser {
    protected readonly lexer: Lexer;
    protected readonly wrapper: ChevrotainWrapper;
    protected _unorderedGroups: Map<string, boolean[]>;
    protected allRules: Map<string, RuleResult>;
    protected mainRule: RuleResult;
    constructor(services: LangiumCoreServices);
    alternatives(idx: number, choices: Array<IOrAlt<any>>): void;
    optional(idx: number, callback: DSLMethodOpts<unknown>): void;
    many(idx: number, callback: DSLMethodOpts<unknown>): void;
    atLeastOne(idx: number, callback: DSLMethodOpts<unknown>): void;
    abstract rule(rule: ParserRule, impl: RuleImpl): RuleResult;
    abstract consume(idx: number, tokenType: TokenType, feature: AbstractElement): void;
    abstract subrule(idx: number, rule: RuleResult, feature: AbstractElement, args: Args): void;
    abstract action($type: string, action: Action): void;
    abstract construct(): unknown;
    getRule(name: string): RuleResult | undefined;
    isRecording(): boolean;
    get unorderedGroups(): Map<string, boolean[]>;
    getRuleStack(): number[];
    finalize(): void;
}
interface ParserOptions {
    rule?: string;
}
declare class LangiumParser extends AbstractLangiumParser {
    private readonly linker;
    private readonly converter;
    private readonly astReflection;
    private readonly nodeBuilder;
    private stack;
    private assignmentMap;
    private get current();
    constructor(services: LangiumCoreServices);
    rule(rule: ParserRule, impl: RuleImpl): RuleResult;
    private computeRuleType;
    parse<T extends AstNode = AstNode>(input: string, options?: ParserOptions): ParseResult<T>;
    private startImplementation;
    consume(idx: number, tokenType: TokenType, feature: AbstractElement): void;
    /**
     * Most consumed parser tokens are valid. However there are two cases in which they are not valid:
     *
     * 1. They were inserted during error recovery by the parser. These tokens don't really exist and should not be further processed
     * 2. They contain invalid token ranges. This might include the special EOF token, or other tokens produced by invalid token builders.
     */
    private isValidToken;
    subrule(idx: number, rule: RuleResult, feature: AbstractElement, args: Args): void;
    private performSubruleAssignment;
    action($type: string, action: Action): void;
    construct(): unknown;
    private getAssignment;
    private assign;
    private assignWithoutOverride;
    get definitionErrors(): IParserDefinitionError[];
}
interface IParserDefinitionError {
    message: string;
    type: number;
    ruleName?: string;
}
interface CompletionParserResult {
    tokens: IToken[];
    elementStack: AbstractElement[];
    tokenIndex: number;
}
declare class LangiumCompletionParser extends AbstractLangiumParser {
    private tokens;
    private elementStack;
    private lastElementStack;
    private nextTokenIndex;
    private stackSize;
    action(): void;
    construct(): unknown;
    parse(input: string): CompletionParserResult;
    rule(rule: ParserRule, impl: RuleImpl): RuleResult;
    private resetState;
    private startImplementation;
    private removeUnexpectedElements;
    keepStackSize(): number;
    resetStackSize(size: number): void;
    consume(idx: number, tokenType: TokenType, feature: AbstractElement): void;
    subrule(idx: number, rule: RuleResult, feature: AbstractElement, args: Args): void;
    before(element: AbstractElement): void;
    after(element: AbstractElement): void;
    get currIdx(): number;
}
/**
 * This class wraps the embedded actions parser of chevrotain and exposes protected methods.
 * This way, we can build the `LangiumParser` as a composition.
 */
declare class ChevrotainWrapper extends EmbeddedActionsParser {
    definitionErrors: IParserDefinitionError[];
    constructor(tokens: TokenVocabulary, config: IParserConfig);
    get IS_RECORDING(): boolean;
    DEFINE_RULE(name: string, impl: RuleImpl): RuleResult;
    wrapSelfAnalysis(): void;
    wrapConsume(idx: number, tokenType: TokenType): IToken;
    wrapSubrule(idx: number, rule: RuleResult, args: Args): unknown;
    wrapOr(idx: number, choices: Array<IOrAlt<any>>): void;
    wrapOption(idx: number, callback: DSLMethodOpts<unknown>): void;
    wrapMany(idx: number, callback: DSLMethodOpts<unknown>): void;
    wrapAtLeastOne(idx: number, callback: DSLMethodOpts<unknown>): void;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * The service registry provides access to the language-specific {@link LangiumCoreServices} optionally including LSP-related services.
 * These are resolved via the URI of a text document.
 */
interface ServiceRegistry {
    /**
     * Register a language via its injected services.
     */
    register(language: LangiumCoreServices): void;
    /**
     * Retrieve the language-specific services for the given URI. In case only one language is
     * registered, it may be used regardless of the URI format.
     */
    getServices(uri: URI): LangiumCoreServices;
    /**
     * Check whether services are available for the given URI.
     */
    hasServices(uri: URI): boolean;
    /**
     * The full set of registered language services.
     */
    readonly all: readonly LangiumCoreServices[];
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * A multimap is a variation of a Map that has potentially multiple values for every key.
 */
declare class MultiMap<K, V> {
    private map;
    constructor();
    constructor(elements: Array<[K, V]>);
    /**
     * The total number of values in the multimap.
     */
    get size(): number;
    /**
     * Clear all entries in the multimap.
     */
    clear(): void;
    /**
     * Operates differently depending on whether a `value` is given:
     *  * With a value, this method deletes the specific key / value pair from the multimap.
     *  * Without a value, all values associated with the given key are deleted.
     *
     * @returns `true` if a value existed and has been removed, or `false` if the specified
     *     key / value does not exist.
     */
    delete(key: K, value?: V): boolean;
    /**
     * Returns an array of all values associated with the given key. If no value exists,
     * an empty array is returned.
     *
     * _Note:_ The returned array is assumed not to be modified. Use the `set` method to add a
     * value and `delete` to remove a value from the multimap.
     */
    get(key: K): readonly V[];
    /**
     * Operates differently depending on whether a `value` is given:
     *  * With a value, this method returns `true` if the specific key / value pair is present in the multimap.
     *  * Without a value, this method returns `true` if the given key is present in the multimap.
     */
    has(key: K, value?: V): boolean;
    /**
     * Add the given key / value pair to the multimap.
     */
    add(key: K, value: V): this;
    /**
     * Add the given set of key / value pairs to the multimap.
     */
    addAll(key: K, values: Iterable<V>): this;
    /**
     * Invokes the given callback function for every key / value pair in the multimap.
     */
    forEach(callbackfn: (value: V, key: K, map: this) => void): void;
    /**
     * Returns an iterator of key, value pairs for every entry in the map.
     */
    [Symbol.iterator](): Iterator<[K, V]>;
    /**
     * Returns a stream of key, value pairs for every entry in the map.
     */
    entries(): Stream<[K, V]>;
    /**
     * Returns a stream of keys in the map.
     */
    keys(): Stream<K>;
    /**
     * Returns a stream of values in the map.
     */
    values(): Stream<V>;
    /**
     * Returns a stream of key, value set pairs for every key in the map.
     */
    entriesGroupedByKey(): Stream<[K, V[]]>;
}

interface Disposable$1 {
    /**
     * Dispose this object.
     */
    dispose(): void;
}
declare namespace Disposable$1 {
    function create(func: () => void): Disposable$1;
}

/**
 * Represents a typed event.
 */
interface Event<T> {
    /**
     *
     * @param listener The listener function will be called when the event happens.
     * @param thisArgs The 'this' which will be used when calling the event listener.
     * @param disposables An array to which a {{IDisposable}} will be added.
     * @return
    */
    (listener: (e: T) => any, thisArgs?: any, disposables?: Disposable$1[]): Disposable$1;
}
declare namespace Event {
    const None: Event<any>;
}

/**
 * Defines a CancellationToken. This interface is not
 * intended to be implemented. A CancellationToken must
 * be created via a CancellationTokenSource.
 */
interface CancellationToken {
    /**
     * Is `true` when the token has been cancelled, `false` otherwise.
     */
    readonly isCancellationRequested: boolean;
    /**
     * An {@link Event event} which fires upon cancellation.
     */
    readonly onCancellationRequested: Event<any>;
}
declare namespace CancellationToken {
    const None: CancellationToken;
    const Cancelled: CancellationToken;
    function is(value: any): value is CancellationToken;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
/**
 * Re-export 'TextDocument' from 'vscode-languageserver-textdocument' for convenience,
 *  including both type _and_ symbol (namespace), as we here and there also refer to the symbol,
 *  the overhead is very small, just a few kilobytes.
 * Everything else of that package (at the time contributing) is also defined
 *  in 'vscode-languageserver-protocol' or 'vscode-languageserver-types'.
 */

/**
 * A Langium document holds the parse result (AST and CST) and any additional state that is derived
 * from the AST, e.g. the result of scope precomputation.
 */
interface LangiumDocument<T extends AstNode = AstNode> {
    /** The Uniform Resource Identifier (URI) of the document */
    readonly uri: URI;
    /** The text document used to convert between offsets and positions */
    readonly textDocument: TextDocument;
    /** The current state of the document */
    state: DocumentState;
    /** The parse result holds the Abstract Syntax Tree (AST) and potentially also parser / lexer errors */
    parseResult: ParseResult<T>;
    /** Result of the scope precomputation phase */
    precomputedScopes?: PrecomputedScopes;
    /** An array of all cross-references found in the AST while linking */
    references: Reference[];
    /** Result of the validation phase */
    diagnostics?: Diagnostic[];
}
/**
 * A document is subject to several phases that are run in predefined order. Any state value implies that
 * smaller state values are finished as well.
 */
declare enum DocumentState {
    /**
     * The text content has changed and needs to be parsed again. The AST held by this outdated
     * document instance is no longer valid.
     */
    Changed = 0,
    /**
     * An AST has been created from the text content. The document structure can be traversed,
     * but cross-references cannot be resolved yet. If necessary, the structure can be manipulated
     * at this stage as a preprocessing step.
     */
    Parsed = 1,
    /**
     * The `IndexManager` service has processed AST nodes of this document. This means the
     * exported symbols are available in the global scope and can be resolved from other documents.
     */
    IndexedContent = 2,
    /**
     * The `ScopeComputation` service has processed this document. This means the local symbols
     * are stored in a MultiMap so they can be looked up by the `ScopeProvider` service.
     * Once a document has reached this state, you may follow every reference - it will lazily
     * resolve its `ref` property and yield either the target AST node or `undefined` in case
     * the target is not in scope.
     */
    ComputedScopes = 3,
    /**
     * The `Linker` service has processed this document. All outgoing references have been
     * resolved or marked as erroneous.
     */
    Linked = 4,
    /**
     * The `IndexManager` service has processed AST node references of this document. This is
     * necessary to determine which documents are affected by a change in one of the workspace
     * documents.
     */
    IndexedReferences = 5,
    /**
     * The `DocumentValidator` service has processed this document. The language server listens
     * to the results of this phase and sends diagnostics to the client.
     */
    Validated = 6
}
/**
 * Result of the scope precomputation phase (`ScopeComputation` service).
 * It maps every AST node to the set of symbols that are visible in the subtree of that node.
 */
type PrecomputedScopes = MultiMap<AstNode, AstNodeDescription>;
interface DocumentSegment {
    readonly range: Range$1;
    readonly offset: number;
    readonly length: number;
    readonly end: number;
}
/**
 * Surrogate definition of the `TextDocuments` interface from the `vscode-languageserver` package.
 * No implementation object is expected to be offered by `LangiumCoreServices`, but only by `LangiumLSPServices`.
 */
type TextDocumentProvider = {
    get(uri: string | URI): TextDocument | undefined;
};
/**
 * Shared service for creating `LangiumDocument` instances.
 *
 * Register a custom implementation if special (additional) behavior is required for your language(s).
 * Note: If you specialize {@link fromString} or {@link fromTextDocument} you probably might want to
 * specialize {@link update}, too!
 */
interface LangiumDocumentFactory {
    /**
     * Create a Langium document from a `TextDocument` (usually associated with a file).
     */
    fromTextDocument<T extends AstNode = AstNode>(textDocument: TextDocument, uri?: URI, options?: ParserOptions): LangiumDocument<T>;
    /**
     * Create a Langium document from a `TextDocument` asynchronously. This action can be cancelled if a cancellable parser implementation has been provided.
     */
    fromTextDocument<T extends AstNode = AstNode>(textDocument: TextDocument, uri: URI | undefined, cancellationToken: CancellationToken): Promise<LangiumDocument<T>>;
    /**
     * Create an Langium document from an in-memory string.
     */
    fromString<T extends AstNode = AstNode>(text: string, uri: URI, options?: ParserOptions): LangiumDocument<T>;
    /**
     * Create a Langium document from an in-memory string asynchronously. This action can be cancelled if a cancellable parser implementation has been provided.
     */
    fromString<T extends AstNode = AstNode>(text: string, uri: URI, cancellationToken: CancellationToken): Promise<LangiumDocument<T>>;
    /**
     * Create an Langium document from a model that has been constructed in memory.
     */
    fromModel<T extends AstNode = AstNode>(model: T, uri: URI): LangiumDocument<T>;
    /**
     * Create an Langium document from a specified `URI`. The factory will use the `FileSystemAccess` service to read the file.
     */
    fromUri<T extends AstNode = AstNode>(uri: URI, cancellationToken?: CancellationToken): Promise<LangiumDocument<T>>;
    /**
     * Update the given document after changes in the corresponding textual representation.
     * Method is called by the document builder after it has been requested to build an existing
     * document and the document's state is {@link DocumentState.Changed}.
     * The text parsing is expected to be done the same way as in {@link fromTextDocument}
     * and {@link fromString}.
     */
    update<T extends AstNode = AstNode>(document: LangiumDocument<T>, cancellationToken: CancellationToken): Promise<LangiumDocument<T>>;
}
/**
 * Shared service for managing Langium documents.
 */
interface LangiumDocuments {
    /**
     * A stream of all documents managed under this service.
     */
    readonly all: Stream<LangiumDocument>;
    /**
     * Manage a new document under this service.
     * @throws an error if a document with the same URI is already present.
     */
    addDocument(document: LangiumDocument): void;
    /**
     * Retrieve the document with the given URI, if present. Otherwise returns `undefined`.
     */
    getDocument(uri: URI): LangiumDocument | undefined;
    /**
     * Retrieve the document with the given URI. If not present, a new one will be created using the file system access.
     * The new document will be added to the list of documents managed under this service.
     */
    getOrCreateDocument(uri: URI, cancellationToken?: CancellationToken): Promise<LangiumDocument>;
    /**
     * Creates a new document with the given URI and text content.
     * The new document is automatically added to this service and can be retrieved using {@link getDocument}.
     *
     * @throws an error if a document with the same URI is already present.
     */
    createDocument(uri: URI, text: string): LangiumDocument;
    /**
     * Creates a new document with the given URI and text content asynchronously.
     * The process can be interrupted with a cancellation token.
     * The new document is automatically added to this service and can be retrieved using {@link getDocument}.
     *
     * @throws an error if a document with the same URI is already present.
     */
    createDocument(uri: URI, text: string, cancellationToken: CancellationToken): Promise<LangiumDocument>;
    /**
     * Returns `true` if a document with the given URI is managed under this service.
     */
    hasDocument(uri: URI): boolean;
    /**
     * Flag the document with the given URI as `Changed`, if present, meaning that its content
     * is no longer valid. The content (parseResult) stays untouched, while internal data may
     * be dropped to reduce memory footprint.
     *
     * @returns the affected {@link LangiumDocument} if existing for convenience
     */
    invalidateDocument(uri: URI): LangiumDocument | undefined;
    /**
     * Remove the document with the given URI, if present, and mark it as `Changed`, meaning
     * that its content is no longer valid. The next call to `getOrCreateDocument` with the same
     * URI will create a new document instance.
     *
     * @returns the affected {@link LangiumDocument} if existing for convenience
     */
    deleteDocument(uri: URI): LangiumDocument | undefined;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * A node in the Abstract Syntax Tree (AST).
 */
interface AstNode {
    /** Every AST node has a type corresponding to what was specified in the grammar declaration. */
    readonly $type: string;
    /** The container node in the AST; every node except the root node has a container. */
    readonly $container?: AstNode;
    /** The property of the `$container` node that contains this node. This is either a direct reference or an array. */
    readonly $containerProperty?: string;
    /** In case `$containerProperty` is an array, the array index is stored here. */
    readonly $containerIndex?: number;
    /** The Concrete Syntax Tree (CST) node of the text range from which this node was parsed. */
    readonly $cstNode?: CstNode;
    /** The document containing the AST; only the root node has a direct reference to the document. */
    readonly $document?: LangiumDocument;
}
type SpecificNodeProperties<N extends AstNode> = keyof Omit<N, keyof AstNode | number | symbol>;
/**
 * The property names of a given AST node type.
 */
type Properties<N extends AstNode> = SpecificNodeProperties<N> extends never ? string : SpecificNodeProperties<N>;
/**
 * A cross-reference in the AST. Cross-references may or may not be successfully resolved.
 */
interface Reference<T extends AstNode = AstNode> {
    /**
     * The target AST node of this reference. Accessing this property may trigger cross-reference
     * resolution by the `Linker` in case it has not been done yet. If the reference cannot be resolved,
     * the value is `undefined`.
     */
    readonly ref?: T;
    /** If any problem occurred while resolving the reference, it is described by this property. */
    readonly error?: LinkingError;
    /** The CST node from which the reference was parsed */
    readonly $refNode?: CstNode;
    /** The actual text used to look up in the surrounding scope */
    readonly $refText: string;
    /** The node description for the AstNode returned by `ref`  */
    readonly $nodeDescription?: AstNodeDescription;
}
/**
 * A description of an AST node is used when constructing scopes and looking up cross-reference targets.
 */
interface AstNodeDescription {
    /** The target node; should be present only for local references (linking to the same document). */
    node?: AstNode;
    /**
     * The document segment that represents the range of the name of the AST node.
     */
    nameSegment?: DocumentSegment;
    /**
     * The document segment that represents the full range of the AST node.
     */
    selectionSegment?: DocumentSegment;
    /** `$type` property value of the AST node */
    type: string;
    /** Name of the AST node; this is usually determined by the `NameProvider` service. */
    name: string;
    /** URI to the document containing the AST node */
    documentUri: URI;
    /** Navigation path inside the document */
    path: string;
}
/**
 * Information about a cross-reference. This is used when traversing references in an AST or to describe
 * unresolved references.
 */
interface ReferenceInfo {
    reference: Reference;
    container: AstNode;
    property: string;
    index?: number;
}
/**
 * Used to collect information when the `Linker` service fails to resolve a cross-reference.
 */
interface LinkingError extends ReferenceInfo {
    message: string;
    targetDescription?: AstNodeDescription;
}
/**
 * Service used for generic access to the structure of the AST. This service is shared between
 * all involved languages, so it operates on the superset of types of these languages.
 */
interface AstReflection {
    getAllTypes(): string[];
    getAllSubTypes(type: string): string[];
    getReferenceType(refInfo: ReferenceInfo): string;
    getTypeMetaData(type: string): TypeMetaData;
    isInstance(node: unknown, type: string): boolean;
    isSubtype(subtype: string, supertype: string): boolean;
}
/**
 * Represents runtime meta data about a meta model type.
 */
interface TypeMetaData {
    /** The name of this meta model type. Corresponds to the `AstNode.$type` value. */
    name: string;
    /** A list of properties. They can contain default values for their respective property in the AST. */
    properties: TypeProperty[];
}
/**
 * Describes the meta data of a property of an AST node.
 *
 * The optional `defaultValue` indicates that the property is mandatory in the AST node.
 * For example, if an AST node contains an array, but no elements of this array have been parsed, we still expect an empty array instead of `undefined`.
 */
interface TypeProperty {
    name: string;
    defaultValue?: PropertyType;
}
/**
 * Represents a default value for an AST property.
 */
type PropertyType = number | string | boolean | PropertyType[];
/**
 * A node in the Concrete Syntax Tree (CST).
 */
interface CstNode extends DocumentSegment {
    /** The container node in the CST */
    readonly container?: CompositeCstNode;
    /** @deprecated use `container` instead. */
    readonly parent?: CompositeCstNode;
    /** The actual text */
    readonly text: string;
    /** The root CST node */
    readonly root: RootCstNode;
    /** The grammar element from which this node was parsed */
    readonly grammarSource: AbstractElement;
    /** @deprecated use `grammarSource` instead. */
    readonly feature: AbstractElement;
    /** The AST node created from this CST node */
    readonly astNode: AstNode;
    /** @deprecated use `astNode` instead. */
    readonly element: AstNode;
    /** Whether the token is hidden, i.e. not explicitly part of the containing grammar rule */
    readonly hidden: boolean;
}
/**
 * A composite CST node contains other nodes, but no directly associated token.
 */
interface CompositeCstNode extends CstNode {
    readonly content: CstNode[];
    /** @deprecated use `content` instead. */
    readonly children: CstNode[];
}
interface RootCstNode extends CompositeCstNode {
    readonly fullText: string;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Provides comments for AST nodes.
 */
interface CommentProvider {
    /**
     * Returns the comment associated with the specified AST node.
     * @param node The AST node to get the comment for.
     * @returns The comment associated with the specified AST node or `undefined` if there is no comment.
     */
    getComment(node: AstNode): string | undefined;
}

interface AsyncDisposable {
    /**
     * Dispose this object.
     */
    dispose(): Promise<void>;
}
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
interface Disposable {
    /**
     * Dispose this object.
     */
    dispose(): void;
}
declare namespace Disposable {
    function create(callback: () => Promise<void>): AsyncDisposable;
    function create(callback: () => void): Disposable;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

declare abstract class DisposableCache implements Disposable {
    protected toDispose: Disposable[];
    protected isDisposed: boolean;
    onDispose(disposable: Disposable): void;
    dispose(): void;
    protected throwIfDisposed(): void;
    abstract clear(): void;
}
declare class SimpleCache<K, V> extends DisposableCache {
    protected readonly cache: Map<K, V>;
    has(key: K): boolean;
    set(key: K, value: V): void;
    get(key: K): V | undefined;
    get(key: K, provider: () => V): V;
    delete(key: K): boolean;
    clear(): void;
}
/**
 * Every key/value pair in this cache is scoped to the whole workspace.
 * If any document in the workspace is added, changed or deleted, the whole cache is evicted.
 */
declare class WorkspaceCache<K, V> extends SimpleCache<K, V> {
    /**
     * Creates a new workspace cache.
     *
     * @param sharedServices Service container instance to hook into document lifecycle events.
     * @param state Optional document state on which the cache should evict.
     * If not provided, the cache will evict on `DocumentBuilder#onUpdate`.
     * *Deleted* documents are considered in both cases.
     */
    constructor(sharedServices: LangiumSharedCoreServices, state?: DocumentState);
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Utility service for retrieving the `name` of an `AstNode` or the `CstNode` containing a `name`.
 */
interface NameProvider {
    /**
     * Returns the `name` of a given AstNode.
     * @param node Specified `AstNode` whose name node shall be retrieved.
     */
    getName(node: AstNode): string | undefined;
    /**
     * Returns the `CstNode` which contains the parsed value of the `name` assignment.
     * @param node Specified `AstNode` whose name node shall be retrieved.
     */
    getNameNode(node: AstNode): CstNode | undefined;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for locating an `AstNode` in a document.
 */
interface AstNodeLocator {
    /**
     * Creates a path represented by a `string` that identifies an `AstNode` inside its document.
     * It must be possible to retrieve exactly the same `AstNode` from the document using this path.
     *
     * @param node The `AstNode` for which to create the path.
     * @returns a path represented by a `string` that identifies `node` inside its document.
     * @see AstNodeLocator.getAstNode
     */
    getAstNodePath(node: AstNode): string;
    /**
     * Locates an `AstNode` inside another node by following the given path.
     *
     * @param node Parent element.
     * @param path Describes how to locate the `AstNode` inside the given `node`.
     * @returns The `AstNode` located under the given path, or `undefined` if the path cannot be resolved.
     * @see AstNodeLocator.getAstNodePath
     */
    getAstNode<T extends AstNode = AstNode>(node: AstNode, path: string): T | undefined;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for creating descriptions of AST nodes to be used for cross-reference resolutions.
 */
interface AstNodeDescriptionProvider {
    /**
     * Create a description for the given AST node. This service method is typically used while indexing
     * the contents of a document and during scope computation.
     *
     * @param node An AST node.
     * @param name The name to be used to refer to the AST node. By default, this is determined by the
     *     `NameProvider` service, but alternative names may be provided according to the semantics
     *     of your language.
     * @param document The document containing the AST node. If omitted, it is taken from the root AST node.
     */
    createDescription(node: AstNode, name: string | undefined, document?: LangiumDocument): AstNodeDescription;
}
/**
 * Describes a cross-reference within a document or between two documents.
 */
interface ReferenceDescription {
    /** URI of the document that holds a reference */
    sourceUri: URI;
    /** Path to AstNode that holds a reference */
    sourcePath: string;
    /** Target document uri */
    targetUri: URI;
    /** Path to the target AstNode inside the document */
    targetPath: string;
    /** Segment of the reference text. */
    segment: DocumentSegment;
    /** Marks a local reference i.e. a cross reference inside a document.   */
    local?: boolean;
}
/**
 * Language-specific service to create descriptions of all cross-references in a document. These are used by the `IndexManager`
 * to determine which documents are affected and should be rebuilt when a document is changed.
 */
interface ReferenceDescriptionProvider {
    /**
     * Create descriptions of all cross-references found in the given document. These descriptions are
     * gathered by the `IndexManager` and stored in the global index so they can be considered when
     * a document change is reported by the client.
     *
     * @param document The document in which to gather cross-references.
     * @param cancelToken Indicates when to cancel the current operation.
     * @throws `OperationCanceled` if a user action occurs during execution
     */
    createDescriptions(document: LangiumDocument, cancelToken?: CancellationToken): Promise<ReferenceDescription[]>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * The index manager is responsible for keeping metadata about symbols and cross-references
 * in the workspace. It is used to look up symbols in the global scope, mostly during linking
 * and completion. This service is shared between all languages of a language server.
 */
interface IndexManager {
    /**
     * Removes the specified document URI from the index.
     * Necessary when documents are deleted and not referenceable anymore.
     *
     * @param uri The URI of the document for which index data shall be removed
     */
    remove(uri: URI): void;
    /**
     * Updates the information about the exportable content of a document inside the index.
     *
     * @param document Document to be updated
     * @param cancelToken Indicates when to cancel the current operation.
     * @throws `OperationCanceled` if a user action occurs during execution
     */
    updateContent(document: LangiumDocument, cancelToken?: CancellationToken): Promise<void>;
    /**
     * Updates the information about the cross-references of a document inside the index.
     *
     * @param document Document to be updated
     * @param cancelToken Indicates when to cancel the current operation.
     * @throws `OperationCanceled` if a user action occurs during execution
     */
    updateReferences(document: LangiumDocument, cancelToken?: CancellationToken): Promise<void>;
    /**
     * Determine whether the given document could be affected by changes of the documents
     * identified by the given URIs (second parameter). The document is typically regarded as
     * affected if it contains a reference to any of the changed files.
     *
     * @param document Document to check whether it's affected
     * @param changedUris URIs of the changed documents
     */
    isAffected(document: LangiumDocument, changedUris: Set<string>): boolean;
    /**
     * Compute a list of all exported elements, optionally filtered using a type identifier and document URIs.
     *
     * @param nodeType The type to filter with, or `undefined` to return descriptions of all types.
     * @param uris If specified, only returns elements from the given URIs.
     * @returns a `Stream` containing all globally visible nodes (of a given type).
     */
    allElements(nodeType?: string, uris?: Set<string>): Stream<AstNodeDescription>;
    /**
     * Returns all known references that are pointing to the given `targetNode`.
     *
     * @param targetNode the `AstNode` to look up references for
     * @param astNodePath the path that points to the `targetNode` inside the document. See also `AstNodeLocator`
     *
     * @returns a `Stream` of references that are targeting the `targetNode`
     */
    findAllReferences(targetNode: AstNode, astNodePath: string): Stream<ReferenceDescription>;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Provides documentation for AST nodes.
 */
interface DocumentationProvider {
    /**
     * Returns a markdown documentation string for the specified AST node.
     *
     * The default implementation `JSDocDocumentationProvider` will inspect the comment associated with the specified node.
     */
    getDocumentation(node: AstNode): string | undefined;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
/**
 * Metadata of a language.
 */
interface LanguageMetaData {
    languageId: string;
    fileExtensions: readonly string[];
    caseInsensitive: boolean;
    /**
     * Mode used to optimize code for development or production environments.
     *
     * In production mode, all Chevrotain lexer/parser validations are disabled.
     */
    mode: 'development' | 'production';
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * A scope describes what target elements are visible from a specific cross-reference context.
 */
interface Scope {
    /**
     * Find a target element matching the given name. If no element is found, `undefined` is returned.
     * If multiple matching elements are present, the selection of the returned element should be done
     * according to the semantics of your language. Usually it is the element that is most closely defined.
     *
     * @param name Name of the cross-reference target as it appears in the source text.
     */
    getElement(name: string): AstNodeDescription | undefined;
    /**
     * Create a stream of all elements in the scope. This is used to compute completion proposals to be
     * shown in the editor.
     */
    getAllElements(): Stream<AstNodeDescription>;
}
interface ScopeOptions {
    caseInsensitive?: boolean;
}

/******************************************************************************
 * Copyright 2021-2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for determining the scope of target elements visible in a specific cross-reference context.
 */
interface ScopeProvider {
    /**
     * Return a scope describing what elements are visible for the given AST node and cross-reference
     * identifier.
     *
     * @param context Information about the reference for which a scope is requested.
     */
    getScope(context: ReferenceInfo): Scope;
}
declare class DefaultScopeProvider implements ScopeProvider {
    protected readonly reflection: AstReflection;
    protected readonly nameProvider: NameProvider;
    protected readonly descriptions: AstNodeDescriptionProvider;
    protected readonly indexManager: IndexManager;
    protected readonly globalScopeCache: WorkspaceCache<string, Scope>;
    constructor(services: LangiumCoreServices);
    getScope(context: ReferenceInfo): Scope;
    /**
     * Create a scope for the given collection of AST node descriptions.
     */
    protected createScope(elements: Iterable<AstNodeDescription>, outerScope?: Scope, options?: ScopeOptions): Scope;
    /**
     * Create a scope for the given collection of AST nodes, which need to be transformed into respective
     * descriptions first. This is done using the `NameProvider` and `AstNodeDescriptionProvider` services.
     */
    protected createScopeForNodes(elements: Iterable<AstNode>, outerScope?: Scope, options?: ScopeOptions): Scope;
    /**
     * Create a global scope filtered for the given reference type.
     */
    protected getGlobalScope(referenceType: string, _context: ReferenceInfo): Scope;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for resolving cross-references in the AST.
 */
interface Linker {
    /**
     * Links all cross-references within the specified document. The default implementation loads only target
     * elements from documents that are present in the `LangiumDocuments` service. The linked references are
     * stored in the document's `references` property.
     *
     * @param document A LangiumDocument that shall be linked.
     * @param cancelToken A token for cancelling the operation.
     *
     * @throws `OperationCancelled` if a cancellation event is detected
     */
    link(document: LangiumDocument, cancelToken?: CancellationToken): Promise<void>;
    /**
     * Unlinks all references within the specified document and removes them from the list of `references`.
     *
     * @param document A LangiumDocument that shall be unlinked.
     */
    unlink(document: LangiumDocument): void;
    /**
     * Determines a candidate AST node description for linking the given reference.
     *
     * @param refInfo Information about the reference.
     */
    getCandidate(refInfo: ReferenceInfo): AstNodeDescription | LinkingError;
    /**
     * Creates a cross reference node being aware of its containing AstNode, the corresponding CstNode,
     * the cross reference text denoting the target AstNode being already extracted of the document text,
     * as well as the unique cross reference identifier.
     *
     * Default behavior:
     *  - The returned Reference's 'ref' property pointing to the target AstNode is populated lazily on its
     *    first visit.
     *  - If the target AstNode cannot be resolved on the first visit, an error indicator will be installed
     *    and further resolution attempts will *not* be performed.
     *
     * @param node The containing AST node
     * @param property The AST node property being referenced
     * @param refNode The corresponding CST node
     * @param refText The cross reference text denoting the target AstNode
     * @returns the desired Reference node, whose behavior wrt. resolving the cross reference is implementation specific.
     */
    buildReference(node: AstNode, property: string, refNode: CstNode | undefined, refText: string): Reference;
}

/******************************************************************************
 * Copyright 2024 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * The hydrator service is responsible for allowing AST parse results to be sent across worker threads.
 */
interface Hydrator {
    /**
     * Converts a parse result to a plain object. The resulting object can be sent across worker threads.
     */
    dehydrate(result: ParseResult<AstNode>): ParseResult<object>;
    /**
     * Converts a plain object to a parse result. The included AST node can then be used in the main thread.
     * Calling this method on objects that have not been dehydrated first will result in undefined behavior.
     */
    hydrate<T extends AstNode = AstNode>(result: ParseResult<object>): ParseResult<T>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

type MaybePromise<T> = T | Promise<T>;
/**
 * Simple implementation of the deferred pattern.
 * An object that exposes a promise and functions to resolve and reject it.
 */
declare class Deferred<T = void> {
    resolve: (value: T) => this;
    reject: (err?: unknown) => this;
    promise: Promise<T>;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Async parser that allows cancellation of the current parsing process.
 *
 * @remarks
 * The sync parser implementation is blocking the event loop, which can become quite problematic for large files.
 * The default implementation is not actually async. It just wraps the sync parser in a promise. A real implementation would create worker threads or web workers to offload the parsing work.
 */
interface AsyncParser {
    /**
     * Parses the given text and returns the parse result.
     *
     * @param text The text to parse.
     * @param cancelToken A cancellation token that can be used to cancel the parsing process.
     * @returns A promise that resolves to the parse result.
     *
     * @throws `OperationCancelled` if the parsing process is cancelled.
     */
    parse<T extends AstNode>(text: string, cancelToken: CancellationToken): Promise<ParseResult<T>>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

type ValueType = string | number | boolean | bigint | Date;
/**
 * Language-specific service for converting string values from the source text format into a value to be held in the AST.
 */
interface ValueConverter {
    /**
     * Converts a string value from the source text format into a value to be held in the AST.
     */
    convert(input: string, cstNode: CstNode): ValueType;
}
declare namespace ValueConverter {
    function convertString(input: string): string;
    function convertID(input: string): string;
    function convertInt(input: string): number;
    function convertBigint(input: string): bigint;
    function convertDate(input: string): Date;
    function convertNumber(input: string): number;
    function convertBoolean(input: string): boolean;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for finding references and declaration of a given `CstNode`.
 */
interface References {
    /**
     * If the CstNode is a reference node the target CstNode will be returned.
     * If the CstNode is a significant node of the CstNode this CstNode will be returned.
     *
     * @param sourceCstNode CstNode that points to a AstNode
     */
    findDeclaration(sourceCstNode: CstNode): AstNode | undefined;
    /**
     * If the CstNode is a reference node the target CstNode will be returned.
     * If the CstNode is a significant node of the CstNode this CstNode will be returned.
     *
     * @param sourceCstNode CstNode that points to a AstNode
     */
    findDeclarationNode(sourceCstNode: CstNode): CstNode | undefined;
    /**
     * Finds all references to the target node as references (local references) or reference descriptions.
     *
     * @param targetNode Specified target node whose references should be returned
     */
    findReferences(targetNode: AstNode, options: FindReferencesOptions): Stream<ReferenceDescription>;
}
interface FindReferencesOptions {
    /**
     * @deprecated Since v1.2.0. Please use `documentUri` instead.
     */
    onlyLocal?: boolean;
    /**
     * When set, the `findReferences` method will only return references/declarations from the specified document.
     */
    documentUri?: URI;
    /**
     * Whether the returned list of references should include the declaration.
     */
    includeDeclaration?: boolean;
}

/******************************************************************************
 * Copyright 2021-2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for precomputing global and local scopes. The service methods are executed
 * as the first and second phase in the `DocumentBuilder`.
 */
interface ScopeComputation {
    /**
     * Creates descriptions of all AST nodes that shall be exported into the _global_ scope from the given
     * document. These descriptions are gathered by the `IndexManager` and stored in the global index so
     * they can be referenced from other documents.
     *
     * _Note:_ You should not resolve any cross-references in this service method. Cross-reference resolution
     * depends on the scope computation phase to be completed (`computeScope` method), which runs after the
     * initial indexing where this method is used.
     *
     * @param document The document from which to gather exported AST nodes.
     * @param cancelToken Indicates when to cancel the current operation.
     * @throws `OperationCanceled` if a user action occurs during execution
     */
    computeExports(document: LangiumDocument, cancelToken?: CancellationToken): Promise<AstNodeDescription[]>;
    /**
     * Precomputes the _local_ scopes for a document, which are necessary for the default way of
     * resolving references to symbols in the same document. The result is a multimap assigning a
     * set of AST node descriptions to every level of the AST. These data are used by the `ScopeProvider`
     * service to determine which target nodes are visible in the context of a specific cross-reference.
     *
     * _Note:_ You should not resolve any cross-references in this service method. Cross-reference
     * resolution depends on the scope computation phase to be completed.
     *
     * @param document The document in which to compute scopes.
     * @param cancelToken Indicates when to cancel the current operation.
     * @throws `OperationCanceled` if a user action occurs during execution
     */
    computeLocalScopes(document: LangiumDocument, cancelToken?: CancellationToken): Promise<PrecomputedScopes>;
}
/**
 * The default scope computation creates and collectes descriptions of the AST nodes to be exported into the
 * _global_ scope from the given document. By default those are the document's root AST node and its directly
 * contained child nodes.
 *
 * Besides, it gathers all AST nodes that have a name (according to the `NameProvider` service) and includes them
 * in the local scope of their particular container nodes. As a result, for every cross-reference in the AST,
 * target elements from the same level (siblings) and further up towards the root (parents and siblings of parents)
 * are visible. Elements being nested inside lower levels (children, children of siblings and parents' siblings)
 * are _invisible_ by default, but that can be changed by customizing this service.
 */
declare class DefaultScopeComputation implements ScopeComputation {
    protected readonly nameProvider: NameProvider;
    protected readonly descriptions: AstNodeDescriptionProvider;
    constructor(services: LangiumCoreServices);
    computeExports(document: LangiumDocument, cancelToken?: CancellationToken): Promise<AstNodeDescription[]>;
    /**
     * Creates {@link AstNodeDescription AstNodeDescriptions} for the given {@link AstNode parentNode} and its children.
     * The list of children to be considered is determined by the function parameter {@link children}.
     * By default only the direct children of {@link parentNode} are visited, nested nodes are not exported.
     *
     * @param parentNode AST node to be exported, i.e., of which an {@link AstNodeDescription} shall be added to the returned list.
     * @param document The document containing the AST node to be exported.
     * @param children A function called with {@link parentNode} as single argument and returning an {@link Iterable} supplying the children to be visited, which must be directly or transitively contained in {@link parentNode}.
     * @param cancelToken Indicates when to cancel the current operation.
     * @throws `OperationCancelled` if a user action occurs during execution.
     * @returns A list of {@link AstNodeDescription AstNodeDescriptions} to be published to index.
     */
    computeExportsForNode(parentNode: AstNode, document: LangiumDocument<AstNode>, children?: (root: AstNode) => Iterable<AstNode>, cancelToken?: CancellationToken): Promise<AstNodeDescription[]>;
    /**
     * Add a single node to the list of exports if it has a name. Override this method to change how
     * symbols are exported, e.g. by modifying their exported name.
     */
    protected exportNode(node: AstNode, exports: AstNodeDescription[], document: LangiumDocument): void;
    computeLocalScopes(document: LangiumDocument, cancelToken?: CancellationToken): Promise<PrecomputedScopes>;
    /**
     * Process a single node during scopes computation. The default implementation makes the node visible
     * in the subtree of its container (if the node has a name). Override this method to change this,
     * e.g. by increasing the visibility to a higher level in the AST.
     */
    protected processNode(node: AstNode, document: LangiumDocument, scopes: PrecomputedScopes): void;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface JsonSerializeOptions {
    /** The space parameter for `JSON.stringify`, controlling whether and how to pretty-print the output. */
    space?: string | number;
    /** Whether to include the `$refText` property for references (the name used to identify the target node). */
    refText?: boolean;
    /** Whether to include the `$sourceText` property, which holds the full source text from which an AST node was parsed. */
    sourceText?: boolean;
    /** Whether to include the `$textRegion` property, which holds information to trace AST node properties to their respective source text regions. */
    textRegions?: boolean;
    /** Whether to include the `$comment` property, which holds comments according to the CommentProvider service. */
    comments?: boolean;
    /** The replacer parameter for `JSON.stringify`; the default replacer given as parameter should be used to apply basic replacements. */
    replacer?: (key: string, value: unknown, defaultReplacer: (key: string, value: unknown) => unknown) => unknown;
    /** Used to convert and serialize URIs when the target of a cross-reference is in a different document. */
    uriConverter?: (uri: URI, reference: Reference) => string;
}
interface JsonDeserializeOptions {
    /** Used to parse and convert URIs when the target of a cross-reference is in a different document. */
    uriConverter?: (uri: string) => URI;
}
/**
 * Utility service for transforming an `AstNode` into a JSON string and vice versa.
 */
interface JsonSerializer {
    /**
     * Serialize an `AstNode` into a JSON `string`.
     * @param node The `AstNode` to be serialized.
     * @param options Serialization options
     */
    serialize(node: AstNode, options?: JsonSerializeOptions): string;
    /**
     * Deserialize (parse) a JSON `string` into an `AstNode`.
     */
    deserialize<T extends AstNode = AstNode>(content: string, options?: JsonDeserializeOptions): T;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

type DiagnosticInfo<N extends AstNode, P extends string = Properties<N>> = {
    /** The AST node to which the diagnostic is attached. */
    node: N;
    /** If a property name is given, the diagnostic is restricted to the corresponding text region. */
    property?: P;
    /** If the value of a keyword is given, the diagnostic will appear at its corresponding text region */
    keyword?: string;
    /** In case of a multi-value property (array), an index can be given to select a specific element. */
    index?: number;
    /** If you want to create a diagnostic independent to any property, use the range property. */
    range?: Range$1;
    /** The diagnostic's code, which usually appear in the user interface. */
    code?: integer | string;
    /** An optional property to describe the error code. */
    codeDescription?: CodeDescription;
    /** Additional metadata about the diagnostic. */
    tags?: DiagnosticTag[];
    /** An array of related diagnostic information, e.g. when symbol-names within a scope collide all definitions can be marked via this property. */
    relatedInformation?: DiagnosticRelatedInformation[];
    /** A data entry field that is preserved between a `textDocument/publishDiagnostics` notification and `textDocument/codeAction` request. */
    data?: unknown;
};
type ValidationSeverity = 'error' | 'warning' | 'info' | 'hint';
type ValidationAcceptor = <N extends AstNode>(severity: ValidationSeverity, message: string, info: DiagnosticInfo<N>) => void;
type ValidationCheck<T extends AstNode = AstNode> = (node: T, accept: ValidationAcceptor, cancelToken: CancellationToken) => MaybePromise<void>;
/**
 * A utility type for describing functions which will be called once before or after all the AstNodes of an AST/Langium document are validated.
 *
 * The AST is represented by its root AstNode.
 *
 * The given validation acceptor helps to report some early or lately detected issues.
 *
 * The 'categories' indicate, which validation categories are executed for all the AstNodes.
 * This helps to tailor the preparations/tear-down logic to the actually executed checks on the nodes.
 *
 * It is recommended to support interrupts during long-running logic with 'interruptAndCheck(cancelToken)'.
 */
type ValidationPreparation = (rootNode: AstNode, accept: ValidationAcceptor, categories: ValidationCategory[], cancelToken: CancellationToken) => MaybePromise<void>;
/**
 * A utility type for associating non-primitive AST types to corresponding validation checks. For example:
 *
 * ```ts
 *   const checks: ValidationChecks<StatemachineAstType> = {
 *       State: validator.checkStateNameStartsWithCapital
 *    };
 * ```
 *
 * If an AST type does not extend AstNode, e.g. if it describes a union of string literals, that type's name must not occur as a key in objects of type `ValidationCheck<...>`.
 *
 * @param T a type definition mapping language specific type names (keys) to the corresponding types (values)
 */
type ValidationChecks<T> = {
    [K in keyof T]?: T[K] extends AstNode ? ValidationCheck<T[K]> | Array<ValidationCheck<T[K]>> : never;
} & {
    AstNode?: ValidationCheck<AstNode> | Array<ValidationCheck<AstNode>>;
};
/**
 * `fast` checks can be executed after every document change (i.e. as the user is typing). If a check
 * is too slow it can delay the response to document changes, yielding bad user experience. By marking
 * it as `slow`, it will be skipped for normal as-you-type validation. Then it's up to you when to
 * schedule these long-running checks: after the fast checks are done, or after saving a document,
 * or with an explicit command, etc.
 *
 * `built-in` checks are errors produced by the lexer, the parser, or the linker. They cannot be used
 * for custom validation checks.
 */
type ValidationCategory = 'fast' | 'slow' | 'built-in';
declare namespace ValidationCategory {
    const all: readonly ValidationCategory[];
}
type ValidationCheckEntry = {
    check: ValidationCheck;
    category: ValidationCategory;
};
/**
 * Manages a set of `ValidationCheck`s to be applied when documents are validated.
 */
declare class ValidationRegistry {
    private readonly entries;
    private readonly reflection;
    private entriesBefore;
    private entriesAfter;
    constructor(services: LangiumCoreServices);
    /**
     * Register a set of validation checks. Each value in the record can be either a single validation check (i.e. a function)
     * or an array of validation checks.
     *
     * @param checksRecord Set of validation checks to register.
     * @param category Optional category for the validation checks (defaults to `'fast'`).
     * @param thisObj Optional object to be used as `this` when calling the validation check functions.
     */
    register<T>(checksRecord: ValidationChecks<T>, thisObj?: ThisParameterType<unknown>, category?: ValidationCategory): void;
    protected wrapValidationException(check: ValidationCheck, thisObj: unknown): ValidationCheck;
    protected handleException(functionality: () => MaybePromise<void>, messageContext: string, accept: ValidationAcceptor, node: AstNode): Promise<void>;
    protected addEntry(type: string, entry: ValidationCheckEntry): void;
    getChecks(type: string, categories?: ValidationCategory[]): Stream<ValidationCheck>;
    /**
     * Register logic which will be executed once before validating all the nodes of an AST/Langium document.
     * This helps to prepare or initialize some information which are required or reusable for the following checks on the AstNodes.
     *
     * As an example, for validating unique fully-qualified names of nodes in the AST,
     * here the map for mapping names to nodes could be established.
     * During the usual checks on the nodes, they are put into this map with their name.
     *
     * Note that this approach makes validations stateful, which is relevant e.g. when cancelling the validation.
     * Therefore it is recommended to clear stored information
     * _before_ validating an AST to validate each AST unaffected from other ASTs
     * AND _after_ validating the AST to free memory by information which are no longer used.
     *
     * @param checkBefore a set-up function which will be called once before actually validating an AST
     * @param thisObj Optional object to be used as `this` when calling the validation check functions.
     */
    registerBeforeDocument(checkBefore: ValidationPreparation, thisObj?: ThisParameterType<unknown>): void;
    /**
     * Register logic which will be executed once after validating all the nodes of an AST/Langium document.
     * This helps to finally evaluate information which are collected during the checks on the AstNodes.
     *
     * As an example, for validating unique fully-qualified names of nodes in the AST,
     * here the map with all the collected nodes and their names is checked
     * and validation hints are created for all nodes with the same name.
     *
     * Note that this approach makes validations stateful, which is relevant e.g. when cancelling the validation.
     * Therefore it is recommended to clear stored information
     * _before_ validating an AST to validate each AST unaffected from other ASTs
     * AND _after_ validating the AST to free memory by information which are no longer used.
     *
     * @param checkBefore a set-up function which will be called once before actually validating an AST
     * @param thisObj Optional object to be used as `this` when calling the validation check functions.
     */
    registerAfterDocument(checkAfter: ValidationPreparation, thisObj?: ThisParameterType<unknown>): void;
    protected wrapPreparationException(check: ValidationPreparation, messageContext: string, thisObj: unknown): ValidationPreparation;
    get checksBefore(): ValidationPreparation[];
    get checksAfter(): ValidationPreparation[];
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface ValidationOptions {
    /**
     * If this is set, only the checks associated with these categories are executed; otherwise
     * all checks are executed. The default category if not specified to the registry is `'fast'`.
     */
    categories?: ValidationCategory[];
    /** If true, no further diagnostics are reported if there are lexing errors. */
    stopAfterLexingErrors?: boolean;
    /** If true, no further diagnostics are reported if there are parsing errors. */
    stopAfterParsingErrors?: boolean;
    /** If true, no further diagnostics are reported if there are linking errors. */
    stopAfterLinkingErrors?: boolean;
}
/**
 * Language-specific service for validating `LangiumDocument`s.
 */
interface DocumentValidator {
    /**
     * Validates the whole specified document.
     *
     * @param document specified document to validate
     * @param options options to control the validation process
     * @param cancelToken allows to cancel the current operation
     * @throws `OperationCanceled` if a user action occurs during execution
     */
    validateDocument(document: LangiumDocument, options?: ValidationOptions, cancelToken?: CancellationToken): Promise<Diagnostic[]>;
}
declare namespace DocumentValidator {
    const LexingError = "lexing-error";
    const LexingWarning = "lexing-warning";
    const LexingInfo = "lexing-info";
    const LexingHint = "lexing-hint";
    const ParsingError = "parsing-error";
    const LinkingError = "linking-error";
}

interface ResponseErrorLiteral<D = void> {
    /**
     * A number indicating the error type that occurred.
     */
    code: number;
    /**
     * A string providing a short description of the error.
     */
    message: string;
    /**
     * A Primitive or Structured value that contains additional
     * information about the error. Can be omitted.
     */
    data?: D;
}
/**
 * An error object return in a response in case a request
 * has failed.
 */
declare class ResponseError<D = void> extends Error {
    readonly code: number;
    readonly data: D | undefined;
    constructor(code: number, message: string, data?: D);
    toJson(): ResponseErrorLiteral<D>;
}
declare class ParameterStructures {
    private readonly kind;
    /**
     * The parameter structure is automatically inferred on the number of parameters
     * and the parameter type in case of a single param.
     */
    static readonly auto: ParameterStructures;
    /**
     * Forces `byPosition` parameter structure. This is useful if you have a single
     * parameter which has a literal type.
     */
    static readonly byPosition: ParameterStructures;
    /**
     * Forces `byName` parameter structure. This is only useful when having a single
     * parameter. The library will report errors if used with a different number of
     * parameters.
     */
    static readonly byName: ParameterStructures;
    private constructor();
    static is(value: any): value is ParameterStructures;
    toString(): string;
}
/**
 * An interface to type messages.
 */
interface MessageSignature {
    readonly method: string;
    readonly numberOfParams: number;
    readonly parameterStructures: ParameterStructures;
}
/**
 * An abstract implementation of a MessageType.
 */
declare abstract class AbstractMessageSignature implements MessageSignature {
    readonly method: string;
    readonly numberOfParams: number;
    constructor(method: string, numberOfParams: number);
    get parameterStructures(): ParameterStructures;
}
/**
 * End marker interface for request and notification types.
 */
interface _EM {
    _$endMarker$_: number;
}
/**
 * Classes to type request response pairs
 */
declare class RequestType0<R, E> extends AbstractMessageSignature {
    /**
     * Clients must not use this property. It is here to ensure correct typing.
     */
    readonly _: [R, E, _EM] | undefined;
    constructor(method: string);
}
declare class RequestType<P, R, E> extends AbstractMessageSignature {
    private _parameterStructures;
    /**
     * Clients must not use this property. It is here to ensure correct typing.
     */
    readonly _: [P, R, E, _EM] | undefined;
    constructor(method: string, _parameterStructures?: ParameterStructures);
    get parameterStructures(): ParameterStructures;
}
declare class NotificationType<P> extends AbstractMessageSignature {
    private _parameterStructures;
    /**
     * Clients must not use this property. It is here to ensure correct typing.
     */
    readonly _: [P, _EM] | undefined;
    constructor(method: string, _parameterStructures?: ParameterStructures);
    get parameterStructures(): ParameterStructures;
}
declare class NotificationType0 extends AbstractMessageSignature {
    /**
     * Clients must not use this property. It is here to ensure correct typing.
     */
    readonly _: [_EM] | undefined;
    constructor(method: string);
}

type ProgressToken = number | string;
declare namespace ProgressToken {
    function is(value: any): value is number | string;
}
declare class ProgressType<PR> {
    /**
     * Clients must not use these properties. They are here to ensure correct typing.
     * in TypeScript
     */
    readonly __: [PR, _EM] | undefined;
    readonly _pr: PR | undefined;
    constructor();
}
type HandlerResult<R, E> = R | ResponseError<E> | Thenable<R> | Thenable<ResponseError<E>> | Thenable<R | ResponseError<E>>;
interface StarRequestHandler {
    (method: string, params: any[] | object | undefined, token: CancellationToken): HandlerResult<any, any>;
}
interface GenericRequestHandler<R, E> {
    (...params: any[]): HandlerResult<R, E>;
}
interface RequestHandler0<R, E> {
    (token: CancellationToken): HandlerResult<R, E>;
}
interface RequestHandler<P, R, E> {
    (params: P, token: CancellationToken): HandlerResult<R, E>;
}
interface StarNotificationHandler {
    (method: string, params: any[] | object | undefined): void;
}
interface GenericNotificationHandler {
    (...params: any[]): void;
}
interface NotificationHandler0 {
    (): void;
}
interface NotificationHandler<P> {
    (params: P): void;
}
interface NotificationHandler1<P1> {
    (p1: P1): void;
}
declare namespace TraceValues {
    /**
     * Turn tracing off.
     */
    const Off: 'off';
    /**
     * Trace messages only.
     */
    const Messages: 'messages';
    /**
     * Compact message tracing.
     */
    const Compact: 'compact';
    /**
     * Verbose message tracing.
     */
    const Verbose: 'verbose';
}
type TraceValues = 'off' | 'messages' | 'compact' | 'verbose';

declare class RegistrationType<RO> {
    /**
     * Clients must not use this property. It is here to ensure correct typing.
     */
    readonly ____: [RO, _EM] | undefined;
    readonly method: string;
    constructor(method: string);
}
declare class ProtocolRequestType0<R, PR, E, RO> extends RequestType0<R, E> implements ProgressType<PR>, RegistrationType<RO> {
    /**
     * Clients must not use these properties. They are here to ensure correct typing.
     * in TypeScript
     */
    readonly __: [PR, _EM] | undefined;
    readonly ___: [PR, RO, _EM] | undefined;
    readonly ____: [RO, _EM] | undefined;
    readonly _pr: PR | undefined;
    constructor(method: string);
}
declare class ProtocolRequestType<P, R, PR, E, RO> extends RequestType<P, R, E> implements ProgressType<PR>, RegistrationType<RO> {
    /**
     * Clients must not use this property. It is here to ensure correct typing.
     */
    readonly __: [PR, _EM] | undefined;
    readonly ___: [PR, RO, _EM] | undefined;
    readonly ____: [RO, _EM] | undefined;
    readonly _pr: PR | undefined;
    constructor(method: string);
}
declare class ProtocolNotificationType0<RO> extends NotificationType0 implements RegistrationType<RO> {
    /**
     * Clients must not use this property. It is here to ensure correct typing.
     */
    readonly ___: [RO, _EM] | undefined;
    readonly ____: [RO, _EM] | undefined;
    constructor(method: string);
}
declare class ProtocolNotificationType<P, RO> extends NotificationType<P> implements RegistrationType<RO> {
    /**
     * Clients must not use this property. It is here to ensure correct typing.
     */
    readonly ___: [RO, _EM] | undefined;
    readonly ____: [RO, _EM] | undefined;
    constructor(method: string);
}

/**
 * @since 3.6.0
 */
interface ImplementationClientCapabilities {
    /**
     * Whether implementation supports dynamic registration. If this is set to `true`
     * the client supports the new `ImplementationRegistrationOptions` return value
     * for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
    /**
     * The client supports additional metadata in the form of definition links.
     *
     * @since 3.14.0
     */
    linkSupport?: boolean;
}
interface ImplementationOptions extends WorkDoneProgressOptions {
}
interface ImplementationRegistrationOptions extends TextDocumentRegistrationOptions, ImplementationOptions, StaticRegistrationOptions {
}
interface ImplementationParams extends TextDocumentPositionParams, WorkDoneProgressParams, PartialResultParams {
}

/**
 * Since 3.6.0
 */
interface TypeDefinitionClientCapabilities {
    /**
     * Whether implementation supports dynamic registration. If this is set to `true`
     * the client supports the new `TypeDefinitionRegistrationOptions` return value
     * for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
    /**
     * The client supports additional metadata in the form of definition links.
     *
     * Since 3.14.0
     */
    linkSupport?: boolean;
}
interface TypeDefinitionOptions extends WorkDoneProgressOptions {
}
interface TypeDefinitionRegistrationOptions extends TextDocumentRegistrationOptions, TypeDefinitionOptions, StaticRegistrationOptions {
}
interface TypeDefinitionParams extends TextDocumentPositionParams, WorkDoneProgressParams, PartialResultParams {
}

interface WorkspaceFoldersInitializeParams {
    /**
     * The workspace folders configured in the client when the server starts.
     *
     * This property is only available if the client supports workspace folders.
     * It can be `null` if the client supports workspace folders but none are
     * configured.
     *
     * @since 3.6.0
     */
    workspaceFolders?: WorkspaceFolder[] | null;
}
interface WorkspaceFoldersServerCapabilities {
    /**
     * The server has support for workspace folders
     */
    supported?: boolean;
    /**
     * Whether the server wants to receive workspace folder
     * change notifications.
     *
     * If a string is provided the string is treated as an ID
     * under which the notification is registered on the client
     * side. The ID can be used to unregister for these events
     * using the `client/unregisterCapability` request.
     */
    changeNotifications?: string | boolean;
}
/**
 * The workspace folder change event.
 */
interface WorkspaceFoldersChangeEvent {
    /**
     * The array of added workspace folders
     */
    added: WorkspaceFolder[];
    /**
     * The array of the removed workspace folders
     */
    removed: WorkspaceFolder[];
}

interface ConfigurationItem {
    /**
     * The scope to get the configuration section for.
     */
    scopeUri?: URI$1;
    /**
     * The configuration section asked for.
     */
    section?: string;
}

interface DocumentColorClientCapabilities {
    /**
     * Whether implementation supports dynamic registration. If this is set to `true`
     * the client supports the new `DocumentColorRegistrationOptions` return value
     * for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
}
interface DocumentColorOptions extends WorkDoneProgressOptions {
}
interface DocumentColorRegistrationOptions extends TextDocumentRegistrationOptions, StaticRegistrationOptions, DocumentColorOptions {
}
/**
 * Parameters for a {@link DocumentColorRequest}.
 */
interface DocumentColorParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
}
/**
 * Parameters for a {@link ColorPresentationRequest}.
 */
interface ColorPresentationParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The color to request presentations for.
     */
    color: Color;
    /**
     * The range where the color would be inserted. Serves as a context.
     */
    range: Range$1;
}

interface FoldingRangeClientCapabilities {
    /**
     * Whether implementation supports dynamic registration for folding range
     * providers. If this is set to `true` the client supports the new
     * `FoldingRangeRegistrationOptions` return value for the corresponding
     * server capability as well.
     */
    dynamicRegistration?: boolean;
    /**
     * The maximum number of folding ranges that the client prefers to receive
     * per document. The value serves as a hint, servers are free to follow the
     * limit.
     */
    rangeLimit?: uinteger;
    /**
     * If set, the client signals that it only supports folding complete lines.
     * If set, client will ignore specified `startCharacter` and `endCharacter`
     * properties in a FoldingRange.
     */
    lineFoldingOnly?: boolean;
    /**
     * Specific options for the folding range kind.
     *
     * @since 3.17.0
     */
    foldingRangeKind?: {
        /**
         * The folding range kind values the client supports. When this
         * property exists the client also guarantees that it will
         * handle values outside its set gracefully and falls back
         * to a default value when unknown.
         */
        valueSet?: FoldingRangeKind[];
    };
    /**
     * Specific options for the folding range.
     *
     * @since 3.17.0
     */
    foldingRange?: {
        /**
        * If set, the client signals that it supports setting collapsedText on
        * folding ranges to display custom labels instead of the default text.
        *
        * @since 3.17.0
        */
        collapsedText?: boolean;
    };
}
/**
 * Client workspace capabilities specific to folding ranges
 *
 * @since 3.18.0
 * @proposed
 */
interface FoldingRangeWorkspaceClientCapabilities {
    /**
     * Whether the client implementation supports a refresh request sent from the
     * server to the client.
     *
     * Note that this event is global and will force the client to refresh all
     * folding ranges currently shown. It should be used with absolute care and is
     * useful for situation where a server for example detects a project wide
     * change that requires such a calculation.
     *
     * @since 3.18.0
     * @proposed
     */
    refreshSupport?: boolean;
}
interface FoldingRangeOptions extends WorkDoneProgressOptions {
}
interface FoldingRangeRegistrationOptions extends TextDocumentRegistrationOptions, FoldingRangeOptions, StaticRegistrationOptions {
}
/**
 * Parameters for a {@link FoldingRangeRequest}.
 */
interface FoldingRangeParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
}

/**
 * @since 3.14.0
 */
interface DeclarationClientCapabilities {
    /**
     * Whether declaration supports dynamic registration. If this is set to `true`
     * the client supports the new `DeclarationRegistrationOptions` return value
     * for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
    /**
     * The client supports additional metadata in the form of declaration links.
     */
    linkSupport?: boolean;
}
interface DeclarationOptions extends WorkDoneProgressOptions {
}
interface DeclarationRegistrationOptions extends DeclarationOptions, TextDocumentRegistrationOptions, StaticRegistrationOptions {
}
interface DeclarationParams extends TextDocumentPositionParams, WorkDoneProgressParams, PartialResultParams {
}

interface SelectionRangeClientCapabilities {
    /**
     * Whether implementation supports dynamic registration for selection range providers. If this is set to `true`
     * the client supports the new `SelectionRangeRegistrationOptions` return value for the corresponding server
     * capability as well.
     */
    dynamicRegistration?: boolean;
}
interface SelectionRangeOptions extends WorkDoneProgressOptions {
}
interface SelectionRangeRegistrationOptions extends SelectionRangeOptions, TextDocumentRegistrationOptions, StaticRegistrationOptions {
}
/**
 * A parameter literal used in selection range requests.
 */
interface SelectionRangeParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The positions inside the text document.
     */
    positions: Position$2[];
}

/**
 * @since 3.16.0
 */
interface CallHierarchyClientCapabilities {
    /**
     * Whether implementation supports dynamic registration. If this is set to `true`
     * the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
     * return value for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
}
/**
 * Call hierarchy options used during static registration.
 *
 * @since 3.16.0
 */
interface CallHierarchyOptions extends WorkDoneProgressOptions {
}
/**
 * Call hierarchy options used during static or dynamic registration.
 *
 * @since 3.16.0
 */
interface CallHierarchyRegistrationOptions extends TextDocumentRegistrationOptions, CallHierarchyOptions, StaticRegistrationOptions {
}
/**
 * The parameter of a `textDocument/prepareCallHierarchy` request.
 *
 * @since 3.16.0
 */
interface CallHierarchyPrepareParams extends TextDocumentPositionParams, WorkDoneProgressParams {
}
/**
 * The parameter of a `callHierarchy/incomingCalls` request.
 *
 * @since 3.16.0
 */
interface CallHierarchyIncomingCallsParams extends WorkDoneProgressParams, PartialResultParams {
    item: CallHierarchyItem;
}
/**
 * The parameter of a `callHierarchy/outgoingCalls` request.
 *
 * @since 3.16.0
 */
interface CallHierarchyOutgoingCallsParams extends WorkDoneProgressParams, PartialResultParams {
    item: CallHierarchyItem;
}

/**
 * @since 3.16.0
 */
interface SemanticTokensPartialResult {
    data: uinteger[];
}
/**
 * @since 3.16.0
 */
interface SemanticTokensDeltaPartialResult {
    edits: SemanticTokensEdit[];
}
declare namespace TokenFormat {
    const Relative: 'relative';
}
type TokenFormat = 'relative';
/**
 * @since 3.16.0
 */
interface SemanticTokensClientCapabilities {
    /**
     * Whether implementation supports dynamic registration. If this is set to `true`
     * the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
     * return value for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
    /**
     * Which requests the client supports and might send to the server
     * depending on the server's capability. Please note that clients might not
     * show semantic tokens or degrade some of the user experience if a range
     * or full request is advertised by the client but not provided by the
     * server. If for example the client capability `requests.full` and
     * `request.range` are both set to true but the server only provides a
     * range provider the client might not render a minimap correctly or might
     * even decide to not show any semantic tokens at all.
     */
    requests: {
        /**
         * The client will send the `textDocument/semanticTokens/range` request if
         * the server provides a corresponding handler.
         */
        range?: boolean | {};
        /**
         * The client will send the `textDocument/semanticTokens/full` request if
         * the server provides a corresponding handler.
         */
        full?: boolean | {
            /**
             * The client will send the `textDocument/semanticTokens/full/delta` request if
             * the server provides a corresponding handler.
             */
            delta?: boolean;
        };
    };
    /**
     * The token types that the client supports.
     */
    tokenTypes: string[];
    /**
     * The token modifiers that the client supports.
     */
    tokenModifiers: string[];
    /**
     * The token formats the clients supports.
     */
    formats: TokenFormat[];
    /**
     * Whether the client supports tokens that can overlap each other.
     */
    overlappingTokenSupport?: boolean;
    /**
     * Whether the client supports tokens that can span multiple lines.
     */
    multilineTokenSupport?: boolean;
    /**
     * Whether the client allows the server to actively cancel a
     * semantic token request, e.g. supports returning
     * LSPErrorCodes.ServerCancelled. If a server does the client
     * needs to retrigger the request.
     *
     * @since 3.17.0
     */
    serverCancelSupport?: boolean;
    /**
     * Whether the client uses semantic tokens to augment existing
     * syntax tokens. If set to `true` client side created syntax
     * tokens and semantic tokens are both used for colorization. If
     * set to `false` the client only uses the returned semantic tokens
     * for colorization.
     *
     * If the value is `undefined` then the client behavior is not
     * specified.
     *
     * @since 3.17.0
     */
    augmentsSyntaxTokens?: boolean;
}
/**
 * @since 3.16.0
 */
interface SemanticTokensOptions extends WorkDoneProgressOptions {
    /**
     * The legend used by the server
     */
    legend: SemanticTokensLegend;
    /**
     * Server supports providing semantic tokens for a specific range
     * of a document.
     */
    range?: boolean | {};
    /**
     * Server supports providing semantic tokens for a full document.
     */
    full?: boolean | {
        /**
         * The server supports deltas for full documents.
         */
        delta?: boolean;
    };
}
/**
 * @since 3.16.0
 */
interface SemanticTokensRegistrationOptions extends TextDocumentRegistrationOptions, SemanticTokensOptions, StaticRegistrationOptions {
}
/**
 * @since 3.16.0
 */
interface SemanticTokensParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
}
/**
 * @since 3.16.0
 */
interface SemanticTokensDeltaParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The result id of a previous response. The result Id can either point to a full response
     * or a delta response depending on what was received last.
     */
    previousResultId: string;
}
/**
 * @since 3.16.0
 */
interface SemanticTokensRangeParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The range the semantic tokens are requested for.
     */
    range: Range$1;
}
/**
 * @since 3.16.0
 */
interface SemanticTokensWorkspaceClientCapabilities {
    /**
     * Whether the client implementation supports a refresh request sent from
     * the server to the client.
     *
     * Note that this event is global and will force the client to refresh all
     * semantic tokens currently shown. It should be used with absolute care
     * and is useful for situation where a server for example detects a project
     * wide change that requires such a calculation.
     */
    refreshSupport?: boolean;
}

/**
 * Client capabilities for the showDocument request.
 *
 * @since 3.16.0
 */
interface ShowDocumentClientCapabilities {
    /**
     * The client has support for the showDocument
     * request.
     */
    support: boolean;
}
/**
 * Params to show a resource in the UI.
 *
 * @since 3.16.0
 */
interface ShowDocumentParams {
    /**
     * The uri to show.
     */
    uri: URI$1;
    /**
     * Indicates to show the resource in an external program.
     * To show, for example, `https://code.visualstudio.com/`
     * in the default WEB browser set `external` to `true`.
     */
    external?: boolean;
    /**
     * An optional property to indicate whether the editor
     * showing the document should take focus or not.
     * Clients might ignore this property if an external
     * program is started.
     */
    takeFocus?: boolean;
    /**
     * An optional selection range if the document is a text
     * document. Clients might ignore the property if an
     * external program is started or the file is not a text
     * file.
     */
    selection?: Range$1;
}
/**
 * The result of a showDocument request.
 *
 * @since 3.16.0
 */
interface ShowDocumentResult {
    /**
     * A boolean indicating if the show was successful.
     */
    success: boolean;
}

/**
 * Client capabilities for the linked editing range request.
 *
 * @since 3.16.0
 */
interface LinkedEditingRangeClientCapabilities {
    /**
     * Whether implementation supports dynamic registration. If this is set to `true`
     * the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
     * return value for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
}
interface LinkedEditingRangeParams extends TextDocumentPositionParams, WorkDoneProgressParams {
}
interface LinkedEditingRangeOptions extends WorkDoneProgressOptions {
}
interface LinkedEditingRangeRegistrationOptions extends TextDocumentRegistrationOptions, LinkedEditingRangeOptions, StaticRegistrationOptions {
}
/**
 * The result of a linked editing range request.
 *
 * @since 3.16.0
 */
interface LinkedEditingRanges {
    /**
     * A list of ranges that can be edited together. The ranges must have
     * identical length and contain identical text content. The ranges cannot overlap.
     */
    ranges: Range$1[];
    /**
     * An optional word pattern (regular expression) that describes valid contents for
     * the given ranges. If no pattern is provided, the client configuration's word
     * pattern will be used.
     */
    wordPattern?: string;
}

/**
 * Options for notifications/requests for user operations on files.
 *
 * @since 3.16.0
 */
interface FileOperationOptions {
    /**
    * The server is interested in receiving didCreateFiles notifications.
    */
    didCreate?: FileOperationRegistrationOptions;
    /**
    * The server is interested in receiving willCreateFiles requests.
    */
    willCreate?: FileOperationRegistrationOptions;
    /**
    * The server is interested in receiving didRenameFiles notifications.
    */
    didRename?: FileOperationRegistrationOptions;
    /**
    * The server is interested in receiving willRenameFiles requests.
    */
    willRename?: FileOperationRegistrationOptions;
    /**
    * The server is interested in receiving didDeleteFiles file notifications.
    */
    didDelete?: FileOperationRegistrationOptions;
    /**
    * The server is interested in receiving willDeleteFiles file requests.
    */
    willDelete?: FileOperationRegistrationOptions;
}
/**
 * The options to register for file operations.
 *
 * @since 3.16.0
 */
interface FileOperationRegistrationOptions {
    /**
     * The actual filters.
     */
    filters: FileOperationFilter[];
}
/**
 * A pattern kind describing if a glob pattern matches a file a folder or
 * both.
 *
 * @since 3.16.0
 */
declare namespace FileOperationPatternKind {
    /**
     * The pattern matches a file only.
     */
    const file: 'file';
    /**
     * The pattern matches a folder only.
     */
    const folder: 'folder';
}
type FileOperationPatternKind = 'file' | 'folder';
/**
 * Matching options for the file operation pattern.
 *
 * @since 3.16.0
 */
interface FileOperationPatternOptions {
    /**
     * The pattern should be matched ignoring casing.
     */
    ignoreCase?: boolean;
}
/**
 * A pattern to describe in which file operation requests or notifications
 * the server is interested in receiving.
 *
 * @since 3.16.0
 */
interface FileOperationPattern {
    /**
     * The glob pattern to match. Glob patterns can have the following syntax:
     * - `*` to match one or more characters in a path segment
     * - `?` to match on one character in a path segment
     * - `**` to match any number of path segments, including none
     * - `{}` to group sub patterns into an OR expression. (e.g. `**​/*.{ts,js}` matches all TypeScript and JavaScript files)
     * - `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, …)
     * - `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)
     */
    glob: string;
    /**
     * Whether to match files or folders with this pattern.
     *
     * Matches both if undefined.
     */
    matches?: FileOperationPatternKind;
    /**
     * Additional options used during matching.
     */
    options?: FileOperationPatternOptions;
}
/**
 * A filter to describe in which file operation requests or notifications
 * the server is interested in receiving.
 *
 * @since 3.16.0
 */
interface FileOperationFilter {
    /**
     * A Uri scheme like `file` or `untitled`.
     */
    scheme?: string;
    /**
     * The actual file operation pattern.
     */
    pattern: FileOperationPattern;
}
/**
 * Capabilities relating to events from file operations by the user in the client.
 *
 * These events do not come from the file system, they come from user operations
 * like renaming a file in the UI.
 *
 * @since 3.16.0
 */
interface FileOperationClientCapabilities {
    /**
     * Whether the client supports dynamic registration for file requests/notifications.
     */
    dynamicRegistration?: boolean;
    /**
     * The client has support for sending didCreateFiles notifications.
     */
    didCreate?: boolean;
    /**
     * The client has support for sending willCreateFiles requests.
     */
    willCreate?: boolean;
    /**
     * The client has support for sending didRenameFiles notifications.
     */
    didRename?: boolean;
    /**
     * The client has support for sending willRenameFiles requests.
     */
    willRename?: boolean;
    /**
     * The client has support for sending didDeleteFiles notifications.
     */
    didDelete?: boolean;
    /**
     * The client has support for sending willDeleteFiles requests.
     */
    willDelete?: boolean;
}
/**
 * The parameters sent in notifications/requests for user-initiated creation of
 * files.
 *
 * @since 3.16.0
 */
interface CreateFilesParams {
    /**
     * An array of all files/folders created in this operation.
     */
    files: FileCreate[];
}
/**
 * Represents information on a file/folder create.
 *
 * @since 3.16.0
 */
interface FileCreate {
    /**
     * A file:// URI for the location of the file/folder being created.
     */
    uri: string;
}
/**
 * The parameters sent in notifications/requests for user-initiated renames of
 * files.
 *
 * @since 3.16.0
 */
interface RenameFilesParams {
    /**
     * An array of all files/folders renamed in this operation. When a folder is renamed, only
     * the folder will be included, and not its children.
     */
    files: FileRename[];
}
/**
 * Represents information on a file/folder rename.
 *
 * @since 3.16.0
 */
interface FileRename {
    /**
     * A file:// URI for the original location of the file/folder being renamed.
     */
    oldUri: string;
    /**
     * A file:// URI for the new location of the file/folder being renamed.
     */
    newUri: string;
}
/**
 * The parameters sent in notifications/requests for user-initiated deletes of
 * files.
 *
 * @since 3.16.0
 */
interface DeleteFilesParams {
    /**
     * An array of all files/folders deleted in this operation.
     */
    files: FileDelete[];
}
/**
 * Represents information on a file/folder delete.
 *
 * @since 3.16.0
 */
interface FileDelete {
    /**
     * A file:// URI for the location of the file/folder being deleted.
     */
    uri: string;
}

/**
 * Moniker uniqueness level to define scope of the moniker.
 *
 * @since 3.16.0
 */
declare namespace UniquenessLevel {
    /**
     * The moniker is only unique inside a document
     */
    const document = "document";
    /**
     * The moniker is unique inside a project for which a dump got created
     */
    const project = "project";
    /**
     * The moniker is unique inside the group to which a project belongs
     */
    const group = "group";
    /**
     * The moniker is unique inside the moniker scheme.
     */
    const scheme = "scheme";
    /**
     * The moniker is globally unique
     */
    const global = "global";
}
type UniquenessLevel = 'document' | 'project' | 'group' | 'scheme' | 'global';
/**
 * The moniker kind.
 *
 * @since 3.16.0
 */
declare namespace MonikerKind {
    /**
     * The moniker represent a symbol that is imported into a project
     */
    const $import = "import";
    /**
     * The moniker represents a symbol that is exported from a project
     */
    const $export = "export";
    /**
     * The moniker represents a symbol that is local to a project (e.g. a local
     * variable of a function, a class not visible outside the project, ...)
     */
    const local = "local";
}
type MonikerKind = 'import' | 'export' | 'local';
/**
 * Moniker definition to match LSIF 0.5 moniker definition.
 *
 * @since 3.16.0
 */
interface Moniker {
    /**
     * The scheme of the moniker. For example tsc or .Net
     */
    scheme: string;
    /**
     * The identifier of the moniker. The value is opaque in LSIF however
     * schema owners are allowed to define the structure if they want.
     */
    identifier: string;
    /**
     * The scope in which the moniker is unique
     */
    unique: UniquenessLevel;
    /**
     * The moniker kind if known.
     */
    kind?: MonikerKind;
}
/**
 * Client capabilities specific to the moniker request.
 *
 * @since 3.16.0
 */
interface MonikerClientCapabilities {
    /**
     * Whether moniker supports dynamic registration. If this is set to `true`
     * the client supports the new `MonikerRegistrationOptions` return value
     * for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
}
interface MonikerOptions extends WorkDoneProgressOptions {
}
interface MonikerRegistrationOptions extends TextDocumentRegistrationOptions, MonikerOptions {
}
interface MonikerParams extends TextDocumentPositionParams, WorkDoneProgressParams, PartialResultParams {
}

/**
 * @since 3.17.0
 */
type TypeHierarchyClientCapabilities = {
    /**
     * Whether implementation supports dynamic registration. If this is set to `true`
     * the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
     * return value for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
};
/**
 * Type hierarchy options used during static registration.
 *
 * @since 3.17.0
 */
type TypeHierarchyOptions = WorkDoneProgressOptions;
/**
 * Type hierarchy options used during static or dynamic registration.
 *
 * @since 3.17.0
 */
type TypeHierarchyRegistrationOptions = TextDocumentRegistrationOptions & TypeHierarchyOptions & StaticRegistrationOptions;
/**
 * The parameter of a `textDocument/prepareTypeHierarchy` request.
 *
 * @since 3.17.0
 */
type TypeHierarchyPrepareParams = TextDocumentPositionParams & WorkDoneProgressParams;
/**
 * The parameter of a `typeHierarchy/supertypes` request.
 *
 * @since 3.17.0
 */
type TypeHierarchySupertypesParams = WorkDoneProgressParams & PartialResultParams & {
    item: TypeHierarchyItem;
};
/**
 * The parameter of a `typeHierarchy/subtypes` request.
 *
 * @since 3.17.0
 */
type TypeHierarchySubtypesParams = WorkDoneProgressParams & PartialResultParams & {
    item: TypeHierarchyItem;
};

/**
 * Client capabilities specific to inline values.
 *
 * @since 3.17.0
 */
type InlineValueClientCapabilities = {
    /**
     * Whether implementation supports dynamic registration for inline value providers.
     */
    dynamicRegistration?: boolean;
};
/**
 * Client workspace capabilities specific to inline values.
 *
 * @since 3.17.0
 */
type InlineValueWorkspaceClientCapabilities = {
    /**
     * Whether the client implementation supports a refresh request sent from the
     * server to the client.
     *
     * Note that this event is global and will force the client to refresh all
     * inline values currently shown. It should be used with absolute care and is
     * useful for situation where a server for example detects a project wide
     * change that requires such a calculation.
     */
    refreshSupport?: boolean;
};
/**
 * Inline value options used during static registration.
 *
 * @since 3.17.0
 */
type InlineValueOptions = WorkDoneProgressOptions;
/**
 * Inline value options used during static or dynamic registration.
 *
 * @since 3.17.0
 */
type InlineValueRegistrationOptions = InlineValueOptions & TextDocumentRegistrationOptions & StaticRegistrationOptions;
/**
 * A parameter literal used in inline value requests.
 *
 * @since 3.17.0
 */
type InlineValueParams = WorkDoneProgressParams & {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The document range for which inline values should be computed.
     */
    range: Range$1;
    /**
     * Additional information about the context in which inline values were
     * requested.
     */
    context: InlineValueContext;
};

/**
 * Inlay hint client capabilities.
 *
 * @since 3.17.0
 */
type InlayHintClientCapabilities = {
    /**
     * Whether inlay hints support dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * Indicates which properties a client can resolve lazily on an inlay
     * hint.
     */
    resolveSupport?: {
        /**
         * The properties that a client can resolve lazily.
         */
        properties: string[];
    };
};
/**
 * Client workspace capabilities specific to inlay hints.
 *
 * @since 3.17.0
 */
type InlayHintWorkspaceClientCapabilities = {
    /**
     * Whether the client implementation supports a refresh request sent from
     * the server to the client.
     *
     * Note that this event is global and will force the client to refresh all
     * inlay hints currently shown. It should be used with absolute care and
     * is useful for situation where a server for example detects a project wide
     * change that requires such a calculation.
     */
    refreshSupport?: boolean;
};
/**
 * Inlay hint options used during static registration.
 *
 * @since 3.17.0
 */
type InlayHintOptions = WorkDoneProgressOptions & {
    /**
     * The server provides support to resolve additional
     * information for an inlay hint item.
     */
    resolveProvider?: boolean;
};
/**
 * Inlay hint options used during static or dynamic registration.
 *
 * @since 3.17.0
 */
type InlayHintRegistrationOptions = InlayHintOptions & TextDocumentRegistrationOptions & StaticRegistrationOptions;
/**
 * A parameter literal used in inlay hint requests.
 *
 * @since 3.17.0
 */
type InlayHintParams = WorkDoneProgressParams & {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The document range for which inlay hints should be computed.
     */
    range: Range$1;
};

/**
 * Client capabilities specific to diagnostic pull requests.
 *
 * @since 3.17.0
 */
type DiagnosticClientCapabilities = {
    /**
     * Whether implementation supports dynamic registration. If this is set to `true`
     * the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
     * return value for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
    /**
     * Whether the clients supports related documents for document diagnostic pulls.
     */
    relatedDocumentSupport?: boolean;
};
/**
 * Workspace client capabilities specific to diagnostic pull requests.
 *
 * @since 3.17.0
 */
type DiagnosticWorkspaceClientCapabilities = {
    /**
     * Whether the client implementation supports a refresh request sent from
     * the server to the client.
     *
     * Note that this event is global and will force the client to refresh all
     * pulled diagnostics currently shown. It should be used with absolute care and
     * is useful for situation where a server for example detects a project wide
     * change that requires such a calculation.
     */
    refreshSupport?: boolean;
};
/**
 * Diagnostic options.
 *
 * @since 3.17.0
 */
type DiagnosticOptions = WorkDoneProgressOptions & {
    /**
     * An optional identifier under which the diagnostics are
     * managed by the client.
     */
    identifier?: string;
    /**
     * Whether the language has inter file dependencies meaning that
     * editing code in one file can result in a different diagnostic
     * set in another file. Inter file dependencies are common for
     * most programming languages and typically uncommon for linters.
     */
    interFileDependencies: boolean;
    /**
     * The server provides support for workspace diagnostics as well.
     */
    workspaceDiagnostics: boolean;
};
/**
 * Diagnostic registration options.
 *
 * @since 3.17.0
 */
type DiagnosticRegistrationOptions = TextDocumentRegistrationOptions & DiagnosticOptions & StaticRegistrationOptions;
/**
 * Cancellation data returned from a diagnostic request.
 *
 * @since 3.17.0
 */
type DiagnosticServerCancellationData = {
    retriggerRequest: boolean;
};
/**
 * @since 3.17.0
 */
declare namespace DiagnosticServerCancellationData {
    function is(value: any): value is DiagnosticServerCancellationData;
}
/**
 * Parameters of the document diagnostic request.
 *
 * @since 3.17.0
 */
type DocumentDiagnosticParams = WorkDoneProgressParams & PartialResultParams & {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The additional identifier  provided during registration.
     */
    identifier?: string;
    /**
     * The result id of a previous response if provided.
     */
    previousResultId?: string;
};
/**
 * The document diagnostic report kinds.
 *
 * @since 3.17.0
 */
declare namespace DocumentDiagnosticReportKind {
    /**
     * A diagnostic report with a full
     * set of problems.
     */
    const Full = "full";
    /**
     * A report indicating that the last
     * returned report is still accurate.
     */
    const Unchanged = "unchanged";
}
type DocumentDiagnosticReportKind = 'full' | 'unchanged';
/**
 * A diagnostic report with a full set of problems.
 *
 * @since 3.17.0
 */
type FullDocumentDiagnosticReport = {
    /**
     * A full document diagnostic report.
     */
    kind: typeof DocumentDiagnosticReportKind.Full;
    /**
     * An optional result id. If provided it will
     * be sent on the next diagnostic request for the
     * same document.
     */
    resultId?: string;
    /**
     * The actual items.
     */
    items: Diagnostic[];
};
/**
 * A full diagnostic report with a set of related documents.
 *
 * @since 3.17.0
 */
type RelatedFullDocumentDiagnosticReport = FullDocumentDiagnosticReport & {
    /**
     * Diagnostics of related documents. This information is useful
     * in programming languages where code in a file A can generate
     * diagnostics in a file B which A depends on. An example of
     * such a language is C/C++ where marco definitions in a file
     * a.cpp and result in errors in a header file b.hpp.
     *
     * @since 3.17.0
     */
    relatedDocuments?: {
        [uri: DocumentUri]: FullDocumentDiagnosticReport | UnchangedDocumentDiagnosticReport;
    };
};
/**
 * A diagnostic report indicating that the last returned
 * report is still accurate.
 *
 * @since 3.17.0
 */
type UnchangedDocumentDiagnosticReport = {
    /**
     * A document diagnostic report indicating
     * no changes to the last result. A server can
     * only return `unchanged` if result ids are
     * provided.
     */
    kind: typeof DocumentDiagnosticReportKind.Unchanged;
    /**
     * A result id which will be sent on the next
     * diagnostic request for the same document.
     */
    resultId: string;
};
/**
 * An unchanged diagnostic report with a set of related documents.
 *
 * @since 3.17.0
 */
type RelatedUnchangedDocumentDiagnosticReport = UnchangedDocumentDiagnosticReport & {
    /**
     * Diagnostics of related documents. This information is useful
     * in programming languages where code in a file A can generate
     * diagnostics in a file B which A depends on. An example of
     * such a language is C/C++ where marco definitions in a file
     * a.cpp and result in errors in a header file b.hpp.
     *
     * @since 3.17.0
     */
    relatedDocuments?: {
        [uri: DocumentUri]: FullDocumentDiagnosticReport | UnchangedDocumentDiagnosticReport;
    };
};
/**
 * The result of a document diagnostic pull request. A report can
 * either be a full report containing all diagnostics for the
 * requested document or an unchanged report indicating that nothing
 * has changed in terms of diagnostics in comparison to the last
 * pull request.
 *
 * @since 3.17.0
 */
type DocumentDiagnosticReport = RelatedFullDocumentDiagnosticReport | RelatedUnchangedDocumentDiagnosticReport;
/**
 * A partial result for a document diagnostic report.
 *
 * @since 3.17.0
 */
type DocumentDiagnosticReportPartialResult = {
    relatedDocuments: {
        [uri: DocumentUri]: FullDocumentDiagnosticReport | UnchangedDocumentDiagnosticReport;
    };
};
/**
 * A previous result id in a workspace pull request.
 *
 * @since 3.17.0
 */
type PreviousResultId = {
    /**
     * The URI for which the client knowns a
     * result id.
     */
    uri: DocumentUri$1;
    /**
     * The value of the previous result id.
     */
    value: string;
};
/**
 * Parameters of the workspace diagnostic request.
 *
 * @since 3.17.0
 */
type WorkspaceDiagnosticParams = WorkDoneProgressParams & PartialResultParams & {
    /**
     * The additional identifier provided during registration.
     */
    identifier?: string;
    /**
     * The currently known diagnostic reports with their
     * previous result ids.
     */
    previousResultIds: PreviousResultId[];
};
/**
 * A full document diagnostic report for a workspace diagnostic result.
 *
 * @since 3.17.0
 */
type WorkspaceFullDocumentDiagnosticReport = FullDocumentDiagnosticReport & {
    /**
     * The URI for which diagnostic information is reported.
     */
    uri: DocumentUri$1;
    /**
     * The version number for which the diagnostics are reported.
     * If the document is not marked as open `null` can be provided.
     */
    version: integer | null;
};
/**
 * An unchanged document diagnostic report for a workspace diagnostic result.
 *
 * @since 3.17.0
 */
type WorkspaceUnchangedDocumentDiagnosticReport = UnchangedDocumentDiagnosticReport & {
    /**
     * The URI for which diagnostic information is reported.
     */
    uri: DocumentUri$1;
    /**
     * The version number for which the diagnostics are reported.
     * If the document is not marked as open `null` can be provided.
     */
    version: integer | null;
};
/**
 * A workspace diagnostic document report.
 *
 * @since 3.17.0
 */
type WorkspaceDocumentDiagnosticReport = WorkspaceFullDocumentDiagnosticReport | WorkspaceUnchangedDocumentDiagnosticReport;
/**
 * A workspace diagnostic report.
 *
 * @since 3.17.0
 */
type WorkspaceDiagnosticReport = {
    items: WorkspaceDocumentDiagnosticReport[];
};
/**
 * A partial result for a workspace diagnostic report.
 *
 * @since 3.17.0
 */
type WorkspaceDiagnosticReportPartialResult = {
    items: WorkspaceDocumentDiagnosticReport[];
};

/**
 * Notebook specific client capabilities.
 *
 * @since 3.17.0
 */
type NotebookDocumentSyncClientCapabilities = {
    /**
     * Whether implementation supports dynamic registration. If this is
     * set to `true` the client supports the new
     * `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
     * return value for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
    /**
     * The client supports sending execution summary data per cell.
     */
    executionSummarySupport?: boolean;
};
/**
 * A notebook cell kind.
 *
 * @since 3.17.0
 */
declare namespace NotebookCellKind {
    /**
     * A markup-cell is formatted source that is used for display.
     */
    const Markup: 1;
    /**
     * A code-cell is source code.
     */
    const Code: 2;
    function is(value: any): value is NotebookCellKind;
}
type NotebookCellKind = 1 | 2;
type ExecutionSummary = {
    /**
     * A strict monotonically increasing value
     * indicating the execution order of a cell
     * inside a notebook.
     */
    executionOrder: uinteger;
    /**
     * Whether the execution was successful or
     * not if known by the client.
     */
    success?: boolean;
};
declare namespace ExecutionSummary {
    function create(executionOrder: number, success?: boolean): ExecutionSummary;
    function is(value: any): value is ExecutionSummary;
    function equals(one: ExecutionSummary | undefined, other: ExecutionSummary | undefined): boolean;
}
/**
 * A notebook cell.
 *
 * A cell's document URI must be unique across ALL notebook
 * cells and can therefore be used to uniquely identify a
 * notebook cell or the cell's text document.
 *
 * @since 3.17.0
 */
type NotebookCell = {
    /**
     * The cell's kind
     */
    kind: NotebookCellKind;
    /**
     * The URI of the cell's text document
     * content.
     */
    document: DocumentUri$1;
    /**
     * Additional metadata stored with the cell.
     *
     * Note: should always be an object literal (e.g. LSPObject)
     */
    metadata?: LSPObject;
    /**
     * Additional execution summary information
     * if supported by the client.
     */
    executionSummary?: ExecutionSummary;
};
declare namespace NotebookCell {
    function create(kind: NotebookCellKind, document: DocumentUri$1): NotebookCell;
    function is(value: any): value is NotebookCell;
    function diff(one: NotebookCell, two: NotebookCell): Set<keyof NotebookCell>;
}
/**
 * A notebook document.
 *
 * @since 3.17.0
 */
type NotebookDocument = {
    /**
     * The notebook document's uri.
     */
    uri: URI$1;
    /**
     * The type of the notebook.
     */
    notebookType: string;
    /**
     * The version number of this document (it will increase after each
     * change, including undo/redo).
     */
    version: integer;
    /**
     * Additional metadata stored with the notebook
     * document.
     *
     * Note: should always be an object literal (e.g. LSPObject)
     */
    metadata?: LSPObject;
    /**
     * The cells of a notebook.
     */
    cells: NotebookCell[];
};
declare namespace NotebookDocument {
    function create(uri: URI$1, notebookType: string, version: integer, cells: NotebookCell[]): NotebookDocument;
    function is(value: any): value is NotebookDocument;
}
/**
 * A literal to identify a notebook document in the client.
 *
 * @since 3.17.0
 */
type NotebookDocumentIdentifier = {
    /**
     * The notebook document's uri.
     */
    uri: URI$1;
};
/**
 * A versioned notebook document identifier.
 *
 * @since 3.17.0
 */
type VersionedNotebookDocumentIdentifier = {
    /**
     * The version number of this notebook document.
     */
    version: integer;
    /**
     * The notebook document's uri.
     */
    uri: URI$1;
};
/**
 * Options specific to a notebook plus its cells
 * to be synced to the server.
 *
 * If a selector provides a notebook document
 * filter but no cell selector all cells of a
 * matching notebook document will be synced.
 *
 * If a selector provides no notebook document
 * filter but only a cell selector all notebook
 * document that contain at least one matching
 * cell will be synced.
 *
 * @since 3.17.0
 */
type NotebookDocumentSyncOptions = {
    /**
     * The notebooks to be synced
     */
    notebookSelector: ({
        /**
         * The notebook to be synced If a string
         * value is provided it matches against the
         * notebook type. '*' matches every notebook.
         */
        notebook: string | NotebookDocumentFilter;
        /**
         * The cells of the matching notebook to be synced.
         */
        cells?: {
            language: string;
        }[];
    } | {
        /**
         * The notebook to be synced If a string
         * value is provided it matches against the
         * notebook type. '*' matches every notebook.
         */
        notebook?: string | NotebookDocumentFilter;
        /**
         * The cells of the matching notebook to be synced.
         */
        cells: {
            language: string;
        }[];
    })[];
    /**
     * Whether save notification should be forwarded to
     * the server. Will only be honored if mode === `notebook`.
     */
    save?: boolean;
};
/**
 * Registration options specific to a notebook.
 *
 * @since 3.17.0
 */
type NotebookDocumentSyncRegistrationOptions = NotebookDocumentSyncOptions & StaticRegistrationOptions;
/**
 * The params sent in an open notebook document notification.
 *
 * @since 3.17.0
 */
type DidOpenNotebookDocumentParams = {
    /**
     * The notebook document that got opened.
     */
    notebookDocument: NotebookDocument;
    /**
     * The text documents that represent the content
     * of a notebook cell.
     */
    cellTextDocuments: TextDocumentItem[];
};
/**
 * A change describing how to move a `NotebookCell`
 * array from state S to S'.
 *
 * @since 3.17.0
 */
type NotebookCellArrayChange = {
    /**
     * The start oftest of the cell that changed.
     */
    start: uinteger;
    /**
     * The deleted cells
     */
    deleteCount: uinteger;
    /**
     * The new cells, if any
     */
    cells?: NotebookCell[];
};
declare namespace NotebookCellArrayChange {
    function is(value: any): value is NotebookCellArrayChange;
    function create(start: uinteger, deleteCount: uinteger, cells?: NotebookCell[]): NotebookCellArrayChange;
}
/**
 * A change event for a notebook document.
 *
 * @since 3.17.0
 */
type NotebookDocumentChangeEvent = {
    /**
     * The changed meta data if any.
     *
     * Note: should always be an object literal (e.g. LSPObject)
     */
    metadata?: LSPObject;
    /**
     * Changes to cells
     */
    cells?: {
        /**
         * Changes to the cell structure to add or
         * remove cells.
         */
        structure?: {
            /**
             * The change to the cell array.
             */
            array: NotebookCellArrayChange;
            /**
             * Additional opened cell text documents.
             */
            didOpen?: TextDocumentItem[];
            /**
             * Additional closed cell text documents.
             */
            didClose?: TextDocumentIdentifier[];
        };
        /**
         * Changes to notebook cells properties like its
         * kind, execution summary or metadata.
         */
        data?: NotebookCell[];
        /**
         * Changes to the text content of notebook cells.
         */
        textContent?: {
            document: VersionedTextDocumentIdentifier;
            changes: TextDocumentContentChangeEvent[];
        }[];
    };
};
/**
 * The params sent in a change notebook document notification.
 *
 * @since 3.17.0
 */
type DidChangeNotebookDocumentParams = {
    /**
     * The notebook document that did change. The version number points
     * to the version after all provided changes have been applied. If
     * only the text document content of a cell changes the notebook version
     * doesn't necessarily have to change.
     */
    notebookDocument: VersionedNotebookDocumentIdentifier;
    /**
     * The actual changes to the notebook document.
     *
     * The changes describe single state changes to the notebook document.
     * So if there are two changes c1 (at array index 0) and c2 (at array
     * index 1) for a notebook in state S then c1 moves the notebook from
     * S to S' and c2 from S' to S''. So c1 is computed on the state S and
     * c2 is computed on the state S'.
     *
     * To mirror the content of a notebook using change events use the following approach:
     * - start with the same initial content
     * - apply the 'notebookDocument/didChange' notifications in the order you receive them.
     * - apply the `NotebookChangeEvent`s in a single notification in the order
     *   you receive them.
     */
    change: NotebookDocumentChangeEvent;
};
/**
 * The params sent in a save notebook document notification.
 *
 * @since 3.17.0
 */
type DidSaveNotebookDocumentParams = {
    /**
     * The notebook document that got saved.
     */
    notebookDocument: NotebookDocumentIdentifier;
};
/**
 * The params sent in a close notebook document notification.
 *
 * @since 3.17.0
 */
type DidCloseNotebookDocumentParams = {
    /**
     * The notebook document that got closed.
     */
    notebookDocument: NotebookDocumentIdentifier;
    /**
     * The text documents that represent the content
     * of a notebook cell that got closed.
     */
    cellTextDocuments: TextDocumentIdentifier[];
};

/**
 * Client capabilities specific to inline completions.
 *
 * @since 3.18.0
 * @proposed
 */
type InlineCompletionClientCapabilities = {
    /**
     * Whether implementation supports dynamic registration for inline completion providers.
     */
    dynamicRegistration?: boolean;
};
/**
 * Inline completion options used during static registration.
 *
 * @since 3.18.0
 * @proposed
 */
type InlineCompletionOptions = WorkDoneProgressOptions;

/**
 * A document filter denotes a document by different properties like
 * the {@link TextDocument.languageId language}, the {@link Uri.scheme scheme} of
 * its resource, or a glob-pattern that is applied to the {@link TextDocument.fileName path}.
 *
 * Glob patterns can have the following syntax:
 * - `*` to match one or more characters in a path segment
 * - `?` to match on one character in a path segment
 * - `**` to match any number of path segments, including none
 * - `{}` to group sub patterns into an OR expression. (e.g. `**​/*.{ts,js}` matches all TypeScript and JavaScript files)
 * - `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, …)
 * - `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)
 *
 * @sample A language filter that applies to typescript files on disk: `{ language: 'typescript', scheme: 'file' }`
 * @sample A language filter that applies to all package.json paths: `{ language: 'json', pattern: '**package.json' }`
 *
 * @since 3.17.0
 */
type TextDocumentFilter = {
    /** A language id, like `typescript`. */
    language: string;
    /** A Uri {@link Uri.scheme scheme}, like `file` or `untitled`. */
    scheme?: string;
    /** A glob pattern, like **​/*.{ts,js}. See TextDocumentFilter for examples. */
    pattern?: string;
} | {
    /** A language id, like `typescript`. */
    language?: string;
    /** A Uri {@link Uri.scheme scheme}, like `file` or `untitled`. */
    scheme: string;
    /** A glob pattern, like **​/*.{ts,js}. See TextDocumentFilter for examples. */
    pattern?: string;
} | {
    /** A language id, like `typescript`. */
    language?: string;
    /** A Uri {@link Uri.scheme scheme}, like `file` or `untitled`. */
    scheme?: string;
    /** A glob pattern, like **​/*.{ts,js}. See TextDocumentFilter for examples. */
    pattern: string;
};
/**
 * The TextDocumentFilter namespace provides helper functions to work with
 * {@link TextDocumentFilter} literals.
 *
 * @since 3.17.0
 */
declare namespace TextDocumentFilter {
    function is(value: any): value is TextDocumentFilter;
}
/**
 * A notebook document filter denotes a notebook document by
 * different properties. The properties will be match
 * against the notebook's URI (same as with documents)
 *
 * @since 3.17.0
 */
type NotebookDocumentFilter = {
    /** The type of the enclosing notebook. */
    notebookType: string;
    /** A Uri {@link Uri.scheme scheme}, like `file` or `untitled`. */
    scheme?: string;
    /** A glob pattern. */
    pattern?: string;
} | {
    /** The type of the enclosing notebook. */
    notebookType?: string;
    /** A Uri {@link Uri.scheme scheme}, like `file` or `untitled`.*/
    scheme: string;
    /** A glob pattern. */
    pattern?: string;
} | {
    /** The type of the enclosing notebook. */
    notebookType?: string;
    /** A Uri {@link Uri.scheme scheme}, like `file` or `untitled`. */
    scheme?: string;
    /** A glob pattern. */
    pattern: string;
};
/**
 * The NotebookDocumentFilter namespace provides helper functions to work with
 * {@link NotebookDocumentFilter} literals.
 *
 * @since 3.17.0
 */
declare namespace NotebookDocumentFilter {
    function is(value: any): value is NotebookDocumentFilter;
}
/**
 * A notebook cell text document filter denotes a cell text
 * document by different properties.
 *
 * @since 3.17.0
 */
type NotebookCellTextDocumentFilter = {
    /**
     * A filter that matches against the notebook
     * containing the notebook cell. If a string
     * value is provided it matches against the
     * notebook type. '*' matches every notebook.
     */
    notebook: string | NotebookDocumentFilter;
    /**
     * A language id like `python`.
     *
     * Will be matched against the language id of the
     * notebook cell document. '*' matches every language.
     */
    language?: string;
};
/**
 * The NotebookCellTextDocumentFilter namespace provides helper functions to work with
 * {@link NotebookCellTextDocumentFilter} literals.
 *
 * @since 3.17.0
 */
declare namespace NotebookCellTextDocumentFilter {
    function is(value: any): value is NotebookCellTextDocumentFilter;
}
/**
 * A document filter describes a top level text document or
 * a notebook cell document.
 *
 * @since 3.17.0 - proposed support for NotebookCellTextDocumentFilter.
 */
type DocumentFilter = TextDocumentFilter | NotebookCellTextDocumentFilter;
/**
 * A document selector is the combination of one or many document filters.
 *
 * @sample `let sel:DocumentSelector = [{ language: 'typescript' }, { language: 'json', pattern: '**∕tsconfig.json' }]`;
 *
 * The use of a string as a document filter is deprecated @since 3.16.0.
 */
type DocumentSelector = (string | DocumentFilter)[];
/**
 * The DocumentSelector namespace provides helper functions to work with
 * {@link DocumentSelector}s.
 */
declare namespace DocumentSelector {
    function is(value: any[] | undefined | null): value is DocumentSelector;
}
interface WorkDoneProgressParams {
    /**
     * An optional token that a server can use to report work done progress.
     */
    workDoneToken?: ProgressToken;
}
interface PartialResultParams {
    /**
     * An optional token that a server can use to report partial results (e.g. streaming) to
     * the client.
     */
    partialResultToken?: ProgressToken;
}
/**
 * A parameter literal used in requests to pass a text document and a position inside that
 * document.
 */
interface TextDocumentPositionParams {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The position inside the text document.
     */
    position: Position$2;
}
/**
 * The kind of resource operations supported by the client.
 */
type ResourceOperationKind = 'create' | 'rename' | 'delete';
declare namespace ResourceOperationKind {
    /**
     * Supports creating new files and folders.
     */
    const Create: ResourceOperationKind;
    /**
     * Supports renaming existing files and folders.
     */
    const Rename: ResourceOperationKind;
    /**
     * Supports deleting existing files and folders.
     */
    const Delete: ResourceOperationKind;
}
type FailureHandlingKind = 'abort' | 'transactional' | 'undo' | 'textOnlyTransactional';
declare namespace FailureHandlingKind {
    /**
     * Applying the workspace change is simply aborted if one of the changes provided
     * fails. All operations executed before the failing operation stay executed.
     */
    const Abort: FailureHandlingKind;
    /**
     * All operations are executed transactional. That means they either all
     * succeed or no changes at all are applied to the workspace.
     */
    const Transactional: FailureHandlingKind;
    /**
     * If the workspace edit contains only textual file changes they are executed transactional.
     * If resource changes (create, rename or delete file) are part of the change the failure
     * handling strategy is abort.
     */
    const TextOnlyTransactional: FailureHandlingKind;
    /**
     * The client tries to undo the operations already executed. But there is no
     * guarantee that this is succeeding.
     */
    const Undo: FailureHandlingKind;
}
/**
 * Workspace specific client capabilities.
 */
interface WorkspaceClientCapabilities {
    /**
     * The client supports applying batch edits
     * to the workspace by supporting the request
     * 'workspace/applyEdit'
     */
    applyEdit?: boolean;
    /**
     * Capabilities specific to `WorkspaceEdit`s.
     */
    workspaceEdit?: WorkspaceEditClientCapabilities;
    /**
     * Capabilities specific to the `workspace/didChangeConfiguration` notification.
     */
    didChangeConfiguration?: DidChangeConfigurationClientCapabilities;
    /**
     * Capabilities specific to the `workspace/didChangeWatchedFiles` notification.
     */
    didChangeWatchedFiles?: DidChangeWatchedFilesClientCapabilities;
    /**
     * Capabilities specific to the `workspace/symbol` request.
     */
    symbol?: WorkspaceSymbolClientCapabilities;
    /**
     * Capabilities specific to the `workspace/executeCommand` request.
     */
    executeCommand?: ExecuteCommandClientCapabilities;
    /**
     * The client has support for workspace folders.
     *
     * @since 3.6.0
     */
    workspaceFolders?: boolean;
    /**
     * The client supports `workspace/configuration` requests.
     *
     * @since 3.6.0
     */
    configuration?: boolean;
    /**
     * Capabilities specific to the semantic token requests scoped to the
     * workspace.
     *
     * @since 3.16.0.
     */
    semanticTokens?: SemanticTokensWorkspaceClientCapabilities;
    /**
     * Capabilities specific to the code lens requests scoped to the
     * workspace.
     *
     * @since 3.16.0.
     */
    codeLens?: CodeLensWorkspaceClientCapabilities;
    /**
     * The client has support for file notifications/requests for user operations on files.
     *
     * Since 3.16.0
     */
    fileOperations?: FileOperationClientCapabilities;
    /**
     * Capabilities specific to the inline values requests scoped to the
     * workspace.
     *
     * @since 3.17.0.
     */
    inlineValue?: InlineValueWorkspaceClientCapabilities;
    /**
     * Capabilities specific to the inlay hint requests scoped to the
     * workspace.
     *
     * @since 3.17.0.
     */
    inlayHint?: InlayHintWorkspaceClientCapabilities;
    /**
     * Capabilities specific to the diagnostic requests scoped to the
     * workspace.
     *
     * @since 3.17.0.
     */
    diagnostics?: DiagnosticWorkspaceClientCapabilities;
    /**
     * Capabilities specific to the folding range requests scoped to the workspace.
     *
     * @since 3.18.0
     * @proposed
     */
    foldingRange?: FoldingRangeWorkspaceClientCapabilities;
}
/**
 * Text document specific client capabilities.
 */
interface TextDocumentClientCapabilities {
    /**
     * Defines which synchronization capabilities the client supports.
     */
    synchronization?: TextDocumentSyncClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/completion` request.
     */
    completion?: CompletionClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/hover` request.
     */
    hover?: HoverClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/signatureHelp` request.
     */
    signatureHelp?: SignatureHelpClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/declaration` request.
     *
     * @since 3.14.0
     */
    declaration?: DeclarationClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/definition` request.
     */
    definition?: DefinitionClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/typeDefinition` request.
     *
     * @since 3.6.0
     */
    typeDefinition?: TypeDefinitionClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/implementation` request.
     *
     * @since 3.6.0
     */
    implementation?: ImplementationClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/references` request.
     */
    references?: ReferenceClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/documentHighlight` request.
     */
    documentHighlight?: DocumentHighlightClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/documentSymbol` request.
     */
    documentSymbol?: DocumentSymbolClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/codeAction` request.
     */
    codeAction?: CodeActionClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/codeLens` request.
     */
    codeLens?: CodeLensClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/documentLink` request.
     */
    documentLink?: DocumentLinkClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/documentColor` and the
     * `textDocument/colorPresentation` request.
     *
     * @since 3.6.0
     */
    colorProvider?: DocumentColorClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/formatting` request.
     */
    formatting?: DocumentFormattingClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/rangeFormatting` request.
     */
    rangeFormatting?: DocumentRangeFormattingClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/onTypeFormatting` request.
     */
    onTypeFormatting?: DocumentOnTypeFormattingClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/rename` request.
     */
    rename?: RenameClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/foldingRange` request.
     *
     * @since 3.10.0
     */
    foldingRange?: FoldingRangeClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/selectionRange` request.
     *
     * @since 3.15.0
     */
    selectionRange?: SelectionRangeClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/publishDiagnostics` notification.
     */
    publishDiagnostics?: PublishDiagnosticsClientCapabilities;
    /**
     * Capabilities specific to the various call hierarchy requests.
     *
     * @since 3.16.0
     */
    callHierarchy?: CallHierarchyClientCapabilities;
    /**
     * Capabilities specific to the various semantic token request.
     *
     * @since 3.16.0
     */
    semanticTokens?: SemanticTokensClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/linkedEditingRange` request.
     *
     * @since 3.16.0
     */
    linkedEditingRange?: LinkedEditingRangeClientCapabilities;
    /**
     * Client capabilities specific to the `textDocument/moniker` request.
     *
     * @since 3.16.0
     */
    moniker?: MonikerClientCapabilities;
    /**
     * Capabilities specific to the various type hierarchy requests.
     *
     * @since 3.17.0
     */
    typeHierarchy?: TypeHierarchyClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/inlineValue` request.
     *
     * @since 3.17.0
     */
    inlineValue?: InlineValueClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/inlayHint` request.
     *
     * @since 3.17.0
     */
    inlayHint?: InlayHintClientCapabilities;
    /**
     * Capabilities specific to the diagnostic pull model.
     *
     * @since 3.17.0
     */
    diagnostic?: DiagnosticClientCapabilities;
    /**
     * Client capabilities specific to inline completions.
     *
     * @since 3.18.0
     * @proposed
     */
    inlineCompletion?: InlineCompletionClientCapabilities;
}
interface WindowClientCapabilities {
    /**
     * It indicates whether the client supports server initiated
     * progress using the `window/workDoneProgress/create` request.
     *
     * The capability also controls Whether client supports handling
     * of progress notifications. If set servers are allowed to report a
     * `workDoneProgress` property in the request specific server
     * capabilities.
     *
     * @since 3.15.0
     */
    workDoneProgress?: boolean;
    /**
     * Capabilities specific to the showMessage request.
     *
     * @since 3.16.0
     */
    showMessage?: ShowMessageRequestClientCapabilities;
    /**
     * Capabilities specific to the showDocument request.
     *
     * @since 3.16.0
     */
    showDocument?: ShowDocumentClientCapabilities;
}
/**
 * Client capabilities specific to regular expressions.
 *
 * @since 3.16.0
 */
interface RegularExpressionsClientCapabilities {
    /**
     * The engine's name.
     */
    engine: string;
    /**
     * The engine's version.
     */
    version?: string;
}
/**
 * Client capabilities specific to the used markdown parser.
 *
 * @since 3.16.0
 */
interface MarkdownClientCapabilities {
    /**
     * The name of the parser.
     */
    parser: string;
    /**
     * The version of the parser.
     */
    version?: string;
    /**
     * A list of HTML tags that the client allows / supports in
     * Markdown.
     *
     * @since 3.17.0
     */
    allowedTags?: string[];
}
/**
 * A set of predefined position encoding kinds.
 *
 * @since 3.17.0
 */
declare namespace PositionEncodingKind {
    /**
     * Character offsets count UTF-8 code units (e.g. bytes).
     */
    const UTF8: PositionEncodingKind;
    /**
     * Character offsets count UTF-16 code units.
     *
     * This is the default and must always be supported
     * by servers
     */
    const UTF16: PositionEncodingKind;
    /**
     * Character offsets count UTF-32 code units.
     *
     * Implementation note: these are the same as Unicode codepoints,
     * so this `PositionEncodingKind` may also be used for an
     * encoding-agnostic representation of character offsets.
     */
    const UTF32: PositionEncodingKind;
}
/**
 * A type indicating how positions are encoded,
 * specifically what column offsets mean.
 *
 * @since 3.17.0
 */
type PositionEncodingKind = string;
/**
 * General client capabilities.
 *
 * @since 3.16.0
 */
interface GeneralClientCapabilities {
    /**
     * Client capability that signals how the client
     * handles stale requests (e.g. a request
     * for which the client will not process the response
     * anymore since the information is outdated).
     *
     * @since 3.17.0
     */
    staleRequestSupport?: {
        /**
         * The client will actively cancel the request.
         */
        cancel: boolean;
        /**
         * The list of requests for which the client
         * will retry the request if it receives a
         * response with error code `ContentModified`
         */
        retryOnContentModified: string[];
    };
    /**
     * Client capabilities specific to regular expressions.
     *
     * @since 3.16.0
     */
    regularExpressions?: RegularExpressionsClientCapabilities;
    /**
     * Client capabilities specific to the client's markdown parser.
     *
     * @since 3.16.0
     */
    markdown?: MarkdownClientCapabilities;
    /**
     * The position encodings supported by the client. Client and server
     * have to agree on the same position encoding to ensure that offsets
     * (e.g. character position in a line) are interpreted the same on both
     * sides.
     *
     * To keep the protocol backwards compatible the following applies: if
     * the value 'utf-16' is missing from the array of position encodings
     * servers can assume that the client supports UTF-16. UTF-16 is
     * therefore a mandatory encoding.
     *
     * If omitted it defaults to ['utf-16'].
     *
     * Implementation considerations: since the conversion from one encoding
     * into another requires the content of the file / line the conversion
     * is best done where the file is read which is usually on the server
     * side.
     *
     * @since 3.17.0
     */
    positionEncodings?: PositionEncodingKind[];
}
/**
 * Capabilities specific to the notebook document support.
 *
 * @since 3.17.0
 */
interface NotebookDocumentClientCapabilities {
    /**
     * Capabilities specific to notebook document synchronization
     *
     * @since 3.17.0
     */
    synchronization: NotebookDocumentSyncClientCapabilities;
}
/**
 * Defines the capabilities provided by the client.
 */
interface ClientCapabilities {
    /**
     * Workspace specific client capabilities.
     */
    workspace?: WorkspaceClientCapabilities;
    /**
     * Text document specific client capabilities.
     */
    textDocument?: TextDocumentClientCapabilities;
    /**
     * Capabilities specific to the notebook document support.
     *
     * @since 3.17.0
     */
    notebookDocument?: NotebookDocumentClientCapabilities;
    /**
     * Window specific client capabilities.
     */
    window?: WindowClientCapabilities;
    /**
     * General client capabilities.
     *
     * @since 3.16.0
     */
    general?: GeneralClientCapabilities;
    /**
     * Experimental client capabilities.
     */
    experimental?: LSPAny;
}
/**
 * Static registration options to be returned in the initialize
 * request.
 */
interface StaticRegistrationOptions {
    /**
     * The id used to register the request. The id can be used to deregister
     * the request again. See also Registration#id.
     */
    id?: string;
}
/**
 * The StaticRegistrationOptions namespace provides helper functions to work with
 * {@link StaticRegistrationOptions} literals.
 */
declare namespace StaticRegistrationOptions {
    function hasId(value: object): value is {
        id: string;
    };
}
/**
 * General text document registration options.
 */
interface TextDocumentRegistrationOptions {
    /**
     * A document selector to identify the scope of the registration. If set to null
     * the document selector provided on the client side will be used.
     */
    documentSelector: DocumentSelector | null;
}
/**
 * The TextDocumentRegistrationOptions namespace provides helper functions to work with
 * {@link TextDocumentRegistrationOptions} literals.
 */
declare namespace TextDocumentRegistrationOptions {
    function is(value: any): value is TextDocumentRegistrationOptions;
}
/**
 * Save options.
 */
interface SaveOptions {
    /**
     * The client is supposed to include the content on save.
     */
    includeText?: boolean;
}
interface WorkDoneProgressOptions {
    workDoneProgress?: boolean;
}
/**
 * The WorkDoneProgressOptions namespace provides helper functions to work with
 * {@link WorkDoneProgressOptions} literals.
 */
declare namespace WorkDoneProgressOptions {
    function is(value: any): value is WorkDoneProgressOptions;
    function hasWorkDoneProgress(value: any): value is {
        workDoneProgress: boolean;
    };
}
/**
 * Defines the capabilities provided by a language
 * server.
 */
interface ServerCapabilities<T = LSPAny> {
    /**
     * The position encoding the server picked from the encodings offered
     * by the client via the client capability `general.positionEncodings`.
     *
     * If the client didn't provide any position encodings the only valid
     * value that a server can return is 'utf-16'.
     *
     * If omitted it defaults to 'utf-16'.
     *
     * @since 3.17.0
     */
    positionEncoding?: PositionEncodingKind;
    /**
     * Defines how text documents are synced. Is either a detailed structure
     * defining each notification or for backwards compatibility the
     * TextDocumentSyncKind number.
     */
    textDocumentSync?: TextDocumentSyncOptions | TextDocumentSyncKind;
    /**
     * Defines how notebook documents are synced.
     *
     * @since 3.17.0
     */
    notebookDocumentSync?: NotebookDocumentSyncOptions | NotebookDocumentSyncRegistrationOptions;
    /**
     * The server provides completion support.
     */
    completionProvider?: CompletionOptions;
    /**
     * The server provides hover support.
     */
    hoverProvider?: boolean | HoverOptions;
    /**
     * The server provides signature help support.
     */
    signatureHelpProvider?: SignatureHelpOptions;
    /**
     * The server provides Goto Declaration support.
     */
    declarationProvider?: boolean | DeclarationOptions | DeclarationRegistrationOptions;
    /**
     * The server provides goto definition support.
     */
    definitionProvider?: boolean | DefinitionOptions;
    /**
     * The server provides Goto Type Definition support.
     */
    typeDefinitionProvider?: boolean | TypeDefinitionOptions | TypeDefinitionRegistrationOptions;
    /**
     * The server provides Goto Implementation support.
     */
    implementationProvider?: boolean | ImplementationOptions | ImplementationRegistrationOptions;
    /**
     * The server provides find references support.
     */
    referencesProvider?: boolean | ReferenceOptions;
    /**
     * The server provides document highlight support.
     */
    documentHighlightProvider?: boolean | DocumentHighlightOptions;
    /**
     * The server provides document symbol support.
     */
    documentSymbolProvider?: boolean | DocumentSymbolOptions;
    /**
     * The server provides code actions. CodeActionOptions may only be
     * specified if the client states that it supports
     * `codeActionLiteralSupport` in its initial `initialize` request.
     */
    codeActionProvider?: boolean | CodeActionOptions;
    /**
     * The server provides code lens.
     */
    codeLensProvider?: CodeLensOptions;
    /**
     * The server provides document link support.
     */
    documentLinkProvider?: DocumentLinkOptions;
    /**
     * The server provides color provider support.
     */
    colorProvider?: boolean | DocumentColorOptions | DocumentColorRegistrationOptions;
    /**
     * The server provides workspace symbol support.
     */
    workspaceSymbolProvider?: boolean | WorkspaceSymbolOptions;
    /**
     * The server provides document formatting.
     */
    documentFormattingProvider?: boolean | DocumentFormattingOptions;
    /**
     * The server provides document range formatting.
     */
    documentRangeFormattingProvider?: boolean | DocumentRangeFormattingOptions;
    /**
     * The server provides document formatting on typing.
     */
    documentOnTypeFormattingProvider?: DocumentOnTypeFormattingOptions;
    /**
     * The server provides rename support. RenameOptions may only be
     * specified if the client states that it supports
     * `prepareSupport` in its initial `initialize` request.
     */
    renameProvider?: boolean | RenameOptions;
    /**
     * The server provides folding provider support.
     */
    foldingRangeProvider?: boolean | FoldingRangeOptions | FoldingRangeRegistrationOptions;
    /**
     * The server provides selection range support.
     */
    selectionRangeProvider?: boolean | SelectionRangeOptions | SelectionRangeRegistrationOptions;
    /**
     * The server provides execute command support.
     */
    executeCommandProvider?: ExecuteCommandOptions;
    /**
     * The server provides call hierarchy support.
     *
     * @since 3.16.0
     */
    callHierarchyProvider?: boolean | CallHierarchyOptions | CallHierarchyRegistrationOptions;
    /**
     * The server provides linked editing range support.
     *
     * @since 3.16.0
     */
    linkedEditingRangeProvider?: boolean | LinkedEditingRangeOptions | LinkedEditingRangeRegistrationOptions;
    /**
     * The server provides semantic tokens support.
     *
     * @since 3.16.0
     */
    semanticTokensProvider?: SemanticTokensOptions | SemanticTokensRegistrationOptions;
    /**
     * The server provides moniker support.
     *
     * @since 3.16.0
     */
    monikerProvider?: boolean | MonikerOptions | MonikerRegistrationOptions;
    /**
     * The server provides type hierarchy support.
     *
     * @since 3.17.0
     */
    typeHierarchyProvider?: boolean | TypeHierarchyOptions | TypeHierarchyRegistrationOptions;
    /**
     * The server provides inline values.
     *
     * @since 3.17.0
     */
    inlineValueProvider?: boolean | InlineValueOptions | InlineValueRegistrationOptions;
    /**
     * The server provides inlay hints.
     *
     * @since 3.17.0
     */
    inlayHintProvider?: boolean | InlayHintOptions | InlayHintRegistrationOptions;
    /**
     * The server has support for pull model diagnostics.
     *
     * @since 3.17.0
     */
    diagnosticProvider?: DiagnosticOptions | DiagnosticRegistrationOptions;
    /**
     * Inline completion options used during static registration.
     *
     * @since 3.18.0
     * @proposed
     */
    inlineCompletionProvider?: boolean | InlineCompletionOptions;
    /**
     * Workspace specific server capabilities.
     */
    workspace?: {
        /**
         * The server supports workspace folder.
         *
         * @since 3.6.0
         */
        workspaceFolders?: WorkspaceFoldersServerCapabilities;
        /**
        * The server is interested in notifications/requests for operations on files.
        *
        * @since 3.16.0
        */
        fileOperations?: FileOperationOptions;
    };
    /**
     * Experimental server capabilities.
     */
    experimental?: T;
}
/**
 * The initialize parameters
 */
interface _InitializeParams extends WorkDoneProgressParams {
    /**
     * The process Id of the parent process that started
     * the server.
     *
     * Is `null` if the process has not been started by another process.
     * If the parent process is not alive then the server should exit.
     */
    processId: integer | null;
    /**
     * Information about the client
     *
     * @since 3.15.0
     */
    clientInfo?: {
        /**
         * The name of the client as defined by the client.
         */
        name: string;
        /**
         * The client's version as defined by the client.
         */
        version?: string;
    };
    /**
     * The locale the client is currently showing the user interface
     * in. This must not necessarily be the locale of the operating
     * system.
     *
     * Uses IETF language tags as the value's syntax
     * (See https://en.wikipedia.org/wiki/IETF_language_tag)
     *
     * @since 3.16.0
     */
    locale?: string;
    /**
     * The rootPath of the workspace. Is null
     * if no folder is open.
     *
     * @deprecated in favour of rootUri.
     */
    rootPath?: string | null;
    /**
     * The rootUri of the workspace. Is null if no
     * folder is open. If both `rootPath` and `rootUri` are set
     * `rootUri` wins.
     *
     * @deprecated in favour of workspaceFolders.
     */
    rootUri: DocumentUri$1 | null;
    /**
     * The capabilities provided by the client (editor or tool)
     */
    capabilities: ClientCapabilities;
    /**
     * User provided initialization options.
     */
    initializationOptions?: LSPAny;
    /**
     * The initial trace setting. If omitted trace is disabled ('off').
     */
    trace?: TraceValues;
}
type InitializeParams = _InitializeParams & WorkspaceFoldersInitializeParams;
/**
 * The result returned from an initialize request.
 */
interface InitializeResult<T = any> {
    /**
     * The capabilities the language server provides.
     */
    capabilities: ServerCapabilities<T>;
    /**
     * Information about the server.
     *
     * @since 3.15.0
     */
    serverInfo?: {
        /**
         * The name of the server as defined by the server.
         */
        name: string;
        /**
         * The server's version as defined by the server.
         */
        version?: string;
    };
    /**
     * Custom initialization results.
     */
    [custom: string]: LSPAny | ServerCapabilities<T> | undefined; /** undefined is needed since serverInfo is optional */
}
/**
 * The data type of the ResponseError if the
 * initialize request fails.
 */
interface InitializeError {
    /**
     * Indicates whether the client execute the following retry logic:
     * (1) show the message provided by the ResponseError to the user
     * (2) user selects retry or cancel
     * (3) if user selected retry the initialize method is sent again.
     */
    retry: boolean;
}
interface InitializedParams {
}
interface DidChangeConfigurationClientCapabilities {
    /**
     * Did change configuration notification supports dynamic registration.
     */
    dynamicRegistration?: boolean;
}
interface DidChangeConfigurationRegistrationOptions {
    section?: string | string[];
}
/**
 * The parameters of a change configuration notification.
 */
interface DidChangeConfigurationParams {
    /**
     * The actual changed settings
     */
    settings: LSPAny;
}
/**
 * Show message request client capabilities
 */
interface ShowMessageRequestClientCapabilities {
    /**
     * Capabilities specific to the `MessageActionItem` type.
     */
    messageActionItem?: {
        /**
         * Whether the client supports additional attributes which
         * are preserved and send back to the server in the
         * request's response.
         */
        additionalPropertiesSupport?: boolean;
    };
}
interface MessageActionItem {
    /**
     * A short title like 'Retry', 'Open Log' etc.
     */
    title: string;
    /**
     * Additional attributes that the client preserves and
     * sends back to the server. This depends on the client
     * capability window.messageActionItem.additionalPropertiesSupport
     */
    [key: string]: string | boolean | integer | object;
}
interface TextDocumentSyncClientCapabilities {
    /**
     * Whether text document synchronization supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * The client supports sending will save notifications.
     */
    willSave?: boolean;
    /**
     * The client supports sending a will save request and
     * waits for a response providing text edits which will
     * be applied to the document before it is saved.
     */
    willSaveWaitUntil?: boolean;
    /**
     * The client supports did save notifications.
     */
    didSave?: boolean;
}
/**
 * Defines how the host (editor) should sync
 * document changes to the language server.
 */
declare namespace TextDocumentSyncKind {
    /**
     * Documents should not be synced at all.
     */
    const None = 0;
    /**
     * Documents are synced by always sending the full content
     * of the document.
     */
    const Full = 1;
    /**
     * Documents are synced by sending the full content on open.
     * After that only incremental updates to the document are
     * send.
     */
    const Incremental = 2;
}
type TextDocumentSyncKind = 0 | 1 | 2;
interface TextDocumentSyncOptions {
    /**
     * Open and close notifications are sent to the server. If omitted open close notification should not
     * be sent.
     */
    openClose?: boolean;
    /**
     * Change notifications are sent to the server. See TextDocumentSyncKind.None, TextDocumentSyncKind.Full
     * and TextDocumentSyncKind.Incremental. If omitted it defaults to TextDocumentSyncKind.None.
     */
    change?: TextDocumentSyncKind;
    /**
     * If present will save notifications are sent to the server. If omitted the notification should not be
     * sent.
     */
    willSave?: boolean;
    /**
     * If present will save wait until requests are sent to the server. If omitted the request should not be
     * sent.
     */
    willSaveWaitUntil?: boolean;
    /**
     * If present save notifications are sent to the server. If omitted the notification should not be
     * sent.
     */
    save?: boolean | SaveOptions;
}
/**
 * The parameters sent in an open text document notification
 */
interface DidOpenTextDocumentParams {
    /**
     * The document that was opened.
     */
    textDocument: TextDocumentItem;
}
/**
 * An event describing a change to a text document. If only a text is provided
 * it is considered to be the full content of the document.
 */
type TextDocumentContentChangeEvent = {
    /**
     * The range of the document that changed.
     */
    range: Range$1;
    /**
     * The optional length of the range that got replaced.
     *
     * @deprecated use range instead.
     */
    rangeLength?: uinteger;
    /**
     * The new text for the provided range.
     */
    text: string;
} | {
    /**
     * The new text of the whole document.
     */
    text: string;
};
declare namespace TextDocumentContentChangeEvent {
    /**
     * Checks whether the information describes a delta event.
     */
    function isIncremental(event: TextDocumentContentChangeEvent): event is {
        range: Range$1;
        rangeLength?: uinteger;
        text: string;
    };
    /**
     * Checks whether the information describes a full replacement event.
     */
    function isFull(event: TextDocumentContentChangeEvent): event is {
        text: string;
    };
}
/**
 * The change text document notification's parameters.
 */
interface DidChangeTextDocumentParams {
    /**
     * The document that did change. The version number points
     * to the version after all provided content changes have
     * been applied.
     */
    textDocument: VersionedTextDocumentIdentifier;
    /**
     * The actual content changes. The content changes describe single state changes
     * to the document. So if there are two content changes c1 (at array index 0) and
     * c2 (at array index 1) for a document in state S then c1 moves the document from
     * S to S' and c2 from S' to S''. So c1 is computed on the state S and c2 is computed
     * on the state S'.
     *
     * To mirror the content of a document using change events use the following approach:
     * - start with the same initial content
     * - apply the 'textDocument/didChange' notifications in the order you receive them.
     * - apply the `TextDocumentContentChangeEvent`s in a single notification in the order
     *   you receive them.
     */
    contentChanges: TextDocumentContentChangeEvent[];
}
/**
 * The parameters sent in a close text document notification
 */
interface DidCloseTextDocumentParams {
    /**
     * The document that was closed.
     */
    textDocument: TextDocumentIdentifier;
}
/**
 * The parameters sent in a save text document notification
 */
interface DidSaveTextDocumentParams {
    /**
     * The document that was saved.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * Optional the content when saved. Depends on the includeText value
     * when the save notification was requested.
     */
    text?: string;
}
/**
 * Represents reasons why a text document is saved.
 */
declare namespace TextDocumentSaveReason {
    /**
     * Manually triggered, e.g. by the user pressing save, by starting debugging,
     * or by an API call.
     */
    const Manual: 1;
    /**
     * Automatic after a delay.
     */
    const AfterDelay: 2;
    /**
     * When the editor lost focus.
     */
    const FocusOut: 3;
}
type TextDocumentSaveReason = 1 | 2 | 3;
/**
 * The parameters sent in a will save text document notification.
 */
interface WillSaveTextDocumentParams {
    /**
     * The document that will be saved.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The 'TextDocumentSaveReason'.
     */
    reason: TextDocumentSaveReason;
}
interface DidChangeWatchedFilesClientCapabilities {
    /**
     * Did change watched files notification supports dynamic registration. Please note
     * that the current protocol doesn't support static configuration for file changes
     * from the server side.
     */
    dynamicRegistration?: boolean;
    /**
     * Whether the client has support for {@link  RelativePattern relative pattern}
     * or not.
     *
     * @since 3.17.0
     */
    relativePatternSupport?: boolean;
}
/**
 * The watched files change notification's parameters.
 */
interface DidChangeWatchedFilesParams {
    /**
     * The actual file events.
     */
    changes: FileEvent[];
}
/**
 * The file event type
 */
declare namespace FileChangeType {
    /**
     * The file got created.
     */
    const Created = 1;
    /**
     * The file got changed.
     */
    const Changed = 2;
    /**
     * The file got deleted.
     */
    const Deleted = 3;
}
type FileChangeType = 1 | 2 | 3;
/**
 * An event describing a file change.
 */
interface FileEvent {
    /**
     * The file's uri.
     */
    uri: DocumentUri$1;
    /**
     * The change type.
     */
    type: FileChangeType;
}
/**
 * The publish diagnostic client capabilities.
 */
interface PublishDiagnosticsClientCapabilities {
    /**
     * Whether the clients accepts diagnostics with related information.
     */
    relatedInformation?: boolean;
    /**
     * Client supports the tag property to provide meta data about a diagnostic.
     * Clients supporting tags have to handle unknown tags gracefully.
     *
     * @since 3.15.0
     */
    tagSupport?: {
        /**
         * The tags supported by the client.
         */
        valueSet: DiagnosticTag[];
    };
    /**
     * Whether the client interprets the version property of the
     * `textDocument/publishDiagnostics` notification's parameter.
     *
     * @since 3.15.0
     */
    versionSupport?: boolean;
    /**
     * Client supports a codeDescription property
     *
     * @since 3.16.0
     */
    codeDescriptionSupport?: boolean;
    /**
     * Whether code action supports the `data` property which is
     * preserved between a `textDocument/publishDiagnostics` and
     * `textDocument/codeAction` request.
     *
     * @since 3.16.0
     */
    dataSupport?: boolean;
}
/**
 * The publish diagnostic notification's parameters.
 */
interface PublishDiagnosticsParams {
    /**
     * The URI for which diagnostic information is reported.
     */
    uri: DocumentUri$1;
    /**
     * Optional the version number of the document the diagnostics are published for.
     *
     * @since 3.15.0
     */
    version?: integer;
    /**
     * An array of diagnostic information items.
     */
    diagnostics: Diagnostic[];
}
/**
 * Completion client capabilities
 */
interface CompletionClientCapabilities {
    /**
     * Whether completion supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * The client supports the following `CompletionItem` specific
     * capabilities.
     */
    completionItem?: {
        /**
         * Client supports snippets as insert text.
         *
         * A snippet can define tab stops and placeholders with `$1`, `$2`
         * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
         * the end of the snippet. Placeholders with equal identifiers are linked,
         * that is typing in one will update others too.
         */
        snippetSupport?: boolean;
        /**
         * Client supports commit characters on a completion item.
         */
        commitCharactersSupport?: boolean;
        /**
         * Client supports the following content formats for the documentation
         * property. The order describes the preferred format of the client.
         */
        documentationFormat?: MarkupKind[];
        /**
         * Client supports the deprecated property on a completion item.
         */
        deprecatedSupport?: boolean;
        /**
         * Client supports the preselect property on a completion item.
         */
        preselectSupport?: boolean;
        /**
         * Client supports the tag property on a completion item. Clients supporting
         * tags have to handle unknown tags gracefully. Clients especially need to
         * preserve unknown tags when sending a completion item back to the server in
         * a resolve call.
         *
         * @since 3.15.0
         */
        tagSupport?: {
            /**
             * The tags supported by the client.
             */
            valueSet: CompletionItemTag[];
        };
        /**
         * Client support insert replace edit to control different behavior if a
         * completion item is inserted in the text or should replace text.
         *
         * @since 3.16.0
         */
        insertReplaceSupport?: boolean;
        /**
         * Indicates which properties a client can resolve lazily on a completion
         * item. Before version 3.16.0 only the predefined properties `documentation`
         * and `details` could be resolved lazily.
         *
         * @since 3.16.0
         */
        resolveSupport?: {
            /**
             * The properties that a client can resolve lazily.
             */
            properties: string[];
        };
        /**
         * The client supports the `insertTextMode` property on
         * a completion item to override the whitespace handling mode
         * as defined by the client (see `insertTextMode`).
         *
         * @since 3.16.0
         */
        insertTextModeSupport?: {
            valueSet: InsertTextMode[];
        };
        /**
         * The client has support for completion item label
         * details (see also `CompletionItemLabelDetails`).
         *
         * @since 3.17.0
         */
        labelDetailsSupport?: boolean;
    };
    completionItemKind?: {
        /**
         * The completion item kind values the client supports. When this
         * property exists the client also guarantees that it will
         * handle values outside its set gracefully and falls back
         * to a default value when unknown.
         *
         * If this property is not present the client only supports
         * the completion items kinds from `Text` to `Reference` as defined in
         * the initial version of the protocol.
         */
        valueSet?: CompletionItemKind[];
    };
    /**
     * Defines how the client handles whitespace and indentation
     * when accepting a completion item that uses multi line
     * text in either `insertText` or `textEdit`.
     *
     * @since 3.17.0
     */
    insertTextMode?: InsertTextMode;
    /**
     * The client supports to send additional context information for a
     * `textDocument/completion` request.
     */
    contextSupport?: boolean;
    /**
     * The client supports the following `CompletionList` specific
     * capabilities.
     *
     * @since 3.17.0
     */
    completionList?: {
        /**
         * The client supports the following itemDefaults on
         * a completion list.
         *
         * The value lists the supported property names of the
         * `CompletionList.itemDefaults` object. If omitted
         * no properties are supported.
         *
         * @since 3.17.0
         */
        itemDefaults?: string[];
    };
}
/**
 * How a completion was triggered
 */
declare namespace CompletionTriggerKind {
    /**
     * Completion was triggered by typing an identifier (24x7 code
     * complete), manual invocation (e.g Ctrl+Space) or via API.
     */
    const Invoked: 1;
    /**
     * Completion was triggered by a trigger character specified by
     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
     */
    const TriggerCharacter: 2;
    /**
     * Completion was re-triggered as current completion list is incomplete
     */
    const TriggerForIncompleteCompletions: 3;
}
type CompletionTriggerKind = 1 | 2 | 3;
/**
 * Contains additional information about the context in which a completion request is triggered.
 */
interface CompletionContext$1 {
    /**
     * How the completion was triggered.
     */
    triggerKind: CompletionTriggerKind;
    /**
     * The trigger character (a single character) that has trigger code complete.
     * Is undefined if `triggerKind !== CompletionTriggerKind.TriggerCharacter`
     */
    triggerCharacter?: string;
}
/**
 * Completion parameters
 */
interface CompletionParams extends TextDocumentPositionParams, WorkDoneProgressParams, PartialResultParams {
    /**
     * The completion context. This is only available it the client specifies
     * to send this using the client capability `textDocument.completion.contextSupport === true`
     */
    context?: CompletionContext$1;
}
/**
 * Completion options.
 */
interface CompletionOptions extends WorkDoneProgressOptions {
    /**
     * Most tools trigger completion request automatically without explicitly requesting
     * it using a keyboard shortcut (e.g. Ctrl+Space). Typically they do so when the user
     * starts to type an identifier. For example if the user types `c` in a JavaScript file
     * code complete will automatically pop up present `console` besides others as a
     * completion item. Characters that make up identifiers don't need to be listed here.
     *
     * If code complete should automatically be trigger on characters not being valid inside
     * an identifier (for example `.` in JavaScript) list them in `triggerCharacters`.
     */
    triggerCharacters?: string[];
    /**
     * The list of all possible characters that commit a completion. This field can be used
     * if clients don't support individual commit characters per completion item. See
     * `ClientCapabilities.textDocument.completion.completionItem.commitCharactersSupport`
     *
     * If a server provides both `allCommitCharacters` and commit characters on an individual
     * completion item the ones on the completion item win.
     *
     * @since 3.2.0
     */
    allCommitCharacters?: string[];
    /**
     * The server provides support to resolve additional
     * information for a completion item.
     */
    resolveProvider?: boolean;
    /**
     * The server supports the following `CompletionItem` specific
     * capabilities.
     *
     * @since 3.17.0
     */
    completionItem?: {
        /**
         * The server has support for completion item label
         * details (see also `CompletionItemLabelDetails`) when
         * receiving a completion item in a resolve call.
         *
         * @since 3.17.0
         */
        labelDetailsSupport?: boolean;
    };
}
interface HoverClientCapabilities {
    /**
     * Whether hover supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * Client supports the following content formats for the content
     * property. The order describes the preferred format of the client.
     */
    contentFormat?: MarkupKind[];
}
/**
 * Hover options.
 */
interface HoverOptions extends WorkDoneProgressOptions {
}
/**
 * Parameters for a {@link HoverRequest}.
 */
interface HoverParams extends TextDocumentPositionParams, WorkDoneProgressParams {
}
/**
 * Client Capabilities for a {@link SignatureHelpRequest}.
 */
interface SignatureHelpClientCapabilities {
    /**
     * Whether signature help supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * The client supports the following `SignatureInformation`
     * specific properties.
     */
    signatureInformation?: {
        /**
         * Client supports the following content formats for the documentation
         * property. The order describes the preferred format of the client.
         */
        documentationFormat?: MarkupKind[];
        /**
         * Client capabilities specific to parameter information.
         */
        parameterInformation?: {
            /**
             * The client supports processing label offsets instead of a
             * simple label string.
             *
             * @since 3.14.0
             */
            labelOffsetSupport?: boolean;
        };
        /**
         * The client supports the `activeParameter` property on `SignatureInformation`
         * literal.
         *
         * @since 3.16.0
         */
        activeParameterSupport?: boolean;
    };
    /**
     * The client supports to send additional context information for a
     * `textDocument/signatureHelp` request. A client that opts into
     * contextSupport will also support the `retriggerCharacters` on
     * `SignatureHelpOptions`.
     *
     * @since 3.15.0
     */
    contextSupport?: boolean;
}
/**
 * Server Capabilities for a {@link SignatureHelpRequest}.
 */
interface SignatureHelpOptions extends WorkDoneProgressOptions {
    /**
     * List of characters that trigger signature help automatically.
     */
    triggerCharacters?: string[];
    /**
     * List of characters that re-trigger signature help.
     *
     * These trigger characters are only active when signature help is already showing. All trigger characters
     * are also counted as re-trigger characters.
     *
     * @since 3.15.0
     */
    retriggerCharacters?: string[];
}
/**
 * How a signature help was triggered.
 *
 * @since 3.15.0
 */
declare namespace SignatureHelpTriggerKind {
    /**
     * Signature help was invoked manually by the user or by a command.
     */
    const Invoked: 1;
    /**
     * Signature help was triggered by a trigger character.
     */
    const TriggerCharacter: 2;
    /**
     * Signature help was triggered by the cursor moving or by the document content changing.
     */
    const ContentChange: 3;
}
type SignatureHelpTriggerKind = 1 | 2 | 3;
/**
 * Additional information about the context in which a signature help request was triggered.
 *
 * @since 3.15.0
 */
interface SignatureHelpContext {
    /**
     * Action that caused signature help to be triggered.
     */
    triggerKind: SignatureHelpTriggerKind;
    /**
     * Character that caused signature help to be triggered.
     *
     * This is undefined when `triggerKind !== SignatureHelpTriggerKind.TriggerCharacter`
     */
    triggerCharacter?: string;
    /**
     * `true` if signature help was already showing when it was triggered.
     *
     * Retriggers occurs when the signature help is already active and can be caused by actions such as
     * typing a trigger character, a cursor move, or document content changes.
     */
    isRetrigger: boolean;
    /**
     * The currently active `SignatureHelp`.
     *
     * The `activeSignatureHelp` has its `SignatureHelp.activeSignature` field updated based on
     * the user navigating through available signatures.
     */
    activeSignatureHelp?: SignatureHelp;
}
/**
 * Parameters for a {@link SignatureHelpRequest}.
 */
interface SignatureHelpParams extends TextDocumentPositionParams, WorkDoneProgressParams {
    /**
     * The signature help context. This is only available if the client specifies
     * to send this using the client capability `textDocument.signatureHelp.contextSupport === true`
     *
     * @since 3.15.0
     */
    context?: SignatureHelpContext;
}
/**
 * Client Capabilities for a {@link DefinitionRequest}.
 */
interface DefinitionClientCapabilities {
    /**
     * Whether definition supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * The client supports additional metadata in the form of definition links.
     *
     * @since 3.14.0
     */
    linkSupport?: boolean;
}
/**
 * Server Capabilities for a {@link DefinitionRequest}.
 */
interface DefinitionOptions extends WorkDoneProgressOptions {
}
/**
 * Parameters for a {@link DefinitionRequest}.
 */
interface DefinitionParams extends TextDocumentPositionParams, WorkDoneProgressParams, PartialResultParams {
}
/**
 * Client Capabilities for a {@link ReferencesRequest}.
 */
interface ReferenceClientCapabilities {
    /**
     * Whether references supports dynamic registration.
     */
    dynamicRegistration?: boolean;
}
/**
 * Parameters for a {@link ReferencesRequest}.
 */
interface ReferenceParams extends TextDocumentPositionParams, WorkDoneProgressParams, PartialResultParams {
    context: ReferenceContext;
}
/**
 * Reference options.
 */
interface ReferenceOptions extends WorkDoneProgressOptions {
}
/**
 * Client Capabilities for a {@link DocumentHighlightRequest}.
 */
interface DocumentHighlightClientCapabilities {
    /**
     * Whether document highlight supports dynamic registration.
     */
    dynamicRegistration?: boolean;
}
/**
 * Parameters for a {@link DocumentHighlightRequest}.
 */
interface DocumentHighlightParams extends TextDocumentPositionParams, WorkDoneProgressParams, PartialResultParams {
}
/**
 * Provider options for a {@link DocumentHighlightRequest}.
 */
interface DocumentHighlightOptions extends WorkDoneProgressOptions {
}
/**
 * Client Capabilities for a {@link DocumentSymbolRequest}.
 */
interface DocumentSymbolClientCapabilities {
    /**
     * Whether document symbol supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * Specific capabilities for the `SymbolKind` in the
     * `textDocument/documentSymbol` request.
     */
    symbolKind?: {
        /**
         * The symbol kind values the client supports. When this
         * property exists the client also guarantees that it will
         * handle values outside its set gracefully and falls back
         * to a default value when unknown.
         *
         * If this property is not present the client only supports
         * the symbol kinds from `File` to `Array` as defined in
         * the initial version of the protocol.
         */
        valueSet?: SymbolKind[];
    };
    /**
     * The client supports hierarchical document symbols.
     */
    hierarchicalDocumentSymbolSupport?: boolean;
    /**
     * The client supports tags on `SymbolInformation`. Tags are supported on
     * `DocumentSymbol` if `hierarchicalDocumentSymbolSupport` is set to true.
     * Clients supporting tags have to handle unknown tags gracefully.
     *
     * @since 3.16.0
     */
    tagSupport?: {
        /**
         * The tags supported by the client.
         */
        valueSet: SymbolTag[];
    };
    /**
     * The client supports an additional label presented in the UI when
     * registering a document symbol provider.
     *
     * @since 3.16.0
     */
    labelSupport?: boolean;
}
/**
 * Parameters for a {@link DocumentSymbolRequest}.
 */
interface DocumentSymbolParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
}
/**
 * Provider options for a {@link DocumentSymbolRequest}.
 */
interface DocumentSymbolOptions extends WorkDoneProgressOptions {
    /**
     * A human-readable string that is shown when multiple outlines trees
     * are shown for the same document.
     *
     * @since 3.16.0
     */
    label?: string;
}
/**
 * The Client Capabilities of a {@link CodeActionRequest}.
 */
interface CodeActionClientCapabilities {
    /**
     * Whether code action supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * The client support code action literals of type `CodeAction` as a valid
     * response of the `textDocument/codeAction` request. If the property is not
     * set the request can only return `Command` literals.
     *
     * @since 3.8.0
     */
    codeActionLiteralSupport?: {
        /**
         * The code action kind is support with the following value
         * set.
         */
        codeActionKind: {
            /**
             * The code action kind values the client supports. When this
             * property exists the client also guarantees that it will
             * handle values outside its set gracefully and falls back
             * to a default value when unknown.
             */
            valueSet: CodeActionKind[];
        };
    };
    /**
     * Whether code action supports the `isPreferred` property.
     *
     * @since 3.15.0
     */
    isPreferredSupport?: boolean;
    /**
     * Whether code action supports the `disabled` property.
     *
     * @since 3.16.0
     */
    disabledSupport?: boolean;
    /**
     * Whether code action supports the `data` property which is
     * preserved between a `textDocument/codeAction` and a
     * `codeAction/resolve` request.
     *
     * @since 3.16.0
     */
    dataSupport?: boolean;
    /**
     * Whether the client supports resolving additional code action
     * properties via a separate `codeAction/resolve` request.
     *
     * @since 3.16.0
     */
    resolveSupport?: {
        /**
         * The properties that a client can resolve lazily.
         */
        properties: string[];
    };
    /**
     * Whether the client honors the change annotations in
     * text edits and resource operations returned via the
     * `CodeAction#edit` property by for example presenting
     * the workspace edit in the user interface and asking
     * for confirmation.
     *
     * @since 3.16.0
     */
    honorsChangeAnnotations?: boolean;
}
/**
 * The parameters of a {@link CodeActionRequest}.
 */
interface CodeActionParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The document in which the command was invoked.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The range for which the command was invoked.
     */
    range: Range$1;
    /**
     * Context carrying additional information.
     */
    context: CodeActionContext;
}
/**
 * Provider options for a {@link CodeActionRequest}.
 */
interface CodeActionOptions extends WorkDoneProgressOptions {
    /**
     * CodeActionKinds that this server may return.
     *
     * The list of kinds may be generic, such as `CodeActionKind.Refactor`, or the server
     * may list out every specific kind they provide.
     */
    codeActionKinds?: CodeActionKind[];
    /**
     * The server provides support to resolve additional
     * information for a code action.
     *
     * @since 3.16.0
     */
    resolveProvider?: boolean;
}
/**
 * Client capabilities for a {@link WorkspaceSymbolRequest}.
 */
interface WorkspaceSymbolClientCapabilities {
    /**
     * Symbol request supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * Specific capabilities for the `SymbolKind` in the `workspace/symbol` request.
     */
    symbolKind?: {
        /**
         * The symbol kind values the client supports. When this
         * property exists the client also guarantees that it will
         * handle values outside its set gracefully and falls back
         * to a default value when unknown.
         *
         * If this property is not present the client only supports
         * the symbol kinds from `File` to `Array` as defined in
         * the initial version of the protocol.
         */
        valueSet?: SymbolKind[];
    };
    /**
     * The client supports tags on `SymbolInformation`.
     * Clients supporting tags have to handle unknown tags gracefully.
     *
     * @since 3.16.0
     */
    tagSupport?: {
        /**
         * The tags supported by the client.
         */
        valueSet: SymbolTag[];
    };
    /**
     * The client support partial workspace symbols. The client will send the
     * request `workspaceSymbol/resolve` to the server to resolve additional
     * properties.
     *
     * @since 3.17.0
     */
    resolveSupport?: {
        /**
         * The properties that a client can resolve lazily. Usually
         * `location.range`
         */
        properties: string[];
    };
}
/**
 * The parameters of a {@link WorkspaceSymbolRequest}.
 */
interface WorkspaceSymbolParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * A query string to filter symbols by. Clients may send an empty
     * string here to request all symbols.
     */
    query: string;
}
/**
 * Server capabilities for a {@link WorkspaceSymbolRequest}.
 */
interface WorkspaceSymbolOptions extends WorkDoneProgressOptions {
    /**
     * The server provides support to resolve additional
     * information for a workspace symbol.
     *
     * @since 3.17.0
     */
    resolveProvider?: boolean;
}
/**
 * The client capabilities  of a {@link CodeLensRequest}.
 */
interface CodeLensClientCapabilities {
    /**
     * Whether code lens supports dynamic registration.
     */
    dynamicRegistration?: boolean;
}
/**
 * @since 3.16.0
 */
interface CodeLensWorkspaceClientCapabilities {
    /**
     * Whether the client implementation supports a refresh request sent from the
     * server to the client.
     *
     * Note that this event is global and will force the client to refresh all
     * code lenses currently shown. It should be used with absolute care and is
     * useful for situation where a server for example detect a project wide
     * change that requires such a calculation.
     */
    refreshSupport?: boolean;
}
/**
 * The parameters of a {@link CodeLensRequest}.
 */
interface CodeLensParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The document to request code lens for.
     */
    textDocument: TextDocumentIdentifier;
}
/**
 * Code Lens provider options of a {@link CodeLensRequest}.
 */
interface CodeLensOptions extends WorkDoneProgressOptions {
    /**
     * Code lens has a resolve provider as well.
     */
    resolveProvider?: boolean;
}
/**
 * The client capabilities of a {@link DocumentLinkRequest}.
 */
interface DocumentLinkClientCapabilities {
    /**
     * Whether document link supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * Whether the client supports the `tooltip` property on `DocumentLink`.
     *
     * @since 3.15.0
     */
    tooltipSupport?: boolean;
}
/**
 * The parameters of a {@link DocumentLinkRequest}.
 */
interface DocumentLinkParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The document to provide document links for.
     */
    textDocument: TextDocumentIdentifier;
}
/**
 * Provider options for a {@link DocumentLinkRequest}.
 */
interface DocumentLinkOptions extends WorkDoneProgressOptions {
    /**
     * Document links have a resolve provider as well.
     */
    resolveProvider?: boolean;
}
/**
 * Client capabilities of a {@link DocumentFormattingRequest}.
 */
interface DocumentFormattingClientCapabilities {
    /**
     * Whether formatting supports dynamic registration.
     */
    dynamicRegistration?: boolean;
}
/**
 * The parameters of a {@link DocumentFormattingRequest}.
 */
interface DocumentFormattingParams extends WorkDoneProgressParams {
    /**
     * The document to format.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The format options.
     */
    options: FormattingOptions;
}
/**
 * Provider options for a {@link DocumentFormattingRequest}.
 */
interface DocumentFormattingOptions extends WorkDoneProgressOptions {
}
/**
 * Client capabilities of a {@link DocumentRangeFormattingRequest}.
 */
interface DocumentRangeFormattingClientCapabilities {
    /**
     * Whether range formatting supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * Whether the client supports formatting multiple ranges at once.
     *
     * @since 3.18.0
     * @proposed
     */
    rangesSupport?: boolean;
}
/**
 * The parameters of a {@link DocumentRangeFormattingRequest}.
 */
interface DocumentRangeFormattingParams extends WorkDoneProgressParams {
    /**
     * The document to format.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The range to format
     */
    range: Range$1;
    /**
     * The format options
     */
    options: FormattingOptions;
}
/**
 * Provider options for a {@link DocumentRangeFormattingRequest}.
 */
interface DocumentRangeFormattingOptions extends WorkDoneProgressOptions {
    /**
     * Whether the server supports formatting multiple ranges at once.
     *
     * @since 3.18.0
     * @proposed
     */
    rangesSupport?: boolean;
}
/**
 * Client capabilities of a {@link DocumentOnTypeFormattingRequest}.
 */
interface DocumentOnTypeFormattingClientCapabilities {
    /**
     * Whether on type formatting supports dynamic registration.
     */
    dynamicRegistration?: boolean;
}
/**
 * The parameters of a {@link DocumentOnTypeFormattingRequest}.
 */
interface DocumentOnTypeFormattingParams {
    /**
     * The document to format.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The position around which the on type formatting should happen.
     * This is not necessarily the exact position where the character denoted
     * by the property `ch` got typed.
     */
    position: Position$2;
    /**
     * The character that has been typed that triggered the formatting
     * on type request. That is not necessarily the last character that
     * got inserted into the document since the client could auto insert
     * characters as well (e.g. like automatic brace completion).
     */
    ch: string;
    /**
     * The formatting options.
     */
    options: FormattingOptions;
}
/**
 * Provider options for a {@link DocumentOnTypeFormattingRequest}.
 */
interface DocumentOnTypeFormattingOptions {
    /**
     * A character on which formatting should be triggered, like `{`.
     */
    firstTriggerCharacter: string;
    /**
     * More trigger characters.
     */
    moreTriggerCharacter?: string[];
}
declare namespace PrepareSupportDefaultBehavior {
    /**
     * The client's default behavior is to select the identifier
     * according the to language's syntax rule.
     */
    const Identifier: 1;
}
type PrepareSupportDefaultBehavior = 1;
interface RenameClientCapabilities {
    /**
     * Whether rename supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * Client supports testing for validity of rename operations
     * before execution.
     *
     * @since 3.12.0
     */
    prepareSupport?: boolean;
    /**
     * Client supports the default behavior result.
     *
     * The value indicates the default behavior used by the
     * client.
     *
     * @since 3.16.0
     */
    prepareSupportDefaultBehavior?: PrepareSupportDefaultBehavior;
    /**
     * Whether the client honors the change annotations in
     * text edits and resource operations returned via the
     * rename request's workspace edit by for example presenting
     * the workspace edit in the user interface and asking
     * for confirmation.
     *
     * @since 3.16.0
     */
    honorsChangeAnnotations?: boolean;
}
/**
 * The parameters of a {@link RenameRequest}.
 */
interface RenameParams extends WorkDoneProgressParams {
    /**
     * The document to rename.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The position at which this request was sent.
     */
    position: Position$2;
    /**
     * The new name of the symbol. If the given name is not valid the
     * request must return a {@link ResponseError} with an
     * appropriate message set.
     */
    newName: string;
}
/**
 * Provider options for a {@link RenameRequest}.
 */
interface RenameOptions extends WorkDoneProgressOptions {
    /**
     * Renames should be checked and tested before being executed.
     *
     * @since version 3.12.0
     */
    prepareProvider?: boolean;
}
interface PrepareRenameParams extends TextDocumentPositionParams, WorkDoneProgressParams {
}
/**
 * The client capabilities of a {@link ExecuteCommandRequest}.
 */
interface ExecuteCommandClientCapabilities {
    /**
     * Execute command supports dynamic registration.
     */
    dynamicRegistration?: boolean;
}
/**
 * The parameters of a {@link ExecuteCommandRequest}.
 */
interface ExecuteCommandParams extends WorkDoneProgressParams {
    /**
     * The identifier of the actual command handler.
     */
    command: string;
    /**
     * Arguments that the command should be invoked with.
     */
    arguments?: LSPAny[];
}
/**
 * The server capabilities of a {@link ExecuteCommandRequest}.
 */
interface ExecuteCommandOptions extends WorkDoneProgressOptions {
    /**
     * The commands to be executed on the server
     */
    commands: string[];
}
interface WorkspaceEditClientCapabilities {
    /**
     * The client supports versioned document changes in `WorkspaceEdit`s
     */
    documentChanges?: boolean;
    /**
     * The resource operations the client supports. Clients should at least
     * support 'create', 'rename' and 'delete' files and folders.
     *
     * @since 3.13.0
     */
    resourceOperations?: ResourceOperationKind[];
    /**
     * The failure handling strategy of a client if applying the workspace edit
     * fails.
     *
     * @since 3.13.0
     */
    failureHandling?: FailureHandlingKind;
    /**
     * Whether the client normalizes line endings to the client specific
     * setting.
     * If set to `true` the client will normalize line ending characters
     * in a workspace edit to the client-specified new line
     * character.
     *
     * @since 3.16.0
     */
    normalizesLineEndings?: boolean;
    /**
     * Whether the client in general supports change annotations on text edits,
     * create file, rename file and delete file changes.
     *
     * @since 3.16.0
     */
    changeAnnotationSupport?: {
        /**
         * Whether the client groups edits with equal labels into tree nodes,
         * for instance all edits labelled with "Changes in Strings" would
         * be a tree node.
         */
        groupsOnLabel?: boolean;
    };
}
/**
 * The parameters passed via an apply workspace edit request.
 */
interface ApplyWorkspaceEditParams {
    /**
     * An optional label of the workspace edit. This label is
     * presented in the user interface for example on an undo
     * stack to undo the workspace edit.
     */
    label?: string;
    /**
     * The edits to apply.
     */
    edit: WorkspaceEdit;
}
/**
 * The result returned from the apply workspace edit request.
 *
 * @since 3.17 renamed from ApplyWorkspaceEditResponse
 */
interface ApplyWorkspaceEditResult {
    /**
     * Indicates whether the edit was applied or not.
     */
    applied: boolean;
    /**
     * An optional textual description for why the edit was not applied.
     * This may be used by the server for diagnostic logging or to provide
     * a suitable error for a request that triggered the edit.
     */
    failureReason?: string;
    /**
     * Depending on the client's failure handling strategy `failedChange` might
     * contain the index of the change that failed. This property is only available
     * if the client signals a `failureHandlingStrategy` in its client capabilities.
     */
    failedChange?: uinteger;
}
/**
 * @deprecated Use ApplyWorkspaceEditResult instead.
 */
type ApplyWorkspaceEditResponse = ApplyWorkspaceEditResult;

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface ConfigurationProvider {
    /**
     * A promise that resolves when the configuration provider is ready to be used.
     */
    readonly ready: Promise<void>;
    /**
     * When used in a language server context, this method is called when the server receives
     * the `initialize` request.
     */
    initialize(params: InitializeParams): void;
    /**
     * When used in a language server context, this method is called when the server receives
     * the `initialized` notification.
     */
    initialized(params: ConfigurationInitializedParams): Promise<void>;
    /**
     * Returns a configuration value stored for the given language.
     *
     * @param language The language id
     * @param configuration Configuration name
     */
    getConfiguration(language: string, configuration: string): Promise<any>;
    /**
     *  Updates the cached configurations using the `change` notification parameters.
     *
     * @param change The parameters of a change configuration notification.
     * `settings` property of the change object could be expressed as `Record<string, Record<string, any>>`
     */
    updateConfiguration(change: DidChangeConfigurationParams): void;
    /**
     * Get notified after a configuration section has been updated.
     */
    onConfigurationSectionUpdate(callback: ConfigurationSectionUpdateListener): Disposable$1;
}
interface ConfigurationInitializedParams extends InitializedParams {
    register?: (params: DidChangeConfigurationRegistrationOptions) => void;
    fetchConfiguration?: (configuration: ConfigurationItem[]) => Promise<any>;
}
interface ConfigurationSectionUpdate {
    /**
     * The name of the configuration section that has been updated.
     */
    section: string;
    /**
     * The updated configuration section.
     */
    configuration: any;
}
type ConfigurationSectionUpdateListener = (update: ConfigurationSectionUpdate) => void;

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface BuildOptions {
    /**
     * Control the validation phase with this option:
     *  - `true` enables all validation checks and forces revalidating the documents
     *  - `false` or `undefined` disables all validation checks
     *  - An object runs only the necessary validation checks; the `categories` property restricts this to a specific subset
     */
    validation?: boolean | ValidationOptions;
}
/**
 * Shared-service for building and updating `LangiumDocument`s.
 */
interface DocumentBuilder {
    /** The options used for rebuilding documents after an update. */
    updateBuildOptions: BuildOptions;
    /**
     * Execute all necessary build steps for the given documents.
     *
     * @param documents Set of documents to be built.
     * @param options Options for the document builder.
     * @param cancelToken Indicates when to cancel the current operation.
     * @throws `OperationCanceled` if a user action occurs during execution
     */
    build<T extends AstNode>(documents: Array<LangiumDocument<T>>, options?: BuildOptions, cancelToken?: CancellationToken): Promise<void>;
    /**
     * This method is called when a document change is detected. It updates the state of all
     * affected documents, including those with references to the changed ones, so they are rebuilt.
     *
     * @param changed URIs of changed or created documents
     * @param deleted URIs of deleted documents
     * @param cancelToken allows to cancel the current operation
     * @throws `OperationCancelled` if cancellation is detected during execution
     */
    update(changed: URI[], deleted: URI[], cancelToken?: CancellationToken): Promise<void>;
    /**
     * Notify the given callback when a document update was triggered, but before any document
     * is rebuilt. Listeners to this event should not perform any long-running task.
     */
    onUpdate(callback: DocumentUpdateListener): Disposable;
    /**
     * Notify the given callback when a set of documents has been built reaching the specified target state.
     */
    onBuildPhase(targetState: DocumentState, callback: DocumentBuildListener): Disposable;
    /**
     * Notify the specified callback when a document has been built reaching the specified target state.
     * Unlike {@link onBuildPhase} the listener is called for every single document.
     *
     * There are two main advantages compared to {@link onBuildPhase}:
     * 1. If the build is cancelled, {@link onDocumentPhase} will still fire for documents that have reached a specific state.
     *    Meanwhile, {@link onBuildPhase} won't fire for that state.
     * 2. The {@link DocumentBuilder} ensures that all {@link DocumentPhaseListener} instances are called for a built document.
     *    Even if the build is cancelled before those listeners were called.
     */
    onDocumentPhase(targetState: DocumentState, callback: DocumentPhaseListener): Disposable;
    /**
     * Wait until the workspace has reached the specified state for all documents.
     *
     * @param state The desired state. The promise won't resolve until all documents have reached this state
     * @param cancelToken Optionally allows to cancel the wait operation, disposing any listeners in the process
     * @throws `OperationCancelled` if cancellation has been requested before the state has been reached
     */
    waitUntil(state: DocumentState, cancelToken?: CancellationToken): Promise<void>;
    /**
     * Wait until the document specified by the {@link uri} has reached the specified state.
     *
     * @param state The desired state. The promise won't resolve until the document has reached this state.
     * @param uri The specified URI that points to the document. If the URI does not exist, the promise will resolve once the workspace has reached the specified state.
     * @param cancelToken Optionally allows to cancel the wait operation, disposing any listeners in the process.
     * @return The URI of the document that has reached the desired state, or `undefined` if the document does not exist.
     * @throws `OperationCancelled` if cancellation has been requested before the state has been reached
     */
    waitUntil(state: DocumentState, uri?: URI, cancelToken?: CancellationToken): Promise<URI | undefined>;
}
type DocumentUpdateListener = (changed: URI[], deleted: URI[]) => void | Promise<void>;
type DocumentBuildListener = (built: LangiumDocument[], cancelToken: CancellationToken) => void | Promise<void>;
type DocumentPhaseListener = (built: LangiumDocument, cancelToken: CancellationToken) => void | Promise<void>;

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Utility service to execute mutually exclusive actions.
 */
interface WorkspaceLock {
    /**
     * Performs a single async action, like initializing the workspace or processing document changes.
     * Only one action will be executed at a time.
     *
     * When another action is queued up, the token provided for the action will be cancelled.
     * Assuming the action makes use of this token, the next action only has to wait for the current action to finish cancellation.
     */
    write(action: (token: CancellationToken) => MaybePromise<void>): Promise<void>;
    /**
     * Performs a single action, like computing completion results or providing workspace symbols.
     * Read actions will only be executed after all write actions have finished. They will be executed in parallel if possible.
     *
     * If a write action is currently running, the read action will be queued up and executed afterwards.
     * If a new write action is queued up while a read action is waiting, the write action will receive priority and will be handled before the read action.
     *
     * Note that read actions are not allowed to modify anything in the workspace. Please use {@link write} instead.
     */
    read<T>(action: () => MaybePromise<T>): Promise<T>;
    /**
     * Cancels the last queued write action. All previous write actions already have been cancelled.
     */
    cancelWrite(): void;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * The workspace manager is responsible for finding source files in the workspace.
 * This service is shared between all languages of a language server.
 */
interface WorkspaceManager {
    /** The options used for the initial workspace build. */
    initialBuildOptions: BuildOptions | undefined;
    /**
     * A promise that resolves when the workspace manager is ready to be used.
     * Use this to ensure that the workspace manager has finished its initialization.
     */
    readonly ready: Promise<void>;
    /**
     * The workspace folders of the current workspace.
     * Available only after the `ready` promise resolves.
     */
    get workspaceFolders(): readonly WorkspaceFolder[] | undefined;
    /**
     * When used in a language server context, this method is called when the server receives
     * the `initialize` request.
     */
    initialize(params: InitializeParams): void;
    /**
     * When used in a language server context, this method is called when the server receives
     * the `initialized` notification.
     */
    initialized(params: InitializedParams): Promise<void>;
    /**
     * Does the initial indexing of workspace folders.
     * Collects information about exported and referenced AstNodes in
     * each language file and stores it locally.
     *
     * @param folders The set of workspace folders to be indexed.
     * @param cancelToken A cancellation token that can be used to cancel the operation.
     *
     * @throws OperationCancelled if a cancellation event has been detected
     */
    initializeWorkspace(folders: WorkspaceFolder[], cancelToken?: CancellationToken): Promise<void>;
}
declare class DefaultWorkspaceManager implements WorkspaceManager {
    initialBuildOptions: BuildOptions;
    protected readonly serviceRegistry: ServiceRegistry;
    protected readonly langiumDocuments: LangiumDocuments;
    protected readonly documentBuilder: DocumentBuilder;
    protected readonly fileSystemProvider: FileSystemProvider;
    protected readonly mutex: WorkspaceLock;
    protected readonly _ready: Deferred<void>;
    protected folders?: WorkspaceFolder[];
    constructor(services: LangiumSharedCoreServices);
    get ready(): Promise<void>;
    get workspaceFolders(): readonly WorkspaceFolder[] | undefined;
    initialize(params: InitializeParams): void;
    initialized(_params: InitializedParams): Promise<void>;
    initializeWorkspace(folders: WorkspaceFolder[], cancelToken?: CancellationToken): Promise<void>;
    /**
     * Performs the uninterruptable startup sequence of the workspace manager.
     * This methods loads all documents in the workspace and other documents and returns them.
     */
    protected performStartup(folders: WorkspaceFolder[]): Promise<LangiumDocument[]>;
    /**
     * Load all additional documents that shall be visible in the context of the given workspace
     * folders and add them to the collector. This can be used to include built-in libraries of
     * your language, which can be either loaded from provided files or constructed in memory.
     */
    protected loadAdditionalDocuments(_folders: WorkspaceFolder[], _collector: (document: LangiumDocument) => void): Promise<void>;
    /**
     * Determine the root folder of the source documents in the given workspace folder.
     * The default implementation returns the URI of the workspace folder, but you can override
     * this to return a subfolder like `src` instead.
     */
    protected getRootFolder(workspaceFolder: WorkspaceFolder): URI;
    /**
     * Traverse the file system folder identified by the given URI and its subfolders. All
     * contained files that match the file extensions are added to the collector.
     */
    protected traverseFolder(workspaceFolder: WorkspaceFolder, folderPath: URI, fileExtensions: string[], collector: (document: LangiumDocument) => void): Promise<void>;
    /**
     * Determine whether the given folder entry shall be included while indexing the workspace.
     */
    protected includeEntry(_workspaceFolder: WorkspaceFolder, entry: FileSystemNode, fileExtensions: string[]): boolean;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * The services generated by `langium-cli` for a specific language. These are derived from the
 * grammar definition and the language configuration.
 */
type LangiumGeneratedCoreServices = {
    readonly Grammar: Grammar;
    readonly LanguageMetaData: LanguageMetaData;
    readonly parser: {
        readonly ParserConfig?: IParserConfig;
    };
};
/**
 * Core services for a specific language of which Langium provides default implementations.
 */
type LangiumDefaultCoreServices = {
    readonly parser: {
        readonly AsyncParser: AsyncParser;
        readonly GrammarConfig: GrammarConfig;
        readonly ValueConverter: ValueConverter;
        readonly LangiumParser: LangiumParser;
        readonly ParserErrorMessageProvider: IParserErrorMessageProvider;
        readonly LexerErrorMessageProvider: ILexerErrorMessageProvider;
        readonly CompletionParser: LangiumCompletionParser;
        readonly TokenBuilder: TokenBuilder;
        readonly Lexer: Lexer;
    };
    readonly documentation: {
        readonly CommentProvider: CommentProvider;
        readonly DocumentationProvider: DocumentationProvider;
    };
    readonly references: {
        readonly Linker: Linker;
        readonly NameProvider: NameProvider;
        readonly References: References;
        readonly ScopeProvider: ScopeProvider;
        readonly ScopeComputation: ScopeComputation;
    };
    readonly serializer: {
        readonly Hydrator: Hydrator;
        readonly JsonSerializer: JsonSerializer;
    };
    readonly validation: {
        readonly DocumentValidator: DocumentValidator;
        readonly ValidationRegistry: ValidationRegistry;
    };
    readonly workspace: {
        readonly AstNodeLocator: AstNodeLocator;
        readonly AstNodeDescriptionProvider: AstNodeDescriptionProvider;
        readonly ReferenceDescriptionProvider: ReferenceDescriptionProvider;
    };
    readonly shared: LangiumSharedCoreServices;
};
/**
 * The core set of services available for a language. These are either generated by `langium-cli`
 * or provided as default implementations.
 */
type LangiumCoreServices = LangiumGeneratedCoreServices & LangiumDefaultCoreServices;
/**
 * The services generated by `langium-cli` that are shared between multiple languages. These are
 * derived from the grammar definition.
 */
type LangiumGeneratedSharedCoreServices = {
    readonly AstReflection: AstReflection;
};
/**
 * Core services shared between multiple languages where Langium provides default implementations.
 */
type LangiumDefaultSharedCoreServices = {
    readonly ServiceRegistry: ServiceRegistry;
    readonly workspace: {
        readonly ConfigurationProvider: ConfigurationProvider;
        readonly DocumentBuilder: DocumentBuilder;
        readonly FileSystemProvider: FileSystemProvider;
        readonly IndexManager: IndexManager;
        readonly LangiumDocuments: LangiumDocuments;
        readonly LangiumDocumentFactory: LangiumDocumentFactory;
        readonly TextDocuments?: TextDocumentProvider;
        readonly WorkspaceLock: WorkspaceLock;
        readonly WorkspaceManager: WorkspaceManager;
    };
};
/**
 * The shared core services are a set of services that are used by every language within a Langium project (excluding LSP services)
 * This is necessary to enable features like cross references across different languages.
 */
type LangiumSharedCoreServices = LangiumDefaultSharedCoreServices & LangiumGeneratedSharedCoreServices;

interface WorkDoneProgressReporter {
    begin(title: string, percentage?: number, message?: string, cancellable?: boolean): void;
    report(percentage: number): void;
    report(message: string): void;
    report(percentage: number, message: string): void;
    done(): void;
}
interface WorkDoneProgressServerReporter extends WorkDoneProgressReporter {
    readonly token: CancellationToken;
}
interface WindowProgress {
    attachWorkDoneProgress(token: ProgressToken | undefined): WorkDoneProgressReporter;
    createWorkDoneProgress(): Promise<WorkDoneProgressServerReporter>;
}
interface ResultProgressReporter<R> {
    report(data: R): void;
}

interface Configuration {
    getConfiguration(): Promise<any>;
    getConfiguration(section: string): Promise<any>;
    getConfiguration(item: ConfigurationItem): Promise<any>;
    getConfiguration(items: ConfigurationItem[]): Promise<any[]>;
}

interface WorkspaceFolders {
    getWorkspaceFolders(): Promise<WorkspaceFolder[] | null>;
    onDidChangeWorkspaceFolders: Event<WorkspaceFoldersChangeEvent>;
}

/**
 * Shape of the call hierarchy feature
 *
 * @since 3.16.0
 */
interface CallHierarchy {
    callHierarchy: {
        onPrepare(handler: ServerRequestHandler<CallHierarchyPrepareParams, CallHierarchyItem[] | null, never, void>): Disposable$1;
        onIncomingCalls(handler: ServerRequestHandler<CallHierarchyIncomingCallsParams, CallHierarchyIncomingCall[] | null, CallHierarchyIncomingCall[], void>): Disposable$1;
        onOutgoingCalls(handler: ServerRequestHandler<CallHierarchyOutgoingCallsParams, CallHierarchyOutgoingCall[] | null, CallHierarchyOutgoingCall[], void>): Disposable$1;
    };
}

/**
 * Shape of the semantic token feature
 *
 * @since 3.16.0
 */
interface SemanticTokensFeatureShape {
    semanticTokens: {
        refresh(): void;
        on(handler: ServerRequestHandler<SemanticTokensParams, SemanticTokens, SemanticTokensPartialResult, void>): Disposable$1;
        onDelta(handler: ServerRequestHandler<SemanticTokensDeltaParams, SemanticTokensDelta | SemanticTokens, SemanticTokensDeltaPartialResult | SemanticTokensPartialResult, void>): Disposable$1;
        onRange(handler: ServerRequestHandler<SemanticTokensRangeParams, SemanticTokens, SemanticTokensPartialResult, void>): Disposable$1;
    };
}
declare class SemanticTokensBuilder$1 {
    private _id;
    private _prevLine;
    private _prevChar;
    private _data;
    private _dataLen;
    private _prevData;
    constructor();
    private initialize;
    push(line: number, char: number, length: number, tokenType: number, tokenModifiers: number): void;
    get id(): string;
    previousResult(id: string): void;
    build(): SemanticTokens;
    canBuildEdits(): boolean;
    buildEdits(): SemanticTokens | SemanticTokensDelta;
}

interface ShowDocumentFeatureShape {
    showDocument(params: ShowDocumentParams): Promise<ShowDocumentResult>;
}

/**
 * Shape of the file operations feature
 *
 * @since 3.16.0
 */
interface FileOperationsFeatureShape {
    onDidCreateFiles(handler: NotificationHandler<CreateFilesParams>): Disposable$1;
    onDidRenameFiles(handler: NotificationHandler<RenameFilesParams>): Disposable$1;
    onDidDeleteFiles(handler: NotificationHandler<DeleteFilesParams>): Disposable$1;
    onWillCreateFiles(handler: RequestHandler<CreateFilesParams, WorkspaceEdit | null, never>): Disposable$1;
    onWillRenameFiles(handler: RequestHandler<RenameFilesParams, WorkspaceEdit | null, never>): Disposable$1;
    onWillDeleteFiles(handler: RequestHandler<DeleteFilesParams, WorkspaceEdit | null, never>): Disposable$1;
}

/**
 * Shape of the linked editing feature
 *
 * @since 3.16.0
 */
interface LinkedEditingRangeFeatureShape {
    /**
     * Installs a handler for the linked editing range request.
     *
     * @param handler The corresponding handler.
     */
    onLinkedEditingRange(handler: ServerRequestHandler<LinkedEditingRangeParams, LinkedEditingRanges | undefined | null, never, never>): Disposable$1;
}

/**
 * Shape of the type hierarchy feature
 *
 * @since 3.17.0
 */
interface TypeHierarchyFeatureShape {
    typeHierarchy: {
        onPrepare(handler: ServerRequestHandler<TypeHierarchyPrepareParams, TypeHierarchyItem[] | null, never, void>): Disposable$1;
        onSupertypes(handler: ServerRequestHandler<TypeHierarchySupertypesParams, TypeHierarchyItem[] | null, TypeHierarchyItem[], void>): Disposable$1;
        onSubtypes(handler: ServerRequestHandler<TypeHierarchySubtypesParams, TypeHierarchyItem[] | null, TypeHierarchyItem[], void>): Disposable$1;
    };
}

/**
 * Shape of the inline values feature
 *
 * @since 3.17.0
 */
interface InlineValueFeatureShape {
    inlineValue: {
        /**
         * Ask the client to refresh all inline values.
         */
        refresh(): Promise<void>;
        /**
         * Installs a handler for the inline values request.
         *
         * @param handler The corresponding handler.
         */
        on(handler: ServerRequestHandler<InlineValueParams, InlineValue[] | undefined | null, InlineValue[], void>): Disposable$1;
    };
}

/**
 * Shape of the folding range feature
 */
interface FoldingRangeFeatureShape {
    foldingRange: {
        /**
         * Ask the client to refresh all folding ranges
         *
         * @since 3.18.0.
         * @proposed
         */
        refresh(): Promise<void>;
        /**
         * Installs a handler for the folding range request.
         *
         * @param handler The corresponding handler.
         */
        on(handler: ServerRequestHandler<FoldingRangeParams, FoldingRange[] | undefined | null, FoldingRange[], void>): Disposable$1;
    };
}

/**
 * Shape of the inlay hints feature
 *
 * @since 3.17.0
 */
interface InlayHintFeatureShape {
    inlayHint: {
        /**
         * Ask the client to refresh all inlay hints.
         */
        refresh(): Promise<void>;
        /**
         * Installs a handler for the inlay hints request.
         *
         * @param handler The corresponding handler.
         */
        on(handler: ServerRequestHandler<InlayHintParams, InlayHint[] | undefined | null, InlayHint[], void>): Disposable$1;
        /**
         * Installs a handler for the inlay hint resolve request.
         *
         * @param handler The corresponding handler.
         */
        resolve(handler: RequestHandler<InlayHint, InlayHint, void>): Disposable$1;
    };
}

/**
 * Shape of the linked editing feature
 *
 * @since 3.16.0
 */
interface DiagnosticFeatureShape {
    diagnostics: {
        /**
        * Asks the client to refresh all diagnostics provided by this server by
        * pull for the corresponding documents again.
        */
        refresh(): void;
        /**
        * Installs a handler for the document diagnostic request.
        *
        * @param handler The corresponding handler.
        */
        on(handler: ServerRequestHandler<DocumentDiagnosticParams, DocumentDiagnosticReport, DocumentDiagnosticReportPartialResult, DiagnosticServerCancellationData>): Disposable$1;
        /**
         * Installs a handler for the workspace diagnostic request.
         *
         * @param handler The corresponding handler.
         */
        onWorkspace(handler: ServerRequestHandler<WorkspaceDiagnosticParams, WorkspaceDiagnosticReport, WorkspaceDiagnosticReportPartialResult, DiagnosticServerCancellationData>): Disposable$1;
    };
}

/**
 * Event to signal changes to a text document.
 */
interface TextDocumentChangeEvent<T> {
    /**
     * The document that has changed.
     */
    document: T;
}
/**
 * Event to signal that a document will be saved.
 */
interface TextDocumentWillSaveEvent<T> {
    /**
     * The document that will be saved
     */
    document: T;
    /**
     * The reason why save was triggered.
     */
    reason: TextDocumentSaveReason;
}

/**
 * Shape of the notebooks feature
 *
 * @since 3.17.0
 */
interface NotebookSyncFeatureShape {
    synchronization: {
        onDidOpenNotebookDocument(handler: NotificationHandler1<DidOpenNotebookDocumentParams>): Disposable$1;
        onDidChangeNotebookDocument(handler: NotificationHandler1<DidChangeNotebookDocumentParams>): Disposable$1;
        onDidSaveNotebookDocument(handler: NotificationHandler1<DidSaveNotebookDocumentParams>): Disposable$1;
        onDidCloseNotebookDocument(handler: NotificationHandler1<DidCloseNotebookDocumentParams>): Disposable$1;
    };
}

/**
 * Shape of the moniker feature
 *
 * @since 3.16.0
 */
interface MonikerFeatureShape {
    moniker: {
        on(handler: ServerRequestHandler<MonikerParams, Moniker[] | null, Moniker[], void>): Disposable$1;
    };
}

interface FeatureBase {
    /**
     * Called to initialize the remote with the given
     * client capabilities
     *
     * @param capabilities The client capabilities
     */
    initialize(capabilities: ClientCapabilities): void;
    /**
     * Called to fill in the server capabilities this feature implements.
     *
     * @param capabilities The server capabilities to fill.
     */
    fillServerCapabilities(capabilities: ServerCapabilities): void;
}
/**
 * The RemoteConsole interface contains all functions to interact with
 * the tools / clients console or log system. Internally it used `window/logMessage`
 * notifications.
 */
interface RemoteConsole extends FeatureBase {
    /**
     * The connection this remote is attached to.
     */
    connection: Connection;
    /**
     * Show an error message.
     *
     * @param message The message to show.
     */
    error(message: string): void;
    /**
     * Show a warning message.
     *
     * @param message The message to show.
     */
    warn(message: string): void;
    /**
     * Show an information message.
     *
     * @param message The message to show.
     */
    info(message: string): void;
    /**
     * Log a message.
     *
     * @param message The message to log.
     */
    log(message: string): void;
    /**
     * Log a debug message.
     *
     * @param message The message to log.
     *
     * @since 3.18.0
     */
    debug(message: string): void;
}
/**
 * The RemoteWindow interface contains all functions to interact with
 * the visual window of VS Code.
 */
interface _RemoteWindow extends FeatureBase {
    /**
     * The connection this remote is attached to.
     */
    connection: Connection;
    /**
     * Shows an error message in the client's user interface. Depending on the client this might
     * be a modal dialog with a confirmation button or a notification in a notification center
     *
     * @param message The message to show.
     * @param actions Possible additional actions presented in the user interface. The selected action
     *  will be the value of the resolved promise
     */
    showErrorMessage(message: string): void;
    showErrorMessage<T extends MessageActionItem>(message: string, ...actions: T[]): Promise<T | undefined>;
    /**
     * Shows a warning message in the client's user interface. Depending on the client this might
     * be a modal dialog with a confirmation button or a notification in a notification center
     *
     * @param message The message to show.
     * @param actions Possible additional actions presented in the user interface. The selected action
     *  will be the value of the resolved promise
     */
    showWarningMessage(message: string): void;
    showWarningMessage<T extends MessageActionItem>(message: string, ...actions: T[]): Promise<T | undefined>;
    /**
     * Shows an information message in the client's user interface. Depending on the client this might
     * be a modal dialog with a confirmation button or a notification in a notification center
     *
     * @param message The message to show.
     * @param actions Possible additional actions presented in the user interface. The selected action
     *  will be the value of the resolved promise
     */
    showInformationMessage(message: string): void;
    showInformationMessage<T extends MessageActionItem>(message: string, ...actions: T[]): Promise<T | undefined>;
}
type RemoteWindow = _RemoteWindow & WindowProgress & ShowDocumentFeatureShape;
/**
 * A bulk registration manages n single registration to be able to register
 * for n notifications or requests using one register request.
 */
interface BulkRegistration {
    /**
     * Adds a single registration.
     * @param type the notification type to register for.
     * @param registerParams special registration parameters.
     */
    add<RO>(type: ProtocolNotificationType0<RO>, registerParams: RO): void;
    add<P, RO>(type: ProtocolNotificationType<P, RO>, registerParams: RO): void;
    /**
     * Adds a single registration.
     * @param type the request type to register for.
     * @param registerParams special registration parameters.
     */
    add<R, PR, E, RO>(type: ProtocolRequestType0<R, PR, E, RO>, registerParams: RO): void;
    add<P, PR, R, E, RO>(type: ProtocolRequestType<P, PR, R, E, RO>, registerParams: RO): void;
    /**
     * Adds a single registration.
     * @param type the notification type to register for.
     * @param registerParams special registration parameters.
     */
    add<RO>(type: RegistrationType<RO>, registerParams: RO): void;
}
declare namespace BulkRegistration {
    /**
     * Creates a new bulk registration.
     * @return an empty bulk registration.
     */
    function create(): BulkRegistration;
}
/**
 * A `BulkUnregistration` manages n unregistrations.
 */
interface BulkUnregistration extends Disposable$1 {
    /**
     * Disposes a single registration. It will be removed from the
     * `BulkUnregistration`.
     */
    disposeSingle(arg: string | MessageSignature): boolean;
}
declare namespace BulkUnregistration {
    function create(): BulkUnregistration;
}
/**
 * Interface to register and unregister `listeners` on the client / tools side.
 */
interface RemoteClient extends FeatureBase {
    /**
     * The connection this remote is attached to.
     */
    connection: Connection;
    /**
     * Registers a listener for the given request.
     *
     * @param type the request type to register for.
     * @param registerParams special registration parameters.
     * @return a `Disposable` to unregister the listener again.
     */
    register<P, RO>(type: ProtocolNotificationType<P, RO>, registerParams?: RO): Promise<Disposable$1>;
    register<RO>(type: ProtocolNotificationType0<RO>, registerParams?: RO): Promise<Disposable$1>;
    /**
     * Registers a listener for the given request.
     *
     * @param unregisteration the unregistration to add a corresponding unregister action to.
     * @param type the request type to register for.
     * @param registerParams special registration parameters.
     * @return the updated unregistration.
     */
    register<P, RO>(unregisteration: BulkUnregistration, type: ProtocolNotificationType<P, RO>, registerParams?: RO): Promise<Disposable$1>;
    register<RO>(unregisteration: BulkUnregistration, type: ProtocolNotificationType0<RO>, registerParams?: RO): Promise<Disposable$1>;
    /**
     * Registers a listener for the given request.
     *
     * @param type the request type to register for.
     * @param registerParams special registration parameters.
     * @return a `Disposable` to unregister the listener again.
     */
    register<P, R, PR, E, RO>(type: ProtocolRequestType<P, R, PR, E, RO>, registerParams?: RO): Promise<Disposable$1>;
    register<R, PR, E, RO>(type: ProtocolRequestType0<R, PR, E, RO>, registerParams?: RO): Promise<Disposable$1>;
    /**
     * Registers a listener for the given request.
     *
     * @param unregisteration the unregistration to add a corresponding unregister action to.
     * @param type the request type to register for.
     * @param registerParams special registration parameters.
     * @return the updated unregistration.
     */
    register<P, R, PR, E, RO>(unregisteration: BulkUnregistration, type: ProtocolRequestType<P, R, PR, E, RO>, registerParams?: RO): Promise<Disposable$1>;
    register<R, PR, E, RO>(unregisteration: BulkUnregistration, type: ProtocolRequestType0<R, PR, E, RO>, registerParams?: RO): Promise<Disposable$1>;
    /**
     * Registers a listener for the given registration type.
     *
     * @param type the registration type.
     * @param registerParams special registration parameters.
     * @return a `Disposable` to unregister the listener again.
     */
    register<RO>(type: RegistrationType<RO>, registerParams?: RO): Promise<Disposable$1>;
    /**
     * Registers a listener for the given registration type.
     *
     * @param unregisteration the unregistration to add a corresponding unregister action to.
     * @param type the registration type.
     * @param registerParams special registration parameters.
     * @return the updated unregistration.
     */
    register<RO>(unregisteration: BulkUnregistration, type: RegistrationType<RO>, registerParams?: RO): Promise<Disposable$1>;
    /**
     * Registers a set of listeners.
     * @param registrations the bulk registration
     * @return a `Disposable` to unregister the listeners again.
     */
    register(registrations: BulkRegistration): Promise<BulkUnregistration>;
}
/**
 * Represents the workspace managed by the client.
 */
interface _RemoteWorkspace extends FeatureBase {
    /**
     * The connection this remote is attached to.
     */
    connection: Connection;
    /**
     * Applies a `WorkspaceEdit` to the workspace
     * @param param the workspace edit params.
     * @return a thenable that resolves to the `ApplyWorkspaceEditResponse`.
     */
    applyEdit(paramOrEdit: ApplyWorkspaceEditParams | WorkspaceEdit): Promise<ApplyWorkspaceEditResponse>;
}
type RemoteWorkspace = _RemoteWorkspace & Configuration & WorkspaceFolders & FileOperationsFeatureShape;
/**
 * Interface to log telemetry events. The events are actually send to the client
 * and the client needs to feed the event into a proper telemetry system.
 */
interface Telemetry extends FeatureBase {
    /**
     * The connection this remote is attached to.
     */
    connection: Connection;
    /**
     * Log the given data to telemetry.
     *
     * @param data The data to log. Must be a JSON serializable object.
     */
    logEvent(data: any): void;
}
/**
 * Interface to log traces to the client. The events are sent to the client and the
 * client needs to log the trace events.
 */
interface RemoteTracer extends FeatureBase {
    /**
     * The connection this remote is attached to.
     */
    connection: Connection;
    /**
     * Log the given data to the trace Log
     */
    log(message: string, verbose?: string): void;
}
interface _Languages extends FeatureBase {
    connection: Connection;
    attachWorkDoneProgress(params: WorkDoneProgressParams): WorkDoneProgressReporter;
    attachPartialResultProgress<PR>(type: ProgressType<PR>, params: PartialResultParams): ResultProgressReporter<PR> | undefined;
}
type Languages = _Languages & CallHierarchy & SemanticTokensFeatureShape & LinkedEditingRangeFeatureShape & TypeHierarchyFeatureShape & InlineValueFeatureShape & InlayHintFeatureShape & DiagnosticFeatureShape & MonikerFeatureShape & FoldingRangeFeatureShape;
interface _Notebooks extends FeatureBase {
    connection: Connection;
    attachWorkDoneProgress(params: WorkDoneProgressParams): WorkDoneProgressReporter;
    attachPartialResultProgress<PR>(type: ProgressType<PR>, params: PartialResultParams): ResultProgressReporter<PR> | undefined;
}
type Notebooks = _Notebooks & NotebookSyncFeatureShape;
/**
 * An empty interface for new proposed API.
 */
interface _ {
}
interface ServerRequestHandler<P, R, PR, E> {
    (params: P, token: CancellationToken, workDoneProgress: WorkDoneProgressReporter, resultProgress?: ResultProgressReporter<PR>): HandlerResult<R, E>;
}
/**
 * Interface to describe the shape of the server connection.
 */
interface _Connection<PConsole = _, PTracer = _, PTelemetry = _, PClient = _, PWindow = _, PWorkspace = _, PLanguages = _, PNotebooks = _> {
    /**
     * Start listening on the input stream for messages to process.
     */
    listen(): void;
    /**
     * Installs a request handler described by the given {@link RequestType}.
     *
     * @param type The {@link RequestType} describing the request.
     * @param handler The handler to install
     */
    onRequest<R, PR, E, RO>(type: ProtocolRequestType0<R, PR, E, RO>, handler: RequestHandler0<R, E>): Disposable$1;
    onRequest<P, R, PR, E, RO>(type: ProtocolRequestType<P, R, PR, E, RO>, handler: RequestHandler<P, R, E>): Disposable$1;
    onRequest<R, PR, E, RO>(type: RequestType0<R, E>, handler: RequestHandler0<R, E>): Disposable$1;
    onRequest<P, R, E>(type: RequestType<P, R, E>, handler: RequestHandler<P, R, E>): Disposable$1;
    /**
     * Installs a request handler for the given method.
     *
     * @param method The method to register a request handler for.
     * @param handler The handler to install.
     */
    onRequest<R, E>(method: string, handler: GenericRequestHandler<R, E>): Disposable$1;
    /**
     * Installs a request handler that is invoked if no specific request handler can be found.
     *
     * @param handler a handler that handles all requests.
     */
    onRequest(handler: StarRequestHandler): Disposable$1;
    /**
     * Send a request to the client.
     *
     * @param type The {@link RequestType} describing the request.
     * @param params The request's parameters.
     */
    sendRequest<R, PR, E, RO>(type: ProtocolRequestType0<R, PR, E, RO>, token?: CancellationToken): Promise<R>;
    sendRequest<P, R, PR, E, RO>(type: ProtocolRequestType<P, R, PR, E, RO>, params: P, token?: CancellationToken): Promise<R>;
    sendRequest<R, E>(type: RequestType0<R, E>, token?: CancellationToken): Promise<R>;
    sendRequest<P, R, E>(type: RequestType<P, R, E>, params: P, token?: CancellationToken): Promise<R>;
    /**
     * Send a request to the client.
     *
     * @param method The method to invoke on the client.
     * @param params The request's parameters.
     */
    sendRequest<R>(method: string, token?: CancellationToken): Promise<R>;
    sendRequest<R>(method: string, params: any, token?: CancellationToken): Promise<R>;
    /**
     * Installs a notification handler described by the given {@link NotificationType}.
     *
     * @param type The {@link NotificationType} describing the notification.
     * @param handler The handler to install.
     */
    onNotification<RO>(type: ProtocolNotificationType0<RO>, handler: NotificationHandler0): Disposable$1;
    onNotification<P, RO>(type: ProtocolNotificationType<P, RO>, handler: NotificationHandler<P>): Disposable$1;
    onNotification(type: NotificationType0, handler: NotificationHandler0): Disposable$1;
    onNotification<P>(type: NotificationType<P>, handler: NotificationHandler<P>): Disposable$1;
    /**
     * Installs a notification handler for the given method.
     *
     * @param method The method to register a request handler for.
     * @param handler The handler to install.
     */
    onNotification(method: string, handler: GenericNotificationHandler): Disposable$1;
    /**
     * Installs a notification handler that is invoked if no specific notification handler can be found.
     *
     * @param handler a handler that handles all notifications.
     */
    onNotification(handler: StarNotificationHandler): Disposable$1;
    /**
     * Send a notification to the client.
     *
     * @param type The {@link NotificationType} describing the notification.
     * @param params The notification's parameters.
     */
    sendNotification<RO>(type: ProtocolNotificationType0<RO>): Promise<void>;
    sendNotification<P, RO>(type: ProtocolNotificationType<P, RO>, params: P): Promise<void>;
    sendNotification(type: NotificationType0): Promise<void>;
    sendNotification<P>(type: NotificationType<P>, params: P): Promise<void>;
    /**
     * Send a notification to the client.
     *
     * @param method The method to invoke on the client.
     * @param params The notification's parameters.
     */
    sendNotification(method: string, params?: any): Promise<void>;
    /**
     * Installs a progress handler for a given token.
     * @param type the progress type
     * @param token the token
     * @param handler the handler
     */
    onProgress<P>(type: ProgressType<P>, token: string | number, handler: NotificationHandler<P>): Disposable$1;
    /**
     * Sends progress.
     * @param type the progress type
     * @param token the token to use
     * @param value the progress value
     */
    sendProgress<P>(type: ProgressType<P>, token: string | number, value: P): Promise<void>;
    /**
     * Installs a handler for the initialize request.
     *
     * @param handler The initialize handler.
     */
    onInitialize(handler: ServerRequestHandler<InitializeParams, InitializeResult, never, InitializeError>): Disposable$1;
    /**
     * Installs a handler for the initialized notification.
     *
     * @param handler The initialized handler.
     */
    onInitialized(handler: NotificationHandler<InitializedParams>): Disposable$1;
    /**
     * Installs a handler for the shutdown request.
     *
     * @param handler The initialize handler.
     */
    onShutdown(handler: RequestHandler0<void, void>): Disposable$1;
    /**
     * Installs a handler for the exit notification.
     *
     * @param handler The exit handler.
     */
    onExit(handler: NotificationHandler0): Disposable$1;
    /**
     * A property to provide access to console specific features.
     */
    console: RemoteConsole & PConsole;
    /**
     * A property to provide access to tracer specific features.
     */
    tracer: RemoteTracer & PTracer;
    /**
     * A property to provide access to telemetry specific features.
     */
    telemetry: Telemetry & PTelemetry;
    /**
     * A property to provide access to client specific features like registering
     * for requests or notifications.
     */
    client: RemoteClient & PClient;
    /**
     * A property to provide access to windows specific features.
     */
    window: RemoteWindow & PWindow;
    /**
     * A property to provide access to workspace specific features.
     */
    workspace: RemoteWorkspace & PWorkspace;
    /**
     * A property to provide access to language specific features.
     */
    languages: Languages & PLanguages;
    /**
     * A property to provide access to notebook specific features.
     */
    notebooks: Notebooks & PNotebooks;
    /**
     * Installs a handler for the `DidChangeConfiguration` notification.
     *
     * @param handler The corresponding handler.
     */
    onDidChangeConfiguration(handler: NotificationHandler<DidChangeConfigurationParams>): Disposable$1;
    /**
     * Installs a handler for the `DidChangeWatchedFiles` notification.
     *
     * @param handler The corresponding handler.
     */
    onDidChangeWatchedFiles(handler: NotificationHandler<DidChangeWatchedFilesParams>): Disposable$1;
    /**
     * Installs a handler for the `DidOpenTextDocument` notification.
     *
     * @param handler The corresponding handler.
     */
    onDidOpenTextDocument(handler: NotificationHandler<DidOpenTextDocumentParams>): Disposable$1;
    /**
     * Installs a handler for the `DidChangeTextDocument` notification.
     *
     * @param handler The corresponding handler.
     */
    onDidChangeTextDocument(handler: NotificationHandler<DidChangeTextDocumentParams>): Disposable$1;
    /**
     * Installs a handler for the `DidCloseTextDocument` notification.
     *
     * @param handler The corresponding handler.
     */
    onDidCloseTextDocument(handler: NotificationHandler<DidCloseTextDocumentParams>): Disposable$1;
    /**
     * Installs a handler for the `WillSaveTextDocument` notification.
     *
     * Note that this notification is opt-in. The client will not send it unless
     * your server has the `textDocumentSync.willSave` capability or you've
     * dynamically registered for the `textDocument/willSave` method.
     *
     * @param handler The corresponding handler.
     */
    onWillSaveTextDocument(handler: NotificationHandler<WillSaveTextDocumentParams>): Disposable$1;
    /**
     * Installs a handler for the `WillSaveTextDocumentWaitUntil` request.
     *
     * Note that this request is opt-in. The client will not send it unless
     * your server has the `textDocumentSync.willSaveWaitUntil` capability,
     * or you've dynamically registered for the `textDocument/willSaveWaitUntil`
     * method.
     *
     * @param handler The corresponding handler.
     */
    onWillSaveTextDocumentWaitUntil(handler: RequestHandler<WillSaveTextDocumentParams, TextEdit$1[] | undefined | null, void>): Disposable$1;
    /**
     * Installs a handler for the `DidSaveTextDocument` notification.
     *
     * @param handler The corresponding handler.
     */
    onDidSaveTextDocument(handler: NotificationHandler<DidSaveTextDocumentParams>): Disposable$1;
    /**
     * Sends diagnostics computed for a given document to VSCode to render them in the
     * user interface.
     *
     * @param params The diagnostic parameters.
     */
    sendDiagnostics(params: PublishDiagnosticsParams): Promise<void>;
    /**
     * Installs a handler for the `Hover` request.
     *
     * @param handler The corresponding handler.
     */
    onHover(handler: ServerRequestHandler<HoverParams, Hover | undefined | null, never, void>): Disposable$1;
    /**
     * Installs a handler for the `Completion` request.
     *
     * @param handler The corresponding handler.
     */
    onCompletion(handler: ServerRequestHandler<CompletionParams, CompletionItem[] | CompletionList | undefined | null, CompletionItem[], void>): Disposable$1;
    /**
     * Installs a handler for the `CompletionResolve` request.
     *
     * @param handler The corresponding handler.
     */
    onCompletionResolve(handler: RequestHandler<CompletionItem, CompletionItem, void>): Disposable$1;
    /**
     * Installs a handler for the `SignatureHelp` request.
     *
     * @param handler The corresponding handler.
     */
    onSignatureHelp(handler: ServerRequestHandler<SignatureHelpParams, SignatureHelp | undefined | null, never, void>): Disposable$1;
    /**
     * Installs a handler for the `Declaration` request.
     *
     * @param handler The corresponding handler.
     */
    onDeclaration(handler: ServerRequestHandler<DeclarationParams, Declaration$1 | DeclarationLink[] | undefined | null, Location[] | DeclarationLink[], void>): Disposable$1;
    /**
     * Installs a handler for the `Definition` request.
     *
     * @param handler The corresponding handler.
     */
    onDefinition(handler: ServerRequestHandler<DefinitionParams, Definition | DefinitionLink[] | undefined | null, Location[] | DefinitionLink[], void>): Disposable$1;
    /**
     * Installs a handler for the `Type Definition` request.
     *
     * @param handler The corresponding handler.
     */
    onTypeDefinition(handler: ServerRequestHandler<TypeDefinitionParams, Definition | DefinitionLink[] | undefined | null, Location[] | DefinitionLink[], void>): Disposable$1;
    /**
     * Installs a handler for the `Implementation` request.
     *
     * @param handler The corresponding handler.
     */
    onImplementation(handler: ServerRequestHandler<ImplementationParams, Definition | DefinitionLink[] | undefined | null, Location[] | DefinitionLink[], void>): Disposable$1;
    /**
     * Installs a handler for the `References` request.
     *
     * @param handler The corresponding handler.
     */
    onReferences(handler: ServerRequestHandler<ReferenceParams, Location[] | undefined | null, Location[], void>): Disposable$1;
    /**
     * Installs a handler for the `DocumentHighlight` request.
     *
     * @param handler The corresponding handler.
     */
    onDocumentHighlight(handler: ServerRequestHandler<DocumentHighlightParams, DocumentHighlight[] | undefined | null, DocumentHighlight[], void>): Disposable$1;
    /**
     * Installs a handler for the `DocumentSymbol` request.
     *
     * @param handler The corresponding handler.
     */
    onDocumentSymbol(handler: ServerRequestHandler<DocumentSymbolParams, SymbolInformation[] | DocumentSymbol[] | undefined | null, SymbolInformation[] | DocumentSymbol[], void>): Disposable$1;
    /**
     * Installs a handler for the `WorkspaceSymbol` request.
     *
     * @param handler The corresponding handler.
     */
    onWorkspaceSymbol(handler: ServerRequestHandler<WorkspaceSymbolParams, SymbolInformation[] | WorkspaceSymbol[] | undefined | null, SymbolInformation[], void>): Disposable$1;
    /**
     * Installs a handler for the `WorkspaceSymbol` request.
     *
     * @param handler The corresponding handler.
     */
    onWorkspaceSymbolResolve(handler: RequestHandler<WorkspaceSymbol, WorkspaceSymbol, void>): Disposable$1;
    /**
     * Installs a handler for the `CodeAction` request.
     *
     * @param handler The corresponding handler.
     */
    onCodeAction(handler: ServerRequestHandler<CodeActionParams, (Command | CodeAction)[] | undefined | null, (Command | CodeAction)[], void>): Disposable$1;
    /**
     * Installs a handler for the `CodeAction` resolve request.
     *
     * @param handler The corresponding handler.
     */
    onCodeActionResolve(handler: RequestHandler<CodeAction, CodeAction, void>): Disposable$1;
    /**
     * Compute a list of {@link CodeLens lenses}. This call should return as fast as possible and if
     * computing the commands is expensive implementers should only return code lens objects with the
     * range set and handle the resolve request.
     *
     * @param handler The corresponding handler.
     */
    onCodeLens(handler: ServerRequestHandler<CodeLensParams, CodeLens[] | undefined | null, CodeLens[], void>): Disposable$1;
    /**
     * This function will be called for each visible code lens, usually when scrolling and after
     * the onCodeLens has been called.
     *
     * @param handler The corresponding handler.
     */
    onCodeLensResolve(handler: RequestHandler<CodeLens, CodeLens, void>): Disposable$1;
    /**
     * Installs a handler for the document formatting request.
     *
     * @param handler The corresponding handler.
     */
    onDocumentFormatting(handler: ServerRequestHandler<DocumentFormattingParams, TextEdit$1[] | undefined | null, never, void>): Disposable$1;
    /**
     * Installs a handler for the document range formatting request.
     *
     * @param handler The corresponding handler.
     */
    onDocumentRangeFormatting(handler: ServerRequestHandler<DocumentRangeFormattingParams, TextEdit$1[] | undefined | null, never, void>): Disposable$1;
    /**
     * Installs a handler for the document on type formatting request.
     *
     * @param handler The corresponding handler.
     */
    onDocumentOnTypeFormatting(handler: RequestHandler<DocumentOnTypeFormattingParams, TextEdit$1[] | undefined | null, void>): Disposable$1;
    /**
     * Installs a handler for the rename request.
     *
     * @param handler The corresponding handler.
     */
    onRenameRequest(handler: ServerRequestHandler<RenameParams, WorkspaceEdit | undefined | null, never, void>): Disposable$1;
    /**
     * Installs a handler for the prepare rename request.
     *
     * @param handler The corresponding handler.
     */
    onPrepareRename(handler: RequestHandler<PrepareRenameParams, Range$1 | {
        range: Range$1;
        placeholder: string;
    } | {
        defaultBehavior: boolean;
    } | undefined | null, void>): Disposable$1;
    /**
     * Installs a handler for the document links request.
     *
     * @param handler The corresponding handler.
     */
    onDocumentLinks(handler: ServerRequestHandler<DocumentLinkParams, DocumentLink[] | undefined | null, DocumentLink[], void>): Disposable$1;
    /**
     * Installs a handler for the document links resolve request.
     *
     * @param handler The corresponding handler.
     */
    onDocumentLinkResolve(handler: RequestHandler<DocumentLink, DocumentLink | undefined | null, void>): Disposable$1;
    /**
     * Installs a handler for the document color request.
     *
     * @param handler The corresponding handler.
     */
    onDocumentColor(handler: ServerRequestHandler<DocumentColorParams, ColorInformation[] | undefined | null, ColorInformation[], void>): Disposable$1;
    /**
     * Installs a handler for the document color request.
     *
     * @param handler The corresponding handler.
     */
    onColorPresentation(handler: ServerRequestHandler<ColorPresentationParams, ColorPresentation[] | undefined | null, ColorPresentation[], void>): Disposable$1;
    /**
     * Installs a handler for the folding ranges request.
     *
     * @param handler The corresponding handler.
     */
    onFoldingRanges(handler: ServerRequestHandler<FoldingRangeParams, FoldingRange[] | undefined | null, FoldingRange[], void>): Disposable$1;
    /**
     * Installs a handler for the selection ranges request.
     *
     * @param handler The corresponding handler.
     */
    onSelectionRanges(handler: ServerRequestHandler<SelectionRangeParams, SelectionRange[] | undefined | null, SelectionRange[], void>): Disposable$1;
    /**
     * Installs a handler for the execute command request.
     *
     * @param handler The corresponding handler.
     */
    onExecuteCommand(handler: ServerRequestHandler<ExecuteCommandParams, any | undefined | null, never, void>): Disposable$1;
    /**
     * Disposes the connection
     */
    dispose(): void;
}
interface Connection extends _Connection {
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling call hierarchy requests.
 */
interface CallHierarchyProvider {
    prepareCallHierarchy(document: LangiumDocument, params: CallHierarchyPrepareParams, cancelToken?: CancellationToken): MaybePromise<CallHierarchyItem[] | undefined>;
    incomingCalls(params: CallHierarchyIncomingCallsParams, cancelToken?: CancellationToken): MaybePromise<CallHierarchyIncomingCall[] | undefined>;
    outgoingCalls(params: CallHierarchyOutgoingCallsParams, cancelToken?: CancellationToken): MaybePromise<CallHierarchyOutgoingCall[] | undefined>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface CodeActionProvider {
    /**
     * Handle a code action request.
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getCodeActions(document: LangiumDocument, params: CodeActionParams, cancelToken?: CancellationToken): MaybePromise<Array<Command | CodeAction> | undefined>;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface CodeLensProvider {
    provideCodeLens(document: LangiumDocument, params: CodeLensParams, cancelToken?: CancellationToken): MaybePromise<CodeLens[] | undefined>;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling go to declaration requests
 */
interface DeclarationProvider {
    /**
     * Handle a go to declaration request.
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getDeclaration(document: LangiumDocument, params: DeclarationParams, cancelToken?: CancellationToken): MaybePromise<LocationLink[] | undefined>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling go to definition requests.
 */
interface DefinitionProvider {
    /**
     * Handle a go to definition request.
     *
     * @param document The document in which the request was triggered.
     * @param params The parameters of the request.
     * @param cancelToken A cancellation token that can be used to cancel the request.
     * @returns A list of location links to the definition(s) of the symbol at the given position.
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getDefinition(document: LangiumDocument, params: DefinitionParams, cancelToken?: CancellationToken): MaybePromise<LocationLink[] | undefined>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling document highlight requests.
 */
interface DocumentHighlightProvider {
    /**
     * Handle a document highlight request.
     *
     * @param document The document in which the request was received.
     * @param params The parameters of the document highlight request.
     * @param cancelToken A cancellation token that can be used to cancel the request.
     * @returns The document highlights or `undefined` if no highlights are available.
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getDocumentHighlight(document: LangiumDocument, params: DocumentHighlightParams, cancelToken?: CancellationToken): MaybePromise<DocumentHighlight[] | undefined>;
}
declare class DefaultDocumentHighlightProvider implements DocumentHighlightProvider {
    protected readonly references: References;
    protected readonly nameProvider: NameProvider;
    protected readonly grammarConfig: GrammarConfig;
    constructor(services: LangiumServices);
    getDocumentHighlight(document: LangiumDocument, params: DocumentHighlightParams, _cancelToken?: CancellationToken): MaybePromise<DocumentHighlight[] | undefined>;
    /**
    * Override this method to determine the highlight kind of the given reference.
    */
    protected createDocumentHighlight(reference: ReferenceDescription): DocumentHighlight;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling document link requests.
 */
interface DocumentLinkProvider {
    /**
     * Handle a document links request.
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getDocumentLinks(document: LangiumDocument, params: DocumentLinkParams, cancelToken?: CancellationToken): MaybePromise<DocumentLink[]>;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * This service consolidates the logic for gathering LSP kind information based on AST nodes or their descriptions.
 */
interface NodeKindProvider$1 {
    /**
     * Returns a `SymbolKind` as used by `WorkspaceSymbolProvider` or `DocumentSymbolProvider`.
     * @param node AST node or node description.
     * @returns The corresponding symbol kind.
     */
    getSymbolKind(node: AstNode | AstNodeDescription): SymbolKind;
    /**
     * Returns a `CompletionItemKind` as used by the `CompletionProvider`.
     * @param node AST node or node description.
     * @returns The corresponding completion item kind.
     */
    getCompletionItemKind(node: AstNode | AstNodeDescription): CompletionItemKind;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling document symbols requests.
 */
interface DocumentSymbolProvider {
    /**
     * Handle a document symbols request.
     *
     * @param document The document in the workspace.
     * @param params The parameters of the request.
     * @param cancelToken A cancellation token that migh be used to cancel the request.
     * @returns The symbols for the given document.
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getSymbols(document: LangiumDocument, params: DocumentSymbolParams, cancelToken?: CancellationToken): MaybePromise<DocumentSymbol[]>;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Shared service for handling text document changes and watching relevant files.
 */
interface DocumentUpdateHandler {
    /**
     * A document open event was triggered by the `TextDocuments` service.
     * @param event The document change event.
     */
    didOpenDocument?(event: TextDocumentChangeEvent<TextDocument>): void;
    /**
     * A content change event was triggered by the `TextDocuments` service.
     * @param event The document change event.
     */
    didChangeContent?(event: TextDocumentChangeEvent<TextDocument>): void;
    /**
     * A document save event (initiated) was triggered by the `TextDocuments` service.
     * @param event The document change event.
     */
    willSaveDocument?(event: TextDocumentWillSaveEvent<TextDocument>): void;
    /**
     * A document save event (initiated) was triggered by the `TextDocuments` service.
     * @param event The document change event.
     * @returns An array of text edits which will be applied to the document before it is saved.
     */
    willSaveDocumentWaitUntil?(event: TextDocumentWillSaveEvent<TextDocument>): MaybePromise<TextEdit$1[]>;
    /**
     * A document save event (completed) was triggered by the `TextDocuments` service.
     * @param event The document change event.
     */
    didSaveDocument?(event: TextDocumentChangeEvent<TextDocument>): void;
    /**
     * A document close event was triggered by the `TextDocuments` service.
     * @param event The document change event.
     */
    didCloseDocument?(event: TextDocumentChangeEvent<TextDocument>): void;
    /**
     * The client detected changes to files and folders watched by the language client.
     * @param params The files/folders change event.
     */
    didChangeWatchedFiles?(params: DidChangeWatchedFilesParams): void;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface ExecuteCommandHandler {
    get commands(): string[];
    executeCommand(name: string, args: any[], cancelToken?: CancellationToken): Promise<unknown>;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Shared service for handling file changes such as file creation, deletion and renaming.
 * The interface methods are optional, so they are only registered if they are implemented.
 */
interface FileOperationHandler {
    /**
     * These options are reported to the client as part of the ServerCapabilities.
     */
    readonly fileOperationOptions: FileOperationOptions;
    /**
     * Files were created from within the client.
     * This notification must be registered with the {@link fileOperationOptions}.
     */
    didCreateFiles?(params: CreateFilesParams): void;
    /**
     * Files were renamed from within the client.
     * This notification must be registered with the {@link fileOperationOptions}.
     */
    didRenameFiles?(params: RenameFilesParams): void;
    /**
     * Files were deleted from within the client.
     * This notification must be registered with the {@link fileOperationOptions}.
     */
    didDeleteFiles?(params: DeleteFilesParams): void;
    /**
     * Called before files are actually created as long as the creation is triggered from within
     * the client either by a user action or by applying a workspace edit.
     * This request must be registered with the {@link fileOperationOptions}.
     * @returns a WorkspaceEdit which will be applied to workspace before the files are created.
     */
    willCreateFiles?(params: CreateFilesParams): MaybePromise<WorkspaceEdit | null>;
    /**
     * Called before files are actually renamed as long as the rename is triggered from within
     * the client either by a user action or by applying a workspace edit.
     * This request must be registered with the {@link fileOperationOptions}.
     * @returns a WorkspaceEdit which will be applied to workspace before the files are renamed.
     */
    willRenameFiles?(params: RenameFilesParams): MaybePromise<WorkspaceEdit | null>;
    /**
     * Called before files are actually deleted as long as the deletion is triggered from within
     * the client either by a user action or by applying a workspace edit.
     * This request must be registered with the {@link fileOperationOptions}.
     * @returns a WorkspaceEdit which will be applied to workspace before the files are deleted.
     */
    willDeleteFiles?(params: DeleteFilesParams): MaybePromise<WorkspaceEdit | null>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling folding range requests.
 */
interface FoldingRangeProvider {
    /**
     * Handle a folding range request.
     *
     * @param document The document to compute folding ranges for
     * @param params The folding range parameters
     * @param cancelToken A cancellation token that can be used to cancel the request
     * @returns The computed folding ranges
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getFoldingRanges(document: LangiumDocument, params: FoldingRangeParams, cancelToken?: CancellationToken): MaybePromise<FoldingRange[]>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language specific service for handling formatting related LSP requests.
 */
interface Formatter {
    /**
     * Handles full document formatting.
     */
    formatDocument(document: LangiumDocument, params: DocumentFormattingParams, cancelToken?: CancellationToken): MaybePromise<TextEdit$1[]>;
    /**
     * Handles partial document formatting. Only parts of the document within the `params.range` property are formatted.
     */
    formatDocumentRange(document: LangiumDocument, params: DocumentRangeFormattingParams, cancelToken?: CancellationToken): MaybePromise<TextEdit$1[]>;
    /**
     * Handles document formatting while typing. Only formats the current line.
     */
    formatDocumentOnType(document: LangiumDocument, params: DocumentOnTypeFormattingParams, cancelToken?: CancellationToken): MaybePromise<TextEdit$1[]>;
    /**
     * Options that determine when the `formatDocumentOnType` method should be invoked by the language client.
     * When `undefined` is returned, document format on type will be disabled.
     */
    get formatOnTypeOptions(): DocumentOnTypeFormattingOptions | undefined;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
/**
 * This service implements a [fuzzy matching](https://en.wikipedia.org/wiki/Approximate_string_matching) method.
 */
interface FuzzyMatcher {
    /**
     * Performs [fuzzy matching](https://en.wikipedia.org/wiki/Approximate_string_matching).
     *
     * Fuzzy matching improves search/completion user experience by allowing to omit characters.
     * For example, a query such as `FuMa` matches the text `FuzzyMatcher`.
     *
     * @param query The user input search query.
     * @param text The text that should be matched against the query.
     * @returns Whether the query matches the text.
     */
    match(query: string, text: string): boolean;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling hover requests.
 */
interface HoverProvider {
    /**
     * Handle a hover request.
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getHoverContent(document: LangiumDocument, params: HoverParams, cancelToken?: CancellationToken): MaybePromise<Hover | undefined>;
}
declare abstract class AstNodeHoverProvider implements HoverProvider {
    protected readonly references: References;
    protected readonly grammarConfig: GrammarConfig;
    constructor(services: LangiumServices);
    getHoverContent(document: LangiumDocument, params: HoverParams): MaybePromise<Hover | undefined>;
    protected abstract getAstNodeHoverContent(node: AstNode): MaybePromise<Hover | undefined>;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling go to implementation requests.
 */
interface ImplementationProvider {
    /**
     * Handles a go to implementation request.
     */
    getImplementation(document: LangiumDocument, params: ImplementationParams, cancelToken?: CancellationToken): MaybePromise<LocationLink[] | undefined>;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Provider for the inlay hint LSP type.
 */
interface InlayHintProvider {
    /**
     * Handle the `textDocument.inlayHint` language server request.
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getInlayHints(document: LangiumDocument, params: InlayHintParams, cancelToken?: CancellationToken): MaybePromise<InlayHint[] | undefined>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface LanguageServer {
    initialize(params: InitializeParams): Promise<InitializeResult>;
    initialized(params: InitializedParams): void;
    onInitialize(callback: (params: InitializeParams) => void): Disposable$1;
    onInitialized(callback: (params: InitializedParams) => void): Disposable$1;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling find references requests.
 */
interface ReferencesProvider {
    /**
     * Handle a find references request.
     *
     * @param document The document in which to search for references.
     * @param params The parameters of the find references request.
     * @param cancelToken A cancellation token that can be used to cancel the request.
     * @returns The locations of the references.
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    findReferences(document: LangiumDocument, params: ReferenceParams, cancelToken?: CancellationToken): MaybePromise<Location[]>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling rename requests and prepare rename requests.
 */
interface RenameProvider {
    /**
     * Handle a rename request.
     *
     * @param document The document in which the rename request was triggered.
     * @param params The rename parameters.
     * @param cancelToken A cancellation token that can be used to cancel the request.
     * @returns A workspace edit that describes the changes to be applied to the workspace.
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    rename(document: LangiumDocument, params: RenameParams, cancelToken?: CancellationToken): MaybePromise<WorkspaceEdit | undefined>;
    /**
     * Handle a prepare rename request.
     *
     * @param document The document in which the prepare rename request was triggered.
     * @param params The prepare rename parameters.
     * @param cancelToken A cancellation token that can be used to cancel the request.
     * @returns A range that describes the range of the symbol to be renamed.
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    prepareRename(document: LangiumDocument, params: TextDocumentPositionParams, cancelToken?: CancellationToken): MaybePromise<Range$1 | undefined>;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface SemanticTokenProvider {
    semanticHighlight(document: LangiumDocument, params: SemanticTokensParams, cancelToken?: CancellationToken): MaybePromise<SemanticTokens>;
    semanticHighlightRange(document: LangiumDocument, params: SemanticTokensRangeParams, cancelToken?: CancellationToken): MaybePromise<SemanticTokens>;
    semanticHighlightDelta(document: LangiumDocument, params: SemanticTokensDeltaParams, cancelToken?: CancellationToken): MaybePromise<SemanticTokens | SemanticTokensDelta>;
    readonly tokenTypes: Record<string, number>;
    readonly tokenModifiers: Record<string, number>;
    readonly semanticTokensOptions: SemanticTokensOptions;
}
type SemanticTokenAcceptorOptions<N extends AstNode = AstNode> = ({
    line: number;
    char: number;
    length: number;
} | {
    node: N;
    property: Properties<N>;
    index?: number;
} | {
    node: N;
    keyword: string;
    index?: number;
} | {
    cst: CstNode;
} | {
    range: Range$1;
}) & {
    type: string;
    modifier?: string | string[];
};
interface SemanticTokenPropertyOptions<T extends AstNode> {
    node: T;
    property: Properties<T>;
    index?: number;
    type: string;
    modifier?: string | string[];
}
interface SemanticTokenKeywordOptions {
    node: AstNode;
    keyword: string;
    index?: number;
    type: string;
    modifier?: string | string[];
}
interface SemanticTokenNodeOptions {
    node: CstNode;
    type: string;
    modifier?: string | string[];
}
interface SemanticTokenRangeOptions {
    range: Range$1;
    type: string;
    modifier?: string | string[];
}
declare class SemanticTokensBuilder extends SemanticTokensBuilder$1 {
    private _tokens;
    push(line: number, char: number, length: number, tokenType: number, tokenModifiers: number): void;
    build(): SemanticTokens;
    buildEdits(): SemanticTokens | SemanticTokensDelta;
    /**
     * Flushes the cached delta token values
     */
    flush(): void;
    private applyTokens;
    private compareTokens;
}
type SemanticTokenAcceptor = <N extends AstNode = AstNode>(options: SemanticTokenAcceptorOptions<N>) => void;
/**
 * A basic super class for providing semantic token data.
 * Users of Langium should extend this class to create their own `SemanticTokenProvider`.
 *
 * The entry method for generating semantic tokens based on an `AstNode` is the `highlightElement` method.
 */
declare abstract class AbstractSemanticTokenProvider implements SemanticTokenProvider {
    /**
     * Store a token builder for each open document.
     */
    protected tokensBuilders: Map<string, SemanticTokensBuilder>;
    protected currentDocument?: LangiumDocument;
    protected currentTokensBuilder?: SemanticTokensBuilder;
    protected currentRange?: Range$1;
    protected clientCapabilities?: SemanticTokensClientCapabilities;
    constructor(services: LangiumServices);
    initialize(clientCapabilities?: SemanticTokensClientCapabilities): void;
    get tokenTypes(): Record<string, number>;
    get tokenModifiers(): Record<string, number>;
    get semanticTokensOptions(): SemanticTokensOptions;
    semanticHighlight(document: LangiumDocument, _params: SemanticTokensParams, cancelToken?: CancellationToken): Promise<SemanticTokens>;
    semanticHighlightRange(document: LangiumDocument, params: SemanticTokensRangeParams, cancelToken?: CancellationToken): Promise<SemanticTokens>;
    semanticHighlightDelta(document: LangiumDocument, params: SemanticTokensDeltaParams, cancelToken?: CancellationToken): Promise<SemanticTokens | SemanticTokensDelta>;
    protected createAcceptor(): SemanticTokenAcceptor;
    protected getDocumentTokensBuilder(document: LangiumDocument): SemanticTokensBuilder;
    protected computeHighlighting(document: LangiumDocument, acceptor: SemanticTokenAcceptor, cancelToken: CancellationToken): Promise<void>;
    /**
     * @return `'prune'` to skip the children of this element, nothing otherwise.
     */
    protected abstract highlightElement(node: AstNode, acceptor: SemanticTokenAcceptor): void | undefined | 'prune';
    protected highlightToken(options: SemanticTokenRangeOptions): void;
    protected highlightProperty<N extends AstNode>(options: SemanticTokenPropertyOptions<N>): void;
    protected highlightKeyword(options: SemanticTokenKeywordOptions): void;
    protected highlightNode(options: SemanticTokenNodeOptions): void;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling signature help requests.
 */
interface SignatureHelpProvider {
    /**
     * Handles a signature help request
     */
    provideSignatureHelp(document: LangiumDocument, params: SignatureHelpParams, cancelToken?: CancellationToken): MaybePromise<SignatureHelp | undefined>;
    /**
     * Options that determine the server capabilities for a signature help request. It contains the list of triggering characters.
     */
    get signatureHelpOptions(): SignatureHelpOptions;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling type hierarchy requests.
 */
interface TypeHierarchyProvider {
    prepareTypeHierarchy(document: LangiumDocument, params: TypeHierarchyPrepareParams, cancelToken?: CancellationToken): MaybePromise<TypeHierarchyItem[] | undefined>;
    supertypes(params: TypeHierarchySupertypesParams, cancelToken?: CancellationToken): MaybePromise<TypeHierarchyItem[] | undefined>;
    subtypes(params: TypeHierarchySubtypesParams, cancelToken?: CancellationToken): MaybePromise<TypeHierarchyItem[] | undefined>;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling go to type requests.
 */
interface TypeDefinitionProvider {
    /**
     * Handles a go to type definition request.
     */
    getTypeDefinition(document: LangiumDocument, params: TypeDefinitionParams, cancelToken?: CancellationToken): MaybePromise<LocationLink[] | undefined>;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Shared service for handling workspace symbols requests.
 */
interface WorkspaceSymbolProvider$1 {
    /**
     * Handle a workspace symbols request.
     *
     * @param params workspaces symbols request parameters
     * @param cancelToken a cancellation token tha can be used to cancel the request
     * @returns a list of workspace symbols
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getSymbols(params: WorkspaceSymbolParams, cancelToken?: CancellationToken): MaybePromise<WorkspaceSymbol[]>;
    /**
     * Handle a resolve request for a workspace symbol.
     *
     * @param symbol the workspace symbol to resolve
     * @param cancelToken a cancellation token tha can be used to cancel the request
     * @returns the resolved workspace symbol
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    resolveSymbol?(symbol: WorkspaceSymbol, cancelToken?: CancellationToken): MaybePromise<WorkspaceSymbol>;
}
declare class DefaultWorkspaceSymbolProvider implements WorkspaceSymbolProvider$1 {
    protected readonly indexManager: IndexManager;
    protected readonly nodeKindProvider: NodeKindProvider$1;
    protected readonly fuzzyMatcher: FuzzyMatcher;
    constructor(services: LangiumSharedServices);
    getSymbols(params: WorkspaceSymbolParams, cancelToken?: CancellationToken): Promise<WorkspaceSymbol[]>;
    protected getWorkspaceSymbol(astDescription: AstNodeDescription): WorkspaceSymbol | undefined;
}

/******************************************************************************
 * Copyright 2024 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * A manager service that keeps track of all currently opened text documents.
 *
 * Designed to be compatible with the `TextDocuments` class in the `vscode-languageserver` package.
 */
interface TextDocuments<T extends {
    uri: string;
}> {
    /**
     * An event that fires when a text document managed by this manager
     * has been opened.
     */
    readonly onDidOpen: Event<TextDocumentChangeEvent<T>>;
    /**
     * An event that fires when a text document managed by this manager
     * has been opened or the content changes.
     */
    readonly onDidChangeContent: Event<TextDocumentChangeEvent<T>>;
    /**
     * An event that fires when a text document managed by this manager
     * will be saved.
     */
    readonly onWillSave: Event<TextDocumentWillSaveEvent<T>>;
    /**
     * Sets a handler that will be called if a participant wants to provide
     * edits during a text document save.
     */
    onWillSaveWaitUntil(handler: RequestHandler<TextDocumentWillSaveEvent<T>, TextEdit$1[], void>): void;
    /**
     * An event that fires when a text document managed by this manager
     * has been saved.
     */
    readonly onDidSave: Event<TextDocumentChangeEvent<T>>;
    /**
     * An event that fires when a text document managed by this manager
     * has been closed.
     */
    readonly onDidClose: Event<TextDocumentChangeEvent<T>>;
    /**
     * Returns the document for the given URI. Returns undefined if
     * the document is not managed by this instance.
     *
     * @param uri The text document's URI to retrieve.
     * @return the text document or `undefined`.
     */
    get(uri: string | URI): T | undefined;
    /**
     * Sets the text document managed by this instance.
     * @param document The text document to add.
     * @returns `true` if the document didn't exist yet, `false` if it was already present.
     */
    set(document: T): boolean;
    /**
     * Deletes a text document managed by this instance.
     */
    delete(uri: string | URI | T): void;
    /**
     * Returns all text documents managed by this instance.
     *
     * @return all text documents.
     */
    all(): T[];
    /**
     * Returns the URIs of all text documents managed by this instance.
     *
     * @return the URI's of all text documents.
     */
    keys(): string[];
    /**
     * Listens for `low level` notification on the given connection to
     * update the text documents managed by this instance.
     *
     * Please note that the connection only provides handlers not an event model. Therefore
     * listening on a connection will overwrite the following handlers on a connection:
     * `onDidOpenTextDocument`, `onDidChangeTextDocument`, `onDidCloseTextDocument`,
     * `onWillSaveTextDocument`, `onWillSaveTextDocumentWaitUntil` and `onDidSaveTextDocument`.
     *
     * Use the corresponding events on the TextDocuments instance instead.
     *
     * @param connection The connection to listen on.
     */
    listen(connection: Connection): Disposable$1;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Combined Core + LSP services of Langium (total services)
 */
type LangiumServices = LangiumCoreServices & LangiumLSPServices;
/**
 * Combined Core + LSP shared services of Langium (total services)
 */
type LangiumSharedServices = LangiumSharedCoreServices & LangiumSharedLSPServices;
/**
 * LSP services for a specific language of which Langium provides default implementations.
 */
type LangiumLSPServices = {
    readonly lsp: {
        readonly CompletionProvider?: CompletionProvider;
        readonly DocumentHighlightProvider?: DocumentHighlightProvider;
        readonly DocumentSymbolProvider?: DocumentSymbolProvider;
        readonly HoverProvider?: HoverProvider;
        readonly FoldingRangeProvider?: FoldingRangeProvider;
        readonly DefinitionProvider?: DefinitionProvider;
        readonly TypeProvider?: TypeDefinitionProvider;
        readonly ImplementationProvider?: ImplementationProvider;
        readonly ReferencesProvider?: ReferencesProvider;
        readonly CodeActionProvider?: CodeActionProvider;
        readonly SemanticTokenProvider?: SemanticTokenProvider;
        readonly RenameProvider?: RenameProvider;
        readonly Formatter?: Formatter;
        readonly SignatureHelp?: SignatureHelpProvider;
        readonly CallHierarchyProvider?: CallHierarchyProvider;
        readonly TypeHierarchyProvider?: TypeHierarchyProvider;
        readonly DeclarationProvider?: DeclarationProvider;
        readonly InlayHintProvider?: InlayHintProvider;
        readonly CodeLensProvider?: CodeLensProvider;
        readonly DocumentLinkProvider?: DocumentLinkProvider;
    };
    readonly shared: LangiumSharedServices;
};
/**
 * LSP services shared between multiple languages of which Langium provides default implementations.
 */
type LangiumSharedLSPServices = {
    readonly lsp: {
        readonly Connection?: Connection;
        readonly DocumentUpdateHandler: DocumentUpdateHandler;
        readonly ExecuteCommandHandler?: ExecuteCommandHandler;
        readonly FileOperationHandler?: FileOperationHandler;
        readonly FuzzyMatcher: FuzzyMatcher;
        readonly LanguageServer: LanguageServer;
        readonly NodeKindProvider: NodeKindProvider$1;
        readonly WorkspaceSymbolProvider?: WorkspaceSymbolProvider$1;
    };
    readonly workspace: {
        readonly TextDocuments: TextDocuments<TextDocument>;
    };
};

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface NextFeature<T extends AbstractElement = AbstractElement> {
    /**
     * A feature that could appear during completion.
     */
    feature: T;
    /**
     * The type that carries this `feature`. Only set if we encounter a new type.
     */
    type?: string;
    /**
     * The container property for the new `type`
     */
    property?: string;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

type CompletionAcceptor = (context: CompletionContext, value: CompletionValueItem) => void;
type CompletionValueItem = ({
    label?: string;
} | {
    node: AstNode;
} | {
    nodeDescription: AstNodeDescription;
}) & Partial<CompletionItem>;
interface CompletionContext {
    node?: AstNode;
    document: LangiumDocument;
    textDocument: TextDocument;
    features: NextFeature[];
    /**
     * Index at the start of the token related to this context.
     * If the context performs completion for a token that doesn't exist yet, it is equal to the `offset`.
     */
    tokenOffset: number;
    /**
     * Index at the end of the token related to this context, even if it is behind the cursor position.
     * Points at the first character after the last token.
     * If the context performs completion for a token that doesn't exist yet, it is equal to the `offset`.
     */
    tokenEndOffset: number;
    /**
     * Index of the requested completed position.
     */
    offset: number;
    position: Position$2;
}
interface CompletionProviderOptions {
    /**
     * Most tools trigger completion request automatically without explicitly requesting
     * it using a keyboard shortcut (e.g. Ctrl+Space). Typically they do so when the user
     * starts to type an identifier. For example if the user types `c` in a JavaScript file
     * code complete will automatically pop up present `console` besides others as a
     * completion item. Characters that make up identifiers don't need to be listed here.
     *
     * If code complete should automatically be trigger on characters not being valid inside
     * an identifier (for example `.` in JavaScript) list them in `triggerCharacters`.
     */
    triggerCharacters?: string[];
    /**
     * The list of all possible characters that commit a completion. This field can be used
     * if clients don't support individual commit characters per completion item.
     *
     * If a server provides both `allCommitCharacters` and commit characters on an individual
     * completion item the ones on the completion item win.
     */
    allCommitCharacters?: string[];
}
interface CompletionBacktrackingInformation {
    previousTokenStart?: number;
    previousTokenEnd?: number;
    nextTokenStart: number;
    nextTokenEnd: number;
}
/**
 * Language-specific service for handling completion requests.
 */
interface CompletionProvider {
    /**
     * Handle a completion request.
     *
     * @param document - the document for which the completion request was triggered
     * @param params - the completion parameters
     * @param cancelToken - a token that can be used to cancel the request
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getCompletion(document: LangiumDocument, params: CompletionParams, cancelToken?: CancellationToken): MaybePromise<CompletionList | undefined>;
    /**
     * Contains the completion options for this completion provider.
     *
     * If multiple languages return different options, they are merged before being sent to the language client.
     */
    readonly completionOptions?: CompletionProviderOptions;
}
declare class DefaultCompletionProvider implements CompletionProvider {
    protected readonly completionParser: LangiumCompletionParser;
    protected readonly documentationProvider: DocumentationProvider;
    protected readonly scopeProvider: ScopeProvider;
    protected readonly grammar: Grammar;
    protected readonly nameProvider: NameProvider;
    protected readonly lexer: Lexer;
    protected readonly nodeKindProvider: NodeKindProvider$1;
    protected readonly fuzzyMatcher: FuzzyMatcher;
    protected readonly grammarConfig: GrammarConfig;
    protected readonly astReflection: AstReflection;
    readonly completionOptions?: CompletionProviderOptions;
    constructor(services: LangiumServices);
    getCompletion(document: LangiumDocument, params: CompletionParams, _cancelToken?: CancellationToken): Promise<CompletionList | undefined>;
    /**
     * The completion algorithm could yield the same reference/keyword multiple times.
     *
     * This methods deduplicates these items afterwards before returning to the client.
     * Unique items are identified as a combination of `kind`, `label` and `detail`.
     */
    protected deduplicateItems(items: CompletionItem[]): CompletionItem[];
    protected findFeaturesAt(document: TextDocument, offset: number): NextFeature[];
    protected buildContexts(document: LangiumDocument, position: Position$2): IterableIterator<CompletionContext>;
    protected performNextTokenCompletion(document: LangiumDocument, text: string, _offset: number, _end: number): boolean;
    protected findDataTypeRuleStart(cst: CstNode, offset: number): [number, number] | undefined;
    /**
     * Indicates whether the completion should continue to process the next completion context.
     *
     * The default implementation continues the completion only if there are currently no proposed completion items.
     */
    protected continueCompletion(items: CompletionItem[]): boolean;
    /**
     * This method returns two sets of token offset information.
     *
     * The `nextToken*` offsets are related to the token at the cursor position.
     * If there is none, both offsets are simply set to `offset`.
     *
     * The `previousToken*` offsets are related to the last token before the current token at the cursor position.
     * They are `undefined`, if there is no token before the cursor position.
     */
    protected backtrackToAnyToken(text: string, offset: number): CompletionBacktrackingInformation;
    protected completionFor(context: CompletionContext, next: NextFeature, acceptor: CompletionAcceptor): MaybePromise<void>;
    protected completionForCrossReference(context: CompletionContext, next: NextFeature<CrossReference>, acceptor: CompletionAcceptor): MaybePromise<void>;
    /**
     * Override this method to change how the stream of candidates is determined for a reference.
     * This way completion-specific modifications and refinements can be added to the proposals computation
     *  beyond the rules being implemented in the scope provider, e.g. filtering.
     *
     * @param refInfo Information about the reference for which the candidates are requested.
     * @param _context Information about the completion request including document, cursor position, token under cursor, etc.
     * @returns A stream of all elements being valid for the given reference.
     */
    protected getReferenceCandidates(refInfo: ReferenceInfo, _context: CompletionContext): Stream<AstNodeDescription>;
    /**
     * Override this method to change how reference completion items are created.
     *
     * To change the `kind` of a completion item, override the `NodeKindProvider` service instead.
     * To change the `documentation`, override the `DocumentationProvider` service instead.
     *
     * @param nodeDescription The description of a reference candidate
     * @returns A partial completion item
     */
    protected createReferenceCompletionItem(nodeDescription: AstNodeDescription): CompletionValueItem;
    protected getReferenceDocumentation(nodeDescription: AstNodeDescription): MarkupContent | string | undefined;
    protected completionForKeyword(context: CompletionContext, keyword: Keyword, acceptor: CompletionAcceptor): MaybePromise<void>;
    protected getKeywordCompletionItemKind(_keyword: Keyword): CompletionItemKind;
    protected filterKeyword(context: CompletionContext, keyword: Keyword): boolean;
    protected fillCompletionItem(context: CompletionContext, item: CompletionValueItem): CompletionItem | undefined;
    protected buildCompletionTextEdit(context: CompletionContext, label: string, newText: string): TextEdit$1 | undefined;
}

interface ChangeViewRequestParams {
    viewId: ViewID$1;
    change: ViewChange;
}

declare class LikeC4CodeLensProvider implements CodeLensProvider {
    private services;
    constructor(services: LikeC4Services);
    provideCodeLens(doc: LangiumDocument, _params: CodeLensParams, cancelToken?: CancellationToken): Promise<CodeLens[] | undefined>;
}

declare class LikeC4CompletionProvider extends DefaultCompletionProvider {
    readonly completionOptions: {
        triggerCharacters: string[];
    };
    protected completionForKeyword(context: CompletionContext, keyword: Keyword, acceptor: CompletionAcceptor): MaybePromise<void>;
}

declare class LikeC4DocumentHighlightProvider extends DefaultDocumentHighlightProvider {
    /**
     * Override this method to determine the highlight kind of the given reference.
     */
    protected createDocumentHighlight(reference: ReferenceDescription): DocumentHighlight;
}

declare class LikeC4DocumentLinkProvider implements DocumentLinkProvider {
    private services;
    constructor(services: LikeC4Services);
    getDocumentLinks(doc: LangiumDocument, _params: DocumentLinkParams): MaybePromise<DocumentLink[]>;
    resolveLink(doc: LangiumDocument, link: string): string;
    relativeLink(doc: LangiumDocument, link: string): string | null;
}

/******************************************************************************
 * This file was generated by langium-cli 3.3.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

type ArrowType = 'crow' | 'diamond' | 'dot' | 'none' | 'normal' | 'odiamond' | 'odot' | 'onormal' | 'open' | 'vee';
type BorderStyleValue = 'none' | LineOptions;
type CustomColorId = 'element' | 'model' | ArrowType | ElementShape | LineOptions | string;
type CustomColorValue = string;
type DynamicViewRule = DynamicViewGlobalPredicateRef | DynamicViewIncludePredicate | ViewRuleAutoLayout | ViewRuleStyleOrGlobalRef;
declare const DynamicViewRule = "DynamicViewRule";
type ElementExpression = ElementDescedantsExpression | ElementKindExpression | ElementRef | ElementTagExpression | ExpandElementExpression | WildcardExpression;
declare const ElementExpression = "ElementExpression";
type ElementPredicate = ElementPredicateOrWhere | ElementPredicateWith;
declare const ElementPredicate = "ElementPredicate";
type ElementPredicateOrWhere = ElementExpression | ElementPredicateWhere;
declare const ElementPredicateOrWhere = "ElementPredicateOrWhere";
type ElementProperty = ElementStringProperty | ElementStyleProperty | IconProperty | LinkProperty | MetadataProperty;
declare const ElementProperty = "ElementProperty";
type ElementShape = 'browser' | 'cylinder' | 'mobile' | 'person' | 'queue' | 'rectangle' | 'storage';
type IconId = string;
type Id = 'element' | 'group' | 'model' | ArrowType | ElementShape | LineOptions | ThemeColor | string;
type LikeC4View = DynamicView | ElementView;
declare const LikeC4View = "LikeC4View";
type LineOptions = 'dashed' | 'dotted' | 'solid';
type MetadataProperty = MetadataBody;
declare const MetadataProperty = "MetadataProperty";
type Predicate = ElementPredicate | RelationPredicate;
declare const Predicate = "Predicate";
type RelationExpression = DirectedRelationExpression | InOutRelationExpression | IncomingRelationExpression | OutgoingRelationExpression;
declare const RelationExpression = "RelationExpression";
type RelationPredicate = RelationPredicateOrWhere | RelationPredicateWith;
declare const RelationPredicate = "RelationPredicate";
type RelationPredicateOrWhere = RelationExpression | RelationPredicateWhere;
declare const RelationPredicateOrWhere = "RelationPredicateOrWhere";
type RelationProperty = LinkProperty | MetadataProperty | RelationNavigateToProperty | RelationStringProperty | RelationStyleProperty;
declare const RelationProperty = "RelationProperty";
type RelationshipStyleProperty = ArrowProperty | ColorProperty | LineProperty;
declare const RelationshipStyleProperty = "RelationshipStyleProperty";
type StringProperty = ElementStringProperty | MetadataAttribute | NotationProperty | NotesProperty | RelationStringProperty | SpecificationElementStringProperty | SpecificationRelationshipStringProperty | ViewStringProperty;
declare const StringProperty = "StringProperty";
type StyleProperty = BorderProperty | ColorProperty | IconProperty | OpacityProperty | ShapeProperty;
declare const StyleProperty = "StyleProperty";
type ThemeColor = 'amber' | 'blue' | 'gray' | 'green' | 'indigo' | 'muted' | 'primary' | 'red' | 'secondary' | 'sky' | 'slate';
type Uri = string;
type ViewLayoutDirection = 'BottomTop' | 'LeftRight' | 'RightLeft' | 'TopBottom';
type ViewProperty = LinkProperty | ViewStringProperty;
declare const ViewProperty = "ViewProperty";
type ViewRule = ViewRuleAutoLayout | ViewRuleGlobalPredicateRef | ViewRuleGroup | ViewRulePredicate | ViewRuleStyleOrGlobalRef;
declare const ViewRule = "ViewRule";
type ViewRulePredicate = ExcludePredicate | IncludePredicate;
declare const ViewRulePredicate = "ViewRulePredicate";
type ViewRuleStyleOrGlobalRef = ViewRuleGlobalStyle | ViewRuleStyle;
declare const ViewRuleStyleOrGlobalRef = "ViewRuleStyleOrGlobalRef";
type WhereElement = WhereElementKind | WhereElementTag;
declare const WhereElement = "WhereElement";
type WhereElementExpression = WhereBinaryExpression | WhereElement | WhereElementNegation;
declare const WhereElementExpression = "WhereElementExpression";
type WhereExpression = WhereElementExpression | WhereRelationExpression;
declare const WhereExpression = "WhereExpression";
type WhereKindEqual = WhereElementKind | WhereRelationKind;
declare const WhereKindEqual = "WhereKindEqual";
type WhereRelation = WhereRelationKind | WhereRelationTag;
declare const WhereRelation = "WhereRelation";
type WhereRelationExpression = WhereBinaryExpression | WhereRelation | WhereRelationNegation;
declare const WhereRelationExpression = "WhereRelationExpression";
type WhereTagEqual = WhereElementTag | WhereRelationTag;
declare const WhereTagEqual = "WhereTagEqual";
interface ArrowProperty extends AstNode {
    readonly $container: CustomRelationProperties | RelationStyleProperty | SpecificationRelationshipKind;
    readonly $type: 'ArrowProperty';
    key: 'head' | 'tail';
    value: ArrowType;
}
declare const ArrowProperty = "ArrowProperty";
interface BorderProperty extends AstNode {
    readonly $container: CustomElementProperties | ElementStyleProperty | GlobalStyle | ViewRuleGroup | ViewRuleStyle;
    readonly $type: 'BorderProperty';
    key: 'border';
    value: BorderStyleValue;
}
declare const BorderProperty = "BorderProperty";
interface ColorProperty extends AstNode {
    readonly $container: CustomElementProperties | CustomRelationProperties | ElementStyleProperty | GlobalStyle | RelationStyleProperty | SpecificationRelationshipKind | ViewRuleGroup | ViewRuleStyle;
    readonly $type: 'ColorProperty';
    customColor?: Reference<CustomColor>;
    key: 'color';
    themeColor?: ThemeColor;
}
declare const ColorProperty = "ColorProperty";
interface CustomColor extends AstNode {
    readonly $container: SpecificationColor;
    readonly $type: 'CustomColor';
    name: CustomColorId;
}
declare const CustomColor = "CustomColor";
interface CustomElementProperties extends AstNode {
    readonly $container: ElementPredicateWith;
    readonly $type: 'CustomElementProperties';
    props: Array<ElementStringProperty | NavigateToProperty | NotationProperty | StyleProperty>;
}
declare const CustomElementProperties = "CustomElementProperties";
interface CustomRelationProperties extends AstNode {
    readonly $container: DynamicViewStep | RelationPredicateWith;
    readonly $type: 'CustomRelationProperties';
    props: Array<NotationProperty | NotesProperty | RelationNavigateToProperty | RelationStringProperty | RelationshipStyleProperty>;
}
declare const CustomRelationProperties = "CustomRelationProperties";
interface DirectedRelationExpression extends AstNode {
    readonly $container: Predicates | RelationPredicateWhere | RelationPredicateWith;
    readonly $type: 'DirectedRelationExpression';
    source: OutgoingRelationExpression;
    target: ElementExpression;
}
declare const DirectedRelationExpression = "DirectedRelationExpression";
interface DynamicView extends AstNode {
    readonly $container: ModelViews;
    readonly $type: 'DynamicView';
    body?: DynamicViewBody;
    name: Id;
}
declare const DynamicView = "DynamicView";
interface DynamicViewBody extends AstNode {
    readonly $container: DynamicView;
    readonly $type: 'DynamicViewBody';
    props: Array<ViewProperty>;
    rules: Array<DynamicViewRule>;
    steps: Array<DynamicViewParallelSteps | DynamicViewStep>;
    tags?: Tags;
}
declare const DynamicViewBody = "DynamicViewBody";
interface DynamicViewGlobalPredicateRef extends AstNode {
    readonly $container: DynamicViewBody;
    readonly $type: 'DynamicViewGlobalPredicateRef';
    predicate: Reference<GlobalDynamicPredicateGroup>;
}
declare const DynamicViewGlobalPredicateRef = "DynamicViewGlobalPredicateRef";
interface DynamicViewIncludePredicate extends AstNode {
    readonly $container: DynamicViewBody | GlobalDynamicPredicateGroup;
    readonly $type: 'DynamicViewIncludePredicate';
    predicates: DynamicViewPredicateIterator;
}
declare const DynamicViewIncludePredicate = "DynamicViewIncludePredicate";
interface DynamicViewParallelSteps extends AstNode {
    readonly $container: DynamicViewBody;
    readonly $type: 'DynamicViewParallelSteps';
    steps: Array<DynamicViewStep>;
}
declare const DynamicViewParallelSteps = "DynamicViewParallelSteps";
interface DynamicViewPredicateIterator extends AstNode {
    readonly $container: DynamicViewIncludePredicate | DynamicViewPredicateIterator;
    readonly $type: 'DynamicViewPredicateIterator';
    prev?: DynamicViewPredicateIterator;
    value: ElementPredicate;
}
declare const DynamicViewPredicateIterator = "DynamicViewPredicateIterator";
interface DynamicViewRef extends AstNode {
    readonly $container: RelationNavigateToProperty;
    readonly $type: 'DynamicViewRef';
    view: Reference<DynamicView>;
}
declare const DynamicViewRef = "DynamicViewRef";
interface DynamicViewStep extends AstNode {
    readonly $container: DynamicViewBody | DynamicViewParallelSteps;
    readonly $type: 'DynamicViewStep';
    custom?: CustomRelationProperties;
    isBackward: boolean;
    kind?: Reference<RelationshipKind>;
    source: ElementRef;
    target: ElementRef;
    title?: string;
}
declare const DynamicViewStep = "DynamicViewStep";
interface Element extends AstNode {
    readonly $container: ElementBody | ExtendElementBody | Model;
    readonly $type: 'Element';
    body?: ElementBody;
    kind: Reference<ElementKind>;
    name: Id;
    props: Array<string>;
}
declare const Element = "Element";
interface ElementBody extends AstNode {
    readonly $container: Element;
    readonly $type: 'ElementBody';
    elements: Array<Element | Relation>;
    props: Array<ElementProperty>;
    tags?: Tags;
}
declare const ElementBody = "ElementBody";
interface ElementDescedantsExpression extends AstNode {
    readonly $container: DirectedRelationExpression | DynamicViewPredicateIterator | ElementExpressionsIterator | ElementPredicateWhere | ElementPredicateWith | IncomingRelationExpression | OutgoingRelationExpression | Predicates;
    readonly $type: 'ElementDescedantsExpression';
    parent: ElementRef;
}
declare const ElementDescedantsExpression = "ElementDescedantsExpression";
interface ElementExpressionsIterator extends AstNode {
    readonly $container: ElementExpressionsIterator | GlobalStyle | ViewRuleStyle;
    readonly $type: 'ElementExpressionsIterator';
    prev?: ElementExpressionsIterator;
    value: ElementExpression;
}
declare const ElementExpressionsIterator = "ElementExpressionsIterator";
interface ElementKind extends AstNode {
    readonly $container: SpecificationElementKind;
    readonly $type: 'ElementKind';
    name: Id;
}
declare const ElementKind = "ElementKind";
interface ElementKindExpression extends AstNode {
    readonly $container: DirectedRelationExpression | DynamicViewPredicateIterator | ElementExpressionsIterator | ElementPredicateWhere | ElementPredicateWith | IncomingRelationExpression | OutgoingRelationExpression | Predicates;
    readonly $type: 'ElementKindExpression';
    isEqual: boolean;
    kind?: Reference<ElementKind>;
}
declare const ElementKindExpression = "ElementKindExpression";
interface ElementPredicateWhere extends AstNode {
    readonly $container: DynamicViewPredicateIterator | ElementPredicateWith | Predicates;
    readonly $type: 'ElementPredicateWhere';
    subject: ElementExpression;
    where?: WhereElementExpression;
}
declare const ElementPredicateWhere = "ElementPredicateWhere";
interface ElementPredicateWith extends AstNode {
    readonly $container: DynamicViewPredicateIterator | Predicates;
    readonly $type: 'ElementPredicateWith';
    custom?: CustomElementProperties;
    subject: ElementPredicateOrWhere;
}
declare const ElementPredicateWith = "ElementPredicateWith";
interface ElementRef extends AstNode {
    readonly $container: DirectedRelationExpression | DynamicViewPredicateIterator | DynamicViewStep | ElementDescedantsExpression | ElementExpressionsIterator | ElementPredicateWhere | ElementPredicateWith | ElementRef | ElementView | ExpandElementExpression | IncomingRelationExpression | OutgoingRelationExpression | Predicates | Relation;
    readonly $type: 'ElementRef';
    el: Reference<Element>;
    parent?: ElementRef;
}
declare const ElementRef = "ElementRef";
interface ElementStringProperty extends AstNode {
    readonly $container: CustomElementProperties | ElementBody;
    readonly $type: 'ElementStringProperty';
    key: 'description' | 'technology' | 'title';
    value: string;
}
declare const ElementStringProperty = "ElementStringProperty";
interface ElementStyleProperty extends AstNode {
    readonly $container: ElementBody | SpecificationElementKind;
    readonly $type: 'ElementStyleProperty';
    key: 'style';
    props: Array<StyleProperty>;
}
declare const ElementStyleProperty = "ElementStyleProperty";
interface ElementTagExpression extends AstNode {
    readonly $container: DirectedRelationExpression | DynamicViewPredicateIterator | ElementExpressionsIterator | ElementPredicateWhere | ElementPredicateWith | IncomingRelationExpression | OutgoingRelationExpression | Predicates;
    readonly $type: 'ElementTagExpression';
    isEqual: boolean;
    tag?: Reference<Tag>;
}
declare const ElementTagExpression = "ElementTagExpression";
interface ElementView extends AstNode {
    readonly $container: ModelViews;
    readonly $type: 'ElementView';
    body?: ElementViewBody;
    extends?: ElementViewRef;
    name?: Id;
    viewOf?: ElementRef;
}
declare const ElementView = "ElementView";
interface ElementViewBody extends AstNode {
    readonly $container: ElementView;
    readonly $type: 'ElementViewBody';
    props: Array<ViewProperty>;
    rules: Array<ViewRule>;
    tags?: Tags;
}
declare const ElementViewBody = "ElementViewBody";
interface ElementViewRef extends AstNode {
    readonly $container: ElementView;
    readonly $type: 'ElementViewRef';
    view: Reference<ElementView>;
}
declare const ElementViewRef = "ElementViewRef";
interface ExcludePredicate extends AstNode {
    readonly $container: ElementViewBody | GlobalPredicateGroup | ViewRuleGroup;
    readonly $type: 'ExcludePredicate';
    predicates: Predicates;
}
declare const ExcludePredicate = "ExcludePredicate";
interface ExpandElementExpression extends AstNode {
    readonly $container: DirectedRelationExpression | DynamicViewPredicateIterator | ElementExpressionsIterator | ElementPredicateWhere | ElementPredicateWith | IncomingRelationExpression | OutgoingRelationExpression | Predicates;
    readonly $type: 'ExpandElementExpression';
    expand: ElementRef;
}
declare const ExpandElementExpression = "ExpandElementExpression";
interface ExtendElement extends AstNode {
    readonly $container: Model;
    readonly $type: 'ExtendElement';
    body: ExtendElementBody;
    element: FqnElementRef;
}
declare const ExtendElement = "ExtendElement";
interface ExtendElementBody extends AstNode {
    readonly $container: ExtendElement;
    readonly $type: 'ExtendElementBody';
    elements: Array<Element | Relation>;
}
declare const ExtendElementBody = "ExtendElementBody";
interface FqnElementRef extends AstNode {
    readonly $container: ExtendElement | FqnElementRef;
    readonly $type: 'FqnElementRef';
    el: Reference<Element>;
    parent?: FqnElementRef;
}
declare const FqnElementRef = "FqnElementRef";
interface GlobalDynamicPredicateGroup extends AstNode {
    readonly $container: Globals;
    readonly $type: 'GlobalDynamicPredicateGroup';
    name: string;
    predicates: Array<DynamicViewIncludePredicate>;
}
declare const GlobalDynamicPredicateGroup = "GlobalDynamicPredicateGroup";
interface GlobalPredicateGroup extends AstNode {
    readonly $container: Globals;
    readonly $type: 'GlobalPredicateGroup';
    name: string;
    predicates: Array<ViewRulePredicate>;
}
declare const GlobalPredicateGroup = "GlobalPredicateGroup";
interface Globals extends AstNode {
    readonly $container: LikeC4Grammar;
    readonly $type: 'Globals';
    name: 'global';
    predicates: Array<GlobalDynamicPredicateGroup | GlobalPredicateGroup>;
    styles: Array<GlobalStyle | GlobalStyleGroup>;
}
declare const Globals = "Globals";
interface GlobalStyle extends AstNode {
    readonly $container: Globals;
    readonly $type: 'GlobalStyle';
    id: GlobalStyleId;
    props: Array<NotationProperty | StyleProperty>;
    target: ElementExpressionsIterator;
}
declare const GlobalStyle = "GlobalStyle";
interface GlobalStyleGroup extends AstNode {
    readonly $container: Globals;
    readonly $type: 'GlobalStyleGroup';
    id: GlobalStyleId;
    styles: Array<ViewRuleStyle>;
}
declare const GlobalStyleGroup = "GlobalStyleGroup";
interface GlobalStyleId extends AstNode {
    readonly $container: GlobalStyle | GlobalStyleGroup;
    readonly $type: 'GlobalStyleId';
    name: string;
}
declare const GlobalStyleId = "GlobalStyleId";
interface IconProperty extends AstNode {
    readonly $container: CustomElementProperties | ElementBody | ElementStyleProperty | GlobalStyle | ViewRuleStyle;
    readonly $type: 'IconProperty';
    key: 'icon';
    libicon?: Reference<LibIcon>;
    value?: 'none' | Uri;
}
declare const IconProperty = "IconProperty";
interface IncludePredicate extends AstNode {
    readonly $container: ElementViewBody | GlobalPredicateGroup | ViewRuleGroup;
    readonly $type: 'IncludePredicate';
    predicates: Predicates;
}
declare const IncludePredicate = "IncludePredicate";
interface IncomingRelationExpression extends AstNode {
    readonly $container: InOutRelationExpression | Predicates | RelationPredicateWhere | RelationPredicateWith;
    readonly $type: 'IncomingRelationExpression';
    to: ElementExpression;
}
declare const IncomingRelationExpression = "IncomingRelationExpression";
interface InOutRelationExpression extends AstNode {
    readonly $container: Predicates | RelationPredicateWhere | RelationPredicateWith;
    readonly $type: 'InOutRelationExpression';
    inout: IncomingRelationExpression;
}
declare const InOutRelationExpression = "InOutRelationExpression";
interface LibIcon extends AstNode {
    readonly $container: LikeC4Lib;
    readonly $type: 'LibIcon';
    name: IconId;
}
declare const LibIcon = "LibIcon";
interface LikeC4Grammar extends AstNode {
    readonly $type: 'LikeC4Grammar';
    globals: Array<Globals>;
    likec4lib: Array<LikeC4Lib>;
    models: Array<Model>;
    specifications: Array<SpecificationRule>;
    views: Array<ModelViews>;
}
declare const LikeC4Grammar = "LikeC4Grammar";
interface LikeC4Lib extends AstNode {
    readonly $container: LikeC4Grammar;
    readonly $type: 'LikeC4Lib';
    icons: Array<LibIcon>;
}
declare const LikeC4Lib = "LikeC4Lib";
interface LineProperty extends AstNode {
    readonly $container: CustomRelationProperties | RelationStyleProperty | SpecificationRelationshipKind;
    readonly $type: 'LineProperty';
    key: 'line';
    value: LineOptions;
}
declare const LineProperty = "LineProperty";
interface LinkProperty extends AstNode {
    readonly $container: DynamicViewBody | ElementBody | ElementViewBody | RelationBody;
    readonly $type: 'LinkProperty';
    key: 'link';
    title?: string;
    value: Uri;
}
declare const LinkProperty = "LinkProperty";
interface MetadataAttribute extends AstNode {
    readonly $container: MetadataBody;
    readonly $type: 'MetadataAttribute';
    key: string;
    value: string;
}
declare const MetadataAttribute = "MetadataAttribute";
interface MetadataBody extends AstNode {
    readonly $container: ElementBody | RelationBody;
    readonly $type: 'MetadataBody';
    props: Array<MetadataAttribute>;
}
declare const MetadataBody = "MetadataBody";
interface Model extends AstNode {
    readonly $container: LikeC4Grammar;
    readonly $type: 'Model';
    elements: Array<Element | ExtendElement | Relation>;
    name: 'model';
}
declare const Model = "Model";
interface ModelViews extends AstNode {
    readonly $container: LikeC4Grammar;
    readonly $type: 'ModelViews';
    name: 'views';
    styles: Array<ViewRuleStyleOrGlobalRef>;
    views: Array<LikeC4View>;
}
declare const ModelViews = "ModelViews";
interface NavigateToProperty extends AstNode {
    readonly $container: CustomElementProperties;
    readonly $type: 'NavigateToProperty';
    key: 'navigateTo';
    value: ViewRef;
}
declare const NavigateToProperty = "NavigateToProperty";
interface NotationProperty extends AstNode {
    readonly $container: CustomElementProperties | CustomRelationProperties | GlobalStyle | ViewRuleStyle;
    readonly $type: 'NotationProperty';
    key: 'notation';
    value: string;
}
declare const NotationProperty = "NotationProperty";
interface NotesProperty extends AstNode {
    readonly $container: CustomRelationProperties;
    readonly $type: 'NotesProperty';
    key: 'notes';
    value: string;
}
declare const NotesProperty = "NotesProperty";
interface OpacityProperty extends AstNode {
    readonly $container: CustomElementProperties | ElementStyleProperty | GlobalStyle | ViewRuleGroup | ViewRuleStyle;
    readonly $type: 'OpacityProperty';
    key: 'opacity';
    value: string;
}
declare const OpacityProperty = "OpacityProperty";
interface OutgoingRelationExpression extends AstNode {
    readonly $container: DirectedRelationExpression | Predicates | RelationPredicateWhere | RelationPredicateWith;
    readonly $type: 'OutgoingRelationExpression';
    from: ElementExpression;
    isBidirectional: boolean;
    kind?: Reference<RelationshipKind>;
}
declare const OutgoingRelationExpression = "OutgoingRelationExpression";
interface Predicates extends AstNode {
    readonly $container: ExcludePredicate | IncludePredicate | Predicates;
    readonly $type: 'Predicates';
    prev?: Predicates;
    value: Predicate;
}
declare const Predicates = "Predicates";
interface Relation extends AstNode {
    readonly $container: ElementBody | ExtendElementBody | Model;
    readonly $type: 'Relation';
    body?: RelationBody;
    kind?: Reference<RelationshipKind>;
    source?: ElementRef;
    tags?: Tags;
    target: ElementRef;
    technology?: string;
    title?: string;
}
declare const Relation = "Relation";
interface RelationBody extends AstNode {
    readonly $container: Relation;
    readonly $type: 'RelationBody';
    props: Array<RelationProperty>;
    tags?: Tags;
}
declare const RelationBody = "RelationBody";
interface RelationNavigateToProperty extends AstNode {
    readonly $container: CustomRelationProperties | RelationBody;
    readonly $type: 'RelationNavigateToProperty';
    key: 'navigateTo';
    value: DynamicViewRef;
}
declare const RelationNavigateToProperty = "RelationNavigateToProperty";
interface RelationPredicateWhere extends AstNode {
    readonly $container: Predicates | RelationPredicateWith;
    readonly $type: 'RelationPredicateWhere';
    subject: RelationExpression;
    where?: WhereRelationExpression;
}
declare const RelationPredicateWhere = "RelationPredicateWhere";
interface RelationPredicateWith extends AstNode {
    readonly $container: Predicates;
    readonly $type: 'RelationPredicateWith';
    custom?: CustomRelationProperties;
    subject: RelationPredicateOrWhere;
}
declare const RelationPredicateWith = "RelationPredicateWith";
interface RelationshipKind extends AstNode {
    readonly $container: SpecificationRelationshipKind;
    readonly $type: 'RelationshipKind';
    name: Id;
}
declare const RelationshipKind = "RelationshipKind";
interface RelationStringProperty extends AstNode {
    readonly $container: CustomRelationProperties | RelationBody;
    readonly $type: 'RelationStringProperty';
    key: 'description' | 'technology' | 'title';
    value: string;
}
declare const RelationStringProperty = "RelationStringProperty";
interface RelationStyleProperty extends AstNode {
    readonly $container: RelationBody;
    readonly $type: 'RelationStyleProperty';
    key: 'style';
    props: Array<RelationshipStyleProperty>;
}
declare const RelationStyleProperty = "RelationStyleProperty";
interface ShapeProperty extends AstNode {
    readonly $container: CustomElementProperties | ElementStyleProperty | GlobalStyle | ViewRuleStyle;
    readonly $type: 'ShapeProperty';
    key: 'shape';
    value: ElementShape;
}
declare const ShapeProperty = "ShapeProperty";
interface SpecificationColor extends AstNode {
    readonly $container: SpecificationRule;
    readonly $type: 'SpecificationColor';
    color: CustomColorValue;
    name: CustomColor;
}
declare const SpecificationColor = "SpecificationColor";
interface SpecificationElementKind extends AstNode {
    readonly $container: SpecificationRule;
    readonly $type: 'SpecificationElementKind';
    kind: ElementKind;
    props: Array<ElementStyleProperty | SpecificationElementStringProperty>;
}
declare const SpecificationElementKind = "SpecificationElementKind";
interface SpecificationElementStringProperty extends AstNode {
    readonly $container: SpecificationElementKind;
    readonly $type: 'SpecificationElementStringProperty';
    key: 'notation' | 'technology';
    value: string;
}
declare const SpecificationElementStringProperty = "SpecificationElementStringProperty";
interface SpecificationRelationshipKind extends AstNode {
    readonly $container: SpecificationRule;
    readonly $type: 'SpecificationRelationshipKind';
    kind: RelationshipKind;
    props: Array<RelationshipStyleProperty | SpecificationRelationshipStringProperty>;
}
declare const SpecificationRelationshipKind = "SpecificationRelationshipKind";
interface SpecificationRelationshipStringProperty extends AstNode {
    readonly $container: SpecificationRelationshipKind;
    readonly $type: 'SpecificationRelationshipStringProperty';
    key: 'notation' | 'technology';
    value: string;
}
declare const SpecificationRelationshipStringProperty = "SpecificationRelationshipStringProperty";
interface SpecificationRule extends AstNode {
    readonly $container: LikeC4Grammar;
    readonly $type: 'SpecificationRule';
    colors: Array<SpecificationColor>;
    elements: Array<SpecificationElementKind>;
    name: 'specification';
    relationships: Array<SpecificationRelationshipKind>;
    tags: Array<SpecificationTag>;
}
declare const SpecificationRule = "SpecificationRule";
interface SpecificationTag extends AstNode {
    readonly $container: SpecificationRule;
    readonly $type: 'SpecificationTag';
    tag: Tag;
}
declare const SpecificationTag = "SpecificationTag";
interface Tag extends AstNode {
    readonly $container: SpecificationTag;
    readonly $type: 'Tag';
    name: Id;
}
declare const Tag = "Tag";
interface Tags extends AstNode {
    readonly $container: DynamicViewBody | ElementBody | ElementViewBody | Relation | RelationBody | Tags;
    readonly $type: 'Tags';
    prev?: Tags;
    values: Array<Reference<Tag>>;
}
declare const Tags = "Tags";
interface ViewRef extends AstNode {
    readonly $container: NavigateToProperty;
    readonly $type: 'ViewRef';
    view: Reference<LikeC4View>;
}
declare const ViewRef = "ViewRef";
interface ViewRuleAutoLayout extends AstNode {
    readonly $container: DynamicViewBody | ElementViewBody;
    readonly $type: 'ViewRuleAutoLayout';
    direction: ViewLayoutDirection;
    nodeSep?: number;
    rankSep?: number;
}
declare const ViewRuleAutoLayout = "ViewRuleAutoLayout";
interface ViewRuleGlobalPredicateRef extends AstNode {
    readonly $container: ElementViewBody;
    readonly $type: 'ViewRuleGlobalPredicateRef';
    predicate: Reference<GlobalPredicateGroup>;
}
declare const ViewRuleGlobalPredicateRef = "ViewRuleGlobalPredicateRef";
interface ViewRuleGlobalStyle extends AstNode {
    readonly $container: DynamicViewBody | ElementViewBody | ModelViews;
    readonly $type: 'ViewRuleGlobalStyle';
    style: Reference<GlobalStyleId>;
}
declare const ViewRuleGlobalStyle = "ViewRuleGlobalStyle";
interface ViewRuleGroup extends AstNode {
    readonly $container: ElementViewBody | ViewRuleGroup;
    readonly $type: 'ViewRuleGroup';
    groupRules: Array<ViewRuleGroup | ViewRulePredicate>;
    props: Array<BorderProperty | ColorProperty | OpacityProperty>;
    title?: string;
}
declare const ViewRuleGroup = "ViewRuleGroup";
interface ViewRuleStyle extends AstNode {
    readonly $container: DynamicViewBody | ElementViewBody | GlobalStyleGroup | ModelViews;
    readonly $type: 'ViewRuleStyle';
    props: Array<NotationProperty | StyleProperty>;
    target: ElementExpressionsIterator;
}
declare const ViewRuleStyle = "ViewRuleStyle";
interface ViewStringProperty extends AstNode {
    readonly $container: DynamicViewBody | ElementViewBody;
    readonly $type: 'ViewStringProperty';
    key: 'description' | 'title';
    value: string;
}
declare const ViewStringProperty = "ViewStringProperty";
interface WhereBinaryExpression extends AstNode {
    readonly $container: ElementPredicateWhere | RelationPredicateWhere | WhereBinaryExpression | WhereElementNegation | WhereRelationNegation;
    readonly $type: 'WhereBinaryExpression';
    left: WhereElementExpression | WhereRelationExpression;
    operator: 'and' | 'or';
    right: WhereElementExpression | WhereRelationExpression;
}
declare const WhereBinaryExpression = "WhereBinaryExpression";
interface WhereElementKind extends AstNode {
    readonly $container: ElementPredicateWhere | WhereBinaryExpression | WhereElementNegation;
    readonly $type: 'WhereElementKind';
    not: boolean;
    operator: 'is' | string;
    value?: Reference<ElementKind>;
}
declare const WhereElementKind = "WhereElementKind";
interface WhereElementNegation extends AstNode {
    readonly $container: ElementPredicateWhere | WhereBinaryExpression | WhereElementNegation;
    readonly $type: 'WhereElementNegation';
    value: WhereElementExpression;
}
declare const WhereElementNegation = "WhereElementNegation";
interface WhereElementTag extends AstNode {
    readonly $container: ElementPredicateWhere | WhereBinaryExpression | WhereElementNegation;
    readonly $type: 'WhereElementTag';
    not: boolean;
    operator: 'is' | string;
    value?: Reference<Tag>;
}
declare const WhereElementTag = "WhereElementTag";
interface WhereRelationKind extends AstNode {
    readonly $container: RelationPredicateWhere | WhereBinaryExpression | WhereRelationNegation;
    readonly $type: 'WhereRelationKind';
    not: boolean;
    operator: 'is' | string;
    value?: Reference<RelationshipKind>;
}
declare const WhereRelationKind = "WhereRelationKind";
interface WhereRelationNegation extends AstNode {
    readonly $container: RelationPredicateWhere | WhereBinaryExpression | WhereRelationNegation;
    readonly $type: 'WhereRelationNegation';
    value: WhereRelationExpression;
}
declare const WhereRelationNegation = "WhereRelationNegation";
interface WhereRelationTag extends AstNode {
    readonly $container: RelationPredicateWhere | WhereBinaryExpression | WhereRelationNegation;
    readonly $type: 'WhereRelationTag';
    not: boolean;
    operator: 'is' | string;
    value?: Reference<Tag>;
}
declare const WhereRelationTag = "WhereRelationTag";
interface WildcardExpression extends AstNode {
    readonly $container: DirectedRelationExpression | DynamicViewPredicateIterator | ElementExpressionsIterator | ElementPredicateWhere | ElementPredicateWith | IncomingRelationExpression | OutgoingRelationExpression | Predicates;
    readonly $type: 'WildcardExpression';
    isWildcard: boolean;
}
declare const WildcardExpression = "WildcardExpression";
type LikeC4AstType = {
    ArrowProperty: ArrowProperty;
    BorderProperty: BorderProperty;
    ColorProperty: ColorProperty;
    CustomColor: CustomColor;
    CustomElementProperties: CustomElementProperties;
    CustomRelationProperties: CustomRelationProperties;
    DirectedRelationExpression: DirectedRelationExpression;
    DynamicView: DynamicView;
    DynamicViewBody: DynamicViewBody;
    DynamicViewGlobalPredicateRef: DynamicViewGlobalPredicateRef;
    DynamicViewIncludePredicate: DynamicViewIncludePredicate;
    DynamicViewParallelSteps: DynamicViewParallelSteps;
    DynamicViewPredicateIterator: DynamicViewPredicateIterator;
    DynamicViewRef: DynamicViewRef;
    DynamicViewRule: DynamicViewRule;
    DynamicViewStep: DynamicViewStep;
    Element: Element;
    ElementBody: ElementBody;
    ElementDescedantsExpression: ElementDescedantsExpression;
    ElementExpression: ElementExpression;
    ElementExpressionsIterator: ElementExpressionsIterator;
    ElementKind: ElementKind;
    ElementKindExpression: ElementKindExpression;
    ElementPredicate: ElementPredicate;
    ElementPredicateOrWhere: ElementPredicateOrWhere;
    ElementPredicateWhere: ElementPredicateWhere;
    ElementPredicateWith: ElementPredicateWith;
    ElementProperty: ElementProperty;
    ElementRef: ElementRef;
    ElementStringProperty: ElementStringProperty;
    ElementStyleProperty: ElementStyleProperty;
    ElementTagExpression: ElementTagExpression;
    ElementView: ElementView;
    ElementViewBody: ElementViewBody;
    ElementViewRef: ElementViewRef;
    ExcludePredicate: ExcludePredicate;
    ExpandElementExpression: ExpandElementExpression;
    ExtendElement: ExtendElement;
    ExtendElementBody: ExtendElementBody;
    FqnElementRef: FqnElementRef;
    GlobalDynamicPredicateGroup: GlobalDynamicPredicateGroup;
    GlobalPredicateGroup: GlobalPredicateGroup;
    GlobalStyle: GlobalStyle;
    GlobalStyleGroup: GlobalStyleGroup;
    GlobalStyleId: GlobalStyleId;
    Globals: Globals;
    IconProperty: IconProperty;
    InOutRelationExpression: InOutRelationExpression;
    IncludePredicate: IncludePredicate;
    IncomingRelationExpression: IncomingRelationExpression;
    LibIcon: LibIcon;
    LikeC4Grammar: LikeC4Grammar;
    LikeC4Lib: LikeC4Lib;
    LikeC4View: LikeC4View;
    LineProperty: LineProperty;
    LinkProperty: LinkProperty;
    MetadataAttribute: MetadataAttribute;
    MetadataBody: MetadataBody;
    MetadataProperty: MetadataProperty;
    Model: Model;
    ModelViews: ModelViews;
    NavigateToProperty: NavigateToProperty;
    NotationProperty: NotationProperty;
    NotesProperty: NotesProperty;
    OpacityProperty: OpacityProperty;
    OutgoingRelationExpression: OutgoingRelationExpression;
    Predicate: Predicate;
    Predicates: Predicates;
    Relation: Relation;
    RelationBody: RelationBody;
    RelationExpression: RelationExpression;
    RelationNavigateToProperty: RelationNavigateToProperty;
    RelationPredicate: RelationPredicate;
    RelationPredicateOrWhere: RelationPredicateOrWhere;
    RelationPredicateWhere: RelationPredicateWhere;
    RelationPredicateWith: RelationPredicateWith;
    RelationProperty: RelationProperty;
    RelationStringProperty: RelationStringProperty;
    RelationStyleProperty: RelationStyleProperty;
    RelationshipKind: RelationshipKind;
    RelationshipStyleProperty: RelationshipStyleProperty;
    ShapeProperty: ShapeProperty;
    SpecificationColor: SpecificationColor;
    SpecificationElementKind: SpecificationElementKind;
    SpecificationElementStringProperty: SpecificationElementStringProperty;
    SpecificationRelationshipKind: SpecificationRelationshipKind;
    SpecificationRelationshipStringProperty: SpecificationRelationshipStringProperty;
    SpecificationRule: SpecificationRule;
    SpecificationTag: SpecificationTag;
    StringProperty: StringProperty;
    StyleProperty: StyleProperty;
    Tag: Tag;
    Tags: Tags;
    ViewProperty: ViewProperty;
    ViewRef: ViewRef;
    ViewRule: ViewRule;
    ViewRuleAutoLayout: ViewRuleAutoLayout;
    ViewRuleGlobalPredicateRef: ViewRuleGlobalPredicateRef;
    ViewRuleGlobalStyle: ViewRuleGlobalStyle;
    ViewRuleGroup: ViewRuleGroup;
    ViewRulePredicate: ViewRulePredicate;
    ViewRuleStyle: ViewRuleStyle;
    ViewRuleStyleOrGlobalRef: ViewRuleStyleOrGlobalRef;
    ViewStringProperty: ViewStringProperty;
    WhereBinaryExpression: WhereBinaryExpression;
    WhereElement: WhereElement;
    WhereElementExpression: WhereElementExpression;
    WhereElementKind: WhereElementKind;
    WhereElementNegation: WhereElementNegation;
    WhereElementTag: WhereElementTag;
    WhereExpression: WhereExpression;
    WhereKindEqual: WhereKindEqual;
    WhereRelation: WhereRelation;
    WhereRelationExpression: WhereRelationExpression;
    WhereRelationKind: WhereRelationKind;
    WhereRelationNegation: WhereRelationNegation;
    WhereRelationTag: WhereRelationTag;
    WhereTagEqual: WhereTagEqual;
    WildcardExpression: WildcardExpression;
};

declare const idattr: unique symbol;
declare module './generated/ast' {
    interface Element {
        [idattr]?: Fqn$1 | undefined;
    }
    interface ElementView {
        [idattr]?: ViewID$1 | undefined;
    }
    interface DynamicView {
        [idattr]?: ViewID$1 | undefined;
    }
}
type ParsedElementStyle = {
    shape?: ElementShape$1;
    icon?: IconUrl;
    color?: Color$1;
    border?: BorderStyle;
    opacity?: number;
};
interface ParsedAstSpecification {
    tags: Set<Tag$1>;
    elements: Record<ElementKind$1, {
        technology?: string;
        notation?: string;
        style: ParsedElementStyle;
    }>;
    relationships: Record<RelationshipKind$1, {
        technology?: string;
        notation?: string;
        color?: Color$1;
        line?: RelationshipLineType;
        head?: RelationshipArrowType;
        tail?: RelationshipArrowType;
    }>;
    colors: Record<CustomColor$1, {
        color: HexColorLiteral;
    }>;
}
interface ParsedAstElement {
    id: Fqn$1;
    astPath: string;
    kind: ElementKind$1;
    title: string;
    description?: string;
    technology?: string;
    tags?: NonEmptyArray<Tag$1>;
    links?: NonEmptyArray<ParsedLink>;
    style: ParsedElementStyle;
    metadata?: {
        [key: string]: string;
    };
}
interface ParsedAstRelation {
    id: RelationID$1;
    astPath: string;
    source: Fqn$1;
    target: Fqn$1;
    kind?: RelationshipKind$1;
    tags?: NonEmptyArray<Tag$1>;
    title: string;
    description?: string;
    technology?: string;
    color?: Color$1;
    line?: RelationshipLineType;
    head?: RelationshipArrowType;
    tail?: RelationshipArrowType;
    links?: NonEmptyArray<ParsedLink>;
    navigateTo?: ViewID$1;
    metadata?: {
        [key: string]: string;
    };
}
type ParsedAstGlobals = ModelGlobals;
interface ParsedAstElementView {
    __: 'element';
    id: ViewID$1;
    viewOf?: Fqn$1;
    extends?: ViewID$1;
    astPath: string;
    title: string | null;
    description: string | null;
    tags: NonEmptyArray<Tag$1> | null;
    links: NonEmptyArray<ParsedLink> | null;
    rules: ViewRule$1[];
    manualLayout?: ViewManualLayout;
}
interface ParsedAstDynamicView {
    __: 'dynamic';
    id: ViewID$1;
    astPath: string;
    title: string | null;
    description: string | null;
    tags: NonEmptyArray<Tag$1> | null;
    links: NonEmptyArray<ParsedLink> | null;
    steps: DynamicViewStepOrParallel[];
    rules: Array<DynamicViewRule$1>;
    manualLayout?: ViewManualLayout;
}
type ParsedAstView = ParsedAstElementView | ParsedAstDynamicView;
interface ParsedLink {
    title?: string;
    url: string;
}
interface DocFqnIndexAstNodeDescription extends AstNodeDescription {
    fqn: Fqn$1;
}
type LikeC4AstNode = ValueOf<ConditionalPick<LikeC4AstType, AstNode>>;
type LikeC4DocumentDiagnostic = Diagnostic & DiagnosticInfo<LikeC4AstNode>;
interface LikeC4DocumentProps {
    diagnostics?: Array<LikeC4DocumentDiagnostic>;
    c4Specification?: ParsedAstSpecification;
    c4Elements?: ParsedAstElement[];
    c4Relations?: ParsedAstRelation[];
    c4Globals?: ParsedAstGlobals;
    c4Views?: ParsedAstView[];
    c4fqnIndex?: MultiMap<Fqn$1, DocFqnIndexAstNodeDescription>;
}
interface LikeC4LangiumDocument extends Omit<LangiumDocument<LikeC4Grammar>, 'diagnostics'>, LikeC4DocumentProps {
}
interface FqnIndexedDocument extends Omit<LangiumDocument<LikeC4Grammar>, 'diagnostics'>, SetRequired<LikeC4DocumentProps, 'c4fqnIndex'> {
}
interface ParsedLikeC4LangiumDocument extends Omit<LangiumDocument<LikeC4Grammar>, 'diagnostics'>, Required<LikeC4DocumentProps> {
}

declare class LikeC4DocumentSymbolProvider implements DocumentSymbolProvider {
    private services;
    protected readonly nodeKindProvider: NodeKindProvider$1;
    constructor(services: LikeC4Services);
    getSymbols({ parseResult: { value: { specifications, models, views, likec4lib } } }: LikeC4LangiumDocument): MaybePromise<DocumentSymbol[]>;
    protected getLikec4LibSymbol(astLib: LikeC4Lib): DocumentSymbol[];
    protected getSpecSymbol(astSpec: SpecificationRule): DocumentSymbol[];
    protected getModelSymbol(astModel: Model): DocumentSymbol[];
    protected getElementsSymbol(el: Element | Relation | ExtendElement): DocumentSymbol[];
    protected getExtendElementSymbol(astElement: ExtendElement): DocumentSymbol[];
    protected getElementSymbol(astElement: Element): DocumentSymbol[];
    protected getModelViewsSymbol(astViews: ModelViews): DocumentSymbol[];
    protected getKindSymbol(astKind: SpecificationElementKind | SpecificationRelationshipKind): DocumentSymbol | null;
    protected getTagSymbol(astTag: SpecificationTag): DocumentSymbol | null;
    protected getLibIconSymbol(astTag: LibIcon): DocumentSymbol | null;
    protected getViewSymbol(astView: LikeC4View): DocumentSymbol[];
    protected symbolKind(node: AstNode): SymbolKind;
}

declare class LikeC4HoverProvider extends AstNodeHoverProvider {
    private locator;
    constructor(services: LikeC4Services);
    protected getAstNodeHoverContent(node: AstNode): MaybePromise<Hover | undefined>;
}

declare class LikeC4SemanticTokenProvider extends AbstractSemanticTokenProvider {
    protected highlightElement(node: AstNode, acceptor: SemanticTokenAcceptor): void | undefined | 'prune';
    private highlightAstElement;
    private highlightView;
}
declare class FqnIndex {
    private services;
    protected langiumDocuments: LangiumDocuments;
    constructor(services: LikeC4Services);
    get documents(): Stream<FqnIndexedDocument>;
    private entries;
    getFqn(el: Element): Fqn$1 | null;
    byFqn(fqn: Fqn$1): Stream<AstNodeDescription>;
    directChildrenOf(parent: Fqn$1): Stream<AstNodeDescription>;
    /**
     * Returns descedant elements with unique names in the scope
     */
    uniqueDescedants(parent: Fqn$1): Stream<AstNodeDescription>;
}

type ModelParsedListener$1 = (docs: URI[]) => void;
declare class LikeC4ModelBuilder {
    private services;
    private langiumDocuments;
    private listeners;
    constructor(services: LikeC4Services);
    /**
     * WARNING:
     * This method is internal and should to be called only when all documents are known to be parsed.
     * Otherwise, the model may be incomplete.
     */
    unsafeSyncBuildModel(): ParsedLikeC4Model | null;
    buildModel(cancelToken?: CancellationToken): Promise<ParsedLikeC4Model | null>;
    private previousViews;
    /**
     * WARNING:
     * This method is internal and should to be called only when all documents are known to be parsed.
     * Otherwise, the model may be incomplete.
     */
    unsafeSyncBuildComputedModel(model: ParsedLikeC4Model): ComputedLikeC4Model;
    buildComputedModel(cancelToken?: CancellationToken): Promise<ComputedLikeC4Model | null>;
    computeView(viewId: ViewID$1, cancelToken?: CancellationToken): Promise<ComputedView | null>;
    onModelParsed(callback: ModelParsedListener$1): Disposable;
    private documents;
    private notifyListeners;
}

declare class LikeC4ModelLocator {
    private services;
    private fqnIndex;
    private langiumDocuments;
    constructor(services: LikeC4Services);
    private documents;
    getParsedElement(astNode: Element): ParsedAstElement | null;
    locateElement(fqn: Fqn$1, _prop?: string): Location | null;
    locateRelation(relationId: RelationID$1): Location | null;
    locateViewAst(viewId: ViewID$1): {
        doc: ParsedLikeC4LangiumDocument;
        view: ParsedAstView;
        viewAst: LikeC4View;
    };
    locateView(viewId: ViewID$1): Location | null;
}
declare class LikeC4ModelParser {
    private services;
    private fqnIndex;
    constructor(services: LikeC4Services);
    parse(doc: LangiumDocument | LangiumDocument[]): ParsedLikeC4LangiumDocument[];
    protected parseLikeC4Document(_doc: FqnIndexedDocument): ParsedLikeC4LangiumDocument;
    private parseSpecification;
    private parseModel;
    private parseElement;
    private parseRelation;
    private parseGlobal;
    private parseAndStoreGlobalPredicateGroupOrDynamic;
    private parseGlobalPredicateGroup;
    private parseGlobalDynamicPredicateGroup;
    private parseGlobalStyleOrGroup;
    private parseViews;
    private parseViewRulePredicate;
    private parsePredicate;
    private parseElementExpressionsIterator;
    private parseElementPredicate;
    private parseElementExpr;
    private parseElementPredicateWith;
    private parseElementPredicateWhere;
    private parseRelationPredicate;
    private parseRelationPredicateWhere;
    private parseRelationPredicateWith;
    private parseRelationExpr;
    private parseViewRule;
    private parseViewRuleGlobalPredicateRef;
    private parseViewRuleStyleOrGlobalRef;
    private parseViewRuleStyle;
    private parseViewRuleGroup;
    private parseRuleStyle;
    private parseViewRuleGlobalStyle;
    private parseViewManualLaout;
    private parseDynamicParallelSteps;
    private parseDynamicStep;
    private parseElementView;
    private parseDynamicElementView;
    private parseDynamicViewRule;
    private parseDynamicViewIncludePredicate;
    protected resolveFqn(node: Element | ExtendElement): Fqn$1;
    private getAstNodePath;
    private getMetadata;
    private convertTags;
    private convertLinks;
}

declare class LikeC4ModelChanges {
    private services;
    private locator;
    constructor(services: LikeC4Services);
    applyChange(changeView: ChangeViewRequestParams): Promise<Location | null>;
    protected convertToTextEdit({ viewId, change }: ChangeViewRequestParams): {
        doc: ParsedLikeC4LangiumDocument;
        modifiedRange: Range$1;
        edits: TextEdit$1[];
    };
}

type ElementsContainer = Model | ElementBody | ExtendElementBody;
declare class LikeC4ScopeComputation extends DefaultScopeComputation {
    computeExports(document: LikeC4LangiumDocument, _cancelToken?: CancellationToken): Promise<AstNodeDescription[]>;
    private exportViews;
    private exportGlobals;
    private exportModel;
    private exportLibrary;
    private exportSpecification;
    computeLocalScopes(document: LikeC4LangiumDocument, _cancelToken?: CancellationToken): Promise<PrecomputedScopes>;
    protected processContainer(container: ElementsContainer, scopes: PrecomputedScopes, document: LikeC4LangiumDocument): MultiMap<string, AstNodeDescription>;
}

declare class LikeC4ScopeProvider extends DefaultScopeProvider {
    private fqnIndex;
    constructor(services: LikeC4Services);
    private directChildrenOf;
    private uniqueDescedants;
    private scopeElementRef;
    private scopeExtendElement;
    private scopeElementView;
    getScope(context: ReferenceInfo): Scope;
    protected computeScope(context: ReferenceInfo): Scope;
    /**
     * Create a global scope filtered for the given reference type.
     */
    protected getGlobalScope(referenceType: string): Scope;
}

declare class Rpc implements Disposable {
    private services;
    private disposables;
    constructor(services: LikeC4Services);
    init(): void;
    dispose(): void;
}

declare class NodeKindProvider implements NodeKindProvider$1 {
    private services;
    constructor(services: LangiumSharedServices);
    /**
     * Returns a `SymbolKind` as used by `WorkspaceSymbolProvider` or `DocumentSymbolProvider`.
     */
    getSymbolKind(node: AstNode | AstNodeDescription): SymbolKind;
    /**
     * Returns a `CompletionItemKind` as used by the `CompletionProvider`.
     */
    getCompletionItemKind(node: AstNode | AstNodeDescription): CompletionItemKind;
}

declare class LikeC4WorkspaceManager extends DefaultWorkspaceManager {
    private documentFactory;
    constructor(services: LangiumSharedServices);
    /**
     * Load all additional documents that shall be visible in the context of the given workspace
     * folders and add them to the collector. This can be used to include built-in libraries of
     * your language, which can be either loaded from provided files or constructed in memory.
     */
    protected loadAdditionalDocuments(folders: WorkspaceFolder[], collector: (document: LangiumDocument) => void): Promise<void>;
    workspace(): WorkspaceFolder;
    get workspaceUri(): URI;
    get workspaceURL(): URL;
}

declare class WorkspaceSymbolProvider extends DefaultWorkspaceSymbolProvider {
}

interface LikeC4AddedSharedServices {
    lsp: {
        NodeKindProvider: NodeKindProvider;
        WorkspaceSymbolProvider: WorkspaceSymbolProvider;
    };
    workspace: {
        WorkspaceManager: LikeC4WorkspaceManager;
    };
}
type LikeC4SharedServices = LangiumSharedServices & LikeC4AddedSharedServices;
/**
 * Declaration of custom services - add your own service classes here.
 */
interface LikeC4AddedServices {
    WorkspaceCache: WorkspaceCache<string, any>;
    Rpc: Rpc;
    likec4: {
        FqnIndex: FqnIndex;
        ModelParser: LikeC4ModelParser;
        ModelBuilder: LikeC4ModelBuilder;
        ModelLocator: LikeC4ModelLocator;
        ModelChanges: LikeC4ModelChanges;
    };
    lsp: {
        CompletionProvider: LikeC4CompletionProvider;
        DocumentHighlightProvider: LikeC4DocumentHighlightProvider;
        DocumentSymbolProvider: LikeC4DocumentSymbolProvider;
        SemanticTokenProvider: LikeC4SemanticTokenProvider;
        HoverProvider: LikeC4HoverProvider;
        CodeLensProvider: LikeC4CodeLensProvider;
        DocumentLinkProvider: LikeC4DocumentLinkProvider;
    };
    references: {
        ScopeComputation: LikeC4ScopeComputation;
        ScopeProvider: LikeC4ScopeProvider;
    };
    shared?: LikeC4SharedServices;
}
type LikeC4Services = LangiumServices & LikeC4AddedServices;

/**
 * @hidden
 */
type $keywords<T extends string> = {
  [key in T]: key;
};

declare module 'ts-graphviz' {
    namespace ClusterSubgraphAttributeKey {
        interface $values extends $keywords<'likec4_type' | 'likec4_path' | 'likec4_id' | 'likec4_level' | 'likec4_depth'> {
        }
    }
    namespace NodeAttributeKey {
        interface $values extends $keywords<'likec4_type' | 'likec4_path' | 'likec4_id' | 'likec4_level'> {
        }
    }
    namespace EdgeAttributeKey {
        interface $values extends $keywords<'likec4_id'> {
        }
    }
    namespace Attribute {
        interface $keys extends $keywords<'likec4_type' | 'likec4_path' | 'likec4_id' | 'likec4_level' | 'likec4_depth'> {
        }
        interface $types {
            likec4_type: 'folder' | 'file' | 'view';
            likec4_path: string;
            likec4_id: string;
            likec4_level: number;
            likec4_depth: number;
        }
    }
}
type DotSource = Tagged<string, 'DotSource'>;

interface GraphvizPort {
    unflatten(dot: DotSource): Promise<DotSource>;
    acyclic(dot: DotSource): Promise<DotSource>;
    layoutJson(dot: DotSource): Promise<string>;
    svg(dot: DotSource): Promise<string>;
}
type LayoutResult = {
    dot: DotSource;
    diagram: DiagramView;
};
declare class GraphvizLayouter {
    private graphviz;
    constructor(graphviz: GraphvizPort);
    get port(): GraphvizPort;
    changePort(graphviz: GraphvizPort): void;
    layout(view: ComputedView): Promise<LayoutResult>;
    svg(view: ComputedView): Promise<{
        svg: string;
        dot: DotSource;
    }>;
    dot(computedView: ComputedView): Promise<DotSource>;
    layoutOverviewGraph(views: ComputedView[]): Promise<OverviewGraph>;
}

// This definition file follows a somewhat unusual format. ESTree allows
// runtime type checks based on the `type` parameter. In order to explain this
// to typescript we want to use discriminated union types:
// https://github.com/Microsoft/TypeScript/pull/9163
//
// For ESTree this is a bit tricky because the high level interfaces like
// Node or Function are pulling double duty. We want to pass common fields down
// to the interfaces that extend them (like Identifier or
// ArrowFunctionExpression), but you can't extend a type union or enforce
// common fields on them. So we've split the high level interfaces into two
// types, a base type which passes down inherited fields, and a type union of
// all types which extend the base type. Only the type union is exported, and
// the union is how other types refer to the collection of inheriting types.
//
// This makes the definitions file here somewhat more difficult to maintain,
// but it has the notable advantage of making ESTree much easier to use as
// an end user.

interface BaseNodeWithoutComments {
    // Every leaf interface that extends BaseNode must specify a type property.
    // The type property should be a string literal. For example, Identifier
    // has: `type: "Identifier"`
    type: string;
    loc?: SourceLocation | null | undefined;
    range?: [number, number] | undefined;
}

interface BaseNode extends BaseNodeWithoutComments {
    leadingComments?: Comment[] | undefined;
    trailingComments?: Comment[] | undefined;
}

interface Comment extends BaseNodeWithoutComments {
    type: "Line" | "Block";
    value: string;
}

interface SourceLocation {
    source?: string | null | undefined;
    start: Position;
    end: Position;
}

interface Position {
    /** >= 1 */
    line: number;
    /** >= 0 */
    column: number;
}

interface BaseFunction extends BaseNode {
    params: Pattern[];
    generator?: boolean | undefined;
    async?: boolean | undefined;
    // The body is either BlockStatement or Expression because arrow functions
    // can have a body that's either. FunctionDeclarations and
    // FunctionExpressions have only BlockStatement bodies.
    body: BlockStatement | Expression;
}

type Statement =
    | ExpressionStatement
    | BlockStatement
    | StaticBlock
    | EmptyStatement
    | DebuggerStatement
    | WithStatement
    | ReturnStatement
    | LabeledStatement
    | BreakStatement
    | ContinueStatement
    | IfStatement
    | SwitchStatement
    | ThrowStatement
    | TryStatement
    | WhileStatement
    | DoWhileStatement
    | ForStatement
    | ForInStatement
    | ForOfStatement
    | Declaration;

interface BaseStatement extends BaseNode {}

interface EmptyStatement extends BaseStatement {
    type: "EmptyStatement";
}

interface BlockStatement extends BaseStatement {
    type: "BlockStatement";
    body: Statement[];
    innerComments?: Comment[] | undefined;
}

interface StaticBlock extends Omit<BlockStatement, "type"> {
    type: "StaticBlock";
}

interface ExpressionStatement extends BaseStatement {
    type: "ExpressionStatement";
    expression: Expression;
}

interface IfStatement extends BaseStatement {
    type: "IfStatement";
    test: Expression;
    consequent: Statement;
    alternate?: Statement | null | undefined;
}

interface LabeledStatement extends BaseStatement {
    type: "LabeledStatement";
    label: Identifier;
    body: Statement;
}

interface BreakStatement extends BaseStatement {
    type: "BreakStatement";
    label?: Identifier | null | undefined;
}

interface ContinueStatement extends BaseStatement {
    type: "ContinueStatement";
    label?: Identifier | null | undefined;
}

interface WithStatement extends BaseStatement {
    type: "WithStatement";
    object: Expression;
    body: Statement;
}

interface SwitchStatement extends BaseStatement {
    type: "SwitchStatement";
    discriminant: Expression;
    cases: SwitchCase[];
}

interface ReturnStatement extends BaseStatement {
    type: "ReturnStatement";
    argument?: Expression | null | undefined;
}

interface ThrowStatement extends BaseStatement {
    type: "ThrowStatement";
    argument: Expression;
}

interface TryStatement extends BaseStatement {
    type: "TryStatement";
    block: BlockStatement;
    handler?: CatchClause | null | undefined;
    finalizer?: BlockStatement | null | undefined;
}

interface WhileStatement extends BaseStatement {
    type: "WhileStatement";
    test: Expression;
    body: Statement;
}

interface DoWhileStatement extends BaseStatement {
    type: "DoWhileStatement";
    body: Statement;
    test: Expression;
}

interface ForStatement extends BaseStatement {
    type: "ForStatement";
    init?: VariableDeclaration | Expression | null | undefined;
    test?: Expression | null | undefined;
    update?: Expression | null | undefined;
    body: Statement;
}

interface BaseForXStatement extends BaseStatement {
    left: VariableDeclaration | Pattern;
    right: Expression;
    body: Statement;
}

interface ForInStatement extends BaseForXStatement {
    type: "ForInStatement";
}

interface DebuggerStatement extends BaseStatement {
    type: "DebuggerStatement";
}

type Declaration = FunctionDeclaration | VariableDeclaration | ClassDeclaration;

interface BaseDeclaration extends BaseStatement {}

interface MaybeNamedFunctionDeclaration extends BaseFunction, BaseDeclaration {
    type: "FunctionDeclaration";
    /** It is null when a function declaration is a part of the `export default function` statement */
    id: Identifier | null;
    body: BlockStatement;
}

interface FunctionDeclaration extends MaybeNamedFunctionDeclaration {
    id: Identifier;
}

interface VariableDeclaration extends BaseDeclaration {
    type: "VariableDeclaration";
    declarations: VariableDeclarator[];
    kind: "var" | "let" | "const";
}

interface VariableDeclarator extends BaseNode {
    type: "VariableDeclarator";
    id: Pattern;
    init?: Expression | null | undefined;
}

interface ExpressionMap {
    ArrayExpression: ArrayExpression;
    ArrowFunctionExpression: ArrowFunctionExpression;
    AssignmentExpression: AssignmentExpression;
    AwaitExpression: AwaitExpression;
    BinaryExpression: BinaryExpression;
    CallExpression: CallExpression;
    ChainExpression: ChainExpression;
    ClassExpression: ClassExpression;
    ConditionalExpression: ConditionalExpression;
    FunctionExpression: FunctionExpression;
    Identifier: Identifier;
    ImportExpression: ImportExpression;
    Literal: Literal;
    LogicalExpression: LogicalExpression;
    MemberExpression: MemberExpression;
    MetaProperty: MetaProperty;
    NewExpression: NewExpression;
    ObjectExpression: ObjectExpression;
    SequenceExpression: SequenceExpression;
    TaggedTemplateExpression: TaggedTemplateExpression;
    TemplateLiteral: TemplateLiteral;
    ThisExpression: ThisExpression;
    UnaryExpression: UnaryExpression;
    UpdateExpression: UpdateExpression;
    YieldExpression: YieldExpression;
}

type Expression = ExpressionMap[keyof ExpressionMap];

interface BaseExpression extends BaseNode {}

type ChainElement = SimpleCallExpression | MemberExpression;

interface ChainExpression extends BaseExpression {
    type: "ChainExpression";
    expression: ChainElement;
}

interface ThisExpression extends BaseExpression {
    type: "ThisExpression";
}

interface ArrayExpression extends BaseExpression {
    type: "ArrayExpression";
    elements: Array<Expression | SpreadElement | null>;
}

interface ObjectExpression extends BaseExpression {
    type: "ObjectExpression";
    properties: Array<Property | SpreadElement>;
}

interface PrivateIdentifier extends BaseNode {
    type: "PrivateIdentifier";
    name: string;
}

interface Property extends BaseNode {
    type: "Property";
    key: Expression | PrivateIdentifier;
    value: Expression | Pattern; // Could be an AssignmentProperty
    kind: "init" | "get" | "set";
    method: boolean;
    shorthand: boolean;
    computed: boolean;
}

interface PropertyDefinition extends BaseNode {
    type: "PropertyDefinition";
    key: Expression | PrivateIdentifier;
    value?: Expression | null | undefined;
    computed: boolean;
    static: boolean;
}

interface FunctionExpression extends BaseFunction, BaseExpression {
    id?: Identifier | null | undefined;
    type: "FunctionExpression";
    body: BlockStatement;
}

interface SequenceExpression extends BaseExpression {
    type: "SequenceExpression";
    expressions: Expression[];
}

interface UnaryExpression extends BaseExpression {
    type: "UnaryExpression";
    operator: UnaryOperator;
    prefix: true;
    argument: Expression;
}

interface BinaryExpression extends BaseExpression {
    type: "BinaryExpression";
    operator: BinaryOperator;
    left: Expression | PrivateIdentifier;
    right: Expression;
}

interface AssignmentExpression extends BaseExpression {
    type: "AssignmentExpression";
    operator: AssignmentOperator;
    left: Pattern | MemberExpression;
    right: Expression;
}

interface UpdateExpression extends BaseExpression {
    type: "UpdateExpression";
    operator: UpdateOperator;
    argument: Expression;
    prefix: boolean;
}

interface LogicalExpression extends BaseExpression {
    type: "LogicalExpression";
    operator: LogicalOperator;
    left: Expression;
    right: Expression;
}

interface ConditionalExpression extends BaseExpression {
    type: "ConditionalExpression";
    test: Expression;
    alternate: Expression;
    consequent: Expression;
}

interface BaseCallExpression extends BaseExpression {
    callee: Expression | Super;
    arguments: Array<Expression | SpreadElement>;
}
type CallExpression = SimpleCallExpression | NewExpression;

interface SimpleCallExpression extends BaseCallExpression {
    type: "CallExpression";
    optional: boolean;
}

interface NewExpression extends BaseCallExpression {
    type: "NewExpression";
}

interface MemberExpression extends BaseExpression, BasePattern {
    type: "MemberExpression";
    object: Expression | Super;
    property: Expression | PrivateIdentifier;
    computed: boolean;
    optional: boolean;
}

type Pattern = Identifier | ObjectPattern | ArrayPattern | RestElement | AssignmentPattern | MemberExpression;

interface BasePattern extends BaseNode {}

interface SwitchCase extends BaseNode {
    type: "SwitchCase";
    test?: Expression | null | undefined;
    consequent: Statement[];
}

interface CatchClause extends BaseNode {
    type: "CatchClause";
    param: Pattern | null;
    body: BlockStatement;
}

interface Identifier extends BaseNode, BaseExpression, BasePattern {
    type: "Identifier";
    name: string;
}

type Literal = SimpleLiteral | RegExpLiteral | BigIntLiteral;

interface SimpleLiteral extends BaseNode, BaseExpression {
    type: "Literal";
    value: string | boolean | number | null;
    raw?: string | undefined;
}

interface RegExpLiteral extends BaseNode, BaseExpression {
    type: "Literal";
    value?: RegExp | null | undefined;
    regex: {
        pattern: string;
        flags: string;
    };
    raw?: string | undefined;
}

interface BigIntLiteral extends BaseNode, BaseExpression {
    type: "Literal";
    value?: bigint | null | undefined;
    bigint: string;
    raw?: string | undefined;
}

type UnaryOperator = "-" | "+" | "!" | "~" | "typeof" | "void" | "delete";

type BinaryOperator =
    | "=="
    | "!="
    | "==="
    | "!=="
    | "<"
    | "<="
    | ">"
    | ">="
    | "<<"
    | ">>"
    | ">>>"
    | "+"
    | "-"
    | "*"
    | "/"
    | "%"
    | "**"
    | "|"
    | "^"
    | "&"
    | "in"
    | "instanceof";

type LogicalOperator = "||" | "&&" | "??";

type AssignmentOperator =
    | "="
    | "+="
    | "-="
    | "*="
    | "/="
    | "%="
    | "**="
    | "<<="
    | ">>="
    | ">>>="
    | "|="
    | "^="
    | "&="
    | "||="
    | "&&="
    | "??=";

type UpdateOperator = "++" | "--";

interface ForOfStatement extends BaseForXStatement {
    type: "ForOfStatement";
    await: boolean;
}

interface Super extends BaseNode {
    type: "Super";
}

interface SpreadElement extends BaseNode {
    type: "SpreadElement";
    argument: Expression;
}

interface ArrowFunctionExpression extends BaseExpression, BaseFunction {
    type: "ArrowFunctionExpression";
    expression: boolean;
    body: BlockStatement | Expression;
}

interface YieldExpression extends BaseExpression {
    type: "YieldExpression";
    argument?: Expression | null | undefined;
    delegate: boolean;
}

interface TemplateLiteral extends BaseExpression {
    type: "TemplateLiteral";
    quasis: TemplateElement[];
    expressions: Expression[];
}

interface TaggedTemplateExpression extends BaseExpression {
    type: "TaggedTemplateExpression";
    tag: Expression;
    quasi: TemplateLiteral;
}

interface TemplateElement extends BaseNode {
    type: "TemplateElement";
    tail: boolean;
    value: {
        /** It is null when the template literal is tagged and the text has an invalid escape (e.g. - tag`\unicode and \u{55}`) */
        cooked?: string | null | undefined;
        raw: string;
    };
}

interface AssignmentProperty extends Property {
    value: Pattern;
    kind: "init";
    method: boolean; // false
}

interface ObjectPattern extends BasePattern {
    type: "ObjectPattern";
    properties: Array<AssignmentProperty | RestElement>;
}

interface ArrayPattern extends BasePattern {
    type: "ArrayPattern";
    elements: Array<Pattern | null>;
}

interface RestElement extends BasePattern {
    type: "RestElement";
    argument: Pattern;
}

interface AssignmentPattern extends BasePattern {
    type: "AssignmentPattern";
    left: Pattern;
    right: Expression;
}
interface BaseClass extends BaseNode {
    superClass?: Expression | null | undefined;
    body: ClassBody;
}

interface ClassBody extends BaseNode {
    type: "ClassBody";
    body: Array<MethodDefinition | PropertyDefinition | StaticBlock>;
}

interface MethodDefinition extends BaseNode {
    type: "MethodDefinition";
    key: Expression | PrivateIdentifier;
    value: FunctionExpression;
    kind: "constructor" | "method" | "get" | "set";
    computed: boolean;
    static: boolean;
}

interface MaybeNamedClassDeclaration extends BaseClass, BaseDeclaration {
    type: "ClassDeclaration";
    /** It is null when a class declaration is a part of the `export default class` statement */
    id: Identifier | null;
}

interface ClassDeclaration extends MaybeNamedClassDeclaration {
    id: Identifier;
}

interface ClassExpression extends BaseClass, BaseExpression {
    type: "ClassExpression";
    id?: Identifier | null | undefined;
}

interface MetaProperty extends BaseExpression {
    type: "MetaProperty";
    meta: Identifier;
    property: Identifier;
}

interface ImportExpression extends BaseExpression {
    type: "ImportExpression";
    source: Expression;
}

interface AwaitExpression extends BaseExpression {
    type: "AwaitExpression";
    argument: Expression;
}

declare module 'estree' {
	export interface Decorator extends BaseNode {
		type: 'Decorator';
		expression: Expression;
	}
	interface PropertyDefinition {
		decorators: undefined[];
	}
	interface MethodDefinition {
		decorators: undefined[];
	}
	interface BaseClass {
		decorators: undefined[];
	}
}

// declare AbortSignal here for environments without DOM lib or @types/node
declare global {
	// eslint-disable-next-line @typescript-eslint/no-empty-object-type
	interface AbortSignal {}
}

type Logger = {
    info(msg: string): void;
    warn(msg: string): void;
    error(err: unknown): void;
};

declare class CliWorkspace {
    private services;
    private isInitialized;
    constructor(services: CliServices);
    initWorkspace(workspace: WorkspaceFolder): Promise<void>;
    init(): Promise<void>;
}

type CliAddedServices = {
    logger: Logger;
    likec4: {
        Layouter: GraphvizLayouter;
        Views: Views;
    };
    cli: {
        Workspace: CliWorkspace;
    };
};
type CliServices = LikeC4Services & CliAddedServices;

type GraphvizOut = {
    dot: string;
    diagram: DiagramView;
};
type GraphvizSvgOut = {
    id: ViewID$1;
    dot: string;
    svg: string;
};
declare class Views {
    private services;
    private cache;
    private layouter;
    private previousAction;
    private limit;
    constructor(services: CliServices);
    private inflightRequest;
    computedViews(): Promise<ComputedView[]>;
    layoutViews(): Promise<Array<Readonly<GraphvizOut>>>;
    diagrams(): Promise<Array<DiagramView>>;
    viewsAsGraphvizOut(): Promise<Array<GraphvizSvgOut>>;
    overviewGraph(): Promise<OverviewGraph>;
}

type LikeC4Options = {
    /**
     * By default, if LikeC4 model is invalid, errors are printed to the console.
     * Disable this behavior by setting this option to false.
     *
     * @default true
     */
    printErrors?: boolean;
    /**
     * If true, initialization will return rejected promise with the LikeC4 instance.
     * Use `likec4.getErrors()` to get the errors.
     * @default false
     */
    throwIfInvalid?: boolean;
    /**
     * Logger to use for the language service.
     * false - no output
     * @default 'default'
     */
    logger?: Logger | 'vite' | 'default' | false;
    /**
     * Whether to use the `dot` binary for layouting or the WebAssembly version.
     * @default 'wasm'
     */
    graphviz?: 'wasm' | 'binary';
};
declare class LikeC4 {
    readonly workspace: string;
    private langium;
    private isPrintErrorEnabled;
    static fromSource(likec4SourceCode: string, opts?: LikeC4Options): Promise<LikeC4>;
    /**
     * Prevents multiple instances of LikeC4 for the same workspace
     */
    private static likec4Instances;
    /**
     * Initializes a LikeC4 instance from the specified workspace path.
     * By default in current folder
     */
    static fromWorkspace(path?: string, opts?: LikeC4Options): Promise<LikeC4>;
    private modelComputedRef;
    private modelLayoutedRef;
    private logger;
    private langiumDocuments;
    private constructor();
    get viewsService(): Views;
    /**
     * Diagram is a computed view, layouted using Graphviz
     * Used in React components
     */
    diagrams(): Promise<DiagramView[]>;
    /**
     * Synchronously builds architecture model
     * Only compute views predicates {@link ComputedView} - i.e. no layout
     * Not ready for rendering, but enough to traverse
     */
    computedModel(): LikeC4Model.Computed;
    /**
     * Same as {@link computedModel()}, after applies layout
     * Ready for rendering
     */
    layoutedModel(): Promise<LikeC4Model.Layouted>;
    getErrors(): {
        message: string;
        line: number;
        range: Range$1;
        sourceFsPath: string;
    }[];
    hasErrors(): boolean;
    /**
     * @returns true if there are errors
     */
    printErrors(): boolean;
    /**
     * TODO Replace with watcher
     */
    notifyUpdate({ changed, removed }: {
        changed?: string;
        removed?: string;
    }): Promise<boolean>;
    /**
     * @returns a function to dispose the listener
     */
    onModelUpdate(listener: () => void): () => void;
    dispose(): void;
}

export { type AutoLayoutDirection, type BBox, BorderStyles, Builder, type BuilderSpecification, type Color$1 as Color, type ComputedDynamicView, type ComputedEdge, type ComputedElementView, type ComputedLikeC4Model, ComputedNode, type ComputedView, type DiagramEdge, DiagramNode, type DiagramView, type DynamicView$1 as DynamicView, type EdgeId$1 as EdgeId, type Element$1 as Element, ElementColors, ElementKind$1 as ElementKind, ElementShapes, type ElementView$1 as ElementView, type Fqn$1 as Fqn, type HexColorLiteral, type LayoutedLikeC4Model, LikeC4, Builder as LikeC4Builder, LikeC4DiagramModel, LikeC4Model, type LikeC4View$1 as LikeC4View, LikeC4ViewModel, type NodeId, type ParsedLikeC4Model, type Point, type Relation$1 as Relation, type RelationExpr, type RelationID$1 as RelationID, RelationshipColors, StepEdgeId, type Tag$1 as Tag, type ThemeColor$1 as ThemeColor, type ViewID$1 as ViewID, type XYPoint, ancestorsFqn, commonAncestor, compareByFqnHierarchically, compareFqnHierarchically, compareRelations, defaultTheme, extractStep, hasAtLeast, invariant, isAncestor, isComputedDynamicView, isDescendantOf, isSameHierarchy, isStepEdgeId, nameFromFqn, nonNullable, nonexhaustive, parentFqn };
