import { jsxs, jsx, Fragment } from "react/jsx-runtime";
import * as React from "react";
import { flushSync } from "react-dom";
import { w as withSelectorExports } from "./likec4-DF_Jsv_p.js";
const pushStateEvent = "pushstate", popStateEvent = "popstate", beforeUnloadEvent = "beforeunload", beforeUnloadListener = (event) => (event.preventDefault(), event.returnValue = ""), stopBlocking = () => {
  removeEventListener(beforeUnloadEvent, beforeUnloadListener, {
    capture: !0
  });
};
function createHistory(opts) {
  let location = opts.getLocation();
  const subscribers = /* @__PURE__ */ new Set();
  let blockers = [];
  const notify = () => {
    location = opts.getLocation(), subscribers.forEach((subscriber) => subscriber());
  }, tryNavigation = async (task, navigateOpts) => {
    var _a;
    if (!(navigateOpts?.ignoreBlocker ?? !1) && typeof document < "u" && blockers.length) {
      for (const blocker of blockers)
        if (!await blocker()) {
          (_a = opts.onBlocked) == null || _a.call(opts, notify);
          return;
        }
    }
    task();
  };
  return {
    get location() {
      return location;
    },
    subscribers,
    subscribe: (cb) => (subscribers.add(cb), () => {
      subscribers.delete(cb);
    }),
    push: (path, state, navigateOpts) => {
      state = assignKey(state), tryNavigation(() => {
        opts.pushState(path, state), notify();
      }, navigateOpts);
    },
    replace: (path, state, navigateOpts) => {
      state = assignKey(state), tryNavigation(() => {
        opts.replaceState(path, state), notify();
      }, navigateOpts);
    },
    go: (index, navigateOpts) => {
      tryNavigation(() => {
        opts.go(index), notify();
      }, navigateOpts);
    },
    back: (navigateOpts) => {
      tryNavigation(() => {
        opts.back(), notify();
      }, navigateOpts);
    },
    forward: (navigateOpts) => {
      tryNavigation(() => {
        opts.forward(), notify();
      }, navigateOpts);
    },
    createHref: (str) => opts.createHref(str),
    block: (blocker) => (blockers.push(blocker), blockers.length === 1 && addEventListener(beforeUnloadEvent, beforeUnloadListener, {
      capture: !0
    }), () => {
      blockers = blockers.filter((b) => b !== blocker), blockers.length || stopBlocking();
    }),
    flush: () => {
      var _a;
      return (_a = opts.flush) == null ? void 0 : _a.call(opts);
    },
    destroy: () => {
      var _a;
      return (_a = opts.destroy) == null ? void 0 : _a.call(opts);
    },
    notify
  };
}
function assignKey(state) {
  return state || (state = {}), {
    ...state,
    key: createRandomKey()
  };
}
function createBrowserHistory(opts) {
  const win = opts?.window ?? (typeof document < "u" ? window : void 0), originalPushState = win.history.pushState, originalReplaceState = win.history.replaceState, createHref = opts?.createHref ?? ((path) => path), parseLocation = opts?.parseLocation ?? (() => parseHref(
    `${win.location.pathname}${win.location.search}${win.location.hash}`,
    win.history.state
  ));
  let currentLocation = parseLocation(), rollbackLocation;
  const getLocation = () => currentLocation;
  let next, scheduled;
  const flush = () => {
    if (!next)
      return;
    (next.isPush ? originalPushState : originalReplaceState).call(win.history, next.state, "", next.href), next = void 0, scheduled = void 0, rollbackLocation = void 0;
  }, queueHistoryAction = (type, destHref, state) => {
    const href = createHref(destHref);
    scheduled || (rollbackLocation = currentLocation), currentLocation = parseHref(destHref, state), next = {
      href,
      state,
      isPush: next?.isPush || type === "push"
    }, scheduled || (scheduled = Promise.resolve().then(() => flush()));
  }, onPushPop = () => {
    currentLocation = parseLocation(), history.notify();
  }, history = createHistory({
    getLocation,
    pushState: (href, state) => queueHistoryAction("push", href, state),
    replaceState: (href, state) => queueHistoryAction("replace", href, state),
    back: () => win.history.back(),
    forward: () => win.history.forward(),
    go: (n) => win.history.go(n),
    createHref: (href) => createHref(href),
    flush,
    destroy: () => {
      win.history.pushState = originalPushState, win.history.replaceState = originalReplaceState, win.removeEventListener(pushStateEvent, onPushPop), win.removeEventListener(popStateEvent, onPushPop);
    },
    onBlocked: (onUpdate) => {
      rollbackLocation && currentLocation !== rollbackLocation && (currentLocation = rollbackLocation, onUpdate());
    }
  });
  return win.addEventListener(pushStateEvent, onPushPop), win.addEventListener(popStateEvent, onPushPop), win.history.pushState = function(...args) {
    const res = originalPushState.apply(win.history, args);
    return onPushPop(), res;
  }, win.history.replaceState = function(...args) {
    const res = originalReplaceState.apply(win.history, args);
    return onPushPop(), res;
  }, history;
}
function createHashHistory(opts) {
  const win = typeof document < "u" ? window : void 0;
  return createBrowserHistory({
    window: win,
    parseLocation: () => {
      const hashHref = win.location.hash.split("#").slice(1).join("#") ?? "/";
      return parseHref(hashHref, win.history.state);
    },
    createHref: (href) => `${win.location.pathname}${win.location.search}#${href}`
  });
}
function createMemoryHistory(opts = {
  initialEntries: ["/"]
}) {
  const entries = opts.initialEntries;
  let index = opts.initialIndex ?? entries.length - 1, currentState = {
    key: createRandomKey()
  };
  return createHistory({
    getLocation: () => parseHref(entries[index], currentState),
    pushState: (path, state) => {
      currentState = state, entries.splice, index < entries.length - 1 && entries.splice(index + 1), entries.push(path), index = Math.max(entries.length - 1, 0);
    },
    replaceState: (path, state) => {
      currentState = state, entries[index] = path;
    },
    back: () => {
      currentState = assignKey(currentState), index = Math.max(index - 1, 0);
    },
    forward: () => {
      currentState = assignKey(currentState), index = Math.min(index + 1, entries.length - 1);
    },
    go: (n) => {
      currentState = assignKey(currentState), index = Math.min(Math.max(index + n, 0), entries.length - 1);
    },
    createHref: (path) => path
  });
}
function parseHref(href, state) {
  const hashIndex = href.indexOf("#"), searchIndex = href.indexOf("?");
  return {
    href,
    pathname: href.substring(
      0,
      hashIndex > 0 ? searchIndex > 0 ? Math.min(hashIndex, searchIndex) : hashIndex : searchIndex > 0 ? searchIndex : href.length
    ),
    hash: hashIndex > -1 ? href.substring(hashIndex) : "",
    search: searchIndex > -1 ? href.slice(searchIndex, hashIndex === -1 ? void 0 : hashIndex) : "",
    state: state || {}
  };
}
function createRandomKey() {
  return (Math.random() + 1).toString(36).substring(7);
}
var isProduction$1 = !0, prefix = "Invariant failed";
function invariant(condition, message) {
  if (!condition) {
    if (isProduction$1)
      throw new Error(prefix);
    var provided = typeof message == "function" ? message() : message, value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
    throw new Error(value);
  }
}
var isProduction = !0;
function warning(condition, message) {
  if (!isProduction) {
    if (condition)
      return;
    var text = "Warning: " + message;
    typeof console < "u" && console.warn(text);
    try {
      throw Error(text);
    } catch {
    }
  }
}
const routerContext = React.createContext(null);
function getRouterContext() {
  return typeof document > "u" ? routerContext : window.__TSR_ROUTER_CONTEXT__ ? window.__TSR_ROUTER_CONTEXT__ : (window.__TSR_ROUTER_CONTEXT__ = routerContext, routerContext);
}
function useRouter(opts) {
  const value = React.useContext(getRouterContext());
  return warning(
    !((opts?.warn ?? !0) && !value),
    "useRouter must be used inside a <RouterProvider> component!"
  ), value;
}
class Store {
  constructor(initialState, options) {
    this.listeners = /* @__PURE__ */ new Set(), this._batching = !1, this._flushing = 0, this.subscribe = (listener) => {
      var _a, _b;
      this.listeners.add(listener);
      const unsub = (_b = (_a = this.options) == null ? void 0 : _a.onSubscribe) == null ? void 0 : _b.call(_a, listener, this);
      return () => {
        this.listeners.delete(listener), unsub?.();
      };
    }, this.setState = (updater) => {
      var _a, _b, _c;
      const previous = this.state;
      this.state = (_a = this.options) != null && _a.updateFn ? this.options.updateFn(previous)(updater) : updater(previous), (_c = (_b = this.options) == null ? void 0 : _b.onUpdate) == null || _c.call(_b), this._flush();
    }, this._flush = () => {
      if (this._batching) return;
      const flushId = ++this._flushing;
      this.listeners.forEach((listener) => {
        this._flushing === flushId && listener();
      });
    }, this.batch = (cb) => {
      if (this._batching) return cb();
      this._batching = !0, cb(), this._batching = !1, this._flush();
    }, this.state = initialState, this.options = options;
  }
}
function useStore(store, selector = (d) => d) {
  return withSelectorExports.useSyncExternalStoreWithSelector(
    store.subscribe,
    () => store.state,
    () => store.state,
    selector,
    shallow
  );
}
function shallow(objA, objB) {
  if (Object.is(objA, objB))
    return !0;
  if (typeof objA != "object" || objA === null || typeof objB != "object" || objB === null)
    return !1;
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length)
    return !1;
  for (let i = 0; i < keysA.length; i++)
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]]))
      return !1;
  return !0;
}
const rootRouteId = "__root__";
function encode(obj, pfx) {
  let k, i, tmp, str = "";
  for (k in obj)
    if ((tmp = obj[k]) !== void 0)
      if (Array.isArray(tmp))
        for (i = 0; i < tmp.length; i++)
          str && (str += "&"), str += encodeURIComponent(k) + "=" + encodeURIComponent(tmp[i]);
      else
        str && (str += "&"), str += encodeURIComponent(k) + "=" + encodeURIComponent(tmp);
  return "" + str;
}
function toValue(mix) {
  if (!mix) return "";
  const str = decodeURIComponent(mix);
  return str === "false" ? !1 : str === "true" ? !0 : +str * 0 === 0 && +str + "" === str ? +str : str;
}
function decode(str, pfx) {
  let tmp, k;
  const out = {}, arr = str.split("&");
  for (; tmp = arr.shift(); ) {
    const equalIndex = tmp.indexOf("=");
    if (equalIndex !== -1) {
      k = tmp.slice(0, equalIndex);
      const value = tmp.slice(equalIndex + 1);
      out[k] !== void 0 ? out[k] = [].concat(out[k], toValue(value)) : out[k] = toValue(value);
    } else
      k = tmp, out[k] = "";
  }
  return out;
}
const defaultParseSearch = parseSearchWith(JSON.parse), defaultStringifySearch = stringifySearchWith(
  JSON.stringify,
  JSON.parse
);
function parseSearchWith(parser) {
  return (searchStr) => {
    searchStr.substring(0, 1) === "?" && (searchStr = searchStr.substring(1));
    const query = decode(searchStr);
    for (const key in query) {
      const value = query[key];
      if (typeof value == "string")
        try {
          query[key] = parser(value);
        } catch {
        }
    }
    return query;
  };
}
function stringifySearchWith(stringify, parser) {
  function stringifyValue(val) {
    if (typeof val == "object" && val !== null)
      try {
        return stringify(val);
      } catch {
      }
    else if (typeof val == "string" && typeof parser == "function")
      try {
        return parser(val), stringify(val);
      } catch {
      }
    return val;
  }
  return (search) => {
    search = { ...search }, Object.keys(search).forEach((key) => {
      const val = search[key];
      typeof val > "u" || val === void 0 ? delete search[key] : search[key] = stringifyValue(val);
    });
    const searchStr = encode(search).toString();
    return searchStr ? `?${searchStr}` : "";
  };
}
function last(arr) {
  return arr[arr.length - 1];
}
function isFunction(d) {
  return typeof d == "function";
}
function functionalUpdate(updater, previous) {
  return isFunction(updater) ? updater(previous) : updater;
}
function pick(parent, keys) {
  return keys.reduce((obj, key) => (obj[key] = parent[key], obj), {});
}
function replaceEqualDeep(prev, _next) {
  if (prev === _next)
    return prev;
  const next = _next, array = isPlainArray(prev) && isPlainArray(next);
  if (array || isPlainObject(prev) && isPlainObject(next)) {
    const prevItems = array ? prev : Object.keys(prev), prevSize = prevItems.length, nextItems = array ? next : Object.keys(next), nextSize = nextItems.length, copy = array ? [] : {};
    let equalItems = 0;
    for (let i = 0; i < nextSize; i++) {
      const key = array ? i : nextItems[i];
      (!array && prevItems.includes(key) || array) && prev[key] === void 0 && next[key] === void 0 ? (copy[key] = void 0, equalItems++) : (copy[key] = replaceEqualDeep(prev[key], next[key]), copy[key] === prev[key] && prev[key] !== void 0 && equalItems++);
    }
    return prevSize === nextSize && equalItems === prevSize ? prev : copy;
  }
  return next;
}
function isPlainObject(o) {
  if (!hasObjectPrototype(o))
    return !1;
  const ctor = o.constructor;
  if (typeof ctor > "u")
    return !0;
  const prot = ctor.prototype;
  return !(!hasObjectPrototype(prot) || !prot.hasOwnProperty("isPrototypeOf"));
}
function hasObjectPrototype(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length;
}
function deepEqual(a, b, partial = !1) {
  if (a === b)
    return !0;
  if (typeof a != typeof b)
    return !1;
  if (isPlainObject(a) && isPlainObject(b)) {
    const aKeys = Object.keys(a).filter((key) => a[key] !== void 0), bKeys = Object.keys(b).filter((key) => b[key] !== void 0);
    return !partial && aKeys.length !== bKeys.length ? !1 : !bKeys.some(
      (key) => !(key in a) || !deepEqual(a[key], b[key], partial)
    );
  }
  return Array.isArray(a) && Array.isArray(b) ? a.length !== b.length ? !1 : !a.some((item, index) => !deepEqual(item, b[index], partial)) : !1;
}
const useLayoutEffect$1 = typeof window < "u" ? React.useLayoutEffect : React.useEffect;
function createControlledPromise(onResolve) {
  let resolveLoadPromise, rejectLoadPromise;
  const controlledPromise = new Promise((resolve, reject) => {
    resolveLoadPromise = resolve, rejectLoadPromise = reject;
  });
  return controlledPromise.status = "pending", controlledPromise.resolve = (value) => {
    controlledPromise.status = "resolved", controlledPromise.value = value, resolveLoadPromise(value), onResolve?.(value);
  }, controlledPromise.reject = (e) => {
    controlledPromise.status = "rejected", rejectLoadPromise(e);
  }, controlledPromise;
}
function usePrevious(value) {
  const ref = React.useRef({
    value,
    prev: null
  }), current = ref.current.value;
  return value !== current && (ref.current = {
    value,
    prev: current
  }), ref.current.prev;
}
function joinPaths(paths) {
  return cleanPath(
    paths.filter((val) => val !== void 0).join("/")
  );
}
function cleanPath(path) {
  return path.replace(/\/{2,}/g, "/");
}
function trimPathLeft(path) {
  return path === "/" ? path : path.replace(/^\/{1,}/, "");
}
function trimPathRight(path) {
  return path === "/" ? path : path.replace(/\/{1,}$/, "");
}
function trimPath(path) {
  return trimPathRight(trimPathLeft(path));
}
function removeTrailingSlash(value, basepath) {
  return value.endsWith("/") && value !== "/" && value !== `${basepath}/` ? value.slice(0, -1) : value;
}
function exactPathTest(pathName1, pathName2, basepath) {
  return removeTrailingSlash(pathName1, basepath) === removeTrailingSlash(pathName2, basepath);
}
function resolvePath({
  basepath,
  base,
  to,
  trailingSlash = "never"
}) {
  var _a, _b;
  base = removeBasepath(basepath, base), to = removeBasepath(basepath, to);
  let baseSegments = parsePathname(base);
  const toSegments = parsePathname(to);
  baseSegments.length > 1 && ((_a = last(baseSegments)) == null ? void 0 : _a.value) === "/" && baseSegments.pop(), toSegments.forEach((toSegment, index) => {
    toSegment.value === "/" ? index ? index === toSegments.length - 1 && baseSegments.push(toSegment) : baseSegments = [toSegment] : toSegment.value === ".." ? baseSegments.pop() : toSegment.value === "." || baseSegments.push(toSegment);
  }), baseSegments.length > 1 && (((_b = last(baseSegments)) == null ? void 0 : _b.value) === "/" ? trailingSlash === "never" && baseSegments.pop() : trailingSlash === "always" && baseSegments.push({ type: "pathname", value: "/" }));
  const joined = joinPaths([basepath, ...baseSegments.map((d) => d.value)]);
  return cleanPath(joined);
}
function parsePathname(pathname) {
  if (!pathname)
    return [];
  pathname = cleanPath(pathname);
  const segments = [];
  if (pathname.slice(0, 1) === "/" && (pathname = pathname.substring(1), segments.push({
    type: "pathname",
    value: "/"
  })), !pathname)
    return segments;
  const split = pathname.split("/").filter(Boolean);
  return segments.push(
    ...split.map((part) => part === "$" || part === "*" ? {
      type: "wildcard",
      value: part
    } : part.charAt(0) === "$" ? {
      type: "param",
      value: part
    } : {
      type: "pathname",
      value: decodeURIComponent(part)
    })
  ), pathname.slice(-1) === "/" && (pathname = pathname.substring(1), segments.push({
    type: "pathname",
    value: "/"
  })), segments;
}
function interpolatePath({
  path,
  params,
  leaveWildcards,
  leaveParams
}) {
  const interpolatedPathSegments = parsePathname(path), encodedParams = {};
  for (const [key, value] of Object.entries(params)) {
    const isValueString = typeof value == "string";
    ["*", "_splat"].includes(key) ? encodedParams[key] = isValueString ? encodeURI(value) : value : encodedParams[key] = isValueString ? encodeURIComponent(value) : value;
  }
  return joinPaths(
    interpolatedPathSegments.map((segment) => {
      if (segment.type === "wildcard") {
        const value = encodedParams._splat;
        return leaveWildcards ? `${segment.value}${value ?? ""}` : value;
      }
      if (segment.type === "param") {
        if (leaveParams) {
          const value = encodedParams[segment.value];
          return `${segment.value}${value ?? ""}`;
        }
        return encodedParams[segment.value.substring(1)] ?? "undefined";
      }
      return segment.value;
    })
  );
}
function matchPathname(basepath, currentPathname, matchLocation) {
  const pathParams = matchByPath(basepath, currentPathname, matchLocation);
  if (!(matchLocation.to && !pathParams))
    return pathParams ?? {};
}
function removeBasepath(basepath, pathname) {
  switch (!0) {
    case basepath === "/":
      return pathname;
    case pathname === basepath:
      return "";
    case pathname.length < basepath.length:
      return pathname;
    case pathname[basepath.length] !== "/":
      return pathname;
    case pathname.startsWith(basepath):
      return pathname.slice(basepath.length);
    default:
      return pathname;
  }
}
function matchByPath(basepath, from, matchLocation) {
  from = removeBasepath(basepath, from);
  const to = removeBasepath(basepath, `${matchLocation.to ?? "$"}`), baseSegments = parsePathname(from), routeSegments = parsePathname(to);
  from.startsWith("/") || baseSegments.unshift({
    type: "pathname",
    value: "/"
  }), to.startsWith("/") || routeSegments.unshift({
    type: "pathname",
    value: "/"
  });
  const params = {};
  return (() => {
    for (let i = 0; i < Math.max(baseSegments.length, routeSegments.length); i++) {
      const baseSegment = baseSegments[i], routeSegment = routeSegments[i], isLastBaseSegment = i >= baseSegments.length - 1, isLastRouteSegment = i >= routeSegments.length - 1;
      if (routeSegment) {
        if (routeSegment.type === "wildcard") {
          if (baseSegment?.value) {
            const _splat = decodeURI(
              joinPaths(baseSegments.slice(i).map((d) => d.value))
            );
            return params["*"] = _splat, params._splat = _splat, !0;
          }
          return !1;
        }
        if (routeSegment.type === "pathname") {
          if (routeSegment.value === "/" && !baseSegment?.value)
            return !0;
          if (baseSegment) {
            if (matchLocation.caseSensitive) {
              if (routeSegment.value !== baseSegment.value)
                return !1;
            } else if (routeSegment.value.toLowerCase() !== baseSegment.value.toLowerCase())
              return !1;
          }
        }
        if (!baseSegment)
          return !1;
        if (routeSegment.type === "param") {
          if (baseSegment.value === "/")
            return !1;
          baseSegment.value.charAt(0) !== "$" && (params[routeSegment.value.substring(1)] = decodeURIComponent(
            baseSegment.value
          ));
        }
      }
      if (!isLastBaseSegment && isLastRouteSegment)
        return params["**"] = joinPaths(baseSegments.slice(i + 1).map((d) => d.value)), !!matchLocation.fuzzy && routeSegment?.value !== "/";
    }
    return !0;
  })() ? params : void 0;
}
function isRedirect(obj) {
  return !!obj?.isRedirect;
}
function isResolvedRedirect(obj) {
  return !!obj?.isRedirect && obj.href;
}
function CatchBoundary(props) {
  const errorComponent = props.errorComponent ?? ErrorComponent;
  return /* @__PURE__ */ jsx(
    CatchBoundaryImpl,
    {
      getResetKey: props.getResetKey,
      onCatch: props.onCatch,
      children: ({ error, reset }) => error ? React.createElement(errorComponent, {
        error,
        reset
      }) : props.children
    }
  );
}
class CatchBoundaryImpl extends React.Component {
  constructor() {
    super(...arguments), this.state = { error: null };
  }
  static getDerivedStateFromProps(props) {
    return { resetKey: props.getResetKey() };
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  reset() {
    this.setState({ error: null });
  }
  componentDidUpdate(prevProps, prevState) {
    prevState.error && prevState.resetKey !== this.state.resetKey && this.reset();
  }
  componentDidCatch(error, errorInfo) {
    this.props.onCatch && this.props.onCatch(error, errorInfo);
  }
  render() {
    return this.props.children({
      error: this.state.resetKey !== this.props.getResetKey() ? null : this.state.error,
      reset: () => {
        this.reset();
      }
    });
  }
}
function ErrorComponent({ error }) {
  const [show, setShow] = React.useState(!1);
  return /* @__PURE__ */ jsxs("div", { style: { padding: ".5rem", maxWidth: "100%" }, children: [
    /* @__PURE__ */ jsxs("div", { style: { display: "flex", alignItems: "center", gap: ".5rem" }, children: [
      /* @__PURE__ */ jsx("strong", { style: { fontSize: "1rem" }, children: "Something went wrong!" }),
      /* @__PURE__ */ jsx(
        "button",
        {
          style: {
            appearance: "none",
            fontSize: ".6em",
            border: "1px solid currentColor",
            padding: ".1rem .2rem",
            fontWeight: "bold",
            borderRadius: ".25rem"
          },
          onClick: () => setShow((d) => !d),
          children: show ? "Hide Error" : "Show Error"
        }
      )
    ] }),
    /* @__PURE__ */ jsx("div", { style: { height: ".25rem" } }),
    show ? /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsx(
      "pre",
      {
        style: {
          fontSize: ".7em",
          border: "1px solid red",
          borderRadius: ".25rem",
          padding: ".3rem",
          color: "red",
          overflow: "auto"
        },
        children: error.message ? /* @__PURE__ */ jsx("code", { children: error.message }) : null
      }
    ) }) : null
  ] });
}
function useRouterState(opts) {
  const contextRouter = useRouter({
    warn: opts?.router === void 0
  });
  return useStore((opts?.router || contextRouter).__store, opts?.select);
}
function notFound(options = {}) {
  if (options.isNotFound = !0, options.throw) throw options;
  return options;
}
function isNotFound(obj) {
  return !!obj?.isNotFound;
}
function CatchNotFound(props) {
  const resetKey = useRouterState({
    select: (s) => `not-found-${s.location.pathname}-${s.status}`
  });
  return /* @__PURE__ */ jsx(
    CatchBoundary,
    {
      getResetKey: () => resetKey,
      onCatch: (error, errorInfo) => {
        var _a;
        if (isNotFound(error))
          (_a = props.onCatch) == null || _a.call(props, error, errorInfo);
        else
          throw error;
      },
      errorComponent: ({ error }) => {
        var _a;
        return (_a = props.fallback) == null ? void 0 : _a.call(props, error);
      },
      children: props.children
    }
  );
}
function DefaultGlobalNotFound() {
  return /* @__PURE__ */ jsx("p", { children: "Not Found" });
}
const componentTypes = [
  "component",
  "errorComponent",
  "pendingComponent",
  "notFoundComponent"
];
function createRouter(options) {
  return new Router(options);
}
class Router {
  /**
   * @deprecated Use the `createRouter` function instead
   */
  constructor(options) {
    this.tempLocationKey = `${Math.round(
      Math.random() * 1e7
    )}`, this.resetNextScroll = !0, this.shouldViewTransition = void 0, this.subscribers = /* @__PURE__ */ new Set(), this.startReactTransition = (fn) => fn(), this.update = (newOptions) => {
      newOptions.notFoundRoute && console.warn(
        "The notFoundRoute API is deprecated and will be removed in the next major version. See https://tanstack.com/router/v1/docs/guide/not-found-errors#migrating-from-notfoundroute for more info."
      );
      const previousOptions = this.options;
      this.options = {
        ...this.options,
        ...newOptions
      }, this.isServer = this.options.isServer ?? typeof document > "u", (!this.basepath || newOptions.basepath && newOptions.basepath !== previousOptions.basepath) && (newOptions.basepath === void 0 || newOptions.basepath === "" || newOptions.basepath === "/" ? this.basepath = "/" : this.basepath = `/${trimPath(newOptions.basepath)}`), // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      (!this.history || this.options.history && this.options.history !== this.history) && (this.history = this.options.history ?? (this.isServer ? createMemoryHistory({
        initialEntries: [this.basepath || "/"]
      }) : createBrowserHistory()), this.latestLocation = this.parseLocation()), this.options.routeTree !== this.routeTree && (this.routeTree = this.options.routeTree, this.buildRouteTree()), this.__store || (this.__store = new Store(getInitialRouterState(this.latestLocation), {
        onUpdate: () => {
          this.__store.state = {
            ...this.state,
            cachedMatches: this.state.cachedMatches.filter(
              (d) => !["redirected"].includes(d.status)
            )
          };
        }
      }));
    }, this.buildRouteTree = () => {
      this.routesById = {}, this.routesByPath = {};
      const notFoundRoute = this.options.notFoundRoute;
      notFoundRoute && (notFoundRoute.init({ originalIndex: 99999999999 }), this.routesById[notFoundRoute.id] = notFoundRoute);
      const recurseRoutes = (childRoutes) => {
        childRoutes.forEach((childRoute, i) => {
          childRoute.init({ originalIndex: i });
          const existingRoute = this.routesById[childRoute.id];
          if (invariant(
            !existingRoute,
            `Duplicate routes found with id: ${String(childRoute.id)}`
          ), this.routesById[childRoute.id] = childRoute, !childRoute.isRoot && childRoute.path) {
            const trimmedFullPath = trimPathRight(childRoute.fullPath);
            (!this.routesByPath[trimmedFullPath] || childRoute.fullPath.endsWith("/")) && (this.routesByPath[trimmedFullPath] = childRoute);
          }
          const children = childRoute.children;
          children?.length && recurseRoutes(children);
        });
      };
      recurseRoutes([this.routeTree]);
      const scoredRoutes = [];
      Object.values(this.routesById).forEach((d, i) => {
        var _a;
        if (d.isRoot || !d.path)
          return;
        const trimmed = trimPathLeft(d.fullPath), parsed = parsePathname(trimmed);
        for (; parsed.length > 1 && ((_a = parsed[0]) == null ? void 0 : _a.value) === "/"; )
          parsed.shift();
        const scores = parsed.map((segment) => segment.value === "/" ? 0.75 : segment.type === "param" ? 0.5 : segment.type === "wildcard" ? 0.25 : 1);
        scoredRoutes.push({ child: d, trimmed, parsed, index: i, scores });
      }), this.flatRoutes = scoredRoutes.sort((a, b) => {
        const minLength = Math.min(a.scores.length, b.scores.length);
        for (let i = 0; i < minLength; i++)
          if (a.scores[i] !== b.scores[i])
            return b.scores[i] - a.scores[i];
        if (a.scores.length !== b.scores.length)
          return b.scores.length - a.scores.length;
        for (let i = 0; i < minLength; i++)
          if (a.parsed[i].value !== b.parsed[i].value)
            return a.parsed[i].value > b.parsed[i].value ? 1 : -1;
        return a.index - b.index;
      }).map((d, i) => (d.child.rank = i, d.child));
    }, this.subscribe = (eventType, fn) => {
      const listener = {
        eventType,
        fn
      };
      return this.subscribers.add(listener), () => {
        this.subscribers.delete(listener);
      };
    }, this.emit = (routerEvent) => {
      this.subscribers.forEach((listener) => {
        listener.eventType === routerEvent.type && listener.fn(routerEvent);
      });
    }, this.parseLocation = (previousLocation) => {
      const parse = ({
        pathname,
        search,
        hash,
        state
      }) => {
        const parsedSearch = this.options.parseSearch(search), searchStr = this.options.stringifySearch(parsedSearch);
        return {
          pathname,
          searchStr,
          search: replaceEqualDeep(previousLocation?.search, parsedSearch),
          hash: hash.split("#").reverse()[0] ?? "",
          href: `${pathname}${searchStr}${hash}`,
          state: replaceEqualDeep(previousLocation?.state, state)
        };
      }, location = parse(this.history.location), { __tempLocation, __tempKey } = location.state;
      if (__tempLocation && (!__tempKey || __tempKey === this.tempLocationKey)) {
        const parsedTempLocation = parse(__tempLocation);
        return parsedTempLocation.state.key = location.state.key, delete parsedTempLocation.state.__tempLocation, {
          ...parsedTempLocation,
          maskedLocation: location
        };
      }
      return location;
    }, this.resolvePathWithBase = (from, path) => resolvePath({
      basepath: this.basepath,
      base: from,
      to: cleanPath(path),
      trailingSlash: this.options.trailingSlash
    }), this.matchRoutes = (pathname, locationSearch, opts) => {
      let routeParams = {};
      const foundRoute = this.flatRoutes.find((route) => {
        const matchedParams = matchPathname(
          this.basepath,
          trimPathRight(pathname),
          {
            to: route.fullPath,
            caseSensitive: route.options.caseSensitive ?? this.options.caseSensitive,
            fuzzy: !0
          }
        );
        return matchedParams ? (routeParams = matchedParams, !0) : !1;
      });
      let routeCursor = foundRoute || this.routesById[rootRouteId];
      const matchedRoutes = [routeCursor];
      let isGlobalNotFound = !1;
      for (// If we found a route, and it's not an index route and we have left over path
      (foundRoute ? foundRoute.path !== "/" && routeParams["**"] : (
        // Or if we didn't find a route and we have left over path
        trimPathRight(pathname)
      )) && (this.options.notFoundRoute ? matchedRoutes.push(this.options.notFoundRoute) : isGlobalNotFound = !0); routeCursor.parentRoute; )
        routeCursor = routeCursor.parentRoute, matchedRoutes.unshift(routeCursor);
      const globalNotFoundRouteId = (() => {
        if (isGlobalNotFound) {
          if (this.options.notFoundMode !== "root")
            for (let i = matchedRoutes.length - 1; i >= 0; i--) {
              const route = matchedRoutes[i];
              if (route.children)
                return route.id;
            }
          return rootRouteId;
        }
      })(), parseErrors = matchedRoutes.map((route) => {
        var _a;
        let parsedParamsError;
        const parseParams = ((_a = route.options.params) == null ? void 0 : _a.parse) ?? route.options.parseParams;
        if (parseParams)
          try {
            const parsedParams = parseParams(routeParams);
            Object.assign(routeParams, parsedParams);
          } catch (err) {
            if (parsedParamsError = new PathParamError(err.message, {
              cause: err
            }), opts?.throwOnError)
              throw parsedParamsError;
            return parsedParamsError;
          }
      }), matches = [];
      return matchedRoutes.forEach((route, index) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
        const parentMatch = matches[index - 1], [preMatchSearch, searchError] = (() => {
          const parentSearch = parentMatch?.search ?? locationSearch;
          try {
            const validator = typeof route.options.validateSearch == "object" ? route.options.validateSearch.parse : route.options.validateSearch, search = validator?.(parentSearch) ?? {};
            return [
              {
                ...parentSearch,
                ...search
              },
              void 0
            ];
          } catch (err) {
            const searchParamError = new SearchParamError(err.message, {
              cause: err
            });
            if (opts?.throwOnError)
              throw searchParamError;
            return [parentSearch, searchParamError];
          }
        })(), loaderDeps = ((_b = (_a = route.options).loaderDeps) == null ? void 0 : _b.call(_a, {
          search: preMatchSearch
        })) ?? "", loaderDepsHash = loaderDeps ? JSON.stringify(loaderDeps) : "", interpolatedPath = interpolatePath({
          path: route.fullPath,
          params: routeParams
        }), matchId = interpolatePath({
          path: route.id,
          params: routeParams,
          leaveWildcards: !0
        }) + loaderDepsHash, existingMatch = this.getMatch(matchId), cause = this.state.matches.find((d) => d.id === matchId) ? "stay" : "enter";
        let match;
        if (existingMatch)
          match = {
            ...existingMatch,
            cause,
            params: routeParams
          };
        else {
          const status = route.options.loader || route.options.beforeLoad || route.lazyFn ? "pending" : "success";
          match = {
            id: matchId,
            index,
            routeId: route.id,
            params: routeParams,
            pathname: joinPaths([this.basepath, interpolatedPath]),
            updatedAt: Date.now(),
            search: {},
            searchError: void 0,
            status,
            isFetching: !1,
            error: void 0,
            paramsError: parseErrors[index],
            routeContext: void 0,
            context: void 0,
            abortController: new AbortController(),
            fetchCount: 0,
            cause,
            loaderDeps,
            invalid: !1,
            preload: !1,
            links: (_d = (_c = route.options).links) == null ? void 0 : _d.call(_c),
            scripts: (_f = (_e = route.options).scripts) == null ? void 0 : _f.call(_e),
            staticData: route.options.staticData || {},
            loadPromise: createControlledPromise()
          };
        }
        match.status === "success" && (match.meta = (_h = (_g = route.options).meta) == null ? void 0 : _h.call(_g, {
          matches,
          match,
          params: match.params,
          loaderData: match.loaderData
        }), match.headers = (_j = (_i = route.options).headers) == null ? void 0 : _j.call(_i, {
          loaderData: match.loaderData
        })), opts?.preload || (match.globalNotFound = globalNotFoundRouteId === route.id), match.search = replaceEqualDeep(match.search, preMatchSearch), match.searchError = searchError, matches.push(match);
      }), matches;
    }, this.cancelMatch = (id) => {
      const match = this.getMatch(id);
      match && (match.abortController.abort(), clearTimeout(match.pendingTimeout));
    }, this.cancelMatches = () => {
      var _a;
      (_a = this.state.pendingMatches) == null || _a.forEach((match) => {
        this.cancelMatch(match.id);
      });
    }, this.buildLocation = (opts) => {
      const build = (dest = {}, matches) => {
        var _a, _b, _c;
        const fromMatches = dest._fromLocation != null ? this.matchRoutes(
          dest._fromLocation.pathname,
          dest.fromSearch || dest._fromLocation.search
        ) : this.state.matches, fromMatch = dest.from != null ? fromMatches.find(
          (d) => matchPathname(this.basepath, trimPathRight(d.pathname), {
            to: dest.from,
            caseSensitive: !1,
            fuzzy: !1
          })
        ) : void 0, fromPath = fromMatch?.pathname || this.latestLocation.pathname;
        invariant(
          dest.from == null || fromMatch != null,
          "Could not find match for from: " + dest.from
        );
        const fromSearch = ((_a = last(fromMatches)) == null ? void 0 : _a.search) || this.latestLocation.search, stayingMatches = matches?.filter(
          (d) => fromMatches.find((e) => e.routeId === d.routeId)
        ), fromRouteByFromPathRouteId = this.routesById[(_b = stayingMatches?.find((d) => d.pathname === fromPath)) == null ? void 0 : _b.routeId];
        let pathname = dest.to ? this.resolvePathWithBase(fromPath, `${dest.to}`) : this.resolvePathWithBase(
          fromPath,
          fromRouteByFromPathRouteId?.to ?? fromPath
        );
        const prevParams = { ...(_c = last(fromMatches)) == null ? void 0 : _c.params };
        let nextParams = (dest.params ?? !0) === !0 ? prevParams : { ...prevParams, ...functionalUpdate(dest.params, prevParams) };
        Object.keys(nextParams).length > 0 && matches?.map((d) => {
          var _a2;
          const route = this.looseRoutesById[d.routeId];
          return ((_a2 = route?.options.params) == null ? void 0 : _a2.stringify) ?? route.options.stringifyParams;
        }).filter(Boolean).forEach((fn) => {
          nextParams = { ...nextParams, ...fn(nextParams) };
        }), pathname = interpolatePath({
          path: pathname,
          params: nextParams ?? {},
          leaveWildcards: !1,
          leaveParams: opts.leaveParams
        });
        const preSearchFilters = stayingMatches?.map(
          (match) => this.looseRoutesById[match.routeId].options.preSearchFilters ?? []
        ).flat().filter(Boolean) ?? [], postSearchFilters = stayingMatches?.map(
          (match) => this.looseRoutesById[match.routeId].options.postSearchFilters ?? []
        ).flat().filter(Boolean) ?? [], preFilteredSearch = preSearchFilters.length ? preSearchFilters.reduce((prev, next) => next(prev), fromSearch) : fromSearch, destSearch = dest.search === !0 ? preFilteredSearch : dest.search ? functionalUpdate(dest.search, preFilteredSearch) : preSearchFilters.length ? preFilteredSearch : {}, postFilteredSearch = postSearchFilters.length ? postSearchFilters.reduce((prev, next) => next(prev), destSearch) : destSearch, search = replaceEqualDeep(fromSearch, postFilteredSearch), searchStr = this.options.stringifySearch(search), hash = dest.hash === !0 ? this.latestLocation.hash : dest.hash ? functionalUpdate(dest.hash, this.latestLocation.hash) : void 0, hashStr = hash ? `#${hash}` : "";
        let nextState = dest.state === !0 ? this.latestLocation.state : dest.state ? functionalUpdate(dest.state, this.latestLocation.state) : {};
        return nextState = replaceEqualDeep(this.latestLocation.state, nextState), {
          pathname,
          search,
          searchStr,
          state: nextState,
          hash: hash ?? "",
          href: `${pathname}${searchStr}${hashStr}`,
          unmaskOnReload: dest.unmaskOnReload
        };
      }, buildWithMatches = (dest = {}, maskedDest) => {
        var _a;
        const next = build(dest);
        let maskedNext = maskedDest ? build(maskedDest) : void 0;
        if (!maskedNext) {
          let params = {};
          const foundMask = (_a = this.options.routeMasks) == null ? void 0 : _a.find((d) => {
            const match = matchPathname(this.basepath, next.pathname, {
              to: d.from,
              caseSensitive: !1,
              fuzzy: !1
            });
            return match ? (params = match, !0) : !1;
          });
          if (foundMask) {
            const { from, ...maskProps } = foundMask;
            maskedDest = {
              ...pick(opts, ["from"]),
              ...maskProps,
              params
            }, maskedNext = build(maskedDest);
          }
        }
        const nextMatches = this.matchRoutes(next.pathname, next.search), maskedMatches = maskedNext ? this.matchRoutes(maskedNext.pathname, maskedNext.search) : void 0, maskedFinal = maskedNext ? build(maskedDest, maskedMatches) : void 0, final = build(dest, nextMatches);
        return maskedFinal && (final.maskedLocation = maskedFinal), final;
      };
      return opts.mask ? buildWithMatches(opts, {
        ...pick(opts, ["from"]),
        ...opts.mask
      }) : buildWithMatches(opts);
    }, this.commitLocation = ({
      viewTransition,
      ignoreBlocker,
      ...next
    }) => {
      const isSameState = () => {
        next.state.key = this.latestLocation.state.key;
        const isEqual = deepEqual(next.state, this.latestLocation.state);
        return delete next.state.key, isEqual;
      }, isSameUrl = this.latestLocation.href === next.href, previousCommitPromise = this.commitLocationPromise;
      if (this.commitLocationPromise = createControlledPromise(() => {
        previousCommitPromise?.resolve();
      }), isSameUrl && isSameState())
        this.load();
      else {
        let { maskedLocation, ...nextHistory } = next;
        maskedLocation && (nextHistory = {
          ...maskedLocation,
          state: {
            ...maskedLocation.state,
            __tempKey: void 0,
            __tempLocation: {
              ...nextHistory,
              search: nextHistory.searchStr,
              state: {
                ...nextHistory.state,
                __tempKey: void 0,
                __tempLocation: void 0,
                key: void 0
              }
            }
          }
        }, (nextHistory.unmaskOnReload ?? this.options.unmaskOnReload ?? !1) && (nextHistory.state.__tempKey = this.tempLocationKey)), this.shouldViewTransition = viewTransition, this.history[next.replace ? "replace" : "push"](
          nextHistory.href,
          nextHistory.state,
          { ignoreBlocker }
        );
      }
      return this.resetNextScroll = next.resetScroll ?? !0, this.history.subscribers.size || this.load(), this.commitLocationPromise;
    }, this.buildAndCommitLocation = ({
      replace,
      resetScroll,
      viewTransition,
      ignoreBlocker,
      ...rest
    } = {}) => {
      const location = this.buildLocation(rest);
      return this.commitLocation({
        ...location,
        viewTransition,
        replace,
        resetScroll,
        ignoreBlocker
      });
    }, this.navigate = ({ from, to, __isRedirect, ...rest }) => {
      const toString = String(to);
      let isExternal;
      try {
        new URL(`${toString}`), isExternal = !0;
      } catch {
      }
      return invariant(
        !isExternal,
        "Attempting to navigate to external url with router.navigate!"
      ), this.buildAndCommitLocation({
        ...rest,
        from,
        to
        // to: toString,
      });
    }, this.load = async () => {
      this.latestLocation = this.parseLocation(this.latestLocation), this.__store.setState((s) => ({
        ...s,
        loadedAt: Date.now()
      }));
      let redirect, notFound2;
      const loadPromise = new Promise((resolve) => {
        this.startReactTransition(async () => {
          var _a;
          try {
            const next = this.latestLocation, prevLocation = this.state.resolvedLocation, pathDidChange = prevLocation.href !== next.href;
            this.cancelMatches();
            let pendingMatches;
            this.__store.batch(() => {
              pendingMatches = this.matchRoutes(next.pathname, next.search), this.__store.setState((s) => ({
                ...s,
                status: "pending",
                isLoading: !0,
                location: next,
                pendingMatches,
                // If a cached moved to pendingMatches, remove it from cachedMatches
                cachedMatches: s.cachedMatches.filter((d) => !pendingMatches.find((e) => e.id === d.id))
              }));
            }), this.state.redirect || this.emit({
              type: "onBeforeNavigate",
              fromLocation: prevLocation,
              toLocation: next,
              pathChanged: pathDidChange
            }), this.emit({
              type: "onBeforeLoad",
              fromLocation: prevLocation,
              toLocation: next,
              pathChanged: pathDidChange
            }), await this.loadMatches({
              matches: pendingMatches,
              location: next,
              // eslint-disable-next-line @typescript-eslint/require-await
              onReady: async () => {
                this.startViewTransition(async () => {
                  let exitingMatches, enteringMatches, stayingMatches;
                  this.__store.batch(() => {
                    this.__store.setState((s) => {
                      const previousMatches = s.matches, newMatches = s.pendingMatches || s.matches;
                      return exitingMatches = previousMatches.filter(
                        (match) => !newMatches.find((d) => d.id === match.id)
                      ), enteringMatches = newMatches.filter(
                        (match) => !previousMatches.find((d) => d.id === match.id)
                      ), stayingMatches = previousMatches.filter(
                        (match) => newMatches.find((d) => d.id === match.id)
                      ), {
                        ...s,
                        isLoading: !1,
                        matches: newMatches,
                        pendingMatches: void 0,
                        cachedMatches: [
                          ...s.cachedMatches,
                          ...exitingMatches.filter((d) => d.status !== "error")
                        ]
                      };
                    }), this.cleanCache();
                  }), [
                    [exitingMatches, "onLeave"],
                    [enteringMatches, "onEnter"],
                    [stayingMatches, "onStay"]
                  ].forEach(([matches, hook]) => {
                    matches.forEach((match) => {
                      var _a2, _b;
                      (_b = (_a2 = this.looseRoutesById[match.routeId].options)[hook]) == null || _b.call(_a2, match);
                    });
                  });
                });
              }
            });
          } catch (err) {
            isResolvedRedirect(err) ? (redirect = err, this.isServer || this.navigate({ ...err, replace: !0, __isRedirect: !0 })) : isNotFound(err) && (notFound2 = err), this.__store.setState((s) => ({
              ...s,
              statusCode: redirect ? redirect.statusCode : notFound2 ? 404 : s.matches.some((d) => d.status === "error") ? 500 : 200,
              redirect
            }));
          }
          this.latestLoadPromise === loadPromise && ((_a = this.commitLocationPromise) == null || _a.resolve(), this.latestLoadPromise = void 0, this.commitLocationPromise = void 0), resolve();
        });
      });
      for (this.latestLoadPromise = loadPromise, await loadPromise; this.latestLoadPromise && loadPromise !== this.latestLoadPromise; )
        await this.latestLoadPromise;
    }, this.startViewTransition = (fn) => {
      var _a, _b;
      const shouldViewTransition = this.shouldViewTransition ?? this.options.defaultViewTransition;
      delete this.shouldViewTransition, (_b = (_a = shouldViewTransition && typeof document < "u" ? document : void 0) == null ? void 0 : _a.startViewTransition) != null && _b.call(_a, fn) || fn();
    }, this.updateMatch = (id, updater) => {
      var _a;
      let updated;
      const isPending = (_a = this.state.pendingMatches) == null ? void 0 : _a.find((d) => d.id === id), isMatched = this.state.matches.find((d) => d.id === id), matchesKey = isPending ? "pendingMatches" : isMatched ? "matches" : "cachedMatches";
      return this.__store.setState((s) => {
        var _a2;
        return {
          ...s,
          [matchesKey]: (_a2 = s[matchesKey]) == null ? void 0 : _a2.map(
            (d) => d.id === id ? updated = updater(d) : d
          )
        };
      }), updated;
    }, this.getMatch = (matchId) => [
      ...this.state.cachedMatches,
      ...this.state.pendingMatches ?? [],
      ...this.state.matches
    ].find((d) => d.id === matchId), this.loadMatches = async ({
      location,
      matches,
      preload,
      onReady,
      updateMatch = this.updateMatch
    }) => {
      let firstBadMatchIndex, rendered = !1;
      const triggerOnReady = async () => {
        rendered || (rendered = !0, await onReady?.());
      };
      !this.isServer && !this.state.matches.length && triggerOnReady();
      const handleRedirectAndNotFound = (match, err) => {
        var _a, _b, _c;
        if (isResolvedRedirect(err)) throw err;
        if (isRedirect(err) || isNotFound(err)) {
          if (updateMatch(match.id, (prev) => ({
            ...prev,
            status: isRedirect(err) ? "redirected" : isNotFound(err) ? "notFound" : "error",
            isFetching: !1,
            error: err,
            beforeLoadPromise: void 0,
            loaderPromise: void 0
          })), err.routeId || (err.routeId = match.routeId), (_a = match.beforeLoadPromise) == null || _a.resolve(), (_b = match.loaderPromise) == null || _b.resolve(), (_c = match.loadPromise) == null || _c.resolve(), isRedirect(err))
            throw rendered = !0, err = this.resolveRedirect({ ...err, _fromLocation: location }), err;
          if (isNotFound(err))
            throw this._handleNotFound(matches, err, {
              updateMatch
            }), err;
        }
      };
      try {
        await new Promise((resolveAll, rejectAll) => {
          (async () => {
            var _a, _b, _c;
            try {
              const handleSerialError = (index, err, routerCode) => {
                var _a2, _b2;
                const { id: matchId, routeId } = matches[index], route = this.looseRoutesById[routeId];
                if (err instanceof Promise)
                  throw err;
                err.routerCode = routerCode, firstBadMatchIndex = firstBadMatchIndex ?? index, handleRedirectAndNotFound(this.getMatch(matchId), err);
                try {
                  (_b2 = (_a2 = route.options).onError) == null || _b2.call(_a2, err);
                } catch (errorHandlerErr) {
                  err = errorHandlerErr, handleRedirectAndNotFound(this.getMatch(matchId), err);
                }
                updateMatch(matchId, (prev) => {
                  var _a3;
                  return (_a3 = prev.beforeLoadPromise) == null || _a3.resolve(), {
                    ...prev,
                    error: err,
                    status: "error",
                    isFetching: !1,
                    updatedAt: Date.now(),
                    abortController: new AbortController(),
                    beforeLoadPromise: void 0
                  };
                });
              };
              for (const [index, { id: matchId, routeId }] of matches.entries()) {
                const existingMatch = this.getMatch(matchId);
                if (
                  // If we are in the middle of a load, either of these will be present
                  // (not to be confused with `loadPromise`, which is always defined)
                  existingMatch.beforeLoadPromise || existingMatch.loaderPromise
                )
                  await existingMatch.beforeLoadPromise;
                else {
                  try {
                    updateMatch(matchId, (prev) => ({
                      ...prev,
                      loadPromise: createControlledPromise(() => {
                        var _a2;
                        (_a2 = prev.loadPromise) == null || _a2.resolve();
                      }),
                      beforeLoadPromise: createControlledPromise()
                    }));
                    const route = this.looseRoutesById[routeId], abortController = new AbortController(), parentMatchId = (_a = matches[index - 1]) == null ? void 0 : _a.id, getParentContext = () => parentMatchId ? this.getMatch(parentMatchId).context ?? this.options.context ?? {} : this.options.context ?? {}, pendingMs = route.options.pendingMs ?? this.options.defaultPendingMs, shouldPending = !!(onReady && !this.isServer && !preload && (route.options.loader || route.options.beforeLoad) && typeof pendingMs == "number" && pendingMs !== 1 / 0 && (route.options.pendingComponent ?? this.options.defaultPendingComponent));
                    let pendingTimeout;
                    shouldPending && (pendingTimeout = setTimeout(() => {
                      try {
                        triggerOnReady();
                      } catch {
                      }
                    }, pendingMs));
                    const { paramsError, searchError } = this.getMatch(matchId);
                    paramsError && handleSerialError(index, paramsError, "PARSE_PARAMS"), searchError && handleSerialError(index, searchError, "VALIDATE_SEARCH");
                    const parentContext = getParentContext();
                    updateMatch(matchId, (prev) => ({
                      ...prev,
                      isFetching: "beforeLoad",
                      fetchCount: prev.fetchCount + 1,
                      routeContext: replaceEqualDeep(
                        prev.routeContext,
                        parentContext
                      ),
                      context: replaceEqualDeep(prev.context, parentContext),
                      abortController,
                      pendingTimeout
                    }));
                    const { search, params, routeContext, cause } = this.getMatch(matchId), beforeLoadFnContext = {
                      search,
                      abortController,
                      params,
                      preload: !!preload,
                      context: routeContext,
                      location,
                      navigate: (opts) => this.navigate({ ...opts, _fromLocation: location }),
                      buildLocation: this.buildLocation,
                      cause: preload ? "preload" : cause
                    }, beforeLoadContext = await ((_c = (_b = route.options).beforeLoad) == null ? void 0 : _c.call(_b, beforeLoadFnContext)) ?? {};
                    (isRedirect(beforeLoadContext) || isNotFound(beforeLoadContext)) && handleSerialError(index, beforeLoadContext, "BEFORE_LOAD"), updateMatch(matchId, (prev) => {
                      const routeContext2 = {
                        ...prev.routeContext,
                        ...beforeLoadContext
                      };
                      return {
                        ...prev,
                        routeContext: replaceEqualDeep(
                          prev.routeContext,
                          routeContext2
                        ),
                        context: replaceEqualDeep(prev.context, routeContext2),
                        abortController
                      };
                    });
                  } catch (err) {
                    handleSerialError(index, err, "BEFORE_LOAD");
                  }
                  updateMatch(matchId, (prev) => {
                    var _a2;
                    return (_a2 = prev.beforeLoadPromise) == null || _a2.resolve(), {
                      ...prev,
                      beforeLoadPromise: void 0,
                      isFetching: !1
                    };
                  });
                }
              }
              const validResolvedMatches = matches.slice(0, firstBadMatchIndex), matchPromises = [];
              validResolvedMatches.forEach(({ id: matchId, routeId }, index) => {
                matchPromises.push(
                  (async () => {
                    const { loaderPromise: prevLoaderPromise } = this.getMatch(matchId);
                    if (prevLoaderPromise)
                      await prevLoaderPromise;
                    else {
                      const parentMatchPromise = matchPromises[index - 1], route = this.looseRoutesById[routeId], getLoaderContext = () => {
                        const {
                          params,
                          loaderDeps,
                          abortController,
                          context,
                          cause
                        } = this.getMatch(matchId);
                        return {
                          params,
                          deps: loaderDeps,
                          preload: !!preload,
                          parentMatchPromise,
                          abortController,
                          context,
                          location,
                          navigate: (opts) => this.navigate({ ...opts, _fromLocation: location }),
                          cause: preload ? "preload" : cause,
                          route
                        };
                      }, age = Date.now() - this.getMatch(matchId).updatedAt, staleAge = preload ? route.options.preloadStaleTime ?? this.options.defaultPreloadStaleTime ?? 3e4 : route.options.staleTime ?? this.options.defaultStaleTime ?? 0, shouldReloadOption = route.options.shouldReload, shouldReload = typeof shouldReloadOption == "function" ? shouldReloadOption(getLoaderContext()) : shouldReloadOption;
                      updateMatch(matchId, (prev) => ({
                        ...prev,
                        loaderPromise: createControlledPromise(),
                        preload: !!preload && !this.state.matches.find((d) => d.id === matchId)
                      }));
                      const runLoader = async () => {
                        var _a2, _b2, _c2, _d, _e, _f, _g, _h;
                        try {
                          const potentialPendingMinPromise = async () => {
                            const latestMatch = this.getMatch(matchId);
                            latestMatch.minPendingPromise && await latestMatch.minPendingPromise;
                          };
                          try {
                            route._lazyPromise = route._lazyPromise || (route.lazyFn ? route.lazyFn().then((lazyRoute) => {
                              Object.assign(
                                route.options,
                                lazyRoute.options
                              );
                            }) : Promise.resolve());
                            const componentsPromise = this.getMatch(matchId).componentsPromise || route._lazyPromise.then(
                              () => Promise.all(
                                componentTypes.map(async (type) => {
                                  const component = route.options[type];
                                  component?.preload && await component.preload();
                                })
                              )
                            );
                            updateMatch(matchId, (prev) => ({
                              ...prev,
                              isFetching: "loader",
                              componentsPromise
                            })), await route._lazyPromise;
                            let loaderData = await ((_b2 = (_a2 = route.options).loader) == null ? void 0 : _b2.call(_a2, getLoaderContext()));
                            this.serializeLoaderData && (loaderData = this.serializeLoaderData(loaderData, {
                              router: this,
                              match: this.getMatch(matchId)
                            })), handleRedirectAndNotFound(
                              this.getMatch(matchId),
                              loaderData
                            ), await potentialPendingMinPromise();
                            const meta = (_d = (_c2 = route.options).meta) == null ? void 0 : _d.call(_c2, {
                              matches,
                              match: this.getMatch(matchId),
                              params: this.getMatch(matchId).params,
                              loaderData
                            }), headers = (_f = (_e = route.options).headers) == null ? void 0 : _f.call(_e, {
                              loaderData
                            });
                            updateMatch(matchId, (prev) => ({
                              ...prev,
                              error: void 0,
                              status: "success",
                              isFetching: !1,
                              updatedAt: Date.now(),
                              loaderData,
                              meta,
                              headers
                            }));
                          } catch (e) {
                            let error = e;
                            await potentialPendingMinPromise(), handleRedirectAndNotFound(this.getMatch(matchId), e);
                            try {
                              (_h = (_g = route.options).onError) == null || _h.call(_g, e);
                            } catch (onErrorError) {
                              error = onErrorError, handleRedirectAndNotFound(
                                this.getMatch(matchId),
                                onErrorError
                              );
                            }
                            updateMatch(matchId, (prev) => ({
                              ...prev,
                              error,
                              status: "error",
                              isFetching: !1
                            }));
                          }
                          await this.getMatch(matchId).componentsPromise;
                        } catch (err) {
                          handleRedirectAndNotFound(this.getMatch(matchId), err);
                        }
                      }, { status, invalid } = this.getMatch(matchId);
                      status === "success" && (invalid || (shouldReload ?? age > staleAge)) ? (async () => {
                        try {
                          await runLoader();
                        } catch {
                        }
                      })() : status !== "success" && await runLoader();
                      const { loaderPromise, loadPromise } = this.getMatch(matchId);
                      loaderPromise?.resolve(), loadPromise?.resolve();
                    }
                    updateMatch(matchId, (prev) => ({
                      ...prev,
                      isFetching: !1,
                      loaderPromise: void 0
                    }));
                  })()
                );
              }), await Promise.all(matchPromises), resolveAll();
            } catch (err) {
              rejectAll(err);
            }
          })();
        }), await triggerOnReady();
      } catch (err) {
        if (isRedirect(err) || isNotFound(err))
          throw isNotFound(err) && !preload && await triggerOnReady(), err;
      }
      return matches;
    }, this.invalidate = () => {
      const invalidate = (d) => ({
        ...d,
        invalid: !0,
        ...d.status === "error" ? { status: "pending", error: void 0 } : {}
      });
      return this.__store.setState((s) => {
        var _a;
        return {
          ...s,
          matches: s.matches.map(invalidate),
          cachedMatches: s.cachedMatches.map(invalidate),
          pendingMatches: (_a = s.pendingMatches) == null ? void 0 : _a.map(invalidate)
        };
      }), this.load();
    }, this.resolveRedirect = (err) => {
      const redirect = err;
      return redirect.href || (redirect.href = this.buildLocation(redirect).href), redirect;
    }, this.cleanCache = () => {
      this.__store.setState((s) => ({
        ...s,
        cachedMatches: s.cachedMatches.filter((d) => {
          const route = this.looseRoutesById[d.routeId];
          if (!route.options.loader)
            return !1;
          const gcTime = (d.preload ? route.options.preloadGcTime ?? this.options.defaultPreloadGcTime : route.options.gcTime ?? this.options.defaultGcTime) ?? 5 * 60 * 1e3;
          return d.status !== "error" && Date.now() - d.updatedAt < gcTime;
        })
      }));
    }, this.preloadRoute = async (opts) => {
      const next = this.buildLocation(opts);
      let matches = this.matchRoutes(next.pathname, next.search, {
        throwOnError: !0,
        preload: !0
      });
      const loadedMatchIds = Object.fromEntries(
        [
          ...this.state.matches,
          ...this.state.pendingMatches ?? [],
          ...this.state.cachedMatches
        ].map((d) => [d.id, !0])
      );
      this.__store.batch(() => {
        matches.forEach((match) => {
          loadedMatchIds[match.id] || this.__store.setState((s) => ({
            ...s,
            cachedMatches: [...s.cachedMatches, match]
          }));
        });
      });
      const activeMatchIds = new Set(
        [...this.state.matches, ...this.state.pendingMatches ?? []].map(
          (d) => d.id
        )
      );
      try {
        return matches = await this.loadMatches({
          matches,
          location: next,
          preload: !0,
          updateMatch: (id, updater) => {
            activeMatchIds.has(id) ? matches = matches.map((d) => d.id === id ? updater(d) : d) : this.updateMatch(id, updater);
          }
        }), matches;
      } catch (err) {
        if (isRedirect(err))
          return await this.preloadRoute({
            ...err,
            _fromLocation: next
          });
        console.error(err);
        return;
      }
    }, this.matchRoute = (location, opts) => {
      const matchLocation = {
        ...location,
        to: location.to ? this.resolvePathWithBase(location.from || "", location.to) : void 0,
        params: location.params || {},
        leaveParams: !0
      }, next = this.buildLocation(matchLocation);
      if (opts?.pending && this.state.status !== "pending")
        return !1;
      const baseLocation = (opts?.pending === void 0 ? !this.state.isLoading : opts.pending) ? this.latestLocation : this.state.resolvedLocation, match = matchPathname(this.basepath, baseLocation.pathname, {
        ...opts,
        to: next.pathname
      });
      return !match || location.params && !deepEqual(match, location.params, !0) ? !1 : match && (opts?.includeSearch ?? !0) ? deepEqual(baseLocation.search, next.search, !0) ? match : !1 : match;
    }, this.dehydrate = () => {
      var _a;
      const pickError = ((_a = this.options.errorSerializer) == null ? void 0 : _a.serialize) ?? defaultSerializeError;
      return {
        state: {
          dehydratedMatches: this.state.matches.map((d) => ({
            ...pick(d, ["id", "status", "updatedAt"]),
            // If an error occurs server-side during SSRing,
            // send a small subset of the error to the client
            error: d.error ? {
              data: pickError(d.error),
              __isServerError: !0
            } : void 0
            // NOTE: We don't send the loader data here, because
            // there is a potential that it needs to be streamed.
            // Instead, we render it next to the route match in the HTML
            // which gives us the potential to stream it via suspense.
          }))
        },
        manifest: this.manifest
      };
    }, this.hydrate = () => {
      var _a, _b, _c;
      let ctx;
      typeof document < "u" && (ctx = this.options.transformer.parse((_a = window.__TSR__) == null ? void 0 : _a.dehydrated)), invariant(
        ctx,
        "Expected to find a dehydrated data on window.__TSR__.dehydrated... but we did not. Please file an issue!"
      ), this.dehydratedData = ctx.payload, (_c = (_b = this.options).hydrate) == null || _c.call(_b, ctx.payload);
      const dehydratedState = ctx.router.state, matches = this.matchRoutes(
        this.state.location.pathname,
        this.state.location.search
      ).map((match) => {
        const dehydratedMatch = dehydratedState.dehydratedMatches.find(
          (d) => d.id === match.id
        );
        return invariant(
          dehydratedMatch,
          `Could not find a client-side match for dehydrated match with id: ${match.id}!`
        ), {
          ...match,
          ...dehydratedMatch
        };
      });
      this.__store.setState((s) => ({
        ...s,
        matches
      })), this.manifest = ctx.router.manifest;
    }, this.injectedHtml = [], this.injectHtml = (html) => {
      const cb = () => (this.injectedHtml = this.injectedHtml.filter((d) => d !== cb), html);
      this.injectedHtml.push(cb);
    }, this.streamedKeys = /* @__PURE__ */ new Set(), this.getStreamedValue = (key) => {
      var _a;
      if (this.isServer)
        return;
      const streamedValue = (_a = window.__TSR__) == null ? void 0 : _a.streamedValues[key];
      if (streamedValue)
        return streamedValue.parsed || (streamedValue.parsed = this.options.transformer.parse(streamedValue.value)), streamedValue.parsed;
    }, this.streamValue = (key, value) => {
      var _a;
      warning(
        !this.streamedKeys.has(key),
        "Key has already been streamed: " + key
      ), this.streamedKeys.add(key);
      const children = `__TSR__.streamedValues['${key}'] = { value: ${(_a = this.serializer) == null ? void 0 : _a.call(this, this.options.transformer.stringify(value))}}`;
      this.injectHtml(
        `<script class='tsr-once'>${children}; __TSR__.cleanScripts()<\/script>`
      );
    }, this._handleNotFound = (matches, err, {
      updateMatch = this.updateMatch
    } = {}) => {
      const matchesByRouteId = Object.fromEntries(
        matches.map((match2) => [match2.routeId, match2])
      );
      let routeCursor = (err.global ? this.looseRoutesById[rootRouteId] : this.looseRoutesById[err.routeId]) || this.looseRoutesById[rootRouteId];
      for (; !routeCursor.options.notFoundComponent && !this.options.defaultNotFoundComponent && routeCursor.id !== rootRouteId; )
        routeCursor = routeCursor.parentRoute, invariant(
          routeCursor,
          "Found invalid route tree while trying to find not-found handler."
        );
      const match = matchesByRouteId[routeCursor.id];
      invariant(match, "Could not find match for route: " + routeCursor.id), updateMatch(match.id, (prev) => ({
        ...prev,
        status: "notFound",
        error: err,
        isFetching: !1
      })), err.routerCode === "BEFORE_LOAD" && routeCursor.parentRoute && (err.routeId = routeCursor.parentRoute.id, this._handleNotFound(matches, err, {
        updateMatch
      }));
    }, this.hasNotFoundMatch = () => this.__store.state.matches.some(
      (d) => d.status === "notFound" || d.globalNotFound
    ), this.update({
      defaultPreloadDelay: 50,
      defaultPendingMs: 1e3,
      defaultPendingMinMs: 500,
      context: void 0,
      ...options,
      stringifySearch: options.stringifySearch ?? defaultStringifySearch,
      parseSearch: options.parseSearch ?? defaultParseSearch
    }), typeof document < "u" && (window.__TSR__ROUTER__ = this);
  }
  get state() {
    return this.__store.state;
  }
  get looseRoutesById() {
    return this.routesById;
  }
}
class SearchParamError extends Error {
}
class PathParamError extends Error {
}
function getInitialRouterState(location) {
  return {
    loadedAt: 0,
    isLoading: !1,
    isTransitioning: !1,
    status: "idle",
    resolvedLocation: { ...location },
    location,
    matches: [],
    pendingMatches: [],
    cachedMatches: [],
    statusCode: 200
  };
}
function defaultSerializeError(err) {
  return err instanceof Error ? {
    name: err.name,
    message: err.message
  } : {
    data: err
  };
}
function isServerSideError(error) {
  return !(typeof error == "object" && error && "data" in error) || !("__isServerError" in error && error.__isServerError) || !(typeof error.data == "object" && error.data) ? !1 : error.__isServerError === !0;
}
function defaultDeserializeError(serializedData) {
  if ("name" in serializedData && "message" in serializedData) {
    const error = new Error(serializedData.message);
    return error.name = serializedData.name, error;
  }
  return serializedData.data;
}
const matchContext = React.createContext(void 0);
function useMatch(opts) {
  const nearestMatchId = React.useContext(matchContext);
  return useRouterState({
    select: (state) => {
      const match = state.matches.find(
        (d) => opts.from ? opts.from === d.routeId : d.id === nearestMatchId
      );
      if (invariant(
        !((opts.shouldThrow ?? !0) && !match),
        `Could not find ${opts.from ? `an active match from "${opts.from}"` : "a nearest match!"}`
      ), match !== void 0)
        return opts.select ? opts.select(match) : match;
    }
  });
}
function useLoaderDeps(opts) {
  return useMatch({
    ...opts,
    select: (s) => typeof opts.select == "function" ? opts.select(s.loaderDeps) : s.loaderDeps
  });
}
function useLoaderData(opts) {
  return useMatch({
    ...opts,
    select: (s) => typeof opts.select == "function" ? opts.select(s.loaderData) : s.loaderData
  });
}
function useParams(opts) {
  return useMatch({
    ...opts,
    select: (match) => opts.select ? opts.select(match.params) : match.params
  });
}
function useSearch(opts) {
  return useMatch({
    ...opts,
    select: (match) => opts.select ? opts.select(match.search) : match.search
  });
}
function useNavigate(_defaultOpts) {
  const router = useRouter();
  return React.useCallback(
    (options) => router.navigate({
      ...options
    }),
    [router]
  );
}
class Route {
  /**
   * @deprecated Use the `createRoute` function instead.
   */
  constructor(options) {
    this.init = (opts) => {
      var _a, _b;
      this.originalIndex = opts.originalIndex;
      const options2 = this.options, isRoot = !options2?.path && !options2?.id;
      this.parentRoute = (_b = (_a = this.options) == null ? void 0 : _a.getParentRoute) == null ? void 0 : _b.call(_a), isRoot ? this.path = rootRouteId : invariant(
        this.parentRoute,
        "Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance."
      );
      let path = isRoot ? rootRouteId : options2.path;
      path && path !== "/" && (path = trimPathLeft(path));
      const customId = options2?.id || path;
      let id = isRoot ? rootRouteId : joinPaths([
        this.parentRoute.id === rootRouteId ? "" : this.parentRoute.id,
        customId
      ]);
      path === rootRouteId && (path = "/"), id !== rootRouteId && (id = joinPaths(["/", id]));
      const fullPath = id === rootRouteId ? "/" : joinPaths([this.parentRoute.fullPath, path]);
      this.path = path, this.id = id, this.fullPath = fullPath, this.to = fullPath;
    }, this.updateLoader = (options2) => (Object.assign(this.options, options2), this), this.update = (options2) => (Object.assign(this.options, options2), this), this.lazy = (lazyFn) => (this.lazyFn = lazyFn, this), this.useMatch = (opts) => useMatch({ ...opts, from: this.id }), this.useRouteContext = (opts) => useMatch({
      ...opts,
      from: this.id,
      select: (d) => opts?.select ? opts.select(d.context) : d.context
    }), this.useSearch = (opts) => useSearch({ ...opts, from: this.id }), this.useParams = (opts) => useParams({ ...opts, from: this.id }), this.useLoaderDeps = (opts) => useLoaderDeps({ ...opts, from: this.id }), this.useLoaderData = (opts) => useLoaderData({ ...opts, from: this.id }), this.useNavigate = () => useNavigate({ from: this.id }), this.options = options || {}, this.isRoot = !options?.getParentRoute, invariant(
      !(options?.id && options?.path),
      "Route cannot have both an 'id' and a 'path' option."
    ), this.$$typeof = Symbol.for("react.memo");
  }
  addChildren(children) {
    return this.children = Array.isArray(children) ? children : Object.values(children), this;
  }
}
function createRoute(options) {
  return new Route(options);
}
function createRootRouteWithContext() {
  return (options) => createRootRoute(options);
}
class RootRoute extends Route {
  /**
   * @deprecated `RootRoute` is now an internal implementation detail. Use `createRootRoute()` instead.
   */
  constructor(options) {
    super(options);
  }
  addChildren(children) {
    return super.addChildren(children);
  }
}
function createRootRoute(options) {
  return new RootRoute(options);
}
function createFileRoute(path) {
  return new FileRoute(path, {
    silent: !0
  }).createRoute;
}
class FileRoute {
  constructor(path, _opts) {
    this.path = path, this.createRoute = (options) => {
      warning(
        this.silent,
        "FileRoute is deprecated and will be removed in the next major version. Use the createFileRoute(path)(options) function instead."
      );
      const route = createRoute(options);
      return route.isRoot = !1, route;
    }, this.silent = _opts?.silent;
  }
}
const preloadWarning = "Error preloading route! ";
function useLinkProps(options) {
  const router = useRouter(), [isTransitioning, setIsTransitioning] = React.useState(!1), {
    // custom props
    activeProps = () => ({ className: "active" }),
    inactiveProps = () => ({}),
    activeOptions,
    hash,
    search,
    params,
    to,
    state,
    mask,
    preload: userPreload,
    preloadDelay: userPreloadDelay,
    replace,
    startTransition,
    resetScroll,
    viewTransition,
    // element props
    children,
    target,
    disabled,
    style,
    className,
    onClick,
    onFocus,
    onMouseEnter,
    onMouseLeave,
    onTouchStart,
    ignoreBlocker,
    ...rest
  } = options;
  let type = "internal";
  try {
    new URL(`${to}`), type = "external";
  } catch {
  }
  const next = router.buildLocation(options), preload = userPreload ?? router.options.defaultPreload, preloadDelay = userPreloadDelay ?? router.options.defaultPreloadDelay ?? 0, isActive = useRouterState({
    select: (s) => {
      const currentPathSplit = removeTrailingSlash(
        s.location.pathname,
        router.basepath
      ).split("/"), pathIsFuzzyEqual = removeTrailingSlash(
        next.pathname,
        router.basepath
      ).split("/").every(
        (d, i) => d === currentPathSplit[i]
      ), pathTest = activeOptions?.exact ? exactPathTest(s.location.pathname, next.pathname, router.basepath) : pathIsFuzzyEqual, hashTest = activeOptions?.includeHash ? s.location.hash === next.hash : !0, searchTest = activeOptions?.includeSearch ?? !0 ? deepEqual(s.location.search, next.search, !activeOptions?.exact) : !0;
      return pathTest && hashTest && searchTest;
    }
  });
  if (type === "external")
    return {
      ...rest,
      type,
      href: to,
      ...children && { children },
      ...target && { target },
      ...disabled && { disabled },
      ...style && { style },
      ...className && { className },
      ...onClick && { onClick },
      ...onFocus && { onFocus },
      ...onMouseEnter && { onMouseEnter },
      ...onMouseLeave && { onMouseLeave },
      ...onTouchStart && { onTouchStart }
    };
  const handleClick = (e) => {
    if (!disabled && !isCtrlEvent(e) && !e.defaultPrevented && (!target || target === "_self") && e.button === 0) {
      e.preventDefault(), flushSync(() => {
        setIsTransitioning(!0);
      });
      const unsub = router.subscribe("onResolved", () => {
        unsub(), setIsTransitioning(!1);
      });
      router.commitLocation({
        ...next,
        replace,
        resetScroll,
        startTransition,
        viewTransition,
        ignoreBlocker
      });
    }
  }, doPreload = () => {
    router.preloadRoute(options).catch((err) => {
      console.warn(err), console.warn(preloadWarning);
    });
  }, handleFocus = (e) => {
    disabled || preload && doPreload();
  }, handleTouchStart = handleFocus, handleEnter = (e) => {
    if (disabled) return;
    const eventTarget = e.target || {};
    if (preload) {
      if (eventTarget.preloadTimeout)
        return;
      eventTarget.preloadTimeout = setTimeout(() => {
        eventTarget.preloadTimeout = null, doPreload();
      }, preloadDelay);
    }
  }, handleLeave = (e) => {
    if (disabled) return;
    const eventTarget = e.target || {};
    eventTarget.preloadTimeout && (clearTimeout(eventTarget.preloadTimeout), eventTarget.preloadTimeout = null);
  }, composeHandlers = (handlers) => (e) => {
    var _a;
    (_a = e.persist) == null || _a.call(e), handlers.filter(Boolean).forEach((handler) => {
      e.defaultPrevented || handler(e);
    });
  }, resolvedActiveProps = isActive ? functionalUpdate(activeProps, {}) ?? {} : {}, resolvedInactiveProps = isActive ? {} : functionalUpdate(inactiveProps, {}), resolvedClassName = [
    className,
    resolvedActiveProps.className,
    resolvedInactiveProps.className
  ].filter(Boolean).join(" "), resolvedStyle = {
    ...style,
    ...resolvedActiveProps.style,
    ...resolvedInactiveProps.style
  };
  return {
    ...resolvedActiveProps,
    ...resolvedInactiveProps,
    ...rest,
    href: disabled ? void 0 : next.maskedLocation ? router.history.createHref(next.maskedLocation.href) : router.history.createHref(next.href),
    onClick: composeHandlers([onClick, handleClick]),
    onFocus: composeHandlers([onFocus, handleFocus]),
    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),
    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),
    onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),
    disabled: !!disabled,
    target,
    ...Object.keys(resolvedStyle).length && { style: resolvedStyle },
    ...resolvedClassName && { className: resolvedClassName },
    ...disabled && {
      role: "link",
      "aria-disabled": !0
    },
    ...isActive && { "data-status": "active", "aria-current": "page" },
    ...isTransitioning && { "data-transitioning": "transitioning" }
  };
}
const Link = React.forwardRef((props, ref) => {
  const { _asChild, ...rest } = props, { type, ...linkProps } = useLinkProps(rest), children = typeof rest.children == "function" ? rest.children({
    isActive: linkProps["data-status"] === "active"
  }) : rest.children;
  return typeof _asChild > "u" && delete linkProps.disabled, React.createElement(
    _asChild || "a",
    {
      ...linkProps,
      ref
    },
    children
  );
});
function isCtrlEvent(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}
function Transitioner() {
  const router = useRouter(), mountLoadForRouter = React.useRef({ router, mounted: !1 }), routerState = useRouterState({
    select: (s) => pick(s, ["isLoading", "location", "resolvedLocation", "isTransitioning"])
  }), [isTransitioning, startReactTransition_] = React.useTransition(), hasPendingMatches = useRouterState({
    select: (s) => s.matches.some((d) => d.status === "pending")
  }), previousIsLoading = usePrevious(routerState.isLoading), isAnyPending = routerState.isLoading || isTransitioning || hasPendingMatches, previousIsAnyPending = usePrevious(isAnyPending);
  return router.isServer || (router.startReactTransition = startReactTransition_), React.useEffect(() => {
    const unsub = router.history.subscribe(router.load), nextLocation = router.buildLocation({
      to: router.latestLocation.pathname,
      search: !0,
      params: !0,
      hash: !0,
      state: !0
    });
    return trimPathRight(router.latestLocation.href) !== trimPathRight(nextLocation.href) && router.commitLocation({ ...nextLocation, replace: !0 }), () => {
      unsub();
    };
  }, [router, router.history]), useLayoutEffect$1(() => {
    var _a;
    if ((_a = window.__TSR__) != null && _a.dehydrated || mountLoadForRouter.current.router === router && mountLoadForRouter.current.mounted)
      return;
    mountLoadForRouter.current = { router, mounted: !0 }, (async () => {
      try {
        await router.load();
      } catch (err) {
        console.error(err);
      }
    })();
  }, [router]), useLayoutEffect$1(() => {
    if (previousIsLoading && !routerState.isLoading) {
      const toLocation = router.state.location, fromLocation = router.state.resolvedLocation, pathChanged = fromLocation.href !== toLocation.href;
      router.emit({
        type: "onLoad",
        // When the new URL has committed, when the new matches have been loaded into state.matches
        fromLocation,
        toLocation,
        pathChanged
      });
    }
  }, [previousIsLoading, router, routerState.isLoading]), useLayoutEffect$1(() => {
    if (previousIsAnyPending && !isAnyPending) {
      const toLocation = router.state.location, fromLocation = router.state.resolvedLocation, pathChanged = fromLocation.href !== toLocation.href;
      if (router.emit({
        type: "onResolved",
        fromLocation,
        toLocation,
        pathChanged
      }), router.__store.setState((s) => ({
        ...s,
        status: "idle",
        resolvedLocation: s.location
      })), document.querySelector && router.state.location.hash !== "") {
        const el = document.getElementById(router.state.location.hash);
        el && el.scrollIntoView();
      }
    }
  }, [isAnyPending, previousIsAnyPending, router]), null;
}
function SafeFragment(props) {
  return /* @__PURE__ */ jsx(Fragment, { children: props.children });
}
function renderRouteNotFound(router, route, data) {
  return route.options.notFoundComponent ? /* @__PURE__ */ jsx(route.options.notFoundComponent, { data }) : router.options.defaultNotFoundComponent ? /* @__PURE__ */ jsx(router.options.defaultNotFoundComponent, { data }) : /* @__PURE__ */ jsx(DefaultGlobalNotFound, {});
}
function Match({ matchId }) {
  var _a, _b;
  const router = useRouter(), routeId = useRouterState({
    select: (s) => {
      var _a2;
      return (_a2 = s.matches.find((d) => d.id === matchId)) == null ? void 0 : _a2.routeId;
    }
  });
  invariant(
    routeId,
    `Could not find routeId for matchId "${matchId}". Please file an issue!`
  );
  const route = router.routesById[routeId], PendingComponent = route.options.pendingComponent ?? router.options.defaultPendingComponent, pendingElement = PendingComponent ? /* @__PURE__ */ jsx(PendingComponent, {}) : null, routeErrorComponent = route.options.errorComponent ?? router.options.defaultErrorComponent, routeOnCatch = route.options.onCatch ?? router.options.defaultOnCatch, routeNotFoundComponent = route.isRoot ? (
    // If it's the root route, use the globalNotFound option, with fallback to the notFoundRoute's component
    route.options.notFoundComponent ?? ((_a = router.options.notFoundRoute) == null ? void 0 : _a.options.component)
  ) : route.options.notFoundComponent, ResolvedSuspenseBoundary = (
    // If we're on the root route, allow forcefully wrapping in suspense
    (!route.isRoot || route.options.wrapInSuspense) && (route.options.wrapInSuspense ?? PendingComponent ?? ((_b = route.options.errorComponent) == null ? void 0 : _b.preload)) ? React.Suspense : SafeFragment
  ), ResolvedCatchBoundary = routeErrorComponent ? CatchBoundary : SafeFragment, ResolvedNotFoundBoundary = routeNotFoundComponent ? CatchNotFound : SafeFragment, resetKey = useRouterState({
    select: (s) => s.loadedAt
  });
  return /* @__PURE__ */ jsx(matchContext.Provider, { value: matchId, children: /* @__PURE__ */ jsx(ResolvedSuspenseBoundary, { fallback: pendingElement, children: /* @__PURE__ */ jsx(
    ResolvedCatchBoundary,
    {
      getResetKey: () => resetKey,
      errorComponent: routeErrorComponent || ErrorComponent,
      onCatch: (error, errorInfo) => {
        if (isNotFound(error)) throw error;
        warning(!1, `Error in route match: ${matchId}`), routeOnCatch?.(error, errorInfo);
      },
      children: /* @__PURE__ */ jsx(
        ResolvedNotFoundBoundary,
        {
          fallback: (error) => {
            if (!routeNotFoundComponent || error.routeId && error.routeId !== routeId || !error.routeId && !route.isRoot)
              throw error;
            return React.createElement(routeNotFoundComponent, error);
          },
          children: /* @__PURE__ */ jsx(MatchInner, { matchId })
        }
      )
    }
  ) }) });
}
function MatchInner({ matchId }) {
  var _a, _b;
  const router = useRouter(), routeId = useRouterState({
    select: (s) => {
      var _a2;
      return (_a2 = s.matches.find((d) => d.id === matchId)) == null ? void 0 : _a2.routeId;
    }
  }), route = router.routesById[routeId], matchIndex = useRouterState({
    select: (s) => s.matches.findIndex((d) => d.id === matchId)
  }), match = useRouterState({
    select: (s) => {
      const match2 = s.matches[matchIndex];
      return pick(match2, [
        "id",
        "status",
        "error",
        "loadPromise",
        "minPendingPromise"
      ]);
    }
  }), RouteErrorComponent = (route.options.errorComponent ?? router.options.defaultErrorComponent) || ErrorComponent;
  if (match.status === "notFound") {
    let error;
    return isServerSideError(match.error) ? error = (((_a = router.options.errorSerializer) == null ? void 0 : _a.deserialize) ?? defaultDeserializeError)(match.error.data) : error = match.error, invariant(isNotFound(error), "Expected a notFound error"), renderRouteNotFound(router, route, error);
  }
  if (match.status === "redirected")
    throw invariant(isRedirect(match.error), "Expected a redirect error"), match.loadPromise;
  if (match.status === "error") {
    if (router.isServer)
      return /* @__PURE__ */ jsx(
        RouteErrorComponent,
        {
          error: match.error,
          info: {
            componentStack: ""
          }
        }
      );
    throw isServerSideError(match.error) ? (((_b = router.options.errorSerializer) == null ? void 0 : _b.deserialize) ?? defaultDeserializeError)(match.error.data) : match.error;
  }
  if (match.status === "pending") {
    const pendingMinMs = route.options.pendingMinMs ?? router.options.defaultPendingMinMs;
    if (pendingMinMs && !match.minPendingPromise && !router.isServer) {
      const minPendingPromise = createControlledPromise();
      Promise.resolve().then(() => {
        router.updateMatch(match.id, (prev) => ({
          ...prev,
          minPendingPromise
        }));
      }), setTimeout(() => {
        minPendingPromise.resolve(), router.updateMatch(match.id, (prev) => ({
          ...prev,
          minPendingPromise: void 0
        }));
      }, pendingMinMs);
    }
    throw match.loadPromise;
  }
  const Comp = route.options.component ?? router.options.defaultComponent;
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    Comp ? /* @__PURE__ */ jsx(Comp, {}) : /* @__PURE__ */ jsx(Outlet, {}),
    router.AfterEachMatch ? /* @__PURE__ */ jsx(router.AfterEachMatch, { match, matchIndex }) : null
  ] });
}
const Outlet = React.memo(function() {
  const router = useRouter(), matchId = React.useContext(matchContext), routeId = useRouterState({
    select: (s) => {
      var _a;
      return (_a = s.matches.find((d) => d.id === matchId)) == null ? void 0 : _a.routeId;
    }
  }), route = router.routesById[routeId], { parentGlobalNotFound } = useRouterState({
    select: (s) => {
      const parentMatch = s.matches.find((d) => d.id === matchId);
      return invariant(
        parentMatch,
        `Could not find parent match for matchId "${matchId}"`
      ), {
        parentGlobalNotFound: parentMatch.globalNotFound
      };
    }
  }), childMatchId = useRouterState({
    select: (s) => {
      var _a;
      const matches = s.matches, index = matches.findIndex((d) => d.id === matchId);
      return (_a = matches[index + 1]) == null ? void 0 : _a.id;
    }
  });
  if (parentGlobalNotFound)
    return renderRouteNotFound(router, route, void 0);
  if (!childMatchId)
    return null;
  const nextMatch = /* @__PURE__ */ jsx(Match, { matchId: childMatchId }), pendingElement = router.options.defaultPendingComponent ? /* @__PURE__ */ jsx(router.options.defaultPendingComponent, {}) : null;
  return matchId === rootRouteId ? /* @__PURE__ */ jsx(React.Suspense, { fallback: pendingElement, children: nextMatch }) : nextMatch;
});
function Matches() {
  const router = useRouter(), pendingElement = router.options.defaultPendingComponent ? /* @__PURE__ */ jsx(router.options.defaultPendingComponent, {}) : null, ResolvedSuspense = router.state.matches.length ? SafeFragment : React.Suspense, inner = /* @__PURE__ */ jsxs(ResolvedSuspense, { fallback: pendingElement, children: [
    /* @__PURE__ */ jsx(Transitioner, {}),
    /* @__PURE__ */ jsx(MatchesInner, {})
  ] });
  return router.options.InnerWrap ? /* @__PURE__ */ jsx(router.options.InnerWrap, { children: inner }) : inner;
}
function MatchesInner() {
  const matchId = useRouterState({
    select: (s) => {
      var _a;
      return (_a = s.matches[0]) == null ? void 0 : _a.id;
    }
  }), resetKey = useRouterState({
    select: (s) => s.loadedAt
  });
  return /* @__PURE__ */ jsx(matchContext.Provider, { value: matchId, children: /* @__PURE__ */ jsx(
    CatchBoundary,
    {
      getResetKey: () => resetKey,
      errorComponent: ErrorComponent,
      onCatch: (error) => {
        warning(
          !1,
          "The following error wasn't caught by any route! At the very least, consider setting an 'errorComponent' in your RootRoute!"
        ), warning(!1, error.message || error.toString());
      },
      children: matchId ? /* @__PURE__ */ jsx(Match, { matchId }) : null
    }
  ) });
}
function RouterContextProvider({
  router,
  children,
  ...rest
}) {
  router.update({
    ...router.options,
    ...rest,
    context: {
      ...router.options.context,
      ...rest.context
    }
  });
  const routerContext2 = getRouterContext(), provider = /* @__PURE__ */ jsx(routerContext2.Provider, { value: router, children });
  return router.options.Wrap ? /* @__PURE__ */ jsx(router.options.Wrap, { children: provider }) : provider;
}
function RouterProvider({ router, ...rest }) {
  return /* @__PURE__ */ jsx(RouterContextProvider, { router, ...rest, children: /* @__PURE__ */ jsx(Matches, {}) });
}
const useLayoutEffect = typeof window < "u" ? React.useLayoutEffect : React.useEffect, windowKey = "window", delimiter = "___";
let weakScrolledElements = /* @__PURE__ */ new WeakSet();
const sessionsStorage = typeof window < "u" && window.sessionStorage, cache = sessionsStorage ? (() => {
  const storageKey = "tsr-scroll-restoration-v2";
  return {
    state: JSON.parse(
      window.sessionStorage.getItem(storageKey) || "null"
    ) || { cached: {}, next: {} },
    set: (updater) => {
      cache.state = functionalUpdate(updater, cache.state), window.sessionStorage.setItem(storageKey, JSON.stringify(cache.state));
    }
  };
})() : void 0, defaultGetKey = (location) => location.state.key || location.href;
function useScrollRestoration(options) {
  const router = useRouter();
  useLayoutEffect(() => {
    const getKey = options?.getKey || defaultGetKey, { history } = window;
    history.scrollRestoration = "manual";
    const onScroll = (event) => {
      if (weakScrolledElements.has(event.target)) return;
      weakScrolledElements.add(event.target);
      let elementSelector = "";
      if (event.target === document || event.target === window)
        elementSelector = windowKey;
      else {
        const attrId = event.target.getAttribute(
          "data-scroll-restoration-id"
        );
        attrId ? elementSelector = `[data-scroll-restoration-id="${attrId}"]` : elementSelector = getCssSelector(event.target);
      }
      cache.state.next[elementSelector] || cache.set((c) => ({
        ...c,
        next: {
          ...c.next,
          [elementSelector]: {
            scrollX: NaN,
            scrollY: NaN
          }
        }
      }));
    };
    typeof document < "u" && document.addEventListener("scroll", onScroll, !0);
    const unsubOnBeforeLoad = router.subscribe("onBeforeLoad", (event) => {
      if (event.pathChanged) {
        const restoreKey = getKey(event.fromLocation);
        for (const elementSelector in cache.state.next) {
          const entry = cache.state.next[elementSelector];
          if (elementSelector === windowKey)
            entry.scrollX = window.scrollX || 0, entry.scrollY = window.scrollY || 0;
          else if (elementSelector) {
            const element = document.querySelector(elementSelector);
            entry.scrollX = element?.scrollLeft || 0, entry.scrollY = element?.scrollTop || 0;
          }
          cache.set((c) => {
            const next = { ...c.next };
            return delete next[elementSelector], {
              ...c,
              next,
              cached: {
                ...c.cached,
                [[restoreKey, elementSelector].join(delimiter)]: entry
              }
            };
          });
        }
      }
    }), unsubOnResolved = router.subscribe("onResolved", (event) => {
      if (event.pathChanged) {
        if (!router.resetNextScroll)
          return;
        router.resetNextScroll = !0;
        const restoreKey = getKey(event.toLocation);
        let windowRestored = !1;
        for (const cacheKey in cache.state.cached) {
          const entry = cache.state.cached[cacheKey], [key, elementSelector] = cacheKey.split(delimiter);
          if (key === restoreKey) {
            if (elementSelector === windowKey)
              windowRestored = !0, window.scrollTo(entry.scrollX, entry.scrollY);
            else if (elementSelector) {
              const element = document.querySelector(elementSelector);
              element && (element.scrollLeft = entry.scrollX, element.scrollTop = entry.scrollY);
            }
          }
        }
        windowRestored || window.scrollTo(0, 0), cache.set((c) => ({ ...c, next: {} })), weakScrolledElements = /* @__PURE__ */ new WeakSet();
      }
    });
    return () => {
      document.removeEventListener("scroll", onScroll), unsubOnBeforeLoad(), unsubOnResolved();
    };
  }, [options?.getKey, router]);
}
function ScrollRestoration(props) {
  return useScrollRestoration(props), null;
}
function getCssSelector(el) {
  const path = [];
  let parent;
  for (; parent = el.parentNode; )
    path.unshift(
      `${el.tagName}:nth-child(${[].indexOf.call(parent.children, el) + 1})`
    ), el = parent;
  return `${path.join(" > ")}`.toLowerCase();
}
export {
  Link as L,
  Outlet as O,
  RouterProvider as R,
  ScrollRestoration as S,
  createFileRoute as a,
  useParams as b,
  createRootRouteWithContext as c,
  useRouterState as d,
  createRouter as e,
  createHashHistory as f,
  createBrowserHistory as g,
  isNotFound as i,
  notFound as n,
  useRouter as u
};
