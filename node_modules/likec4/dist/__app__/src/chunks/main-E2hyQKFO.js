import { jsx, jsxs, Fragment as Fragment$1 } from "react/jsx-runtime";
import * as React from "react";
import { createContext as createContext$1, useContext as useContext$1, useId as useId$1, useEffect as useEffect$1, useCallback as useCallback$1, Component, useLayoutEffect as useLayoutEffect$1, useRef as useRef$1, useInsertionEffect, useMemo as useMemo$1, forwardRef as forwardRef$1, Fragment, createElement as createElement$1, Children, isValidElement, useState as useState$1, memo as memo$1, Suspense, lazy, useSyncExternalStore, StrictMode } from "react";
import { createRoot } from "react-dom/client";
import { L as Link, c as createRootRouteWithContext, S as ScrollRestoration, O as Outlet, a as createFileRoute, u as useRouter, b as useParams, d as useRouterState, i as isNotFound, n as notFound, R as RouterProvider, e as createRouter$1, f as createHashHistory, g as createBrowserHistory } from "./tanstack-router-CF1kJvtP.js";
import { e as Container, f as Title, a as Text$6, G as Group, g as Button, h as useReducedMotion, i as useMergedRef, B as Box, t as themeToVars, j as useMantineStyleNonce, S as Spotlight, k as SpotlightActionsGroup, d as Center, H as Highlight, l as useComputedColorScheme, m as Popover, n as PopoverTarget, T as ThemeIcon, o as PopoverDropdown, p as ScrollAreaAutosize, c as clsx, A as ActionIcon$1, q as Stack$1, r as useTree, s as Tree, v as Tooltip$5, w as useId$2, x as SegmentedControl, P as Paper, y as Alert, z as Anchor, D as Pill, E as Divider$1, F as useViewportSize, R as RemoveScroll, C as Card, J as FocusTrap, K as FocusTrapInitialFocus, L as CloseButton, M as Badge, N as Flex, O as ActionIconGroup, Q as Tabs, U as TabsList, V as TabsTab, W as TabsPanel, X as ScrollArea, Y as UnstyledButton, Z as CopyButton$1, _ as Code, $ as useLocalStorage, a0 as useStateHistory, a1 as Space, a2 as useHotkeys, a3 as MantineContext, a4 as Menu, a5 as MenuTarget, a6 as MenuDropdown, a7 as MenuLabel, a8 as MenuDivider, a9 as TooltipGroup, aa as MenuItem, ab as keys$1, ac as ColorSwatch, ad as CheckIcon, ae as rem, af as Slider, ag as useDebouncedValue, b as CardSection, ah as Spoiler, ai as ButtonGroup, aj as useHover, ak as FloatingIndicator, al as useUncontrolled, am as clampUseMovePosition, an as useMove, ao as openSpotlight, ap as HoverCard, aq as HoverCardTarget, ar as Overlay, as as HoverCardDropdown, at as Notification, au as createTheme, av as MantineProvider, aw as useInViewport, ax as SimpleGrid, u as useMantineColorScheme, ay as Drawer, az as Select, aA as ModalRoot, aB as ModalOverlay, aC as ModalContent, aD as ModalBody, aE as useMantineTheme, aF as useMediaQuery, aG as useDisclosure, aH as LoadingOverlay, aI as useCallbackRef, aJ as Burger, aK as Loader } from "./mantine-BzD51ZKm.js";
import { withOverviewGraph, ComponentName, isDevelopment, krokiD2SvgUrl, basepath, useHashHistory } from "../const.js";
import { useLikeC4ModelAtom } from "virtual:likec4/model";
import { g as getDefaultExportFromCjs, d as useReactFlow, e as useStoreApi, f as useStore$1, h as useNodesData, j as getNodeDimensions, k as createWithEqualityFn, l as applyNodeChanges, m as applyEdgeChanges, n as getViewportForBounds, o as getBoundsOfRects, s as shallow$1, p as boxToRect, q as useStoreWithEqualityFn, M as MarkerType, H as Handle, P as Position, r as getBezierPath, B as BaseEdge, E as EdgeLabelRenderer, i as index, t as Panel$1, V as ViewportPortal, R as ReactFlowProvider, v as useOnViewportChange, x as useInternalNode, N as NodeToolbar, b as Background, c as BackgroundVariant } from "./likec4-DF_Jsv_p.js";
import { RenderIcon } from "../icons.js";
import { usePreviewUrl } from "virtual:likec4/previews";
var content = "_1u4wf800", image = "_1u4wf801", inner = "_1u4wf802", root = "_1u4wf803", description$2 = "_1u4wf804", title$5 = "_1u4wf805";
function NotFound() {
  return /* @__PURE__ */ jsx(Container, { className: root, children: /* @__PURE__ */ jsxs("div", { className: inner, children: [
    /* @__PURE__ */ jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 362 145", className: image, children: /* @__PURE__ */ jsx(
      "path",
      {
        fill: "currentColor",
        d: "M62.6 142c-2.133 0-3.2-1.067-3.2-3.2V118h-56c-2 0-3-1-3-3V92.8c0-1.333.4-2.733 1.2-4.2L58.2 4c.8-1.333 2.067-2 3.8-2h28c2 0 3 1 3 3v85.4h11.2c.933 0 1.733.333 2.4 1 .667.533 1 1.267 1 2.2v21.2c0 .933-.333 1.733-1 2.4-.667.533-1.467.8-2.4.8H93v20.8c0 2.133-1.067 3.2-3.2 3.2H62.6zM33 90.4h26.4V51.2L33 90.4zM181.67 144.6c-7.333 0-14.333-1.333-21-4-6.666-2.667-12.866-6.733-18.6-12.2-5.733-5.467-10.266-13-13.6-22.6-3.333-9.6-5-20.667-5-33.2 0-12.533 1.667-23.6 5-33.2 3.334-9.6 7.867-17.133 13.6-22.6 5.734-5.467 11.934-9.533 18.6-12.2 6.667-2.8 13.667-4.2 21-4.2 7.467 0 14.534 1.4 21.2 4.2 6.667 2.667 12.8 6.733 18.4 12.2 5.734 5.467 10.267 13 13.6 22.6 3.334 9.6 5 20.667 5 33.2 0 12.533-1.666 23.6-5 33.2-3.333 9.6-7.866 17.133-13.6 22.6-5.6 5.467-11.733 9.533-18.4 12.2-6.666 2.667-13.733 4-21.2 4zm0-31c9.067 0 15.6-3.733 19.6-11.2 4.134-7.6 6.2-17.533 6.2-29.8s-2.066-22.2-6.2-29.8c-4.133-7.6-10.666-11.4-19.6-11.4-8.933 0-15.466 3.8-19.6 11.4-4 7.6-6 17.533-6 29.8s2 22.2 6 29.8c4.134 7.467 10.667 11.2 19.6 11.2zM316.116 142c-2.134 0-3.2-1.067-3.2-3.2V118h-56c-2 0-3-1-3-3V92.8c0-1.333.4-2.733 1.2-4.2l56.6-84.6c.8-1.333 2.066-2 3.8-2h28c2 0 3 1 3 3v85.4h11.2c.933 0 1.733.333 2.4 1 .666.533 1 1.267 1 2.2v21.2c0 .933-.334 1.733-1 2.4-.667.533-1.467.8-2.4.8h-11.2v20.8c0 2.133-1.067 3.2-3.2 3.2h-27.2zm-29.6-51.6h26.4V51.2l-26.4 39.2z"
      }
    ) }),
    /* @__PURE__ */ jsxs("div", { className: content, children: [
      /* @__PURE__ */ jsx(Title, { className: title$5, children: "Nothing to see here" }),
      /* @__PURE__ */ jsx(Text$6, { c: "dimmed", size: "lg", ta: "center", className: description$2, children: "Page you are trying to open does not exist. You may have mistyped the address, or the page has been moved to another URL. If you think this is an error contact support." }),
      /* @__PURE__ */ jsx(Group, { justify: "center", children: /* @__PURE__ */ jsx(Button, { component: Link, to: "/", search: !0, startTransition: !0, size: "md", children: "Take me back to home page" }) })
    ] })
  ] }) });
}
var getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols, hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function combineComparators(comparatorA, comparatorB) {
  return function(a2, b2, state) {
    return comparatorA(a2, b2, state) && comparatorB(a2, b2, state);
  };
}
function createIsCircular(areItemsEqual) {
  return function(a2, b2, state) {
    if (!a2 || !b2 || typeof a2 != "object" || typeof b2 != "object")
      return areItemsEqual(a2, b2, state);
    var cache = state.cache, cachedA = cache.get(a2), cachedB = cache.get(b2);
    if (cachedA && cachedB)
      return cachedA === b2 && cachedB === a2;
    cache.set(a2, b2), cache.set(b2, a2);
    var result = areItemsEqual(a2, b2, state);
    return cache.delete(a2), cache.delete(b2), result;
  };
}
function getStrictProperties(object2) {
  return getOwnPropertyNames(object2).concat(getOwnPropertySymbols(object2));
}
var hasOwn = Object.hasOwn || function(object2, property) {
  return hasOwnProperty$2.call(object2, property);
};
function sameValueZeroEqual(a2, b2) {
  return a2 || b2 ? a2 === b2 : a2 === b2 || a2 !== a2 && b2 !== b2;
}
var OWNER = "_owner", getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, keys = Object.keys;
function areArraysEqual(a2, b2, state) {
  var index2 = a2.length;
  if (b2.length !== index2)
    return !1;
  for (; index2-- > 0; )
    if (!state.equals(a2[index2], b2[index2], index2, index2, a2, b2, state))
      return !1;
  return !0;
}
function areDatesEqual(a2, b2) {
  return sameValueZeroEqual(a2.getTime(), b2.getTime());
}
function areMapsEqual(a2, b2, state) {
  if (a2.size !== b2.size)
    return !1;
  for (var matchedIndices = {}, aIterable = a2.entries(), index2 = 0, aResult, bResult; (aResult = aIterable.next()) && !aResult.done; ) {
    for (var bIterable = b2.entries(), hasMatch = !1, matchIndex = 0; (bResult = bIterable.next()) && !bResult.done; ) {
      var _a2 = aResult.value, aKey = _a2[0], aValue = _a2[1], _b = bResult.value, bKey = _b[0], bValue = _b[1];
      !hasMatch && !matchedIndices[matchIndex] && (hasMatch = state.equals(aKey, bKey, index2, matchIndex, a2, b2, state) && state.equals(aValue, bValue, aKey, bKey, a2, b2, state)) && (matchedIndices[matchIndex] = !0), matchIndex++;
    }
    if (!hasMatch)
      return !1;
    index2++;
  }
  return !0;
}
function areObjectsEqual(a2, b2, state) {
  var properties = keys(a2), index2 = properties.length;
  if (keys(b2).length !== index2)
    return !1;
  for (var property; index2-- > 0; )
    if (property = properties[index2], property === OWNER && (a2.$$typeof || b2.$$typeof) && a2.$$typeof !== b2.$$typeof || !hasOwn(b2, property) || !state.equals(a2[property], b2[property], property, property, a2, b2, state))
      return !1;
  return !0;
}
function areObjectsEqualStrict(a2, b2, state) {
  var properties = getStrictProperties(a2), index2 = properties.length;
  if (getStrictProperties(b2).length !== index2)
    return !1;
  for (var property, descriptorA, descriptorB; index2-- > 0; )
    if (property = properties[index2], property === OWNER && (a2.$$typeof || b2.$$typeof) && a2.$$typeof !== b2.$$typeof || !hasOwn(b2, property) || !state.equals(a2[property], b2[property], property, property, a2, b2, state) || (descriptorA = getOwnPropertyDescriptor(a2, property), descriptorB = getOwnPropertyDescriptor(b2, property), (descriptorA || descriptorB) && (!descriptorA || !descriptorB || descriptorA.configurable !== descriptorB.configurable || descriptorA.enumerable !== descriptorB.enumerable || descriptorA.writable !== descriptorB.writable)))
      return !1;
  return !0;
}
function arePrimitiveWrappersEqual(a2, b2) {
  return sameValueZeroEqual(a2.valueOf(), b2.valueOf());
}
function areRegExpsEqual(a2, b2) {
  return a2.source === b2.source && a2.flags === b2.flags;
}
function areSetsEqual(a2, b2, state) {
  if (a2.size !== b2.size)
    return !1;
  for (var matchedIndices = {}, aIterable = a2.values(), aResult, bResult; (aResult = aIterable.next()) && !aResult.done; ) {
    for (var bIterable = b2.values(), hasMatch = !1, matchIndex = 0; (bResult = bIterable.next()) && !bResult.done; )
      !hasMatch && !matchedIndices[matchIndex] && (hasMatch = state.equals(aResult.value, bResult.value, aResult.value, bResult.value, a2, b2, state)) && (matchedIndices[matchIndex] = !0), matchIndex++;
    if (!hasMatch)
      return !1;
  }
  return !0;
}
function areTypedArraysEqual(a2, b2) {
  var index2 = a2.length;
  if (b2.length !== index2)
    return !1;
  for (; index2-- > 0; )
    if (a2[index2] !== b2[index2])
      return !1;
  return !0;
}
var ARGUMENTS_TAG = "[object Arguments]", BOOLEAN_TAG = "[object Boolean]", DATE_TAG = "[object Date]", MAP_TAG = "[object Map]", NUMBER_TAG = "[object Number]", OBJECT_TAG = "[object Object]", REG_EXP_TAG = "[object RegExp]", SET_TAG = "[object Set]", STRING_TAG = "[object String]", isArray = Array.isArray, isTypedArray = typeof ArrayBuffer == "function" && ArrayBuffer.isView ? ArrayBuffer.isView : null, assign = Object.assign, getTag = Object.prototype.toString.call.bind(Object.prototype.toString);
function createEqualityComparator(_a2) {
  var areArraysEqual2 = _a2.areArraysEqual, areDatesEqual2 = _a2.areDatesEqual, areMapsEqual2 = _a2.areMapsEqual, areObjectsEqual2 = _a2.areObjectsEqual, arePrimitiveWrappersEqual2 = _a2.arePrimitiveWrappersEqual, areRegExpsEqual2 = _a2.areRegExpsEqual, areSetsEqual2 = _a2.areSetsEqual, areTypedArraysEqual2 = _a2.areTypedArraysEqual;
  return function(a2, b2, state) {
    if (a2 === b2)
      return !0;
    if (a2 == null || b2 == null || typeof a2 != "object" || typeof b2 != "object")
      return a2 !== a2 && b2 !== b2;
    var constructor = a2.constructor;
    if (constructor !== b2.constructor)
      return !1;
    if (constructor === Object)
      return areObjectsEqual2(a2, b2, state);
    if (isArray(a2))
      return areArraysEqual2(a2, b2, state);
    if (isTypedArray != null && isTypedArray(a2))
      return areTypedArraysEqual2(a2, b2, state);
    if (constructor === Date)
      return areDatesEqual2(a2, b2, state);
    if (constructor === RegExp)
      return areRegExpsEqual2(a2, b2, state);
    if (constructor === Map)
      return areMapsEqual2(a2, b2, state);
    if (constructor === Set)
      return areSetsEqual2(a2, b2, state);
    var tag = getTag(a2);
    return tag === DATE_TAG ? areDatesEqual2(a2, b2, state) : tag === REG_EXP_TAG ? areRegExpsEqual2(a2, b2, state) : tag === MAP_TAG ? areMapsEqual2(a2, b2, state) : tag === SET_TAG ? areSetsEqual2(a2, b2, state) : tag === OBJECT_TAG ? typeof a2.then != "function" && typeof b2.then != "function" && areObjectsEqual2(a2, b2, state) : tag === ARGUMENTS_TAG ? areObjectsEqual2(a2, b2, state) : tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG ? arePrimitiveWrappersEqual2(a2, b2, state) : !1;
  };
}
function createEqualityComparatorConfig(_a2) {
  var circular = _a2.circular, createCustomConfig = _a2.createCustomConfig, strict = _a2.strict, config = {
    areArraysEqual: strict ? areObjectsEqualStrict : areArraysEqual,
    areDatesEqual,
    areMapsEqual: strict ? combineComparators(areMapsEqual, areObjectsEqualStrict) : areMapsEqual,
    areObjectsEqual: strict ? areObjectsEqualStrict : areObjectsEqual,
    arePrimitiveWrappersEqual,
    areRegExpsEqual,
    areSetsEqual: strict ? combineComparators(areSetsEqual, areObjectsEqualStrict) : areSetsEqual,
    areTypedArraysEqual: strict ? areObjectsEqualStrict : areTypedArraysEqual
  };
  if (createCustomConfig && (config = assign({}, config, createCustomConfig(config))), circular) {
    var areArraysEqual$1 = createIsCircular(config.areArraysEqual), areMapsEqual$1 = createIsCircular(config.areMapsEqual), areObjectsEqual$1 = createIsCircular(config.areObjectsEqual), areSetsEqual$1 = createIsCircular(config.areSetsEqual);
    config = assign({}, config, {
      areArraysEqual: areArraysEqual$1,
      areMapsEqual: areMapsEqual$1,
      areObjectsEqual: areObjectsEqual$1,
      areSetsEqual: areSetsEqual$1
    });
  }
  return config;
}
function createInternalEqualityComparator(compare2) {
  return function(a2, b2, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, state) {
    return compare2(a2, b2, state);
  };
}
function createIsEqual(_a2) {
  var circular = _a2.circular, comparator = _a2.comparator, createState2 = _a2.createState, equals = _a2.equals, strict = _a2.strict;
  if (createState2)
    return function(a2, b2) {
      var _a3 = createState2(), _b = _a3.cache, cache = _b === void 0 ? circular ? /* @__PURE__ */ new WeakMap() : void 0 : _b, meta = _a3.meta;
      return comparator(a2, b2, {
        cache,
        equals,
        meta,
        strict
      });
    };
  if (circular)
    return function(a2, b2) {
      return comparator(a2, b2, {
        cache: /* @__PURE__ */ new WeakMap(),
        equals,
        meta: void 0,
        strict
      });
    };
  var state = {
    cache: void 0,
    equals,
    meta: void 0,
    strict
  };
  return function(a2, b2) {
    return comparator(a2, b2, state);
  };
}
var deepEqual = createCustomEqual();
createCustomEqual({ strict: !0 });
createCustomEqual({ circular: !0 });
createCustomEqual({
  circular: !0,
  strict: !0
});
var shallowEqual = createCustomEqual({
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
createCustomEqual({
  strict: !0,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
createCustomEqual({
  circular: !0,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
createCustomEqual({
  circular: !0,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  },
  strict: !0
});
function createCustomEqual(options) {
  options === void 0 && (options = {});
  var _a2 = options.circular, circular = _a2 === void 0 ? !1 : _a2, createCustomInternalComparator = options.createInternalComparator, createState2 = options.createState, _b = options.strict, strict = _b === void 0 ? !1 : _b, config = createEqualityComparatorConfig(options), comparator = createEqualityComparator(config), equals = createCustomInternalComparator ? createCustomInternalComparator(comparator) : createInternalEqualityComparator(comparator);
  return createIsEqual({ circular, comparator, createState: createState2, equals, strict });
}
function u$a(t2, n2, a2) {
  let o2 = (r2) => t2(r2, ...n2);
  return a2 === void 0 ? o2 : Object.assign(o2, { lazy: a2, lazyArgs: n2 });
}
function u$9(r2, n2, a2) {
  let o2 = r2.length - n2.length;
  if (o2 === 0) return r2(...n2);
  if (o2 === 1) return u$a(r2, n2, a2);
  throw new Error("Wrong number of arguments");
}
function r$6(...t2) {
  return u$9(Object.values, t2);
}
var s$3 = { done: !1, hasNext: !1 };
function x$1(t2, ...o2) {
  let n2 = t2, u2 = o2.map((e2) => "lazy" in e2 ? f$3(e2) : void 0), p2 = 0;
  for (; p2 < o2.length; ) {
    if (u2[p2] === void 0 || !B(n2)) {
      let i2 = o2[p2];
      n2 = i2(n2), p2 += 1;
      continue;
    }
    let r2 = [];
    for (let i2 = p2; i2 < o2.length; i2++) {
      let l2 = u2[i2];
      if (l2 === void 0 || (r2.push(l2), l2.isSingle)) break;
    }
    let a2 = [];
    for (let i2 of n2) if (A(i2, a2, r2)) break;
    let { isSingle: y2 } = r2.at(-1);
    n2 = y2 ? a2[0] : a2, p2 += r2.length;
  }
  return n2;
}
function A(t2, o2, n2) {
  if (n2.length === 0) return o2.push(t2), !1;
  let u2 = t2, p2 = s$3, e2 = !1;
  for (let [r2, a2] of n2.entries()) {
    let { index: y2, items: i2 } = a2;
    if (i2.push(u2), p2 = a2(u2, y2, i2), a2.index += 1, p2.hasNext) {
      if (p2.hasMany ?? !1) {
        for (let l2 of p2.next) if (A(l2, o2, n2.slice(r2 + 1))) return !0;
        return e2;
      }
      u2 = p2.next;
    }
    if (!p2.hasNext) break;
    p2.done && (e2 = !0);
  }
  return p2.hasNext && o2.push(u2), e2;
}
function f$3(t2) {
  let { lazy: o2, lazyArgs: n2 } = t2, u2 = o2(...n2);
  return Object.assign(u2, { isSingle: o2.single ?? !1, index: 0, items: [] });
}
function B(t2) {
  return typeof t2 == "string" || typeof t2 == "object" && t2 !== null && Symbol.iterator in t2;
}
function f$2(t2, i2) {
  let o2 = i2.length - t2.length;
  if (o2 === 1) {
    let [n2, ...r2] = i2;
    return x$1(n2, { lazy: t2, lazyArgs: r2 });
  }
  if (o2 === 0) {
    let n2 = { lazy: t2, lazyArgs: i2 };
    return Object.assign((e2) => x$1(e2, n2), n2);
  }
  throw new Error("Wrong number of arguments");
}
function i$9(...e2) {
  return f$2(o$a, e2);
}
function o$a() {
  let e2 = /* @__PURE__ */ new Set();
  return (t2) => e2.has(t2) ? s$3 : (e2.add(t2), { done: !1, hasNext: !0, next: t2 });
}
function i$8(...e2) {
  return u$9(r$5, e2);
}
var r$5 = (e2, t2) => e2.length >= t2, T$1 = { asc: (r2, n2) => r2 > n2, desc: (r2, n2) => r2 < n2 };
function s$2(r2, n2) {
  let [e2, ...o2] = n2;
  if (!m$3(e2)) {
    let t2 = u$8(...o2);
    return r2(e2, t2);
  }
  let a2 = u$8(e2, ...o2);
  return (t2) => r2(t2, a2);
}
function u$8(r2, n2, ...e2) {
  let o2 = typeof r2 == "function" ? r2 : r2[0], a2 = typeof r2 == "function" ? "asc" : r2[1], { [a2]: t2 } = T$1, i2 = n2 === void 0 ? void 0 : u$8(n2, ...e2);
  return (y2, c) => {
    let p2 = o2(y2), l2 = o2(c);
    return t2(p2, l2) ? 1 : t2(l2, p2) ? -1 : i2?.(y2, c) ?? 0;
  };
}
function m$3(r2) {
  if (d$3(r2)) return !0;
  if (typeof r2 != "object" || !Array.isArray(r2)) return !1;
  let [n2, e2, ...o2] = r2;
  return d$3(n2) && typeof e2 == "string" && e2 in T$1 && o2.length === 0;
}
var d$3 = (r2) => typeof r2 == "function" && r2.length === 1;
function u$7(...e2) {
  return u$9(i$7, e2);
}
function i$7(e2, a2) {
  let n2 = [];
  for (let [o2, r2] of e2.entries()) {
    if (!a2(r2, o2, e2)) break;
    n2.push(r2);
  }
  return n2;
}
function r$4(...n2) {
  return u$9(e$3, n2);
}
function e$3(n2, o2) {
  return o2(n2), n2;
}
function b(t2) {
  return (e2, r2) => {
    if (r2 === 0) return t2(e2);
    if (!Number.isInteger(r2)) throw new TypeError(`precision must be an integer: ${r2.toString()}`);
    if (r2 > 15 || r2 < -15) throw new RangeError("precision must be between -15 and 15");
    if (Number.isNaN(e2) || !Number.isFinite(e2)) return t2(e2);
    let n2 = 10 ** r2;
    return t2(e2 * n2) / n2;
  };
}
function s$1(...e2) {
  return u$9(r$3, e2);
}
function r$3(e2, u2, t2) {
  let [n2, ...a2] = u2;
  if (n2 === void 0) return t2;
  if (Array.isArray(e2)) {
    let o2 = [...e2];
    return o2[n2] = r$3(e2[n2], a2, t2), o2;
  }
  let { [n2]: T2, ...y2 } = e2;
  return { ...y2, [n2]: r$3(T2, a2, t2) };
}
function m$2(...r2) {
  return u$9(o$9, r2);
}
function o$9(r2, t2) {
  let e2 = [...r2];
  return e2.sort(t2), e2;
}
function a$3(...r2) {
  return s$2(n$6, r2);
}
var n$6 = (r2, t2) => [...r2].sort(t2);
function o$8(r2, n2) {
  let e2 = Math.ceil(r2), t2 = Math.floor(n2);
  if (t2 < e2) throw new RangeError(`randomInteger: The range [${r2.toString()},${n2.toString()}] contains no integer`);
  return Math.floor(Math.random() * (t2 - e2 + 1) + e2);
}
function l$4(...e2) {
  return u$9(u$6, e2);
}
var u$6 = (e2, a2, n2) => e2.reduce(a2, n2);
function t$7(...e2) {
  return u$9(r$2, e2);
}
function r$2(e2) {
  return [...e2].reverse();
}
function i$6(...e2) {
  return u$9(o$7, e2);
}
function o$7(e2, n2) {
  let t2 = {};
  for (let r2 of n2) r2 in e2 && (t2[r2] = e2[r2]);
  return t2;
}
function p$3(...n2) {
  return u$9(t$6, n2);
}
var t$6 = (n2, e2) => n2[e2];
function y$4(...t2) {
  return u$9(f$1, t2);
}
function f$1(t2, e2) {
  if (!i$8(e2, 1)) return { ...t2 };
  if (!i$8(e2, 2)) {
    let { [e2[0]]: r2, ...m2 } = t2;
    return m2;
  }
  let o2 = { ...t2 };
  for (let r2 of e2) delete o2[r2];
  return o2;
}
function t$5(...n2) {
  return u$9(o$6, n2);
}
var o$6 = (n2) => n2.length === 1 ? n2[0] : void 0;
function d$2(...r2) {
  return u$9(i$5, r2);
}
var i$5 = (r2, t2) => {
  let a2 = [[], []];
  for (let [o2, e2] of r2.entries()) t2(e2, o2, r2) ? a2[0].push(e2) : a2[1].push(e2);
  return a2;
};
function t$4(...n2) {
  return u$9(Object.keys, n2);
}
function a$2(...e2) {
  return u$9(n$5, e2);
}
var n$5 = (e2) => e2.at(-1);
function m$1(...a2) {
  return u$9(o$5, a2, p$2);
}
var o$5 = (a2, e2) => a2.map(e2), p$2 = (a2) => (e2, t2, r2) => ({ done: !1, hasNext: !0, next: a2(e2, t2, r2) });
function l$3(...n2) {
  return u$9(d$1, n2);
}
function d$1(n2, o2) {
  let e2 = {};
  for (let [a2, t2] of n2.entries()) {
    let [y2, u2] = o2(t2, a2, n2);
    e2[y2] = u2;
  }
  return e2;
}
function t$3(r2) {
  return typeof r2 == "string";
}
function n$4(e2) {
  return !!e2;
}
function n$3(l2) {
  return l2 !== null;
}
function l$2(n2) {
  return n2 != null;
}
function o$4(a2) {
  return (t2) => !a2(t2);
}
function n$2(e2) {
  return e2 == null;
}
function e$2(r2) {
  return typeof r2 == "number" && !Number.isNaN(r2);
}
function o$3(r2) {
  return Array.isArray(r2);
}
function n$1(e2) {
  return e2 !== void 0;
}
function n(e2) {
  return e2 === void 0 ? !0 : typeof e2 == "string" || Array.isArray(e2) ? e2.length === 0 : Object.keys(e2).length === 0;
}
function u$5(...a2) {
  return u$9(o$2, a2, l$1);
}
var o$2 = (a2, r2) => a2.flatMap(r2), l$1 = (a2) => (r2, t2, y2) => {
  let n2 = a2(r2, t2, y2);
  return Array.isArray(n2) ? { done: !1, hasNext: !0, hasMany: !0, next: n2 } : { done: !1, hasNext: !0, next: n2 };
};
function u$4(...e2) {
  return u$9(o$1, e2, i$4);
}
function o$1(e2, r2) {
  return e2.forEach(r2), e2;
}
var i$4 = (e2) => (r2, n2, t2) => (e2(r2, n2, t2), { done: !1, hasNext: !0, next: r2 });
function i$3(...e2) {
  return u$9(a$1, e2);
}
function a$1(e2, r2) {
  for (let [t2, o2] of Object.entries(e2)) r2(o2, t2, e2);
  return e2;
}
function i$2(...e2) {
  return u$9(p$1, e2);
}
var p$1 = (e2, a2) => {
  let n2 = {};
  for (let [d2, t2] of e2.entries()) {
    let y2 = a2(t2, d2, e2);
    if (y2 !== void 0) {
      let { [y2]: r2 } = n2;
      r2 === void 0 && (r2 = [], n2[y2] = r2), r2.push(t2);
    }
  }
  return n2;
};
function T(...a2) {
  return u$9(l, a2, y$3);
}
var l = (a2, e2) => a2.filter(e2), y$3 = (a2) => (e2, t2, o2) => a2(e2, t2, o2) ? { done: !1, hasNext: !0, next: e2 } : s$3, e$1 = (n2) => Object.assign(n2, { single: !0 });
function f(...e2) {
  return u$9(i$1, e2, e$1(u$3));
}
var i$1 = (e2, n2) => e2.find(n2), u$3 = (e2) => (n2, t2, o2) => e2(n2, t2, o2) ? { done: !0, hasNext: !0, next: n2 } : s$3;
function d(...e2) {
  return u$9(r$1, e2, e$1(o));
}
var r$1 = ([e2]) => e2, o = () => a, a = (e2) => ({ hasNext: !0, next: e2, done: !0 });
function t$2(...r2) {
  return u$9(Object.entries, r2);
}
function p(...n2) {
  return u$9(u$2, n2);
}
function u$2(n2, t2 = [], r2 = []) {
  if (typeof n2 == "function") return n2;
  if (typeof n2 != "object" || n2 === null || n2 instanceof Date || n2 instanceof RegExp) return structuredClone(n2);
  let o2 = t2.indexOf(n2);
  return o2 !== -1 ? r2[o2] : (t2.push(n2), Array.isArray(n2) ? y$2(n2, t2, r2) : s(n2, t2, r2));
}
function s(n2, t2, r2) {
  let o2 = {};
  r2.push(o2);
  for (let [e2, c] of Object.entries(n2)) o2[e2] = u$2(c, t2, r2);
  return o2;
}
function y$2(n2, t2, r2) {
  let o2 = [];
  r2.push(o2);
  for (let [e2, c] of n2.entries()) o2[e2] = u$2(c, t2, r2);
  return o2;
}
function t$1(...a2) {
  return u$9(e, a2);
}
var e = (a2, o2) => o2.every((l2) => l2(a2));
function y$1(...a2) {
  return u$9(r, a2);
}
var r = (a2, o2) => o2.some((e2) => e2(a2));
function u$1(...e2) {
  return u$9(b(Math.ceil), e2);
}
function u(...n2) {
  return u$9(i, n2);
}
var i = (n2, { min: e2, max: r2 }) => e2 !== void 0 && n2 < e2 ? e2 : r2 !== void 0 && n2 > r2 ? r2 : n2, rootClassName = "likec4-diagram-root";
function nonNullable(value, message) {
  if (typeof value > "u" || value == null)
    throw new Error(message ?? `Expected defined value, but received ${value}`);
  return value;
}
function invariant$1(condition, message) {
  if (!condition)
    throw new Error(message ?? "Invariant failed");
}
function nonexhaustive(value) {
  throw new Error(`NonExhaustive value: ${value}`);
}
var ElementKind;
((ElementKind2) => {
  ElementKind2.Group = "@group";
})(ElementKind || (ElementKind = {}));
const ElementShapes = [
  "rectangle",
  "person",
  "browser",
  "mobile",
  "cylinder",
  "storage",
  "queue"
], isTagEqual = (operator) => "tag" in operator, isKindEqual = (operator) => "kind" in operator, isNotOperator = (operator) => "not" in operator, isAndOperator = (operator) => "and" in operator, isOrOperator = (operator) => "or" in operator;
function whereOperatorAsPredicate(operator) {
  switch (!0) {
    case isTagEqual(operator): {
      if ("eq" in operator.tag) {
        const tag2 = operator.tag.eq;
        return (value) => Array.isArray(value.tags) && value.tags.includes(tag2);
      }
      const tag = operator.tag.neq;
      return (value) => !Array.isArray(value.tags) || !value.tags.includes(tag);
    }
    case isKindEqual(operator): {
      if ("eq" in operator.kind) {
        const kind2 = operator.kind.eq;
        return (value) => value.kind === kind2;
      }
      const kind = operator.kind.neq;
      return (value) => n$2(value.kind) || value.kind !== kind;
    }
    case isNotOperator(operator): {
      const predicate = whereOperatorAsPredicate(operator.not);
      return o$4(predicate);
    }
    case isAndOperator(operator): {
      const predicates = operator.and.map(whereOperatorAsPredicate);
      return t$1(predicates);
    }
    case isOrOperator(operator): {
      const predicates = operator.or.map(whereOperatorAsPredicate);
      return y$1(predicates);
    }
    default:
      nonexhaustive(operator);
  }
}
function isStepEdgeId(id2) {
  return id2.startsWith("step-");
}
function extractStep(id2) {
  if (!isStepEdgeId(id2))
    throw new Error(`Invalid step edge id: ${id2}`);
  return parseFloat(id2.slice(5));
}
function getParallelStepsPrefix(id2) {
  return isStepEdgeId(id2) && id2.includes(".") ? id2.slice(0, id2.indexOf(".") + 1) : null;
}
var ComputedNode;
((ComputedNode2) => {
  function isNodesGroup(node2) {
    return node2.kind === ElementKind.Group;
  }
  ComputedNode2.isNodesGroup = isNodesGroup;
})(ComputedNode || (ComputedNode = {}));
function getBBoxCenter({
  x: x2,
  y: y2,
  width: width2,
  height
}) {
  return {
    x: x2 + width2 / 2,
    y: y2 + height / 2
  };
}
var DiagramNode;
((DiagramNode2) => {
  function isNodesGroup(node2) {
    return node2.kind === ElementKind.Group;
  }
  DiagramNode2.isNodesGroup = isNodesGroup;
})(DiagramNode || (DiagramNode = {}));
var naturalCompareLite = { exports: {} };
naturalCompareLite.exports;
/*
 * @version    1.4.0
 * @date       2015-10-26
 * @stability  3 - Stable
 * @author     Lauri Rooden (https://github.com/litejs/natural-compare-lite)
 * @license    MIT License
 */
var naturalCompare = function(a2, b2) {
  var i2, codeA, codeB = 1, posA = 0, posB = 0, alphabet = String.alphabet;
  function getCode(str, pos, code) {
    if (code) {
      for (i2 = pos; code = getCode(str, i2), code < 76 && code > 65; ) ++i2;
      return +str.slice(pos - 1, i2);
    }
    return code = alphabet && alphabet.indexOf(str.charAt(pos)), code > -1 ? code + 76 : (code = str.charCodeAt(pos) || 0, code < 45 || code > 127 ? code : code < 46 ? 65 : code < 48 ? code - 1 : code < 58 ? code + 18 : code < 65 ? code - 11 : code < 91 ? code + 11 : code < 97 ? code - 37 : code < 123 ? code + 5 : code - 63);
  }
  if ((a2 += "") != (b2 += "")) {
    for (; codeB; )
      if (codeA = getCode(a2, posA++), codeB = getCode(b2, posB++), codeA < 76 && codeB < 76 && codeA > 66 && codeB > 66 && (codeA = getCode(a2, posA, posA), codeB = getCode(b2, posB, posA = i2), posB = i2), codeA != codeB) return codeA < codeB ? -1 : 1;
  }
  return 0;
};
try {
  naturalCompareLite.exports = naturalCompare;
} catch {
  String.naturalCompare = naturalCompare;
}
var naturalCompareLiteExports = naturalCompareLite.exports;
const compare$1 = /* @__PURE__ */ getDefaultExportFromCjs(naturalCompareLiteExports);
function compareNatural(a2, b2) {
  return a2 === b2 ? 0 : t$3(a2) ? t$3(b2) ? compare$1(a2, b2) : 1 : t$3(b2) ? -1 : 0;
}
function isString(value) {
  return value != null && typeof value == "string";
}
function nameFromFqn(fqn2) {
  const lastDot = fqn2.lastIndexOf(".");
  return lastDot > 0 ? fqn2.slice(lastDot + 1) : fqn2;
}
function isAncestor(...args) {
  const ancestor = isString(args[0]) ? args[0] : args[0].id;
  return (isString(args[1]) ? args[1] : args[1].id).startsWith(ancestor + ".");
}
function commonAncestor(first, second) {
  const parentA = parentFqn(first), parentB = parentFqn(second);
  if (parentA === parentB)
    return parentA;
  if (!parentA || !parentB)
    return null;
  const a2 = first.split("."), b2 = second.split(".");
  let ancestor = null;
  for (; a2.length > 1 && b2.length > 1 && a2[0] && a2[0] === b2[0]; )
    ancestor = ancestor ? `${ancestor}.${a2[0]}` : a2[0], a2.shift(), b2.shift();
  return ancestor;
}
function parentFqn(fqn2) {
  const lastDot = fqn2.lastIndexOf(".");
  return lastDot > 0 ? fqn2.slice(0, lastDot) : null;
}
function ancestorsFqn(fqn2) {
  const path = fqn2.split(".");
  return path.pop(), path.length === 0 ? [] : path.reduce((acc, part, idx) => idx === 0 ? (acc.push(part), acc) : (acc.unshift(`${acc[0]}.${part}`), acc), []);
}
function compareFqnHierarchically(a2, b2) {
  const depthA = a2.split(".").length, depthB = b2.split(".").length;
  switch (!0) {
    case depthA > depthB:
      return 1;
    case depthA < depthB:
      return -1;
    default:
      return 0;
  }
}
function compareByFqnHierarchically(a2, b2) {
  return compareFqnHierarchically(a2.id, b2.id);
}
const blue$1 = {
  fill: "#3b82f6",
  stroke: "#2563eb",
  hiContrast: "#eff6ff",
  loContrast: "#bfdbfe"
}, sky$1 = {
  fill: "#0284c7",
  stroke: "#0369a1",
  hiContrast: "#f0f9ff",
  loContrast: "#B6ECF7"
}, slate$1 = {
  fill: "#64748b",
  stroke: "#475569",
  hiContrast: "#f8fafc",
  loContrast: "#cbd5e1"
}, ElementColors = {
  primary: blue$1,
  blue: blue$1,
  secondary: sky$1,
  sky: sky$1,
  muted: slate$1,
  slate: slate$1,
  gray: {
    // fill: colors.neutral[500],
    // stroke: colors.neutral[600],
    // hiContrast: colors.neutral[50],
    // loContrast: colors.neutral[200],
    fill: "#737373",
    stroke: "#525252",
    hiContrast: "#fafafa",
    loContrast: "#d4d4d4"
  },
  red: {
    // fill: colors.red[500],
    // stroke: colors.red[600],
    // hiContrast: colors.red[50],
    // loContrast: colors.red[200],
    fill: "#AC4D39",
    // fill: '#b54548',
    stroke: "#853A2D",
    // hiContrast: '#fef2f2',
    // loContrast: '#fecaca',
    // hiContrast: '#191111', // colors.gray[900],
    // loContrast: '#3b1219' // colors.gray[800],
    hiContrast: "#FBD3CB",
    // hiContrast: '#f8fafc',
    // loContrast: '#fdd8d8' // radix black red 12
    loContrast: "#f5b2a3"
  },
  green: {
    fill: "#428a4f",
    stroke: "#2d5d39",
    hiContrast: "#f8fafc",
    loContrast: "#c2f0c2"
  },
  amber: {
    fill: "#A35829",
    stroke: "#7E451D",
    hiContrast: "#FFE0C2",
    loContrast: "#f9b27c"
  },
  indigo: {
    // fill: colors.indigo[500],
    // stroke: colors.indigo[600],
    // hiContrast: colors.indigo[50],
    // loContrast: colors.indigo[200],
    fill: "#6366f1",
    stroke: "#4f46e5",
    hiContrast: "#eef2ff",
    loContrast: "#c7d2fe"
  }
}, gray = {
  lineColor: "#6E6E6E",
  labelBgColor: "#18191b",
  labelColor: "#C6C6C6"
}, slate = {
  lineColor: "#64748b",
  // 500
  labelBgColor: "#0f172a",
  // 900
  labelColor: "#cbd5e1"
  // 300
}, blue = {
  lineColor: "#3b82f6",
  // 500
  labelBgColor: "#172554",
  // 950
  labelColor: "#60a5fa"
  // 400
}, sky = {
  lineColor: "#0ea5e9",
  // 500
  labelBgColor: "#082f49",
  // 950
  labelColor: "#38bdf8"
  // 400
}, RelationshipColors = {
  amber: {
    lineColor: "#b45309",
    labelBgColor: "#78350f",
    labelColor: "#FFE0C2"
  },
  blue,
  gray,
  green: {
    lineColor: "#15803d",
    // 700
    labelBgColor: "#052e16",
    // 950
    labelColor: "#22c55e"
    // 500
  },
  indigo: {
    lineColor: "#6366f1",
    // 500
    labelBgColor: "#1e1b4b",
    // 950
    labelColor: "#818cf8"
    // 400
  },
  muted: slate,
  primary: blue,
  red: {
    lineColor: "#AC4D39",
    labelBgColor: "#b91c1c",
    labelColor: "#f5b2a3"
  },
  secondary: sky,
  sky,
  slate
}, defaultTheme = {
  elements: ElementColors,
  relationships: RelationshipColors,
  font: "Arial",
  shadow: "#0a0a0a"
}, DELAY = "LIKEC4_DELAY";
function delay$1(...args) {
  let ms = 100;
  return args.length === 2 ? ms = o$8(args[0], args[1]) : args.length === 1 && (ms = args[0]), new Promise((resolve) => {
    setTimeout(() => {
      resolve(DELAY);
    }, ms ?? 100);
  });
}
const compareRelations = (a2, b2) => {
  const parentA = commonAncestor(a2.source, a2.target), parentB = commonAncestor(b2.source, b2.target);
  if (parentA && !parentB)
    return 1;
  if (!parentA && parentB)
    return -1;
  const compareParents = parentA && parentB ? compareFqnHierarchically(parentA, parentB) : 0;
  if (compareParents !== 0)
    return compareParents;
  const compareSource = compareFqnHierarchically(a2.source, b2.source);
  return compareSource !== 0 ? compareSource : compareFqnHierarchically(a2.target, b2.target);
};
function createDOMMotionComponentProxy(componentFactory) {
  if (typeof Proxy > "u")
    return componentFactory;
  const componentCache = /* @__PURE__ */ new Map(), deprecatedFactoryFunction = (...args) => componentFactory(...args);
  return new Proxy(deprecatedFactoryFunction, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (_target, key) => key === "create" ? componentFactory : (componentCache.has(key) || componentCache.set(key, componentFactory(key)), componentCache.get(key))
  });
}
function isAnimationControls(v) {
  return v !== null && typeof v == "object" && typeof v.start == "function";
}
const isKeyframesTarget = (v) => Array.isArray(v);
function shallowCompare(next, prev) {
  if (!Array.isArray(prev))
    return !1;
  const prevLength = prev.length;
  if (prevLength !== next.length)
    return !1;
  for (let i2 = 0; i2 < prevLength; i2++)
    if (prev[i2] !== next[i2])
      return !1;
  return !0;
}
function isVariantLabel(v) {
  return typeof v == "string" || Array.isArray(v);
}
function getValueState(visualElement) {
  const state = [{}, {}];
  return visualElement?.values.forEach((value, key) => {
    state[0][key] = value.get(), state[1][key] = value.getVelocity();
  }), state;
}
function resolveVariantFromProps(props2, definition, custom5, visualElement) {
  if (typeof definition == "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom5 !== void 0 ? custom5 : props2.custom, current, velocity);
  }
  if (typeof definition == "string" && (definition = props2.variants && props2.variants[definition]), typeof definition == "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom5 !== void 0 ? custom5 : props2.custom, current, velocity);
  }
  return definition;
}
function resolveVariant(visualElement, definition, custom5) {
  const props2 = visualElement.getProps();
  return resolveVariantFromProps(props2, definition, custom5 !== void 0 ? custom5 : props2.custom, visualElement);
}
const variantPriorityOrder = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], variantProps = ["initial", ...variantPriorityOrder], transformPropOrder = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], transformProps = new Set(transformPropOrder), secondsToMilliseconds = (seconds) => seconds * 1e3, millisecondsToSeconds = (milliseconds) => milliseconds / 1e3, underDampedSpring = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, criticallyDampedSpring = (target) => ({
  type: "spring",
  stiffness: 550,
  damping: target === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), keyframesTransition = {
  type: "keyframes",
  duration: 0.8
}, ease = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, getDefaultTransition = (valueKey, { keyframes: keyframes2 }) => keyframes2.length > 2 ? keyframesTransition : transformProps.has(valueKey) ? valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes2[1]) : underDampedSpring : ease;
function getValueTransition$1(transition, key) {
  return transition ? transition[key] || transition.default || transition : void 0;
}
const MotionGlobalConfig = {
  skipAnimations: !1,
  useManualTiming: !1
}, isNotNull = (value) => value !== null;
function getFinalKeyframe(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe) {
  const resolvedKeyframes = keyframes2.filter(isNotNull), index2 = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
  return !index2 || finalKeyframe === void 0 ? resolvedKeyframes[index2] : finalKeyframe;
}
const noop$2 = (any) => any;
function createRenderStep(runNextFrame) {
  let thisFrame = /* @__PURE__ */ new Set(), nextFrame = /* @__PURE__ */ new Set(), isProcessing = !1, flushNextFrame = !1;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  let latestFrameData = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  };
  function triggerCallback(callback) {
    toKeepAlive.has(callback) && (step.schedule(callback), runNextFrame()), callback(latestFrameData);
  }
  const step = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (callback, keepAlive = !1, immediate = !1) => {
      const queue = immediate && isProcessing ? thisFrame : nextFrame;
      return keepAlive && toKeepAlive.add(callback), queue.has(callback) || queue.add(callback), callback;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (callback) => {
      nextFrame.delete(callback), toKeepAlive.delete(callback);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (frameData2) => {
      if (latestFrameData = frameData2, isProcessing) {
        flushNextFrame = !0;
        return;
      }
      isProcessing = !0, [thisFrame, nextFrame] = [nextFrame, thisFrame], nextFrame.clear(), thisFrame.forEach(triggerCallback), isProcessing = !1, flushNextFrame && (flushNextFrame = !1, step.process(frameData2));
    }
  };
  return step;
}
const stepsOrder = [
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
], maxElapsed = 40;
function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
  let runNextFrame = !1, useDefaultElapsed = !0;
  const state = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, flagRunNextFrame = () => runNextFrame = !0, steps = stepsOrder.reduce((acc, key) => (acc[key] = createRenderStep(flagRunNextFrame), acc), {}), { read: read2, resolveKeyframes, update, preRender, render, postRender } = steps, processBatch = () => {
    const timestamp = performance.now();
    runNextFrame = !1, state.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1), state.timestamp = timestamp, state.isProcessing = !0, read2.process(state), resolveKeyframes.process(state), update.process(state), preRender.process(state), render.process(state), postRender.process(state), state.isProcessing = !1, runNextFrame && allowKeepAlive && (useDefaultElapsed = !1, scheduleNextBatch(processBatch));
  }, wake = () => {
    runNextFrame = !0, useDefaultElapsed = !0, state.isProcessing || scheduleNextBatch(processBatch);
  };
  return { schedule: stepsOrder.reduce((acc, key) => {
    const step = steps[key];
    return acc[key] = (process2, keepAlive = !1, immediate = !1) => (runNextFrame || wake(), step.schedule(process2, keepAlive, immediate)), acc;
  }, {}), cancel: (process2) => {
    for (let i2 = 0; i2 < stepsOrder.length; i2++)
      steps[stepsOrder[i2]].cancel(process2);
  }, state, steps };
}
const { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps } = createRenderBatcher(typeof requestAnimationFrame < "u" ? requestAnimationFrame : noop$2, !0), calcBezier = (t2, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t2 + (3 * a2 - 6 * a1)) * t2 + 3 * a1) * t2, subdivisionPrecision = 1e-7, subdivisionMaxIterations = 12;
function binarySubdivide(x2, lowerBound, upperBound, mX1, mX2) {
  let currentX, currentT, i2 = 0;
  do
    currentT = lowerBound + (upperBound - lowerBound) / 2, currentX = calcBezier(currentT, mX1, mX2) - x2, currentX > 0 ? upperBound = currentT : lowerBound = currentT;
  while (Math.abs(currentX) > subdivisionPrecision && ++i2 < subdivisionMaxIterations);
  return currentT;
}
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return noop$2;
  const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
  return (t2) => t2 === 0 || t2 === 1 ? t2 : calcBezier(getTForX(t2), mY1, mY2);
}
const mirrorEasing = (easing) => (p2) => p2 <= 0.5 ? easing(2 * p2) / 2 : (2 - easing(2 * (1 - p2))) / 2, reverseEasing = (easing) => (p2) => 1 - easing(1 - p2), backOut = /* @__PURE__ */ cubicBezier(0.33, 1.53, 0.69, 0.99), backIn = /* @__PURE__ */ reverseEasing(backOut), backInOut = /* @__PURE__ */ mirrorEasing(backIn), anticipate = (p2) => (p2 *= 2) < 1 ? 0.5 * backIn(p2) : 0.5 * (2 - Math.pow(2, -10 * (p2 - 1))), circIn = (p2) => 1 - Math.sin(Math.acos(p2)), circOut = reverseEasing(circIn), circInOut = mirrorEasing(circIn), isZeroValueString = (v) => /^0[^.\s]+$/u.test(v);
function isNone(value) {
  return typeof value == "number" ? value === 0 : value !== null ? value === "none" || value === "0" || isZeroValueString(value) : !0;
}
let invariant = noop$2;
const isNumericalString = (v) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v), checkStringStartsWith = (token) => (key) => typeof key == "string" && key.startsWith(token), isCSSVariableName = /* @__PURE__ */ checkStringStartsWith("--"), startsAsVariableToken = /* @__PURE__ */ checkStringStartsWith("var(--"), isCSSVariableToken = (value) => startsAsVariableToken(value) ? singleCssVariableRegex.test(value.split("/*")[0].trim()) : !1, singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, splitCSSVariableRegex = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function parseCSSVariable(current) {
  const match = splitCSSVariableRegex.exec(current);
  if (!match)
    return [,];
  const [, token1, token2, fallback] = match;
  return [`--${token1 ?? token2}`, fallback];
}
function getVariableValue(current, element, depth = 1) {
  const [token, fallback] = parseCSSVariable(current);
  if (!token)
    return;
  const resolved = window.getComputedStyle(element).getPropertyValue(token);
  if (resolved) {
    const trimmed = resolved.trim();
    return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
  }
  return isCSSVariableToken(fallback) ? getVariableValue(fallback, element, depth + 1) : fallback;
}
const clamp = (min2, max2, v) => v > max2 ? max2 : v < min2 ? min2 : v, number = {
  test: (v) => typeof v == "number",
  parse: parseFloat,
  transform: (v) => v
}, alpha = {
  ...number,
  transform: (v) => clamp(0, 1, v)
}, scale = {
  ...number,
  default: 1
}, createUnitType = (unit) => ({
  test: (v) => typeof v == "string" && v.endsWith(unit) && v.split(" ").length === 1,
  parse: parseFloat,
  transform: (v) => `${v}${unit}`
}), degrees = /* @__PURE__ */ createUnitType("deg"), percent = /* @__PURE__ */ createUnitType("%"), px = /* @__PURE__ */ createUnitType("px"), vh = /* @__PURE__ */ createUnitType("vh"), vw = /* @__PURE__ */ createUnitType("vw"), progressPercentage = {
  ...percent,
  parse: (v) => percent.parse(v) / 100,
  transform: (v) => percent.transform(v * 100)
}, positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y",
  "translateX",
  "translateY"
]), isNumOrPxType = (v) => v === number || v === px, getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(", ")[pos]), getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {
  if (transform === "none" || !transform)
    return 0;
  const matrix3d = transform.match(/^matrix3d\((.+)\)$/u);
  if (matrix3d)
    return getPosFromMatrix(matrix3d[1], pos3);
  {
    const matrix = transform.match(/^matrix\((.+)\)$/u);
    return matrix ? getPosFromMatrix(matrix[1], pos2) : 0;
  }
}, transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]), nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
function removeNonTranslationalTransform(visualElement) {
  const removedTransforms = [];
  return nonTranslationalTransformKeys.forEach((key) => {
    const value = visualElement.getValue(key);
    value !== void 0 && (removedTransforms.push([key, value.get()]), value.set(key.startsWith("scale") ? 1 : 0));
  }), removedTransforms;
}
const positionalValues = {
  // Dimensions
  width: ({ x: x2 }, { paddingLeft = "0", paddingRight = "0" }) => x2.max - x2.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
  height: ({ y: y2 }, { paddingTop = "0", paddingBottom = "0" }) => y2.max - y2.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
  top: (_bbox, { top }) => parseFloat(top),
  left: (_bbox, { left }) => parseFloat(left),
  bottom: ({ y: y2 }, { top }) => parseFloat(top) + (y2.max - y2.min),
  right: ({ x: x2 }, { left }) => parseFloat(left) + (x2.max - x2.min),
  // Transform
  x: getTranslateFromMatrix(4, 13),
  y: getTranslateFromMatrix(5, 14)
};
positionalValues.translateX = positionalValues.x;
positionalValues.translateY = positionalValues.y;
const testValueType = (v) => (type) => type.test(v), auto = {
  test: (v) => v === "auto",
  parse: (v) => v
}, dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto], findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v)), toResolve = /* @__PURE__ */ new Set();
let isScheduled = !1, anyNeedsMeasurement = !1;
function measureAllKeyframes() {
  if (anyNeedsMeasurement) {
    const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement), elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element)), transformsToRestore = /* @__PURE__ */ new Map();
    elementsToMeasure.forEach((element) => {
      const removedTransforms = removeNonTranslationalTransform(element);
      removedTransforms.length && (transformsToRestore.set(element, removedTransforms), element.render());
    }), resolversToMeasure.forEach((resolver) => resolver.measureInitialState()), elementsToMeasure.forEach((element) => {
      element.render();
      const restore = transformsToRestore.get(element);
      restore && restore.forEach(([key, value]) => {
        var _a2;
        (_a2 = element.getValue(key)) === null || _a2 === void 0 || _a2.set(value);
      });
    }), resolversToMeasure.forEach((resolver) => resolver.measureEndState()), resolversToMeasure.forEach((resolver) => {
      resolver.suspendedScrollY !== void 0 && window.scrollTo(0, resolver.suspendedScrollY);
    });
  }
  anyNeedsMeasurement = !1, isScheduled = !1, toResolve.forEach((resolver) => resolver.complete()), toResolve.clear();
}
function readAllKeyframes() {
  toResolve.forEach((resolver) => {
    resolver.readKeyframes(), resolver.needsMeasurement && (anyNeedsMeasurement = !0);
  });
}
function flushKeyframeResolvers() {
  readAllKeyframes(), measureAllKeyframes();
}
class KeyframeResolver {
  constructor(unresolvedKeyframes, onComplete, name, motionValue2, element, isAsync = !1) {
    this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...unresolvedKeyframes], this.onComplete = onComplete, this.name = name, this.motionValue = motionValue2, this.element = element, this.isAsync = isAsync;
  }
  scheduleResolve() {
    this.isScheduled = !0, this.isAsync ? (toResolve.add(this), isScheduled || (isScheduled = !0, frame.read(readAllKeyframes), frame.resolveKeyframes(measureAllKeyframes))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes, name, element, motionValue: motionValue2 } = this;
    for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++)
      if (unresolvedKeyframes[i2] === null)
        if (i2 === 0) {
          const currentValue = motionValue2?.get(), finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
          if (currentValue !== void 0)
            unresolvedKeyframes[0] = currentValue;
          else if (element && name) {
            const valueAsRead = element.readValue(name, finalKeyframe);
            valueAsRead != null && (unresolvedKeyframes[0] = valueAsRead);
          }
          unresolvedKeyframes[0] === void 0 && (unresolvedKeyframes[0] = finalKeyframe), motionValue2 && currentValue === void 0 && motionValue2.set(unresolvedKeyframes[0]);
        } else
          unresolvedKeyframes[i2] = unresolvedKeyframes[i2 - 1];
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete() {
    this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), toResolve.delete(this);
  }
  cancel() {
    this.isComplete || (this.isScheduled = !1, toResolve.delete(this));
  }
  resume() {
    this.isComplete || this.scheduleResolve();
  }
}
const sanitize = (v) => Math.round(v * 1e5) / 1e5, floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function isNullish(v) {
  return v == null;
}
const singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, isColorString = (type, testProp) => (v) => !!(typeof v == "string" && singleColorRegex.test(v) && v.startsWith(type) || testProp && !isNullish(v) && Object.prototype.hasOwnProperty.call(v, testProp)), splitColor = (aName, bName, cName) => (v) => {
  if (typeof v != "string")
    return v;
  const [a2, b2, c, alpha2] = v.match(floatRegex);
  return {
    [aName]: parseFloat(a2),
    [bName]: parseFloat(b2),
    [cName]: parseFloat(c),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
}, clampRgbUnit = (v) => clamp(0, 255, v), rgbUnit = {
  ...number,
  transform: (v) => Math.round(clampRgbUnit(v))
}, rgba = {
  test: /* @__PURE__ */ isColorString("rgb", "red"),
  parse: /* @__PURE__ */ splitColor("red", "green", "blue"),
  transform: ({ red, green, blue: blue2, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue2) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
};
function parseHex(v) {
  let r2 = "", g = "", b2 = "", a2 = "";
  return v.length > 5 ? (r2 = v.substring(1, 3), g = v.substring(3, 5), b2 = v.substring(5, 7), a2 = v.substring(7, 9)) : (r2 = v.substring(1, 2), g = v.substring(2, 3), b2 = v.substring(3, 4), a2 = v.substring(4, 5), r2 += r2, g += g, b2 += b2, a2 += a2), {
    red: parseInt(r2, 16),
    green: parseInt(g, 16),
    blue: parseInt(b2, 16),
    alpha: a2 ? parseInt(a2, 16) / 255 : 1
  };
}
const hex = {
  test: /* @__PURE__ */ isColorString("#"),
  parse: parseHex,
  transform: rgba.transform
}, hsla = {
  test: /* @__PURE__ */ isColorString("hsl", "hue"),
  parse: /* @__PURE__ */ splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
}, color = {
  test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),
  parse: (v) => rgba.test(v) ? rgba.parse(v) : hsla.test(v) ? hsla.parse(v) : hex.parse(v),
  transform: (v) => typeof v == "string" ? v : v.hasOwnProperty("red") ? rgba.transform(v) : hsla.transform(v)
}, colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function test(v) {
  var _a2, _b;
  return isNaN(v) && typeof v == "string" && (((_a2 = v.match(floatRegex)) === null || _a2 === void 0 ? void 0 : _a2.length) || 0) + (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) > 0;
}
const NUMBER_TOKEN = "number", COLOR_TOKEN = "color", VAR_TOKEN = "var", VAR_FUNCTION_TOKEN = "var(", SPLIT_TOKEN = "${}", complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function analyseComplexValue(value) {
  const originalValue = value.toString(), values = [], indexes = {
    color: [],
    number: [],
    var: []
  }, types = [];
  let i2 = 0;
  const split = originalValue.replace(complexRegex, (parsedValue) => (color.test(parsedValue) ? (indexes.color.push(i2), types.push(COLOR_TOKEN), values.push(color.parse(parsedValue))) : parsedValue.startsWith(VAR_FUNCTION_TOKEN) ? (indexes.var.push(i2), types.push(VAR_TOKEN), values.push(parsedValue)) : (indexes.number.push(i2), types.push(NUMBER_TOKEN), values.push(parseFloat(parsedValue))), ++i2, SPLIT_TOKEN)).split(SPLIT_TOKEN);
  return { values, split, indexes, types };
}
function parseComplexValue(v) {
  return analyseComplexValue(v).values;
}
function createTransformer(source) {
  const { split, types } = analyseComplexValue(source), numSections = split.length;
  return (v) => {
    let output = "";
    for (let i2 = 0; i2 < numSections; i2++)
      if (output += split[i2], v[i2] !== void 0) {
        const type = types[i2];
        type === NUMBER_TOKEN ? output += sanitize(v[i2]) : type === COLOR_TOKEN ? output += color.transform(v[i2]) : output += v[i2];
      }
    return output;
  };
}
const convertNumbersToZero = (v) => typeof v == "number" ? 0 : v;
function getAnimatableNone$1(v) {
  const parsed = parseComplexValue(v);
  return createTransformer(v)(parsed.map(convertNumbersToZero));
}
const complex = {
  test,
  parse: parseComplexValue,
  createTransformer,
  getAnimatableNone: getAnimatableNone$1
}, maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v) {
  const [name, value] = v.slice(0, -1).split("(");
  if (name === "drop-shadow")
    return v;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v;
  const unit = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name) ? 1 : 0;
  return number2 !== value && (defaultValue *= 100), name + "(" + defaultValue + unit + ")";
}
const functionRegex = /\b([a-z-]*)\(.*?\)/gu, filter = {
  ...complex,
  getAnimatableNone: (v) => {
    const functions = v.match(functionRegex);
    return functions ? functions.map(applyDefaultFilter).join(" ") : v;
  }
}, browserNumberValueTypes = {
  // Border props
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  // Positioning props
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  // Spacing props
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  // Misc
  backgroundPositionX: px,
  backgroundPositionY: px
}, transformValueTypes = {
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px
}, int = {
  ...number,
  transform: Math.round
}, numberValueTypes = {
  ...browserNumberValueTypes,
  ...transformValueTypes,
  zIndex: int,
  size: px,
  // SVG
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
}, defaultValueTypes = {
  ...numberValueTypes,
  // Color props
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  // Border props
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter,
  WebkitFilter: filter
}, getDefaultValueType = (key) => defaultValueTypes[key];
function getAnimatableNone(key, value) {
  let defaultValueType = getDefaultValueType(key);
  return defaultValueType !== filter && (defaultValueType = complex), defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
}
const invalidTemplates = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {
  let i2 = 0, animatableTemplate;
  for (; i2 < unresolvedKeyframes.length && !animatableTemplate; ) {
    const keyframe = unresolvedKeyframes[i2];
    typeof keyframe == "string" && !invalidTemplates.has(keyframe) && analyseComplexValue(keyframe).values.length && (animatableTemplate = unresolvedKeyframes[i2]), i2++;
  }
  if (animatableTemplate && name)
    for (const noneIndex of noneKeyframeIndexes)
      unresolvedKeyframes[noneIndex] = getAnimatableNone(name, animatableTemplate);
}
class DOMKeyframesResolver extends KeyframeResolver {
  constructor(unresolvedKeyframes, onComplete, name, motionValue2, element) {
    super(unresolvedKeyframes, onComplete, name, motionValue2, element, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes, element, name } = this;
    if (!element || !element.current)
      return;
    super.readKeyframes();
    for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
      let keyframe = unresolvedKeyframes[i2];
      if (typeof keyframe == "string" && (keyframe = keyframe.trim(), isCSSVariableToken(keyframe))) {
        const resolved = getVariableValue(keyframe, element.current);
        resolved !== void 0 && (unresolvedKeyframes[i2] = resolved), i2 === unresolvedKeyframes.length - 1 && (this.finalKeyframe = keyframe);
      }
    }
    if (this.resolveNoneKeyframes(), !positionalKeys.has(name) || unresolvedKeyframes.length !== 2)
      return;
    const [origin, target] = unresolvedKeyframes, originType = findDimensionValueType(origin), targetType = findDimensionValueType(target);
    if (originType !== targetType)
      if (isNumOrPxType(originType) && isNumOrPxType(targetType))
        for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
          const value = unresolvedKeyframes[i2];
          typeof value == "string" && (unresolvedKeyframes[i2] = parseFloat(value));
        }
      else
        this.needsMeasurement = !0;
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes, name } = this, noneKeyframeIndexes = [];
    for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++)
      isNone(unresolvedKeyframes[i2]) && noneKeyframeIndexes.push(i2);
    noneKeyframeIndexes.length && makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);
  }
  measureInitialState() {
    const { element, unresolvedKeyframes, name } = this;
    if (!element || !element.current)
      return;
    name === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current)), unresolvedKeyframes[0] = this.measuredOrigin;
    const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
    measureKeyframe !== void 0 && element.getValue(name, measureKeyframe).jump(measureKeyframe, !1);
  }
  measureEndState() {
    var _a2;
    const { element, name, unresolvedKeyframes } = this;
    if (!element || !element.current)
      return;
    const value = element.getValue(name);
    value && value.jump(this.measuredOrigin, !1);
    const finalKeyframeIndex = unresolvedKeyframes.length - 1, finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
    unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current)), finalKeyframe !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = finalKeyframe), !((_a2 = this.removedTransforms) === null || _a2 === void 0) && _a2.length && this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {
      element.getValue(unsetTransformName).set(unsetTransformValue);
    }), this.resolveNoneKeyframes();
  }
}
function isGenerator(type) {
  return typeof type == "function";
}
let now;
function clearTime() {
  now = void 0;
}
const time$1 = {
  now: () => (now === void 0 && time$1.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now()), now),
  set: (newTime) => {
    now = newTime, queueMicrotask(clearTime);
  }
}, isAnimatable = (value, name) => name === "zIndex" ? !1 : !!(typeof value == "number" || Array.isArray(value) || typeof value == "string" && // It's animatable if we have a string
(complex.test(value) || value === "0") && // And it contains numbers and/or colors
!value.startsWith("url("));
function hasKeyframesChanged(keyframes2) {
  const current = keyframes2[0];
  if (keyframes2.length === 1)
    return !0;
  for (let i2 = 0; i2 < keyframes2.length; i2++)
    if (keyframes2[i2] !== current)
      return !0;
}
function canAnimate(keyframes2, name, type, velocity) {
  const originKeyframe = keyframes2[0];
  if (originKeyframe === null)
    return !1;
  if (name === "display" || name === "visibility")
    return !0;
  const targetKeyframe = keyframes2[keyframes2.length - 1], isOriginAnimatable = isAnimatable(originKeyframe, name), isTargetAnimatable = isAnimatable(targetKeyframe, name);
  return !isOriginAnimatable || !isTargetAnimatable ? !1 : hasKeyframesChanged(keyframes2) || (type === "spring" || isGenerator(type)) && velocity;
}
const MAX_RESOLVE_DELAY = 40;
class BaseAnimation {
  constructor({ autoplay = !0, delay: delay2 = 0, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", ...options }) {
    this.isStopped = !1, this.hasAttemptedResolve = !1, this.createdAt = time$1.now(), this.options = {
      autoplay,
      delay: delay2,
      type,
      repeat,
      repeatDelay,
      repeatType,
      ...options
    }, this.updateFinishedPromise();
  }
  /**
   * This method uses the createdAt and resolvedAt to calculate the
   * animation startTime. *Ideally*, we would use the createdAt time as t=0
   * as the following frame would then be the first frame of the animation in
   * progress, which would feel snappier.
   *
   * However, if there's a delay (main thread work) between the creation of
   * the animation and the first commited frame, we prefer to use resolvedAt
   * to avoid a sudden jump into the animation.
   */
  calcStartTime() {
    return this.resolvedAt ? this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt : this.createdAt;
  }
  /**
   * A getter for resolved data. If keyframes are not yet resolved, accessing
   * this.resolved will synchronously flush all pending keyframe resolvers.
   * This is a deoptimisation, but at its worst still batches read/writes.
   */
  get resolved() {
    return !this._resolved && !this.hasAttemptedResolve && flushKeyframeResolvers(), this._resolved;
  }
  /**
   * A method to be called when the keyframes resolver completes. This method
   * will check if its possible to run the animation and, if not, skip it.
   * Otherwise, it will call initPlayback on the implementing class.
   */
  onKeyframesResolved(keyframes2, finalKeyframe) {
    this.resolvedAt = time$1.now(), this.hasAttemptedResolve = !0;
    const { name, type, velocity, delay: delay2, onComplete, onUpdate, isGenerator: isGenerator2 } = this.options;
    if (!isGenerator2 && !canAnimate(keyframes2, name, type, velocity))
      if (delay2)
        this.options.duration = 0;
      else {
        onUpdate?.(getFinalKeyframe(keyframes2, this.options, finalKeyframe)), onComplete?.(), this.resolveFinishedPromise();
        return;
      }
    const resolvedAnimation = this.initPlayback(keyframes2, finalKeyframe);
    resolvedAnimation !== !1 && (this._resolved = {
      keyframes: keyframes2,
      finalKeyframe,
      ...resolvedAnimation
    }, this.onPostResolved());
  }
  onPostResolved() {
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(resolve, reject) {
    return this.currentFinishedPromise.then(resolve, reject);
  }
  flatten() {
    this.options.type = "keyframes", this.options.ease = "linear";
  }
  updateFinishedPromise() {
    this.currentFinishedPromise = new Promise((resolve) => {
      this.resolveFinishedPromise = resolve;
    });
  }
}
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}
const velocitySampleDuration = 5;
function calcGeneratorVelocity(resolveValue, t2, current) {
  const prevT = Math.max(t2 - velocitySampleDuration, 0);
  return velocityPerSecond(current - resolveValue(prevT), t2 - prevT);
}
const safeMin = 1e-3, minDuration = 0.01, maxDuration$1 = 10, minDamping = 0.05, maxDamping = 1;
function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1 }) {
  let envelope, derivative, dampingRatio = 1 - bounce;
  dampingRatio = clamp(minDamping, maxDamping, dampingRatio), duration = clamp(minDuration, maxDuration$1, millisecondsToSeconds(duration)), dampingRatio < 1 ? (envelope = (undampedFreq2) => {
    const exponentialDecay = undampedFreq2 * dampingRatio, delta = exponentialDecay * duration, a2 = exponentialDecay - velocity, b2 = calcAngularFreq(undampedFreq2, dampingRatio), c = Math.exp(-delta);
    return safeMin - a2 / b2 * c;
  }, derivative = (undampedFreq2) => {
    const delta = undampedFreq2 * dampingRatio * duration, d2 = delta * velocity + velocity, e2 = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration, f2 = Math.exp(-delta), g = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
    return (-envelope(undampedFreq2) + safeMin > 0 ? -1 : 1) * ((d2 - e2) * f2) / g;
  }) : (envelope = (undampedFreq2) => {
    const a2 = Math.exp(-undampedFreq2 * duration), b2 = (undampedFreq2 - velocity) * duration + 1;
    return -safeMin + a2 * b2;
  }, derivative = (undampedFreq2) => {
    const a2 = Math.exp(-undampedFreq2 * duration), b2 = (velocity - undampedFreq2) * (duration * duration);
    return a2 * b2;
  });
  const initialGuess = 5 / duration, undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  if (duration = secondsToMilliseconds(duration), isNaN(undampedFreq))
    return {
      stiffness: 100,
      damping: 10,
      duration
    };
  {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
const rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i2 = 1; i2 < rootIterations; i2++)
    result = result - envelope(result) / derivative(result);
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}
const durationKeys = ["duration", "bounce"], physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys2) {
  return keys2.some((key) => options[key] !== void 0);
}
function getSpringOptions(options) {
  let springOptions = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: !1,
    ...options
  };
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    const derived = findSpring(options);
    springOptions = {
      ...springOptions,
      ...derived,
      mass: 1
    }, springOptions.isResolvedFromDuration = !0;
  }
  return springOptions;
}
function spring({ keyframes: keyframes2, restDelta, restSpeed, ...options }) {
  const origin = keyframes2[0], target = keyframes2[keyframes2.length - 1], state = { done: !1, value: origin }, { stiffness, damping, mass, duration, velocity, isResolvedFromDuration } = getSpringOptions({
    ...options,
    velocity: -millisecondsToSeconds(options.velocity || 0)
  }), initialVelocity = velocity || 0, dampingRatio = damping / (2 * Math.sqrt(stiffness * mass)), initialDelta = target - origin, undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass)), isGranularScale = Math.abs(initialDelta) < 5;
  restSpeed || (restSpeed = isGranularScale ? 0.01 : 2), restDelta || (restDelta = isGranularScale ? 5e-3 : 0.5);
  let resolveSpring;
  if (dampingRatio < 1) {
    const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
    resolveSpring = (t2) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t2) + initialDelta * Math.cos(angularFreq * t2));
    };
  } else if (dampingRatio === 1)
    resolveSpring = (t2) => target - Math.exp(-undampedAngularFreq * t2) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t2);
  else {
    const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
    resolveSpring = (t2) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2), freqForT = Math.min(dampedAngularFreq * t2, 300);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
    };
  }
  return {
    calculatedDuration: isResolvedFromDuration && duration || null,
    next: (t2) => {
      const current = resolveSpring(t2);
      if (isResolvedFromDuration)
        state.done = t2 >= duration;
      else {
        let currentVelocity = 0;
        dampingRatio < 1 && (currentVelocity = t2 === 0 ? secondsToMilliseconds(initialVelocity) : calcGeneratorVelocity(resolveSpring, t2, current));
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed, isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      }
      return state.value = state.done ? target : current, state;
    }
  };
}
function inertia({ keyframes: keyframes2, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min: min2, max: max2, restDelta = 0.5, restSpeed }) {
  const origin = keyframes2[0], state = {
    done: !1,
    value: origin
  }, isOutOfBounds = (v) => min2 !== void 0 && v < min2 || max2 !== void 0 && v > max2, nearestBoundary = (v) => min2 === void 0 ? max2 : max2 === void 0 || Math.abs(min2 - v) < Math.abs(max2 - v) ? min2 : max2;
  let amplitude = power * velocity;
  const ideal = origin + amplitude, target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  target !== ideal && (amplitude = target - origin);
  const calcDelta = (t2) => -amplitude * Math.exp(-t2 / timeConstant), calcLatest = (t2) => target + calcDelta(t2), applyFriction = (t2) => {
    const delta = calcDelta(t2), latest = calcLatest(t2);
    state.done = Math.abs(delta) <= restDelta, state.value = state.done ? target : latest;
  };
  let timeReachedBoundary, spring$1;
  const checkCatchBoundary = (t2) => {
    isOutOfBounds(state.value) && (timeReachedBoundary = t2, spring$1 = spring({
      keyframes: [state.value, nearestBoundary(state.value)],
      velocity: calcGeneratorVelocity(calcLatest, t2, state.value),
      // TODO: This should be passing * 1000
      damping: bounceDamping,
      stiffness: bounceStiffness,
      restDelta,
      restSpeed
    }));
  };
  return checkCatchBoundary(0), {
    calculatedDuration: null,
    next: (t2) => {
      let hasUpdatedFrame = !1;
      return !spring$1 && timeReachedBoundary === void 0 && (hasUpdatedFrame = !0, applyFriction(t2), checkCatchBoundary(t2)), timeReachedBoundary !== void 0 && t2 >= timeReachedBoundary ? spring$1.next(t2 - timeReachedBoundary) : (!hasUpdatedFrame && applyFriction(t2), state);
    }
  };
}
const easeIn = /* @__PURE__ */ cubicBezier(0.42, 0, 1, 1), easeOut = /* @__PURE__ */ cubicBezier(0, 0, 0.58, 1), easeInOut = /* @__PURE__ */ cubicBezier(0.42, 0, 0.58, 1), isEasingArray = (ease2) => Array.isArray(ease2) && typeof ease2[0] != "number", isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] == "number", easingLookup = {
  linear: noop$2,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate
}, easingDefinitionToFunction = (definition) => {
  if (isBezierDefinition(definition)) {
    invariant(definition.length === 4);
    const [x1, y1, x2, y2] = definition;
    return cubicBezier(x1, y1, x2, y2);
  } else if (typeof definition == "string")
    return invariant(easingLookup[definition] !== void 0), easingLookup[definition];
  return definition;
}, combineFunctions = (a2, b2) => (v) => b2(a2(v)), pipe = (...transformers) => transformers.reduce(combineFunctions), progress = (from, to, value) => {
  const toFromDifference = to - from;
  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
}, mixNumber$1 = (from, to, progress2) => from + (to - from) * progress2;
function hueToRgb(p2, q, t2) {
  return t2 < 0 && (t2 += 1), t2 > 1 && (t2 -= 1), t2 < 1 / 6 ? p2 + (q - p2) * 6 * t2 : t2 < 1 / 2 ? q : t2 < 2 / 3 ? p2 + (q - p2) * (2 / 3 - t2) * 6 : p2;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360, saturation /= 100, lightness /= 100;
  let red = 0, green = 0, blue2 = 0;
  if (!saturation)
    red = green = blue2 = lightness;
  else {
    const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation, p2 = 2 * lightness - q;
    red = hueToRgb(p2, q, hue + 1 / 3), green = hueToRgb(p2, q, hue), blue2 = hueToRgb(p2, q, hue - 1 / 3);
  }
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue2 * 255),
    alpha: alpha2
  };
}
function mixImmediate(a2, b2) {
  return (p2) => p2 > 0 ? b2 : a2;
}
const mixLinearColor = (from, to, v) => {
  const fromExpo = from * from, expo = v * (to * to - fromExpo) + fromExpo;
  return expo < 0 ? 0 : Math.sqrt(expo);
}, colorTypes = [hex, rgba, hsla], getColorType = (v) => colorTypes.find((type) => type.test(v));
function asRGBA(color2) {
  const type = getColorType(color2);
  if (!type)
    return !1;
  let model = type.parse(color2);
  return type === hsla && (model = hslaToRgba(model)), model;
}
const mixColor = (from, to) => {
  const fromRGBA = asRGBA(from), toRGBA = asRGBA(to);
  if (!fromRGBA || !toRGBA)
    return mixImmediate(from, to);
  const blended = { ...fromRGBA };
  return (v) => (blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v), blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v), blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v), blended.alpha = mixNumber$1(fromRGBA.alpha, toRGBA.alpha, v), rgba.transform(blended));
}, invisibleValues = /* @__PURE__ */ new Set(["none", "hidden"]);
function mixVisibility(origin, target) {
  return invisibleValues.has(origin) ? (p2) => p2 <= 0 ? origin : target : (p2) => p2 >= 1 ? target : origin;
}
function mixNumber(a2, b2) {
  return (p2) => mixNumber$1(a2, b2, p2);
}
function getMixer(a2) {
  return typeof a2 == "number" ? mixNumber : typeof a2 == "string" ? isCSSVariableToken(a2) ? mixImmediate : color.test(a2) ? mixColor : mixComplex : Array.isArray(a2) ? mixArray : typeof a2 == "object" ? color.test(a2) ? mixColor : mixObject : mixImmediate;
}
function mixArray(a2, b2) {
  const output = [...a2], numValues = output.length, blendValue = a2.map((v, i2) => getMixer(v)(v, b2[i2]));
  return (p2) => {
    for (let i2 = 0; i2 < numValues; i2++)
      output[i2] = blendValue[i2](p2);
    return output;
  };
}
function mixObject(a2, b2) {
  const output = { ...a2, ...b2 }, blendValue = {};
  for (const key in output)
    a2[key] !== void 0 && b2[key] !== void 0 && (blendValue[key] = getMixer(a2[key])(a2[key], b2[key]));
  return (v) => {
    for (const key in blendValue)
      output[key] = blendValue[key](v);
    return output;
  };
}
function matchOrder(origin, target) {
  var _a2;
  const orderedOrigin = [], pointers = { color: 0, var: 0, number: 0 };
  for (let i2 = 0; i2 < target.values.length; i2++) {
    const type = target.types[i2], originIndex = origin.indexes[type][pointers[type]], originValue = (_a2 = origin.values[originIndex]) !== null && _a2 !== void 0 ? _a2 : 0;
    orderedOrigin[i2] = originValue, pointers[type]++;
  }
  return orderedOrigin;
}
const mixComplex = (origin, target) => {
  const template = complex.createTransformer(target), originStats = analyseComplexValue(origin), targetStats = analyseComplexValue(target);
  return originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length ? invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length ? mixVisibility(origin, target) : pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template) : mixImmediate(origin, target);
};
function mix(from, to, p2) {
  return typeof from == "number" && typeof to == "number" && typeof p2 == "number" ? mixNumber$1(from, to, p2) : getMixer(from)(from, to);
}
function createMixers(output, ease2, customMixer) {
  const mixers = [], mixerFactory = customMixer || mix, numMixers = output.length - 1;
  for (let i2 = 0; i2 < numMixers; i2++) {
    let mixer = mixerFactory(output[i2], output[i2 + 1]);
    if (ease2) {
      const easingFunction = Array.isArray(ease2) ? ease2[i2] || noop$2 : ease2;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function interpolate(input, output, { clamp: isClamp = !0, ease: ease2, mixer } = {}) {
  const inputLength = input.length;
  if (invariant(inputLength === output.length), inputLength === 1)
    return () => output[0];
  if (inputLength === 2 && input[0] === input[1])
    return () => output[1];
  input[0] > input[inputLength - 1] && (input = [...input].reverse(), output = [...output].reverse());
  const mixers = createMixers(output, ease2, mixer), numMixers = mixers.length, interpolator = (v) => {
    let i2 = 0;
    if (numMixers > 1)
      for (; i2 < input.length - 2 && !(v < input[i2 + 1]); i2++)
        ;
    const progressInRange = progress(input[i2], input[i2 + 1], v);
    return mixers[i2](progressInRange);
  };
  return isClamp ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v)) : interpolator;
}
function fillOffset(offset, remaining) {
  const min2 = offset[offset.length - 1];
  for (let i2 = 1; i2 <= remaining; i2++) {
    const offsetProgress = progress(0, remaining, i2);
    offset.push(mixNumber$1(min2, 1, offsetProgress));
  }
}
function defaultOffset(arr) {
  const offset = [0];
  return fillOffset(offset, arr.length - 1), offset;
}
function convertOffsetToTimes(offset, duration) {
  return offset.map((o2) => o2 * duration);
}
function defaultEasing(values, easing) {
  return values.map(() => easing || easeInOut).splice(0, values.length - 1);
}
function keyframes({ duration = 300, keyframes: keyframeValues, times, ease: ease2 = "easeInOut" }) {
  const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2), state = {
    done: !1,
    value: keyframeValues[0]
  }, absoluteTimes = convertOffsetToTimes(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
    duration
  ), mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
    ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
  });
  return {
    calculatedDuration: duration,
    next: (t2) => (state.value = mapTimeToKeyframe(t2), state.done = t2 >= duration, state)
  };
}
const maxGeneratorDuration = 2e4;
function calcGeneratorDuration(generator) {
  let duration = 0;
  const timeStep = 50;
  let state = generator.next(duration);
  for (; !state.done && duration < maxGeneratorDuration; )
    duration += timeStep, state = generator.next(duration);
  return duration >= maxGeneratorDuration ? 1 / 0 : duration;
}
const frameloopDriver = (update) => {
  const passTimestamp = ({ timestamp }) => update(timestamp);
  return {
    start: () => frame.update(passTimestamp, !0),
    stop: () => cancelFrame(passTimestamp),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => frameData.isProcessing ? frameData.timestamp : time$1.now()
  };
}, generators = {
  decay: inertia,
  inertia,
  tween: keyframes,
  keyframes,
  spring
}, percentToProgress = (percent2) => percent2 / 100;
class MainThreadAnimation extends BaseAnimation {
  constructor(options) {
    super(options), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => {
      if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
        return;
      this.teardown();
      const { onStop } = this.options;
      onStop && onStop();
    };
    const { name, motionValue: motionValue2, element, keyframes: keyframes2 } = this.options, KeyframeResolver$1 = element?.KeyframeResolver || KeyframeResolver, onResolved = (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);
    this.resolver = new KeyframeResolver$1(keyframes2, onResolved, name, motionValue2, element), this.resolver.scheduleResolve();
  }
  flatten() {
    super.flatten(), this._resolved && Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));
  }
  initPlayback(keyframes$1) {
    const { type = "keyframes", repeat = 0, repeatDelay = 0, repeatType, velocity = 0 } = this.options, generatorFactory = isGenerator(type) ? type : generators[type] || keyframes;
    let mapPercentToKeyframes, mirroredGenerator;
    generatorFactory !== keyframes && typeof keyframes$1[0] != "number" && (mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1])), keyframes$1 = [0, 100]);
    const generator = generatorFactory({ ...this.options, keyframes: keyframes$1 });
    repeatType === "mirror" && (mirroredGenerator = generatorFactory({
      ...this.options,
      keyframes: [...keyframes$1].reverse(),
      velocity: -velocity
    })), generator.calculatedDuration === null && (generator.calculatedDuration = calcGeneratorDuration(generator));
    const { calculatedDuration } = generator, resolvedDuration = calculatedDuration + repeatDelay, totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;
    return {
      generator,
      mirroredGenerator,
      mapPercentToKeyframes,
      calculatedDuration,
      resolvedDuration,
      totalDuration
    };
  }
  onPostResolved() {
    const { autoplay = !0 } = this.options;
    this.play(), this.pendingPlayState === "paused" || !autoplay ? this.pause() : this.state = this.pendingPlayState;
  }
  tick(timestamp, sample = !1) {
    const { resolved } = this;
    if (!resolved) {
      const { keyframes: keyframes3 } = this.options;
      return { done: !0, value: keyframes3[keyframes3.length - 1] };
    }
    const { finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes: keyframes2, calculatedDuration, totalDuration, resolvedDuration } = resolved;
    if (this.startTime === null)
      return generator.next(0);
    const { delay: delay2, repeat, repeatType, repeatDelay, onUpdate } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, timestamp) : this.speed < 0 && (this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime)), sample ? this.currentTime = timestamp : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(timestamp - this.startTime) * this.speed;
    const timeWithoutDelay = this.currentTime - delay2 * (this.speed >= 0 ? 1 : -1), isInDelayPhase = this.speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
    this.currentTime = Math.max(timeWithoutDelay, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = totalDuration);
    let elapsed = this.currentTime, frameGenerator = generator;
    if (repeat) {
      const progress2 = Math.min(this.currentTime, totalDuration) / resolvedDuration;
      let currentIteration = Math.floor(progress2), iterationProgress = progress2 % 1;
      !iterationProgress && progress2 >= 1 && (iterationProgress = 1), iterationProgress === 1 && currentIteration--, currentIteration = Math.min(currentIteration, repeat + 1), !!(currentIteration % 2) && (repeatType === "reverse" ? (iterationProgress = 1 - iterationProgress, repeatDelay && (iterationProgress -= repeatDelay / resolvedDuration)) : repeatType === "mirror" && (frameGenerator = mirroredGenerator)), elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;
    }
    const state = isInDelayPhase ? { done: !1, value: keyframes2[0] } : frameGenerator.next(elapsed);
    mapPercentToKeyframes && (state.value = mapPercentToKeyframes(state.value));
    let { done } = state;
    !isInDelayPhase && calculatedDuration !== null && (done = this.speed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0);
    const isAnimationFinished = this.holdTime === null && (this.state === "finished" || this.state === "running" && done);
    return isAnimationFinished && finalKeyframe !== void 0 && (state.value = getFinalKeyframe(keyframes2, this.options, finalKeyframe)), onUpdate && onUpdate(state.value), isAnimationFinished && this.finish(), state;
  }
  get duration() {
    const { resolved } = this;
    return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;
  }
  get time() {
    return millisecondsToSeconds(this.currentTime);
  }
  set time(newTime) {
    newTime = secondsToMilliseconds(newTime), this.currentTime = newTime, this.holdTime !== null || this.speed === 0 ? this.holdTime = newTime : this.driver && (this.startTime = this.driver.now() - newTime / this.speed);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(newSpeed) {
    const hasChanged = this.playbackSpeed !== newSpeed;
    this.playbackSpeed = newSpeed, hasChanged && (this.time = millisecondsToSeconds(this.currentTime));
  }
  play() {
    if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) {
      this.pendingPlayState = "running";
      return;
    }
    if (this.isStopped)
      return;
    const { driver = frameloopDriver, onPlay, startTime } = this.options;
    this.driver || (this.driver = driver((timestamp) => this.tick(timestamp))), onPlay && onPlay();
    const now2 = this.driver.now();
    this.holdTime !== null ? this.startTime = now2 - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = now2) : this.startTime = startTime ?? this.calcStartTime(), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    var _a2;
    if (!this._resolved) {
      this.pendingPlayState = "paused";
      return;
    }
    this.state = "paused", this.holdTime = (_a2 = this.currentTime) !== null && _a2 !== void 0 ? _a2 : 0;
  }
  complete() {
    this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null;
  }
  finish() {
    this.teardown(), this.state = "finished";
    const { onComplete } = this.options;
    onComplete && onComplete();
  }
  cancel() {
    this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise();
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel();
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(time2) {
    return this.startTime = 0, this.tick(time2, !0);
  }
}
const acceleratedValues = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved
  // or until we implement support for linear() easing.
  // "background-color"
]), resolution = 10, generateLinearEasing = (easing, duration) => {
  let points = "";
  const numPoints = Math.max(Math.round(duration / resolution), 2);
  for (let i2 = 0; i2 < numPoints; i2++)
    points += easing(progress(0, numPoints - 1, i2)) + ", ";
  return `linear(${points.substring(0, points.length - 2)})`;
};
function memo(callback) {
  let result;
  return () => (result === void 0 && (result = callback()), result);
}
const supportsFlags = {
  linearEasing: void 0
};
function memoSupports(callback, supportsFlag) {
  const memoized = memo(callback);
  return () => {
    var _a2;
    return (_a2 = supportsFlags[supportsFlag]) !== null && _a2 !== void 0 ? _a2 : memoized();
  };
}
const supportsLinearEasing = /* @__PURE__ */ memoSupports(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch {
    return !1;
  }
  return !0;
}, "linearEasing");
function isWaapiSupportedEasing(easing) {
  return !!(typeof easing == "function" && supportsLinearEasing() || !easing || typeof easing == "string" && (easing in supportedWaapiEasing || supportsLinearEasing()) || isBezierDefinition(easing) || Array.isArray(easing) && easing.every(isWaapiSupportedEasing));
}
const cubicBezierAsString = ([a2, b2, c, d2]) => `cubic-bezier(${a2}, ${b2}, ${c}, ${d2})`, supportedWaapiEasing = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ cubicBezierAsString([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ cubicBezierAsString([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
};
function mapEasingToNativeEasing(easing, duration) {
  if (easing)
    return typeof easing == "function" && supportsLinearEasing() ? generateLinearEasing(easing, duration) : isBezierDefinition(easing) ? cubicBezierAsString(easing) : Array.isArray(easing) ? easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration) || supportedWaapiEasing.easeOut) : supportedWaapiEasing[easing];
}
function startWaapiAnimation(element, valueName, keyframes2, { delay: delay2 = 0, duration = 300, repeat = 0, repeatType = "loop", ease: ease2 = "easeInOut", times } = {}) {
  const keyframeOptions = { [valueName]: keyframes2 };
  times && (keyframeOptions.offset = times);
  const easing = mapEasingToNativeEasing(ease2, duration);
  return Array.isArray(easing) && (keyframeOptions.easing = easing), element.animate(keyframeOptions, {
    delay: delay2,
    duration,
    easing: Array.isArray(easing) ? "linear" : easing,
    fill: "both",
    iterations: repeat + 1,
    direction: repeatType === "reverse" ? "alternate" : "normal"
  });
}
function attachTimeline(animation, timeline) {
  animation.timeline = timeline, animation.onfinish = null;
}
const supportsWaapi = /* @__PURE__ */ memo(() => Object.hasOwnProperty.call(Element.prototype, "animate")), sampleDelta = 10, maxDuration = 2e4;
function requiresPregeneratedKeyframes(options) {
  return isGenerator(options.type) || options.type === "spring" || !isWaapiSupportedEasing(options.ease);
}
function pregenerateKeyframes(keyframes2, options) {
  const sampleAnimation = new MainThreadAnimation({
    ...options,
    keyframes: keyframes2,
    repeat: 0,
    delay: 0,
    isGenerator: !0
  });
  let state = { done: !1, value: keyframes2[0] };
  const pregeneratedKeyframes = [];
  let t2 = 0;
  for (; !state.done && t2 < maxDuration; )
    state = sampleAnimation.sample(t2), pregeneratedKeyframes.push(state.value), t2 += sampleDelta;
  return {
    times: void 0,
    keyframes: pregeneratedKeyframes,
    duration: t2 - sampleDelta,
    ease: "linear"
  };
}
const unsupportedEasingFunctions = {
  anticipate,
  backInOut,
  circInOut
};
function isUnsupportedEase(key) {
  return key in unsupportedEasingFunctions;
}
class AcceleratedAnimation extends BaseAnimation {
  constructor(options) {
    super(options);
    const { name, motionValue: motionValue2, element, keyframes: keyframes2 } = this.options;
    this.resolver = new DOMKeyframesResolver(keyframes2, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue2, element), this.resolver.scheduleResolve();
  }
  initPlayback(keyframes2, finalKeyframe) {
    var _a2;
    let { duration = 300, times, ease: ease2, type, motionValue: motionValue2, name, startTime } = this.options;
    if (!(!((_a2 = motionValue2.owner) === null || _a2 === void 0) && _a2.current))
      return !1;
    if (typeof ease2 == "string" && supportsLinearEasing() && isUnsupportedEase(ease2) && (ease2 = unsupportedEasingFunctions[ease2]), requiresPregeneratedKeyframes(this.options)) {
      const { onComplete, onUpdate, motionValue: motionValue3, element, ...options } = this.options, pregeneratedAnimation = pregenerateKeyframes(keyframes2, options);
      keyframes2 = pregeneratedAnimation.keyframes, keyframes2.length === 1 && (keyframes2[1] = keyframes2[0]), duration = pregeneratedAnimation.duration, times = pregeneratedAnimation.times, ease2 = pregeneratedAnimation.ease, type = "keyframes";
    }
    const animation = startWaapiAnimation(motionValue2.owner.current, name, keyframes2, { ...this.options, duration, times, ease: ease2 });
    return animation.startTime = startTime ?? this.calcStartTime(), this.pendingTimeline ? (attachTimeline(animation, this.pendingTimeline), this.pendingTimeline = void 0) : animation.onfinish = () => {
      const { onComplete } = this.options;
      motionValue2.set(getFinalKeyframe(keyframes2, this.options, finalKeyframe)), onComplete && onComplete(), this.cancel(), this.resolveFinishedPromise();
    }, {
      animation,
      duration,
      times,
      type,
      ease: ease2,
      keyframes: keyframes2
    };
  }
  get duration() {
    const { resolved } = this;
    if (!resolved)
      return 0;
    const { duration } = resolved;
    return millisecondsToSeconds(duration);
  }
  get time() {
    const { resolved } = this;
    if (!resolved)
      return 0;
    const { animation } = resolved;
    return millisecondsToSeconds(animation.currentTime || 0);
  }
  set time(newTime) {
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation } = resolved;
    animation.currentTime = secondsToMilliseconds(newTime);
  }
  get speed() {
    const { resolved } = this;
    if (!resolved)
      return 1;
    const { animation } = resolved;
    return animation.playbackRate;
  }
  set speed(newSpeed) {
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation } = resolved;
    animation.playbackRate = newSpeed;
  }
  get state() {
    const { resolved } = this;
    if (!resolved)
      return "idle";
    const { animation } = resolved;
    return animation.playState;
  }
  get startTime() {
    const { resolved } = this;
    if (!resolved)
      return null;
    const { animation } = resolved;
    return animation.startTime;
  }
  /**
   * Replace the default DocumentTimeline with another AnimationTimeline.
   * Currently used for scroll animations.
   */
  attachTimeline(timeline) {
    if (!this._resolved)
      this.pendingTimeline = timeline;
    else {
      const { resolved } = this;
      if (!resolved)
        return noop$2;
      const { animation } = resolved;
      attachTimeline(animation, timeline);
    }
    return noop$2;
  }
  play() {
    if (this.isStopped)
      return;
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation } = resolved;
    animation.playState === "finished" && this.updateFinishedPromise(), animation.play();
  }
  pause() {
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation } = resolved;
    animation.pause();
  }
  stop() {
    if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
      return;
    this.resolveFinishedPromise(), this.updateFinishedPromise();
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation, keyframes: keyframes2, duration, type, ease: ease2, times } = resolved;
    if (animation.playState === "idle" || animation.playState === "finished")
      return;
    if (this.time) {
      const { motionValue: motionValue2, onUpdate, onComplete, element, ...options } = this.options, sampleAnimation = new MainThreadAnimation({
        ...options,
        keyframes: keyframes2,
        duration,
        type,
        ease: ease2,
        times,
        isGenerator: !0
      }), sampleTime = secondsToMilliseconds(this.time);
      motionValue2.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);
    }
    const { onStop } = this.options;
    onStop && onStop(), this.cancel();
  }
  complete() {
    const { resolved } = this;
    resolved && resolved.animation.finish();
  }
  cancel() {
    const { resolved } = this;
    resolved && resolved.animation.cancel();
  }
  static supports(options) {
    const { motionValue: motionValue2, name, repeatDelay, repeatType, damping, type } = options;
    return supportsWaapi() && name && acceleratedValues.has(name) && motionValue2 && motionValue2.owner && motionValue2.owner.current instanceof HTMLElement && /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !motionValue2.owner.getProps().onUpdate && !repeatDelay && repeatType !== "mirror" && damping !== 0 && type !== "inertia";
  }
}
const supportsScrollTimeline = memo(() => window.ScrollTimeline !== void 0);
class GroupPlaybackControls {
  constructor(animations2) {
    this.stop = () => this.runAll("stop"), this.animations = animations2.filter(Boolean);
  }
  then(onResolve, onReject) {
    return Promise.all(this.animations).then(onResolve).catch(onReject);
  }
  /**
   * TODO: Filter out cancelled or stopped animations before returning
   */
  getAll(propName) {
    return this.animations[0][propName];
  }
  setAll(propName, newValue) {
    for (let i2 = 0; i2 < this.animations.length; i2++)
      this.animations[i2][propName] = newValue;
  }
  attachTimeline(timeline, fallback) {
    const subscriptions = this.animations.map((animation) => supportsScrollTimeline() && animation.attachTimeline ? animation.attachTimeline(timeline) : fallback(animation));
    return () => {
      subscriptions.forEach((cancel, i2) => {
        cancel && cancel(), this.animations[i2].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(time2) {
    this.setAll("time", time2);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(speed) {
    this.setAll("speed", speed);
  }
  get startTime() {
    return this.getAll("startTime");
  }
  get duration() {
    let max2 = 0;
    for (let i2 = 0; i2 < this.animations.length; i2++)
      max2 = Math.max(max2, this.animations[i2].duration);
    return max2;
  }
  runAll(methodName) {
    this.animations.forEach((controls) => controls[methodName]());
  }
  flatten() {
    this.runAll("flatten");
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
}
function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {
  return !!Object.keys(transition).length;
}
const animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {
  const valueTransition = getValueTransition$1(transition, name) || {}, delay2 = valueTransition.delay || transition.delay || 0;
  let { elapsed = 0 } = transition;
  elapsed = elapsed - secondsToMilliseconds(delay2);
  let options = {
    keyframes: Array.isArray(target) ? target : [null, target],
    ease: "easeOut",
    velocity: value.getVelocity(),
    ...valueTransition,
    delay: -elapsed,
    onUpdate: (v) => {
      value.set(v), valueTransition.onUpdate && valueTransition.onUpdate(v);
    },
    onComplete: () => {
      onComplete(), valueTransition.onComplete && valueTransition.onComplete();
    },
    name,
    motionValue: value,
    element: isHandoff ? void 0 : element
  };
  isTransitionDefined(valueTransition) || (options = {
    ...options,
    ...getDefaultTransition(name, options)
  }), options.duration && (options.duration = secondsToMilliseconds(options.duration)), options.repeatDelay && (options.repeatDelay = secondsToMilliseconds(options.repeatDelay)), options.from !== void 0 && (options.keyframes[0] = options.from);
  let shouldSkip = !1;
  if ((options.type === !1 || options.duration === 0 && !options.repeatDelay) && (options.duration = 0, options.delay === 0 && (shouldSkip = !0)), shouldSkip && !isHandoff && value.get() !== void 0) {
    const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);
    if (finalKeyframe !== void 0)
      return frame.update(() => {
        options.onUpdate(finalKeyframe), options.onComplete();
      }), new GroupPlaybackControls([]);
  }
  return !isHandoff && AcceleratedAnimation.supports(options) ? new AcceleratedAnimation(options) : new MainThreadAnimation(options);
}, isCustomValue = (v) => !!(v && typeof v == "object" && v.mix && v.toValue), resolveFinalValueInKeyframes = (v) => isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
function addUniqueItem(arr, item) {
  arr.indexOf(item) === -1 && arr.push(item);
}
function removeItem(arr, item) {
  const index2 = arr.indexOf(item);
  index2 > -1 && arr.splice(index2, 1);
}
class SubscriptionManager {
  constructor() {
    this.subscriptions = [];
  }
  add(handler) {
    return addUniqueItem(this.subscriptions, handler), () => removeItem(this.subscriptions, handler);
  }
  notify(a2, b2, c) {
    const numSubscriptions = this.subscriptions.length;
    if (numSubscriptions)
      if (numSubscriptions === 1)
        this.subscriptions[0](a2, b2, c);
      else
        for (let i2 = 0; i2 < numSubscriptions; i2++) {
          const handler = this.subscriptions[i2];
          handler && handler(a2, b2, c);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const MAX_VELOCITY_DELTA = 30, isFloat = (value) => !isNaN(parseFloat(value));
class MotionValue {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(init, options = {}) {
    this.version = "11.11.17", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (v, render = !0) => {
      const currentTime = time$1.now();
      this.updatedAt !== currentTime && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(v), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), render && this.events.renderRequest && this.events.renderRequest.notify(this.current);
    }, this.hasAnimated = !1, this.setCurrent(init), this.owner = options.owner;
  }
  setCurrent(current) {
    this.current = current, this.updatedAt = time$1.now(), this.canTrackVelocity === null && current !== void 0 && (this.canTrackVelocity = isFloat(this.current));
  }
  setPrevFrameValue(prevFrameValue = this.current) {
    this.prevFrameValue = prevFrameValue, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(subscription) {
    return this.on("change", subscription);
  }
  on(eventName, callback) {
    this.events[eventName] || (this.events[eventName] = new SubscriptionManager());
    const unsubscribe = this.events[eventName].add(callback);
    return eventName === "change" ? () => {
      unsubscribe(), frame.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : unsubscribe;
  }
  clearListeners() {
    for (const eventManagers in this.events)
      this.events[eventManagers].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(passiveEffect, stopPassiveEffect) {
    this.passiveEffect = passiveEffect, this.stopPassiveEffect = stopPassiveEffect;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(v, render = !0) {
    !render || !this.passiveEffect ? this.updateAndNotify(v, render) : this.passiveEffect(v, this.updateAndNotify);
  }
  setWithVelocity(prev, current, delta) {
    this.set(current), this.prev = void 0, this.prevFrameValue = prev, this.prevUpdatedAt = this.updatedAt - delta;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(v, endAnimation = !0) {
    this.updateAndNotify(v), this.prev = v, this.prevUpdatedAt = this.prevFrameValue = void 0, endAnimation && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const currentTime = time$1.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA)
      return 0;
    const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
    return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(startAnimation) {
    return this.stop(), new Promise((resolve) => {
      this.hasAnimated = !0, this.animation = startAnimation(resolve), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function motionValue(init, options) {
  return new MotionValue(init, options);
}
function setMotionValue(visualElement, key, value) {
  visualElement.hasValue(key) ? visualElement.getValue(key).set(value) : visualElement.addValue(key, motionValue(value));
}
function setTarget(visualElement, definition) {
  const resolved = resolveVariant(visualElement, definition);
  let { transitionEnd = {}, transition = {}, ...target } = resolved || {};
  target = { ...target, ...transitionEnd };
  for (const key in target) {
    const value = resolveFinalValueInKeyframes(target[key]);
    setMotionValue(visualElement, key, value);
  }
}
const camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), optimizedAppearDataId = "framerAppearId", optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
function getOptimisedAppearId(visualElement) {
  return visualElement.props[optimizedAppearDataAttribute];
}
const isMotionValue = (value) => !!(value && value.getVelocity);
function isWillChangeMotionValue(value) {
  return !!(isMotionValue(value) && value.add);
}
function addValueToWillChange(visualElement, key) {
  const willChange = visualElement.getValue("willChange");
  if (isWillChangeMotionValue(willChange))
    return willChange.add(key);
}
function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
  const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== !0;
  return needsAnimating[key] = !1, shouldBlock;
}
function animateTarget(visualElement, targetAndTransition, { delay: delay2 = 0, transitionOverride, type } = {}) {
  var _a2;
  let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;
  transitionOverride && (transition = transitionOverride);
  const animations2 = [], animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
  for (const key in target) {
    const value = visualElement.getValue(key, (_a2 = visualElement.latestValues[key]) !== null && _a2 !== void 0 ? _a2 : null), valueTarget = target[key];
    if (valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key))
      continue;
    const valueTransition = {
      delay: delay2,
      ...getValueTransition$1(transition || {}, key)
    };
    let isHandoff = !1;
    if (window.MotionHandoffAnimation) {
      const appearId = getOptimisedAppearId(visualElement);
      if (appearId) {
        const startTime = window.MotionHandoffAnimation(appearId, key, frame);
        startTime !== null && (valueTransition.startTime = startTime, isHandoff = !0);
      }
    }
    addValueToWillChange(visualElement, key), value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key) ? { type: !1 } : valueTransition, visualElement, isHandoff));
    const animation = value.animation;
    animation && animations2.push(animation);
  }
  return transitionEnd && Promise.all(animations2).then(() => {
    frame.update(() => {
      transitionEnd && setTarget(visualElement, transitionEnd);
    });
  }), animations2;
}
function animateVariant(visualElement, variant, options = {}) {
  var _a2;
  const resolved = resolveVariant(visualElement, variant, options.type === "exit" ? (_a2 = visualElement.presenceContext) === null || _a2 === void 0 ? void 0 : _a2.custom : void 0);
  let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
  options.transitionOverride && (transition = options.transitionOverride);
  const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve(), getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
    const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
  } : () => Promise.resolve(), { when } = transition;
  if (when) {
    const [first, last] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
    return first().then(() => last());
  } else
    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
}
function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
  const animations2 = [], maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren, generateStaggerDuration = staggerDirection === 1 ? (i2 = 0) => i2 * staggerChildren : (i2 = 0) => maxStaggerDuration - i2 * staggerChildren;
  return Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i2) => {
    child.notify("AnimationStart", variant), animations2.push(animateVariant(child, variant, {
      ...options,
      delay: delayChildren + generateStaggerDuration(i2)
    }).then(() => child.notify("AnimationComplete", variant)));
  }), Promise.all(animations2);
}
function sortByTreeOrder(a2, b2) {
  return a2.sortNodePosition(b2);
}
function animateVisualElement(visualElement, definition, options = {}) {
  visualElement.notify("AnimationStart", definition);
  let animation;
  if (Array.isArray(definition)) {
    const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));
    animation = Promise.all(animations2);
  } else if (typeof definition == "string")
    animation = animateVariant(visualElement, definition, options);
  else {
    const resolvedDefinition = typeof definition == "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
    animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
  }
  return animation.then(() => {
    visualElement.notify("AnimationComplete", definition);
  });
}
const numVariantProps = variantProps.length;
function getVariantContext(visualElement) {
  if (!visualElement)
    return;
  if (!visualElement.isControllingVariants) {
    const context2 = visualElement.parent ? getVariantContext(visualElement.parent) || {} : {};
    return visualElement.props.initial !== void 0 && (context2.initial = visualElement.props.initial), context2;
  }
  const context = {};
  for (let i2 = 0; i2 < numVariantProps; i2++) {
    const name = variantProps[i2], prop = visualElement.props[name];
    (isVariantLabel(prop) || prop === !1) && (context[name] = prop);
  }
  return context;
}
const reversePriorityOrder = [...variantPriorityOrder].reverse(), numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement) {
  return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));
}
function createAnimationState(visualElement) {
  let animate = animateList(visualElement), state = createState(), isInitialRender = !0;
  const buildResolvedTypeValues = (type) => (acc, definition) => {
    var _a2;
    const resolved = resolveVariant(visualElement, definition, type === "exit" ? (_a2 = visualElement.presenceContext) === null || _a2 === void 0 ? void 0 : _a2.custom : void 0);
    if (resolved) {
      const { transition, transitionEnd, ...target } = resolved;
      acc = { ...acc, ...target, ...transitionEnd };
    }
    return acc;
  };
  function setAnimateFunction(makeAnimator) {
    animate = makeAnimator(visualElement);
  }
  function animateChanges(changedActiveType) {
    const { props: props2 } = visualElement, context = getVariantContext(visualElement.parent) || {}, animations2 = [], removedKeys = /* @__PURE__ */ new Set();
    let encounteredKeys = {}, removedVariantIndex = 1 / 0;
    for (let i2 = 0; i2 < numAnimationTypes; i2++) {
      const type = reversePriorityOrder[i2], typeState = state[type], prop = props2[type] !== void 0 ? props2[type] : context[type], propIsVariant = isVariantLabel(prop), activeDelta = type === changedActiveType ? typeState.isActive : null;
      activeDelta === !1 && (removedVariantIndex = i2);
      let isInherited = prop === context[type] && prop !== props2[type] && propIsVariant;
      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount && (isInherited = !1), typeState.protectedKeys = { ...encounteredKeys }, // If it isn't active and hasn't *just* been set as inactive
      !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
      !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
      isAnimationControls(prop) || typeof prop == "boolean")
        continue;
      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
      i2 > removedVariantIndex && propIsVariant, handledRemovedValues = !1;
      const definitionList = Array.isArray(prop) ? prop : [prop];
      let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});
      activeDelta === !1 && (resolvedValues = {});
      const { prevResolvedValues = {} } = typeState, allKeys = {
        ...prevResolvedValues,
        ...resolvedValues
      }, markToAnimate = (key) => {
        shouldAnimateType = !0, removedKeys.has(key) && (handledRemovedValues = !0, removedKeys.delete(key)), typeState.needsAnimating[key] = !0;
        const motionValue2 = visualElement.getValue(key);
        motionValue2 && (motionValue2.liveStyle = !1);
      };
      for (const key in allKeys) {
        const next = resolvedValues[key], prev = prevResolvedValues[key];
        if (encounteredKeys.hasOwnProperty(key))
          continue;
        let valueHasChanged = !1;
        isKeyframesTarget(next) && isKeyframesTarget(prev) ? valueHasChanged = !shallowCompare(next, prev) : valueHasChanged = next !== prev, valueHasChanged ? next != null ? markToAnimate(key) : removedKeys.add(key) : next !== void 0 && removedKeys.has(key) ? markToAnimate(key) : typeState.protectedKeys[key] = !0;
      }
      typeState.prevProp = prop, typeState.prevResolvedValues = resolvedValues, typeState.isActive && (encounteredKeys = { ...encounteredKeys, ...resolvedValues }), isInitialRender && visualElement.blockInitialAnimation && (shouldAnimateType = !1), shouldAnimateType && (!(isInherited && variantDidChange) || handledRemovedValues) && animations2.push(...definitionList.map((animation) => ({
        animation,
        options: { type }
      })));
    }
    if (removedKeys.size) {
      const fallbackAnimation = {};
      removedKeys.forEach((key) => {
        const fallbackTarget = visualElement.getBaseTarget(key), motionValue2 = visualElement.getValue(key);
        motionValue2 && (motionValue2.liveStyle = !0), fallbackAnimation[key] = fallbackTarget ?? null;
      }), animations2.push({ animation: fallbackAnimation });
    }
    let shouldAnimate = !!animations2.length;
    return isInitialRender && (props2.initial === !1 || props2.initial === props2.animate) && !visualElement.manuallyAnimateOnMount && (shouldAnimate = !1), isInitialRender = !1, shouldAnimate ? animate(animations2) : Promise.resolve();
  }
  function setActive(type, isActive) {
    var _a2;
    if (state[type].isActive === isActive)
      return Promise.resolve();
    (_a2 = visualElement.variantChildren) === null || _a2 === void 0 || _a2.forEach((child) => {
      var _a3;
      return (_a3 = child.animationState) === null || _a3 === void 0 ? void 0 : _a3.setActive(type, isActive);
    }), state[type].isActive = isActive;
    const animations2 = animateChanges(type);
    for (const key in state)
      state[key].protectedKeys = {};
    return animations2;
  }
  return {
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: () => state,
    reset: () => {
      state = createState(), isInitialRender = !0;
    }
  };
}
function checkVariantsDidChange(prev, next) {
  return typeof next == "string" ? next !== prev : Array.isArray(next) ? !shallowCompare(next, prev) : !1;
}
function createTypeState(isActive = !1) {
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  return {
    animate: createTypeState(!0),
    whileInView: createTypeState(),
    whileHover: createTypeState(),
    whileTap: createTypeState(),
    whileDrag: createTypeState(),
    whileFocus: createTypeState(),
    exit: createTypeState()
  };
}
class Feature {
  constructor(node2) {
    this.isMounted = !1, this.node = node2;
  }
  update() {
  }
}
class AnimationFeature extends Feature {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(node2) {
    super(node2), node2.animationState || (node2.animationState = createAnimationState(node2));
  }
  updateAnimationControlsSubscription() {
    const { animate } = this.node.getProps();
    isAnimationControls(animate) && (this.unmountControls = animate.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate } = this.node.getProps(), { animate: prevAnimate } = this.node.prevProps || {};
    animate !== prevAnimate && this.updateAnimationControlsSubscription();
  }
  unmount() {
    var _a2;
    this.node.animationState.reset(), (_a2 = this.unmountControls) === null || _a2 === void 0 || _a2.call(this);
  }
}
let id$1 = 0;
class ExitAnimationFeature extends Feature {
  constructor() {
    super(...arguments), this.id = id$1++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent, onExitComplete } = this.node.presenceContext, { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || isPresent === prevIsPresent)
      return;
    const exitAnimation = this.node.animationState.setActive("exit", !isPresent);
    onExitComplete && !isPresent && exitAnimation.then(() => onExitComplete(this.id));
  }
  mount() {
    const { register } = this.node.presenceContext || {};
    register && (this.unmount = register(this.id));
  }
  unmount() {
  }
}
const animations = {
  animation: {
    Feature: AnimationFeature
  },
  exit: {
    Feature: ExitAnimationFeature
  }
}, isPrimaryPointer = (event) => event.pointerType === "mouse" ? typeof event.button != "number" || event.button <= 0 : event.isPrimary !== !1;
function extractEventInfo(event, pointType = "page") {
  return {
    point: {
      x: event[`${pointType}X`],
      y: event[`${pointType}Y`]
    }
  };
}
const addPointerInfo = (handler) => (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
function addDomEvent(target, eventName, handler, options = { passive: !0 }) {
  return target.addEventListener(eventName, handler, options), () => target.removeEventListener(eventName, handler);
}
function addPointerEvent(target, eventName, handler, options) {
  return addDomEvent(target, eventName, addPointerInfo(handler), options);
}
const distance = (a2, b2) => Math.abs(a2 - b2);
function distance2D(a2, b2) {
  const xDelta = distance(a2.x, b2.x), yDelta = distance(a2.y, b2.y);
  return Math.sqrt(xDelta ** 2 + yDelta ** 2);
}
class PanSession {
  constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = !1 } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const info2 = getPanInfo(this.lastMoveEventInfo, this.history), isPanStarted = this.startEvent !== null, isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= 3;
      if (!isPanStarted && !isDistancePastThreshold)
        return;
      const { point: point3 } = info2, { timestamp: timestamp2 } = frameData;
      this.history.push({ ...point3, timestamp: timestamp2 });
      const { onStart, onMove } = this.handlers;
      isPanStarted || (onStart && onStart(this.lastMoveEvent, info2), this.startEvent = this.lastMoveEvent), onMove && onMove(this.lastMoveEvent, info2);
    }, this.handlePointerMove = (event2, info2) => {
      this.lastMoveEvent = event2, this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint), frame.update(this.updatePoint, !0);
    }, this.handlePointerUp = (event2, info2) => {
      this.end();
      const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
      if (this.dragSnapToOrigin && resumeAnimation && resumeAnimation(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
      this.startEvent && onEnd && onEnd(event2, panInfo), onSessionEnd && onSessionEnd(event2, panInfo);
    }, !isPrimaryPointer(event))
      return;
    this.dragSnapToOrigin = dragSnapToOrigin, this.handlers = handlers, this.transformPagePoint = transformPagePoint, this.contextWindow = contextWindow || window;
    const info = extractEventInfo(event), initialInfo = transformPoint(info, this.transformPagePoint), { point: point2 } = initialInfo, { timestamp } = frameData;
    this.history = [{ ...point2, timestamp }];
    const { onSessionStart } = handlers;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history)), this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(handlers) {
    this.handlers = handlers;
  }
  end() {
    this.removeListeners && this.removeListeners(), cancelFrame(this.updatePoint);
  }
}
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a2, b2) {
  return { x: a2.x - b2.x, y: a2.y - b2.y };
}
function getPanInfo({ point: point2 }, history) {
  return {
    point: point2,
    delta: subtractPoint(point2, lastDevicePoint(history)),
    offset: subtractPoint(point2, startDevicePoint(history)),
    velocity: getVelocity(history, 0.1)
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity(history, timeDelta) {
  if (history.length < 2)
    return { x: 0, y: 0 };
  let i2 = history.length - 1, timestampedPoint = null;
  const lastPoint = lastDevicePoint(history);
  for (; i2 >= 0 && (timestampedPoint = history[i2], !(lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta))); )
    i2--;
  if (!timestampedPoint)
    return { x: 0, y: 0 };
  const time2 = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
  if (time2 === 0)
    return { x: 0, y: 0 };
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time2,
    y: (lastPoint.y - timestampedPoint.y) / time2
  };
  return currentVelocity.x === 1 / 0 && (currentVelocity.x = 0), currentVelocity.y === 1 / 0 && (currentVelocity.y = 0), currentVelocity;
}
function createLock(name) {
  let lock = null;
  return () => {
    const openLock = () => {
      lock = null;
    };
    return lock === null ? (lock = name, openLock) : !1;
  };
}
const globalHorizontalLock = createLock("dragHorizontal"), globalVerticalLock = createLock("dragVertical");
function getGlobalLock(drag2) {
  let lock = !1;
  if (drag2 === "y")
    lock = globalVerticalLock();
  else if (drag2 === "x")
    lock = globalHorizontalLock();
  else {
    const openHorizontal = globalHorizontalLock(), openVertical = globalVerticalLock();
    openHorizontal && openVertical ? lock = () => {
      openHorizontal(), openVertical();
    } : (openHorizontal && openHorizontal(), openVertical && openVertical());
  }
  return lock;
}
function isDragActive() {
  const openGestureLock = getGlobalLock(!0);
  return openGestureLock ? (openGestureLock(), !1) : !0;
}
function isRefObject(ref) {
  return ref && typeof ref == "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}
const SCALE_PRECISION = 1e-4, SCALE_MIN = 1 - SCALE_PRECISION, SCALE_MAX = 1 + SCALE_PRECISION, TRANSLATE_PRECISION = 0.01, TRANSLATE_MIN = 0 - TRANSLATE_PRECISION, TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
function calcLength(axis) {
  return axis.max - axis.min;
}
function isNear(value, target, maxDistance) {
  return Math.abs(value - target) <= maxDistance;
}
function calcAxisDelta(delta, source, target, origin = 0.5) {
  delta.origin = origin, delta.originPoint = mixNumber$1(source.min, source.max, delta.origin), delta.scale = calcLength(target) / calcLength(source), delta.translate = mixNumber$1(target.min, target.max, delta.origin) - delta.originPoint, (delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX || isNaN(delta.scale)) && (delta.scale = 1), (delta.translate >= TRANSLATE_MIN && delta.translate <= TRANSLATE_MAX || isNaN(delta.translate)) && (delta.translate = 0);
}
function calcBoxDelta(delta, source, target, origin) {
  calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0), calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
}
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min, target.max = target.min + calcLength(relative);
}
function calcRelativeBox(target, relative, parent) {
  calcRelativeAxis(target.x, relative.x, parent.x), calcRelativeAxis(target.y, relative.y, parent.y);
}
function calcRelativeAxisPosition(target, layout2, parent) {
  target.min = layout2.min - parent.min, target.max = target.min + calcLength(layout2);
}
function calcRelativePosition(target, layout2, parent) {
  calcRelativeAxisPosition(target.x, layout2.x, parent.x), calcRelativeAxisPosition(target.y, layout2.y, parent.y);
}
function applyConstraints(point2, { min: min2, max: max2 }, elastic) {
  return min2 !== void 0 && point2 < min2 ? point2 = elastic ? mixNumber$1(min2, point2, elastic.min) : Math.max(point2, min2) : max2 !== void 0 && point2 > max2 && (point2 = elastic ? mixNumber$1(max2, point2, elastic.max) : Math.min(point2, max2)), point2;
}
function calcRelativeAxisConstraints(axis, min2, max2) {
  return {
    min: min2 !== void 0 ? axis.min + min2 : void 0,
    max: max2 !== void 0 ? axis.max + max2 - (axis.max - axis.min) : void 0
  };
}
function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  let min2 = constraintsAxis.min - layoutAxis.min, max2 = constraintsAxis.max - layoutAxis.max;
  return constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min && ([min2, max2] = [max2, min2]), { min: min2, max: max2 };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcOrigin$1(source, target) {
  let origin = 0.5;
  const sourceLength = calcLength(source), targetLength = calcLength(target);
  return targetLength > sourceLength ? origin = progress(target.min, target.max - sourceLength, source.min) : sourceLength > targetLength && (origin = progress(source.min, source.max - targetLength, target.min)), clamp(0, 1, origin);
}
function rebaseAxisConstraints(layout2, constraints) {
  const relativeConstraints = {};
  return constraints.min !== void 0 && (relativeConstraints.min = constraints.min - layout2.min), constraints.max !== void 0 && (relativeConstraints.max = constraints.max - layout2.min), relativeConstraints;
}
const defaultElastic = 0.35;
function resolveDragElastic(dragElastic = defaultElastic) {
  return dragElastic === !1 ? dragElastic = 0 : dragElastic === !0 && (dragElastic = defaultElastic), {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label2) {
  return typeof dragElastic == "number" ? dragElastic : dragElastic[label2] || 0;
}
const createAxisDelta = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), createDelta = () => ({
  x: createAxisDelta(),
  y: createAxisDelta()
}), createAxis = () => ({ min: 0, max: 0 }), createBox = () => ({
  x: createAxis(),
  y: createAxis()
});
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}
function convertBoundingBoxToBox({ top, left, right, bottom }) {
  return {
    x: { min: left, max: right },
    y: { min: top, max: bottom }
  };
}
function convertBoxToBoundingBox({ x: x2, y: y2 }) {
  return { top: y2.min, right: x2.max, bottom: y2.max, left: x2.min };
}
function transformBoxPoints(point2, transformPoint2) {
  if (!transformPoint2)
    return point2;
  const topLeft = transformPoint2({ x: point2.left, y: point2.top }), bottomRight = transformPoint2({ x: point2.right, y: point2.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
function hasScale({ scale: scale2, scaleX, scaleY }) {
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
}
function hasTransform(values) {
  return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY || values.skewX || values.skewY;
}
function has2DTranslate(values) {
  return is2DTranslate(values.x) || is2DTranslate(values.y);
}
function is2DTranslate(value) {
  return value && value !== "0%";
}
function scalePoint(point2, scale2, originPoint) {
  const distanceFromOrigin = point2 - originPoint, scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point2, translate, scale2, originPoint, boxScale) {
  return boxScale !== void 0 && (point2 = scalePoint(point2, boxScale, originPoint)), scalePoint(point2, scale2, originPoint) + translate;
}
function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale), axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function applyBoxDelta(box, { x: x2, y: y2 }) {
  applyAxisDelta(box.x, x2.translate, x2.scale, x2.originPoint), applyAxisDelta(box.y, y2.translate, y2.scale, y2.originPoint);
}
const TREE_SCALE_SNAP_MIN = 0.999999999999, TREE_SCALE_SNAP_MAX = 1.0000000000001;
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = !1) {
  const treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  let node2, delta;
  for (let i2 = 0; i2 < treeLength; i2++) {
    node2 = treePath[i2], delta = node2.projectionDelta;
    const { visualElement } = node2.options;
    visualElement && visualElement.props.style && visualElement.props.style.display === "contents" || (isSharedTransition && node2.options.layoutScroll && node2.scroll && node2 !== node2.root && transformBox(box, {
      x: -node2.scroll.offset.x,
      y: -node2.scroll.offset.y
    }), delta && (treeScale.x *= delta.x.scale, treeScale.y *= delta.y.scale, applyBoxDelta(box, delta)), isSharedTransition && hasTransform(node2.latestValues) && transformBox(box, node2.latestValues));
  }
  treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN && (treeScale.x = 1), treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN && (treeScale.y = 1);
}
function translateAxis(axis, distance2) {
  axis.min = axis.min + distance2, axis.max = axis.max + distance2;
}
function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {
  const originPoint = mixNumber$1(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);
}
function transformBox(box, transform) {
  transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX), transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);
}
function measureViewportBox(instance, transformPoint2) {
  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
}
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  const viewportBox = measureViewportBox(element, transformPagePoint), { scroll } = rootProjectionNode2;
  return scroll && (translateAxis(viewportBox.x, scroll.offset.x), translateAxis(viewportBox.y, scroll.offset.y)), viewportBox;
}
const getContextWindow = ({ current }) => current ? current.ownerDocument.defaultView : null, elementDragControls = /* @__PURE__ */ new WeakMap();
class VisualElementDragControls {
  constructor(visualElement) {
    this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = createBox(), this.visualElement = visualElement;
  }
  start(originEvent, { snapToCursor = !1 } = {}) {
    const { presenceContext } = this.visualElement;
    if (presenceContext && presenceContext.isPresent === !1)
      return;
    const onSessionStart = (event) => {
      const { dragSnapToOrigin: dragSnapToOrigin2 } = this.getProps();
      dragSnapToOrigin2 ? this.pauseAnimation() : this.stopAnimation(), snapToCursor && this.snapToCursor(extractEventInfo(event, "page").point);
    }, onStart = (event, info) => {
      const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
      if (drag2 && !dragPropagation && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = getGlobalLock(drag2), !this.openGlobalLock))
        return;
      this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), eachAxis((axis) => {
        let current = this.getAxisMotionValue(axis).get() || 0;
        if (percent.test(current)) {
          const { projection } = this.visualElement;
          if (projection && projection.layout) {
            const measuredAxis = projection.layout.layoutBox[axis];
            measuredAxis && (current = calcLength(measuredAxis) * (parseFloat(current) / 100));
          }
        }
        this.originPoint[axis] = current;
      }), onDragStart && frame.postRender(() => onDragStart(event, info)), addValueToWillChange(this.visualElement, "transform");
      const { animationState } = this.visualElement;
      animationState && animationState.setActive("whileDrag", !0);
    }, onMove = (event, info) => {
      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
      if (!dragPropagation && !this.openGlobalLock)
        return;
      const { offset } = info;
      if (dragDirectionLock && this.currentDirection === null) {
        this.currentDirection = getCurrentDirection(offset), this.currentDirection !== null && onDirectionLock && onDirectionLock(this.currentDirection);
        return;
      }
      this.updateAxis("x", info.point, offset), this.updateAxis("y", info.point, offset), this.visualElement.render(), onDrag && onDrag(event, info);
    }, onSessionEnd = (event, info) => this.stop(event, info), resumeAnimation = () => eachAxis((axis) => {
      var _a2;
      return this.getAnimationState(axis) === "paused" && ((_a2 = this.getAxisMotionValue(axis).animation) === null || _a2 === void 0 ? void 0 : _a2.play());
    }), { dragSnapToOrigin } = this.getProps();
    this.panSession = new PanSession(originEvent, {
      onSessionStart,
      onStart,
      onMove,
      onSessionEnd,
      resumeAnimation
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin,
      contextWindow: getContextWindow(this.visualElement)
    });
  }
  stop(event, info) {
    const isDragging = this.isDragging;
    if (this.cancel(), !isDragging)
      return;
    const { velocity } = info;
    this.startAnimation(velocity);
    const { onDragEnd } = this.getProps();
    onDragEnd && frame.postRender(() => onDragEnd(event, info));
  }
  cancel() {
    this.isDragging = !1;
    const { projection, animationState } = this.visualElement;
    projection && (projection.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
    const { dragPropagation } = this.getProps();
    !dragPropagation && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), animationState && animationState.setActive("whileDrag", !1);
  }
  updateAxis(axis, _point, offset) {
    const { drag: drag2 } = this.getProps();
    if (!offset || !shouldDrag(axis, drag2, this.currentDirection))
      return;
    const axisValue = this.getAxisMotionValue(axis);
    let next = this.originPoint[axis] + offset[axis];
    this.constraints && this.constraints[axis] && (next = applyConstraints(next, this.constraints[axis], this.elastic[axis])), axisValue.set(next);
  }
  resolveConstraints() {
    var _a2;
    const { dragConstraints, dragElastic } = this.getProps(), layout2 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (_a2 = this.visualElement.projection) === null || _a2 === void 0 ? void 0 : _a2.layout, prevConstraints = this.constraints;
    dragConstraints && isRefObject(dragConstraints) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : dragConstraints && layout2 ? this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints) : this.constraints = !1, this.elastic = resolveDragElastic(dragElastic), prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints && eachAxis((axis) => {
      this.constraints !== !1 && this.getAxisMotionValue(axis) && (this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
    if (!constraints || !isRefObject(constraints))
      return !1;
    const constraintsElement = constraints.current, { projection } = this.visualElement;
    if (!projection || !projection.layout)
      return !1;
    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
    if (onMeasureDragConstraints) {
      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
      this.hasMutatedConstraints = !!userConstraints, userConstraints && (measuredConstraints = convertBoundingBoxToBox(userConstraints));
    }
    return measuredConstraints;
  }
  startAnimation(velocity) {
    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps(), constraints = this.constraints || {}, momentumAnimations = eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      let transition = constraints && constraints[axis] || {};
      dragSnapToOrigin && (transition = { min: 0, max: 0 });
      const bounceStiffness = dragElastic ? 200 : 1e6, bounceDamping = dragElastic ? 40 : 1e7, inertia2 = {
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...dragTransition,
        ...transition
      };
      return this.startAxisValueAnimation(axis, inertia2);
    });
    return Promise.all(momentumAnimations).then(onDragTransitionEnd);
  }
  startAxisValueAnimation(axis, transition) {
    const axisValue = this.getAxisMotionValue(axis);
    return addValueToWillChange(this.visualElement, axis), axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, !1));
  }
  stopAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).stop());
  }
  pauseAnimation() {
    eachAxis((axis) => {
      var _a2;
      return (_a2 = this.getAxisMotionValue(axis).animation) === null || _a2 === void 0 ? void 0 : _a2.pause();
    });
  }
  getAnimationState(axis) {
    var _a2;
    return (_a2 = this.getAxisMotionValue(axis).animation) === null || _a2 === void 0 ? void 0 : _a2.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(axis) {
    const dragKey = `_drag${axis.toUpperCase()}`, props2 = this.visualElement.getProps(), externalMotionValue = props2[dragKey];
    return externalMotionValue || this.visualElement.getValue(axis, (props2.initial ? props2.initial[axis] : void 0) || 0);
  }
  snapToCursor(point2) {
    eachAxis((axis) => {
      const { drag: drag2 } = this.getProps();
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      const { projection } = this.visualElement, axisValue = this.getAxisMotionValue(axis);
      if (projection && projection.layout) {
        const { min: min2, max: max2 } = projection.layout.layoutBox[axis];
        axisValue.set(point2[axis] - mixNumber$1(min2, max2, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: drag2, dragConstraints } = this.getProps(), { projection } = this.visualElement;
    if (!isRefObject(dragConstraints) || !projection || !this.constraints)
      return;
    this.stopAnimation();
    const boxProgress = { x: 0, y: 0 };
    eachAxis((axis) => {
      const axisValue = this.getAxisMotionValue(axis);
      if (axisValue && this.constraints !== !1) {
        const latest = axisValue.get();
        boxProgress[axis] = calcOrigin$1({ min: latest, max: latest }, this.constraints[axis]);
      }
    });
    const { transformTemplate } = this.visualElement.getProps();
    this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none", projection.root && projection.root.updateScroll(), projection.updateLayout(), this.resolveConstraints(), eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, null))
        return;
      const axisValue = this.getAxisMotionValue(axis), { min: min2, max: max2 } = this.constraints[axis];
      axisValue.set(mixNumber$1(min2, max2, boxProgress[axis]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    elementDragControls.set(this.visualElement, this);
    const element = this.visualElement.current, stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
      const { drag: drag2, dragListener = !0 } = this.getProps();
      drag2 && dragListener && this.start(event);
    }), measureDragConstraints = () => {
      const { dragConstraints } = this.getProps();
      isRefObject(dragConstraints) && dragConstraints.current && (this.constraints = this.resolveRefConstraints());
    }, { projection } = this.visualElement, stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
    projection && !projection.layout && (projection.root && projection.root.updateScroll(), projection.updateLayout()), frame.read(measureDragConstraints);
    const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints()), stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({ delta, hasLayoutChanged }) => {
      this.isDragging && hasLayoutChanged && (eachAxis((axis) => {
        const motionValue2 = this.getAxisMotionValue(axis);
        motionValue2 && (this.originPoint[axis] += delta[axis].translate, motionValue2.set(motionValue2.get() + delta[axis].translate));
      }), this.visualElement.render());
    });
    return () => {
      stopResizeListener(), stopPointerListener(), stopMeasureLayoutListener(), stopLayoutUpdateListener && stopLayoutUpdateListener();
    };
  }
  getProps() {
    const props2 = this.visualElement.getProps(), { drag: drag2 = !1, dragDirectionLock = !1, dragPropagation = !1, dragConstraints = !1, dragElastic = defaultElastic, dragMomentum = !0 } = props2;
    return {
      ...props2,
      drag: drag2,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum
    };
  }
}
function shouldDrag(direction, drag2, currentDirection) {
  return (drag2 === !0 || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
function getCurrentDirection(offset, lockThreshold = 10) {
  let direction = null;
  return Math.abs(offset.y) > lockThreshold ? direction = "y" : Math.abs(offset.x) > lockThreshold && (direction = "x"), direction;
}
class DragGesture extends Feature {
  constructor(node2) {
    super(node2), this.removeGroupControls = noop$2, this.removeListeners = noop$2, this.controls = new VisualElementDragControls(node2);
  }
  mount() {
    const { dragControls } = this.node.getProps();
    dragControls && (this.removeGroupControls = dragControls.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || noop$2;
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const asyncHandler = (handler) => (event, info) => {
  handler && frame.postRender(() => handler(event, info));
};
class PanGesture extends Feature {
  constructor() {
    super(...arguments), this.removePointerDownListener = noop$2;
  }
  onPointerDown(pointerDownEvent) {
    this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: getContextWindow(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
    return {
      onSessionStart: asyncHandler(onPanSessionStart),
      onStart: asyncHandler(onPanStart),
      onMove: onPan,
      onEnd: (event, info) => {
        delete this.session, onPanEnd && frame.postRender(() => onPanEnd(event, info));
      }
    };
  }
  mount() {
    this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
const PresenceContext = createContext$1(null);
function usePresence() {
  const context = useContext$1(PresenceContext);
  if (context === null)
    return [!0, null];
  const { isPresent, onExitComplete, register } = context, id2 = useId$1();
  useEffect$1(() => register(id2), []);
  const safeToRemove = useCallback$1(() => onExitComplete && onExitComplete(id2), [id2, onExitComplete]);
  return !isPresent && onExitComplete ? [!1, safeToRemove] : [!0];
}
const LayoutGroupContext = createContext$1({}), SwitchLayoutGroupContext = createContext$1({}), globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
};
function pixelsToPercent(pixels, axis) {
  return axis.max === axis.min ? 0 : pixels / (axis.max - axis.min) * 100;
}
const correctBorderRadius = {
  correct: (latest, node2) => {
    if (!node2.target)
      return latest;
    if (typeof latest == "string")
      if (px.test(latest))
        latest = parseFloat(latest);
      else
        return latest;
    const x2 = pixelsToPercent(latest, node2.target.x), y2 = pixelsToPercent(latest, node2.target.y);
    return `${x2}% ${y2}%`;
  }
}, correctBoxShadow = {
  correct: (latest, { treeScale, projectionDelta }) => {
    const original = latest, shadow = complex.parse(latest);
    if (shadow.length > 5)
      return original;
    const template = complex.createTransformer(latest), offset = typeof shadow[0] != "number" ? 1 : 0, xScale = projectionDelta.x.scale * treeScale.x, yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset] /= xScale, shadow[1 + offset] /= yScale;
    const averageScale = mixNumber$1(xScale, yScale, 0.5);
    return typeof shadow[2 + offset] == "number" && (shadow[2 + offset] /= averageScale), typeof shadow[3 + offset] == "number" && (shadow[3 + offset] /= averageScale), template(shadow);
  }
}, scaleCorrectors = {};
function addScaleCorrector(correctors) {
  Object.assign(scaleCorrectors, correctors);
}
const { schedule: microtask, cancel: cancelMicrotask } = createRenderBatcher(queueMicrotask, !1);
class MeasureLayoutWithContext extends Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props, { projection } = visualElement;
    addScaleCorrector(defaultScaleCorrectors), projection && (layoutGroup.group && layoutGroup.group.add(projection), switchLayoutGroup && switchLayoutGroup.register && layoutId && switchLayoutGroup.register(projection), projection.root.didUpdate(), projection.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), projection.setOptions({
      ...projection.options,
      onExitComplete: () => this.safeToRemove()
    })), globalProjectionState.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(prevProps) {
    const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props, projection = visualElement.projection;
    return projection && (projection.isPresent = isPresent, drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0 ? projection.willUpdate() : this.safeToRemove(), prevProps.isPresent !== isPresent && (isPresent ? projection.promote() : projection.relegate() || frame.postRender(() => {
      const stack = projection.getStack();
      (!stack || !stack.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection } = this.props.visualElement;
    projection && (projection.root.didUpdate(), microtask.postRender(() => {
      !projection.currentAnimation && projection.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props, { projection } = visualElement;
    projection && (projection.scheduleCheckAfterUnmount(), layoutGroup && layoutGroup.group && layoutGroup.group.remove(projection), promoteContext && promoteContext.deregister && promoteContext.deregister(projection));
  }
  safeToRemove() {
    const { safeToRemove } = this.props;
    safeToRemove && safeToRemove();
  }
  render() {
    return null;
  }
}
function MeasureLayout(props2) {
  const [isPresent, safeToRemove] = usePresence(), layoutGroup = useContext$1(LayoutGroupContext);
  return jsx(MeasureLayoutWithContext, { ...props2, layoutGroup, switchLayoutGroup: useContext$1(SwitchLayoutGroupContext), isPresent, safeToRemove });
}
const defaultScaleCorrectors = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
}, borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], numBorders = borders.length, asNumber = (value) => typeof value == "string" ? parseFloat(value) : value, isPx = (value) => typeof value == "number" || px.test(value);
function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
  shouldCrossfadeOpacity ? (target.opacity = mixNumber$1(
    0,
    // TODO Reinstate this if only child
    lead.opacity !== void 0 ? lead.opacity : 1,
    easeCrossfadeIn(progress2)
  ), target.opacityExit = mixNumber$1(follow.opacity !== void 0 ? follow.opacity : 1, 0, easeCrossfadeOut(progress2))) : isOnlyMember && (target.opacity = mixNumber$1(follow.opacity !== void 0 ? follow.opacity : 1, lead.opacity !== void 0 ? lead.opacity : 1, progress2));
  for (let i2 = 0; i2 < numBorders; i2++) {
    const borderLabel = `border${borders[i2]}Radius`;
    let followRadius = getRadius(follow, borderLabel), leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0), leadRadius || (leadRadius = 0), followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius) ? (target[borderLabel] = Math.max(mixNumber$1(asNumber(followRadius), asNumber(leadRadius), progress2), 0), (percent.test(leadRadius) || percent.test(followRadius)) && (target[borderLabel] += "%")) : target[borderLabel] = leadRadius;
  }
  (follow.rotate || lead.rotate) && (target.rotate = mixNumber$1(follow.rotate || 0, lead.rotate || 0, progress2));
}
function getRadius(values, radiusName) {
  return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
}
const easeCrossfadeIn = /* @__PURE__ */ compress(0, 0.5, circOut), easeCrossfadeOut = /* @__PURE__ */ compress(0.5, 0.95, noop$2);
function compress(min2, max2, easing) {
  return (p2) => p2 < min2 ? 0 : p2 > max2 ? 1 : easing(progress(min2, max2, p2));
}
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min, axis.max = originAxis.max;
}
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x), copyAxisInto(box.y, originBox.y);
}
function copyAxisDeltaInto(delta, originDelta) {
  delta.translate = originDelta.translate, delta.scale = originDelta.scale, delta.originPoint = originDelta.originPoint, delta.origin = originDelta.origin;
}
function removePointDelta(point2, translate, scale2, originPoint, boxScale) {
  return point2 -= translate, point2 = scalePoint(point2, 1 / scale2, originPoint), boxScale !== void 0 && (point2 = scalePoint(point2, 1 / boxScale, originPoint)), point2;
}
function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
  if (percent.test(translate) && (translate = parseFloat(translate), translate = mixNumber$1(sourceAxis.min, sourceAxis.max, translate / 100) - sourceAxis.min), typeof translate != "number")
    return;
  let originPoint = mixNumber$1(originAxis.min, originAxis.max, origin);
  axis === originAxis && (originPoint -= translate), axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale), axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {
  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
}
const xKeys = ["x", "scaleX", "originX"], yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(box, transforms, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0), removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
}
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
function axisEquals(a2, b2) {
  return a2.min === b2.min && a2.max === b2.max;
}
function boxEquals(a2, b2) {
  return axisEquals(a2.x, b2.x) && axisEquals(a2.y, b2.y);
}
function axisEqualsRounded(a2, b2) {
  return Math.round(a2.min) === Math.round(b2.min) && Math.round(a2.max) === Math.round(b2.max);
}
function boxEqualsRounded(a2, b2) {
  return axisEqualsRounded(a2.x, b2.x) && axisEqualsRounded(a2.y, b2.y);
}
function aspectRatio(box) {
  return calcLength(box.x) / calcLength(box.y);
}
function axisDeltaEquals(a2, b2) {
  return a2.translate === b2.translate && a2.scale === b2.scale && a2.originPoint === b2.originPoint;
}
class NodeStack {
  constructor() {
    this.members = [];
  }
  add(node2) {
    addUniqueItem(this.members, node2), node2.scheduleRender();
  }
  remove(node2) {
    if (removeItem(this.members, node2), node2 === this.prevLead && (this.prevLead = void 0), node2 === this.lead) {
      const prevLead = this.members[this.members.length - 1];
      prevLead && this.promote(prevLead);
    }
  }
  relegate(node2) {
    const indexOfNode = this.members.findIndex((member) => node2 === member);
    if (indexOfNode === 0)
      return !1;
    let prevLead;
    for (let i2 = indexOfNode; i2 >= 0; i2--) {
      const member = this.members[i2];
      if (member.isPresent !== !1) {
        prevLead = member;
        break;
      }
    }
    return prevLead ? (this.promote(prevLead), !0) : !1;
  }
  promote(node2, preserveFollowOpacity) {
    const prevLead = this.lead;
    if (node2 !== prevLead && (this.prevLead = prevLead, this.lead = node2, node2.show(), prevLead)) {
      prevLead.instance && prevLead.scheduleRender(), node2.scheduleRender(), node2.resumeFrom = prevLead, preserveFollowOpacity && (node2.resumeFrom.preserveOpacity = !0), prevLead.snapshot && (node2.snapshot = prevLead.snapshot, node2.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues), node2.root && node2.root.isUpdating && (node2.isLayoutDirty = !0);
      const { crossfade } = node2.options;
      crossfade === !1 && prevLead.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((node2) => {
      const { options, resumingFrom } = node2;
      options.onExitComplete && options.onExitComplete(), resumingFrom && resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((node2) => {
      node2.instance && node2.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function buildProjectionTransform(delta, treeScale, latestTransform) {
  let transform = "";
  const xTranslate = delta.x.translate / treeScale.x, yTranslate = delta.y.translate / treeScale.y, zTranslate = latestTransform?.z || 0;
  if ((xTranslate || yTranslate || zTranslate) && (transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `), (treeScale.x !== 1 || treeScale.y !== 1) && (transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `), latestTransform) {
    const { transformPerspective, rotate, rotateX, rotateY, skewX, skewY } = latestTransform;
    transformPerspective && (transform = `perspective(${transformPerspective}px) ${transform}`), rotate && (transform += `rotate(${rotate}deg) `), rotateX && (transform += `rotateX(${rotateX}deg) `), rotateY && (transform += `rotateY(${rotateY}deg) `), skewX && (transform += `skewX(${skewX}deg) `), skewY && (transform += `skewY(${skewY}deg) `);
  }
  const elementScaleX = delta.x.scale * treeScale.x, elementScaleY = delta.y.scale * treeScale.y;
  return (elementScaleX !== 1 || elementScaleY !== 1) && (transform += `scale(${elementScaleX}, ${elementScaleY})`), transform || "none";
}
const compareByDepth = (a2, b2) => a2.depth - b2.depth;
class FlatTree {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(child) {
    addUniqueItem(this.children, child), this.isDirty = !0;
  }
  remove(child) {
    removeItem(this.children, child), this.isDirty = !0;
  }
  forEach(callback) {
    this.isDirty && this.children.sort(compareByDepth), this.isDirty = !1, this.children.forEach(callback);
  }
}
function resolveMotionValue(value) {
  const unwrappedValue = isMotionValue(value) ? value.get() : value;
  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}
function delay(callback, timeout) {
  const start = time$1.now(), checkElapsed = ({ timestamp }) => {
    const elapsed = timestamp - start;
    elapsed >= timeout && (cancelFrame(checkElapsed), callback(elapsed - timeout));
  };
  return frame.read(checkElapsed, !0), () => cancelFrame(checkElapsed);
}
function isSVGElement(element) {
  return element instanceof SVGElement && element.tagName !== "svg";
}
function animateSingleValue(value, keyframes2, options) {
  const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
  return motionValue$1.start(animateMotionValue("", motionValue$1, keyframes2, options)), motionValue$1.animation;
}
const metrics = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
}, isDebug = typeof window < "u" && window.MotionDebug !== void 0, transformAxes = ["", "X", "Y", "Z"], hiddenVisibility = { visibility: "hidden" }, animationTarget = 1e3;
let id = 0;
function resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {
  const { latestValues } = visualElement;
  latestValues[key] && (values[key] = latestValues[key], visualElement.setStaticValue(key, 0), sharedAnimationValues && (sharedAnimationValues[key] = 0));
}
function cancelTreeOptimisedTransformAnimations(projectionNode) {
  if (projectionNode.hasCheckedOptimisedAppear = !0, projectionNode.root === projectionNode)
    return;
  const { visualElement } = projectionNode.options;
  if (!visualElement)
    return;
  const appearId = getOptimisedAppearId(visualElement);
  if (window.MotionHasOptimisedAnimation(appearId, "transform")) {
    const { layout: layout2, layoutId } = projectionNode.options;
    window.MotionCancelOptimisedAnimation(appearId, "transform", frame, !(layout2 || layoutId));
  }
  const { parent } = projectionNode;
  parent && !parent.hasCheckedOptimisedAppear && cancelTreeOptimisedTransformAnimations(parent);
}
function createProjectionNode$1({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
  return class {
    constructor(latestValues = {}, parent = defaultParent?.()) {
      this.id = id++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, isDebug && (metrics.totalNodes = metrics.resolvedTargetDeltas = metrics.recalculatedProjection = 0), this.nodes.forEach(propagateDirtyNodes), this.nodes.forEach(resolveTargetDelta), this.nodes.forEach(calcProjection), this.nodes.forEach(cleanDirtyNodes), isDebug && window.MotionDebug.record(metrics);
      }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = latestValues, this.root = parent ? parent.root || parent : this, this.path = parent ? [...parent.path, parent] : [], this.parent = parent, this.depth = parent ? parent.depth + 1 : 0;
      for (let i2 = 0; i2 < this.path.length; i2++)
        this.path[i2].shouldResetTransform = !0;
      this.root === this && (this.nodes = new FlatTree());
    }
    addEventListener(name, handler) {
      return this.eventHandlers.has(name) || this.eventHandlers.set(name, new SubscriptionManager()), this.eventHandlers.get(name).add(handler);
    }
    notifyListeners(name, ...args) {
      const subscriptionManager = this.eventHandlers.get(name);
      subscriptionManager && subscriptionManager.notify(...args);
    }
    hasListeners(name) {
      return this.eventHandlers.has(name);
    }
    /**
     * Lifecycles
     */
    mount(instance, isLayoutDirty = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = isSVGElement(instance), this.instance = instance;
      const { layoutId, layout: layout2, visualElement } = this.options;
      if (visualElement && !visualElement.current && visualElement.mount(instance), this.root.nodes.add(this), this.parent && this.parent.children.add(this), isLayoutDirty && (layout2 || layoutId) && (this.isLayoutDirty = !0), attachResizeListener) {
        let cancelDelay;
        const resizeUnblockUpdate = () => this.root.updateBlockedByResize = !1;
        attachResizeListener(instance, () => {
          this.root.updateBlockedByResize = !0, cancelDelay && cancelDelay(), cancelDelay = delay(resizeUnblockUpdate, 250), globalProjectionState.hasAnimatedSinceResize && (globalProjectionState.hasAnimatedSinceResize = !1, this.nodes.forEach(finishAnimation));
        });
      }
      layoutId && this.root.registerSharedNode(layoutId, this), this.options.animate !== !1 && visualElement && (layoutId || layout2) && this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition, { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps(), targetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout) || hasRelativeTargetChanged, hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
        if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
          const animationOptions = {
            ...getValueTransition$1(layoutTransition, "layout"),
            onPlay: onLayoutAnimationStart,
            onComplete: onLayoutAnimationComplete
          };
          (visualElement.shouldReduceMotion || this.options.layoutRoot) && (animationOptions.delay = 0, animationOptions.type = !1), this.startAnimation(animationOptions);
        } else
          hasLayoutChanged || finishAnimation(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = newLayout;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const stack = this.getStack();
      stack && stack.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, cancelFrame(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(resetSkewAndRotation), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement } = this.options;
      return visualElement && visualElement.getProps().transformTemplate;
    }
    willUpdate(shouldNotifyListeners = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && cancelTreeOptimisedTransformAnimations(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node2 = this.path[i2];
        node2.shouldResetTransform = !0, node2.updateScroll("snapshot"), node2.options.layoutRoot && node2.willUpdate(!1);
      }
      const { layoutId, layout: layout2 } = this.options;
      if (layoutId === void 0 && !layout2)
        return;
      const transformTemplate = this.getTransformTemplate();
      this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0, this.updateSnapshot(), shouldNotifyListeners && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(clearMeasurements);
        return;
      }
      this.isUpdating || this.nodes.forEach(clearIsLayoutDirty), this.isUpdating = !1, this.nodes.forEach(resetTransformStyle), this.nodes.forEach(updateLayout), this.nodes.forEach(notifyLayoutUpdate), this.clearAllSnapshots();
      const now2 = time$1.now();
      frameData.delta = clamp(0, 1e3 / 60, now2 - frameData.timestamp), frameData.timestamp = now2, frameData.isProcessing = !0, frameSteps.update.process(frameData), frameSteps.preRender.process(frameData), frameSteps.render.process(frameData), frameData.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, microtask.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot), this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, frame.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      frame.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let i2 = 0; i2 < this.path.length; i2++)
          this.path[i2].updateScroll();
      const prevLayout = this.layout;
      this.layout = this.measure(!1), this.layoutCorrected = createBox(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement } = this.options;
      visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
    }
    updateScroll(phase = "measure") {
      let needsMeasurement = !!(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase && (needsMeasurement = !1), needsMeasurement) {
        const isRoot = checkIsScrollRoot(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase,
          isRoot,
          offset: measureScroll(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : isRoot
        };
      }
    }
    resetTransform() {
      if (!resetTransform)
        return;
      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta), transformTemplate = this.getTransformTemplate(), transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0, transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
      isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged) && (resetTransform(this.instance, transformTemplateValue), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(removeTransform = !0) {
      const pageBox = this.measurePageBox();
      let layoutBox = this.removeElementScroll(pageBox);
      return removeTransform && (layoutBox = this.removeTransform(layoutBox)), roundBox(layoutBox), {
        animationId: this.root.animationId,
        measuredBox: pageBox,
        layoutBox,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      var _a2;
      const { visualElement } = this.options;
      if (!visualElement)
        return createBox();
      const box = visualElement.measureViewportBox();
      if (!(((_a2 = this.scroll) === null || _a2 === void 0 ? void 0 : _a2.wasRoot) || this.path.some(checkNodeWasScrollRoot))) {
        const { scroll } = this.root;
        scroll && (translateAxis(box.x, scroll.offset.x), translateAxis(box.y, scroll.offset.y));
      }
      return box;
    }
    removeElementScroll(box) {
      var _a2;
      const boxWithoutScroll = createBox();
      if (copyBoxInto(boxWithoutScroll, box), !((_a2 = this.scroll) === null || _a2 === void 0) && _a2.wasRoot)
        return boxWithoutScroll;
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node2 = this.path[i2], { scroll, options } = node2;
        node2 !== this.root && scroll && options.layoutScroll && (scroll.wasRoot && copyBoxInto(boxWithoutScroll, box), translateAxis(boxWithoutScroll.x, scroll.offset.x), translateAxis(boxWithoutScroll.y, scroll.offset.y));
      }
      return boxWithoutScroll;
    }
    applyTransform(box, transformOnly = !1) {
      const withTransforms = createBox();
      copyBoxInto(withTransforms, box);
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node2 = this.path[i2];
        !transformOnly && node2.options.layoutScroll && node2.scroll && node2 !== node2.root && transformBox(withTransforms, {
          x: -node2.scroll.offset.x,
          y: -node2.scroll.offset.y
        }), hasTransform(node2.latestValues) && transformBox(withTransforms, node2.latestValues);
      }
      return hasTransform(this.latestValues) && transformBox(withTransforms, this.latestValues), withTransforms;
    }
    removeTransform(box) {
      const boxWithoutTransform = createBox();
      copyBoxInto(boxWithoutTransform, box);
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node2 = this.path[i2];
        if (!node2.instance || !hasTransform(node2.latestValues))
          continue;
        hasScale(node2.latestValues) && node2.updateSnapshot();
        const sourceBox = createBox(), nodeBox = node2.measurePageBox();
        copyBoxInto(sourceBox, nodeBox), removeBoxTransforms(boxWithoutTransform, node2.latestValues, node2.snapshot ? node2.snapshot.layoutBox : void 0, sourceBox);
      }
      return hasTransform(this.latestValues) && removeBoxTransforms(boxWithoutTransform, this.latestValues), boxWithoutTransform;
    }
    setTargetDelta(delta) {
      this.targetDelta = delta, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(options) {
      this.options = {
        ...this.options,
        ...options,
        crossfade: options.crossfade !== void 0 ? options.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(forceRecalculation = !1) {
      var _a2;
      const lead = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
      const isShared = !!this.resumingFrom || this !== lead;
      if (!(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || !((_a2 = this.parent) === null || _a2 === void 0) && _a2.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
        return;
      const { layout: layout2, layoutId } = this.options;
      if (!(!this.layout || !(layout2 || layoutId))) {
        if (this.resolvedRelativeTargetAt = frameData.timestamp, !this.targetDelta && !this.relativeTarget) {
          const relativeParent = this.getClosestProjectingParent();
          relativeParent && relativeParent.layout && this.animationProgress !== 1 ? (this.relativeParent = relativeParent, this.forceRelativeParentToResolveTarget(), this.relativeTarget = createBox(), this.relativeTargetOrigin = createBox(), calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox), copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (this.target || (this.target = createBox(), this.targetWithTransforms = createBox()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : copyBoxInto(this.target, this.layout.layoutBox), applyBoxDelta(this.target, this.targetDelta)) : copyBoxInto(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
            this.attemptToResolveRelativeTarget = !1;
            const relativeParent = this.getClosestProjectingParent();
            relativeParent && !!relativeParent.resumingFrom == !!this.resumingFrom && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1 ? (this.relativeParent = relativeParent, this.forceRelativeParentToResolveTarget(), this.relativeTarget = createBox(), this.relativeTargetOrigin = createBox(), calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target), copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
          }
          isDebug && metrics.resolvedTargetDeltas++;
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var _a2;
      const lead = this.getLead(), isShared = !!this.resumingFrom || this !== lead;
      let canSkip = !0;
      if ((this.isProjectionDirty || !((_a2 = this.parent) === null || _a2 === void 0) && _a2.isProjectionDirty) && (canSkip = !1), isShared && (this.isSharedProjectionDirty || this.isTransformDirty) && (canSkip = !1), this.resolvedRelativeTargetAt === frameData.timestamp && (canSkip = !1), canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(layout2 || layoutId))
        return;
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
      const prevTreeScaleX = this.treeScale.x, prevTreeScaleY = this.treeScale.y;
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared), lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (lead.target = lead.layout.layoutBox, lead.targetWithTransforms = createBox());
      const { target } = lead;
      if (!target) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x), copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y)), calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues), (this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", target)), isDebug && metrics.recalculatedProjection++;
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(notifyAll = !0) {
      var _a2;
      if ((_a2 = this.options.visualElement) === null || _a2 === void 0 || _a2.scheduleRender(), notifyAll) {
        const stack = this.getStack();
        stack && stack.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = createDelta(), this.projectionDelta = createDelta(), this.projectionDeltaWithTransform = createDelta();
    }
    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = !1) {
      const snapshot = this.snapshot, snapshotLatestValues = snapshot ? snapshot.latestValues : {}, mixedValues = { ...this.latestValues }, targetDelta = createDelta();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      const relativeLayout = createBox(), snapshotSource = snapshot ? snapshot.source : void 0, layoutSource = this.layout ? this.layout.source : void 0, isSharedLayoutAnimation = snapshotSource !== layoutSource, stack = this.getStack(), isOnlyMember = !stack || stack.members.length <= 1, shouldCrossfadeOpacity = !!(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === !0 && !this.path.some(hasOpacityCrossfade));
      this.animationProgress = 0;
      let prevRelativeTarget;
      this.mixTargetDelta = (latest) => {
        const progress2 = latest / 1e3;
        mixAxisDelta(targetDelta.x, delta.x, progress2), mixAxisDelta(targetDelta.y, delta.y, progress2), this.setTargetDelta(targetDelta), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox), mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2), prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget) && (this.isProjectionDirty = !1), prevRelativeTarget || (prevRelativeTarget = createBox()), copyBoxInto(prevRelativeTarget, this.relativeTarget)), isSharedLayoutAnimation && (this.animationValues = mixedValues, mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = progress2;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(options) {
      this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (cancelFrame(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = frame.update(() => {
        globalProjectionState.hasAnimatedSinceResize = !0, this.currentAnimation = animateSingleValue(0, animationTarget, {
          ...options,
          onUpdate: (latest) => {
            this.mixTargetDelta(latest), options.onUpdate && options.onUpdate(latest);
          },
          onComplete: () => {
            options.onComplete && options.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const stack = this.getStack();
      stack && stack.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(animationTarget), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const lead = this.getLead();
      let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
      if (!(!targetWithTransforms || !target || !layout2)) {
        if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
          target = this.target || createBox();
          const xLength = calcLength(this.layout.layoutBox.x);
          target.x.min = lead.target.x.min, target.x.max = target.x.min + xLength;
          const yLength = calcLength(this.layout.layoutBox.y);
          target.y.min = lead.target.y.min, target.y.max = target.y.min + yLength;
        }
        copyBoxInto(targetWithTransforms, target), transformBox(targetWithTransforms, latestValues), calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
      }
    }
    registerSharedNode(layoutId, node2) {
      this.sharedNodes.has(layoutId) || this.sharedNodes.set(layoutId, new NodeStack()), this.sharedNodes.get(layoutId).add(node2);
      const config = node2.options.initialPromotionConfig;
      node2.promote({
        transition: config ? config.transition : void 0,
        preserveFollowOpacity: config && config.shouldPreserveFollowOpacity ? config.shouldPreserveFollowOpacity(node2) : void 0
      });
    }
    isLead() {
      const stack = this.getStack();
      return stack ? stack.lead === this : !0;
    }
    getLead() {
      var _a2;
      const { layoutId } = this.options;
      return layoutId ? ((_a2 = this.getStack()) === null || _a2 === void 0 ? void 0 : _a2.lead) || this : this;
    }
    getPrevLead() {
      var _a2;
      const { layoutId } = this.options;
      return layoutId ? (_a2 = this.getStack()) === null || _a2 === void 0 ? void 0 : _a2.prevLead : void 0;
    }
    getStack() {
      const { layoutId } = this.options;
      if (layoutId)
        return this.root.sharedNodes.get(layoutId);
    }
    promote({ needsReset, transition, preserveFollowOpacity } = {}) {
      const stack = this.getStack();
      stack && stack.promote(this, preserveFollowOpacity), needsReset && (this.projectionDelta = void 0, this.needsReset = !0), transition && this.setOptions({ transition });
    }
    relegate() {
      const stack = this.getStack();
      return stack ? stack.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement } = this.options;
      if (!visualElement)
        return;
      let hasDistortingTransform = !1;
      const { latestValues } = visualElement;
      if ((latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) && (hasDistortingTransform = !0), !hasDistortingTransform)
        return;
      const resetValues = {};
      latestValues.z && resetDistortingTransform("z", visualElement, resetValues, this.animationValues);
      for (let i2 = 0; i2 < transformAxes.length; i2++)
        resetDistortingTransform(`rotate${transformAxes[i2]}`, visualElement, resetValues, this.animationValues), resetDistortingTransform(`skew${transformAxes[i2]}`, visualElement, resetValues, this.animationValues);
      visualElement.render();
      for (const key in resetValues)
        visualElement.setStaticValue(key, resetValues[key]), this.animationValues && (this.animationValues[key] = resetValues[key]);
      visualElement.scheduleRender();
    }
    getProjectionStyles(styleProp) {
      var _a2, _b;
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible)
        return hiddenVisibility;
      const styles = {
        visibility: ""
      }, transformTemplate = this.getTransformTemplate();
      if (this.needsReset)
        return this.needsReset = !1, styles.opacity = "", styles.pointerEvents = resolveMotionValue(styleProp?.pointerEvents) || "", styles.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none", styles;
      const lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        const emptyStyles = {};
        return this.options.layoutId && (emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, emptyStyles.pointerEvents = resolveMotionValue(styleProp?.pointerEvents) || ""), this.hasProjected && !hasTransform(this.latestValues) && (emptyStyles.transform = transformTemplate ? transformTemplate({}, "") : "none", this.hasProjected = !1), emptyStyles;
      }
      const valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget(), styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender), transformTemplate && (styles.transform = transformTemplate(valuesToRender, styles.transform));
      const { x: x2, y: y2 } = this.projectionDelta;
      styles.transformOrigin = `${x2.origin * 100}% ${y2.origin * 100}% 0`, lead.animationValues ? styles.opacity = lead === this ? (_b = (_a2 = valuesToRender.opacity) !== null && _a2 !== void 0 ? _a2 : this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit : styles.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
      for (const key in scaleCorrectors) {
        if (valuesToRender[key] === void 0)
          continue;
        const { correct, applyTo } = scaleCorrectors[key], corrected = styles.transform === "none" ? valuesToRender[key] : correct(valuesToRender[key], lead);
        if (applyTo) {
          const num = applyTo.length;
          for (let i2 = 0; i2 < num; i2++)
            styles[applyTo[i2]] = corrected;
        } else
          styles[key] = corrected;
      }
      return this.options.layoutId && (styles.pointerEvents = lead === this ? resolveMotionValue(styleProp?.pointerEvents) || "" : "none"), styles;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((node2) => {
        var _a2;
        return (_a2 = node2.currentAnimation) === null || _a2 === void 0 ? void 0 : _a2.stop();
      }), this.root.nodes.forEach(clearMeasurements), this.root.sharedNodes.clear();
    }
  };
}
function updateLayout(node2) {
  node2.updateLayout();
}
function notifyLayoutUpdate(node2) {
  var _a2;
  const snapshot = ((_a2 = node2.resumeFrom) === null || _a2 === void 0 ? void 0 : _a2.snapshot) || node2.snapshot;
  if (node2.isLead() && node2.layout && snapshot && node2.hasListeners("didUpdate")) {
    const { layoutBox: layout2, measuredBox: measuredLayout } = node2.layout, { animationType } = node2.options, isShared = snapshot.source !== node2.layout.source;
    animationType === "size" ? eachAxis((axis) => {
      const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis], length = calcLength(axisSnapshot);
      axisSnapshot.min = layout2[axis].min, axisSnapshot.max = axisSnapshot.min + length;
    }) : shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2) && eachAxis((axis) => {
      const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis], length = calcLength(layout2[axis]);
      axisSnapshot.max = axisSnapshot.min + length, node2.relativeTarget && !node2.currentAnimation && (node2.isProjectionDirty = !0, node2.relativeTarget[axis].max = node2.relativeTarget[axis].min + length);
    });
    const layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
    const visualDelta = createDelta();
    isShared ? calcBoxDelta(visualDelta, node2.applyTransform(measuredLayout, !0), snapshot.measuredBox) : calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
    const hasLayoutChanged = !isDeltaZero(layoutDelta);
    let hasRelativeTargetChanged = !1;
    if (!node2.resumeFrom) {
      const relativeParent = node2.getClosestProjectingParent();
      if (relativeParent && !relativeParent.resumeFrom) {
        const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
        if (parentSnapshot && parentLayout) {
          const relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
          const relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox), boxEqualsRounded(relativeSnapshot, relativeLayout) || (hasRelativeTargetChanged = !0), relativeParent.options.layoutRoot && (node2.relativeTarget = relativeLayout, node2.relativeTargetOrigin = relativeSnapshot, node2.relativeParent = relativeParent);
        }
      }
    }
    node2.notifyListeners("didUpdate", {
      layout: layout2,
      snapshot,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeTargetChanged
    });
  } else if (node2.isLead()) {
    const { onExitComplete } = node2.options;
    onExitComplete && onExitComplete();
  }
  node2.options.transition = void 0;
}
function propagateDirtyNodes(node2) {
  isDebug && metrics.totalNodes++, node2.parent && (node2.isProjecting() || (node2.isProjectionDirty = node2.parent.isProjectionDirty), node2.isSharedProjectionDirty || (node2.isSharedProjectionDirty = !!(node2.isProjectionDirty || node2.parent.isProjectionDirty || node2.parent.isSharedProjectionDirty)), node2.isTransformDirty || (node2.isTransformDirty = node2.parent.isTransformDirty));
}
function cleanDirtyNodes(node2) {
  node2.isProjectionDirty = node2.isSharedProjectionDirty = node2.isTransformDirty = !1;
}
function clearSnapshot(node2) {
  node2.clearSnapshot();
}
function clearMeasurements(node2) {
  node2.clearMeasurements();
}
function clearIsLayoutDirty(node2) {
  node2.isLayoutDirty = !1;
}
function resetTransformStyle(node2) {
  const { visualElement } = node2.options;
  visualElement && visualElement.getProps().onBeforeLayoutMeasure && visualElement.notify("BeforeLayoutMeasure"), node2.resetTransform();
}
function finishAnimation(node2) {
  node2.finishAnimation(), node2.targetDelta = node2.relativeTarget = node2.target = void 0, node2.isProjectionDirty = !0;
}
function resolveTargetDelta(node2) {
  node2.resolveTargetDelta();
}
function calcProjection(node2) {
  node2.calcProjection();
}
function resetSkewAndRotation(node2) {
  node2.resetSkewAndRotation();
}
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
function mixAxisDelta(output, delta, p2) {
  output.translate = mixNumber$1(delta.translate, 0, p2), output.scale = mixNumber$1(delta.scale, 1, p2), output.origin = delta.origin, output.originPoint = delta.originPoint;
}
function mixAxis(output, from, to, p2) {
  output.min = mixNumber$1(from.min, to.min, p2), output.max = mixNumber$1(from.max, to.max, p2);
}
function mixBox(output, from, to, p2) {
  mixAxis(output.x, from.x, to.x, p2), mixAxis(output.y, from.y, to.y, p2);
}
function hasOpacityCrossfade(node2) {
  return node2.animationValues && node2.animationValues.opacityExit !== void 0;
}
const defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, userAgentContains = (string) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string), roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop$2;
function roundAxis(axis) {
  axis.min = roundPoint(axis.min), axis.max = roundPoint(axis.max);
}
function roundBox(box) {
  roundAxis(box.x), roundAxis(box.y);
}
function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
  return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);
}
function checkNodeWasScrollRoot(node2) {
  var _a2;
  return node2 !== node2.root && ((_a2 = node2.scroll) === null || _a2 === void 0 ? void 0 : _a2.wasRoot);
}
const DocumentProjectionNode = createProjectionNode$1({
  attachResizeListener: (ref, notify2) => addDomEvent(ref, "resize", notify2),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => !0
}), rootProjectionNode = {
  current: void 0
}, HTMLProjectionNode = createProjectionNode$1({
  measureScroll: (instance) => ({
    x: instance.scrollLeft,
    y: instance.scrollTop
  }),
  defaultParent: () => {
    if (!rootProjectionNode.current) {
      const documentNode = new DocumentProjectionNode({});
      documentNode.mount(window), documentNode.setOptions({ layoutScroll: !0 }), rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: (instance, value) => {
    instance.style.transform = value !== void 0 ? value : "none";
  },
  checkIsScrollRoot: (instance) => window.getComputedStyle(instance).position === "fixed"
}), drag = {
  pan: {
    Feature: PanGesture
  },
  drag: {
    Feature: DragGesture,
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};
function addHoverEvent(node2, isActive) {
  const eventName = isActive ? "pointerenter" : "pointerleave", callbackName = isActive ? "onHoverStart" : "onHoverEnd", handleEvent = (event, info) => {
    if (event.pointerType === "touch" || isDragActive())
      return;
    const props2 = node2.getProps();
    node2.animationState && props2.whileHover && node2.animationState.setActive("whileHover", isActive);
    const callback = props2[callbackName];
    callback && frame.postRender(() => callback(event, info));
  };
  return addPointerEvent(node2.current, eventName, handleEvent, {
    passive: !node2.getProps()[callbackName]
  });
}
class HoverGesture extends Feature {
  mount() {
    this.unmount = pipe(addHoverEvent(this.node, !0), addHoverEvent(this.node, !1));
  }
  unmount() {
  }
}
class FocusGesture extends Feature {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let isFocusVisible = !1;
    try {
      isFocusVisible = this.node.current.matches(":focus-visible");
    } catch {
      isFocusVisible = !0;
    }
    !isFocusVisible || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
const isNodeOrChild = (parent, child) => child ? parent === child ? !0 : isNodeOrChild(parent, child.parentElement) : !1;
function fireSyntheticPointerEvent(name, handler) {
  if (!handler)
    return;
  const syntheticPointerEvent = new PointerEvent("pointer" + name);
  handler(syntheticPointerEvent, extractEventInfo(syntheticPointerEvent));
}
class PressGesture extends Feature {
  constructor() {
    super(...arguments), this.removeStartListeners = noop$2, this.removeEndListeners = noop$2, this.removeAccessibleListeners = noop$2, this.startPointerPress = (startEvent, startInfo) => {
      if (this.isPressing)
        return;
      this.removeEndListeners();
      const props2 = this.node.getProps(), removePointerUpListener = addPointerEvent(window, "pointerup", (endEvent, endInfo) => {
        if (!this.checkPressEnd())
          return;
        const { onTap, onTapCancel, globalTapTarget } = this.node.getProps(), handler = !globalTapTarget && !isNodeOrChild(this.node.current, endEvent.target) ? onTapCancel : onTap;
        handler && frame.update(() => handler(endEvent, endInfo));
      }, {
        passive: !(props2.onTap || props2.onPointerUp)
      }), removePointerCancelListener = addPointerEvent(window, "pointercancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo), {
        passive: !(props2.onTapCancel || props2.onPointerCancel)
      });
      this.removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener), this.startPress(startEvent, startInfo);
    }, this.startAccessiblePress = () => {
      const handleKeydown = (keydownEvent) => {
        if (keydownEvent.key !== "Enter" || this.isPressing)
          return;
        const handleKeyup = (keyupEvent) => {
          keyupEvent.key !== "Enter" || !this.checkPressEnd() || fireSyntheticPointerEvent("up", (event, info) => {
            const { onTap } = this.node.getProps();
            onTap && frame.postRender(() => onTap(event, info));
          });
        };
        this.removeEndListeners(), this.removeEndListeners = addDomEvent(this.node.current, "keyup", handleKeyup), fireSyntheticPointerEvent("down", (event, info) => {
          this.startPress(event, info);
        });
      }, removeKeydownListener = addDomEvent(this.node.current, "keydown", handleKeydown), handleBlur = () => {
        this.isPressing && fireSyntheticPointerEvent("cancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo));
      }, removeBlurListener = addDomEvent(this.node.current, "blur", handleBlur);
      this.removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);
    };
  }
  startPress(event, info) {
    this.isPressing = !0;
    const { onTapStart, whileTap } = this.node.getProps();
    whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !0), onTapStart && frame.postRender(() => onTapStart(event, info));
  }
  checkPressEnd() {
    return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !isDragActive();
  }
  cancelPress(event, info) {
    if (!this.checkPressEnd())
      return;
    const { onTapCancel } = this.node.getProps();
    onTapCancel && frame.postRender(() => onTapCancel(event, info));
  }
  mount() {
    const props2 = this.node.getProps(), removePointerListener = addPointerEvent(props2.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, {
      passive: !(props2.onTapStart || props2.onPointerStart)
    }), removeFocusListener = addDomEvent(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = pipe(removePointerListener, removeFocusListener);
  }
  unmount() {
    this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners();
  }
}
const observerCallbacks = /* @__PURE__ */ new WeakMap(), observers = /* @__PURE__ */ new WeakMap(), fireObserverCallback = (entry) => {
  const callback = observerCallbacks.get(entry.target);
  callback && callback(entry);
}, fireAllObserverCallbacks = (entries) => {
  entries.forEach(fireObserverCallback);
};
function initIntersectionObserver({ root: root2, ...options }) {
  const lookupRoot = root2 || document;
  observers.has(lookupRoot) || observers.set(lookupRoot, {});
  const rootObservers = observers.get(lookupRoot), key = JSON.stringify(options);
  return rootObservers[key] || (rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root: root2, ...options })), rootObservers[key];
}
function observeIntersection(element, options, callback) {
  const rootInteresectionObserver = initIntersectionObserver(options);
  return observerCallbacks.set(element, callback), rootInteresectionObserver.observe(element), () => {
    observerCallbacks.delete(element), rootInteresectionObserver.unobserve(element);
  };
}
const thresholdNames = {
  some: 0,
  all: 1
};
class InViewFeature extends Feature {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport = {} } = this.node.getProps(), { root: root2, margin: rootMargin, amount = "some", once } = viewport, options = {
      root: root2 ? root2.current : void 0,
      rootMargin,
      threshold: typeof amount == "number" ? amount : thresholdNames[amount]
    }, onIntersectionUpdate = (entry) => {
      const { isIntersecting } = entry;
      if (this.isInView === isIntersecting || (this.isInView = isIntersecting, once && !isIntersecting && this.hasEnteredView))
        return;
      isIntersecting && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", isIntersecting);
      const { onViewportEnter, onViewportLeave } = this.node.getProps(), callback = isIntersecting ? onViewportEnter : onViewportLeave;
      callback && callback(entry);
    };
    return observeIntersection(this.node.current, options, onIntersectionUpdate);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: props2, prevProps } = this.node;
    ["amount", "margin", "root"].some(hasViewportOptionChanged(props2, prevProps)) && this.startObserver();
  }
  unmount() {
  }
}
function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
  return (name) => viewport[name] !== prevViewport[name];
}
const gestureAnimations = {
  inView: {
    Feature: InViewFeature
  },
  tap: {
    Feature: PressGesture
  },
  focus: {
    Feature: FocusGesture
  },
  hover: {
    Feature: HoverGesture
  }
}, layout$3 = {
  layout: {
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
}, MotionConfigContext = createContext$1({
  transformPagePoint: (p2) => p2,
  isStatic: !1,
  reducedMotion: "never"
}), MotionContext = createContext$1({}), isBrowser$1 = typeof window < "u", useIsomorphicLayoutEffect$2 = isBrowser$1 ? useLayoutEffect$1 : useEffect$1, LazyContext = createContext$1({ strict: !1 });
function useVisualElement(Component2, visualState, props2, createVisualElement, ProjectionNodeConstructor) {
  var _a2, _b;
  const { visualElement: parent } = useContext$1(MotionContext), lazyContext = useContext$1(LazyContext), presenceContext = useContext$1(PresenceContext), reducedMotionConfig = useContext$1(MotionConfigContext).reducedMotion, visualElementRef = useRef$1();
  createVisualElement = createVisualElement || lazyContext.renderer, !visualElementRef.current && createVisualElement && (visualElementRef.current = createVisualElement(Component2, {
    visualState,
    parent,
    props: props2,
    presenceContext,
    blockInitialAnimation: presenceContext ? presenceContext.initial === !1 : !1,
    reducedMotionConfig
  }));
  const visualElement = visualElementRef.current, initialLayoutGroupConfig = useContext$1(SwitchLayoutGroupContext);
  visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === "html" || visualElement.type === "svg") && createProjectionNode(visualElementRef.current, props2, ProjectionNodeConstructor, initialLayoutGroupConfig);
  const isMounted = useRef$1(!1);
  useInsertionEffect(() => {
    visualElement && isMounted.current && visualElement.update(props2, presenceContext);
  });
  const optimisedAppearId = props2[optimizedAppearDataAttribute], wantsHandoff = useRef$1(!!optimisedAppearId && !(!((_a2 = window.MotionHandoffIsComplete) === null || _a2 === void 0) && _a2.call(window, optimisedAppearId)) && ((_b = window.MotionHasOptimisedAnimation) === null || _b === void 0 ? void 0 : _b.call(window, optimisedAppearId)));
  return useIsomorphicLayoutEffect$2(() => {
    visualElement && (isMounted.current = !0, window.MotionIsMounted = !0, visualElement.updateFeatures(), microtask.render(visualElement.render), wantsHandoff.current && visualElement.animationState && visualElement.animationState.animateChanges());
  }), useEffect$1(() => {
    visualElement && (!wantsHandoff.current && visualElement.animationState && visualElement.animationState.animateChanges(), wantsHandoff.current && (queueMicrotask(() => {
      var _a3;
      (_a3 = window.MotionHandoffMarkAsComplete) === null || _a3 === void 0 || _a3.call(window, optimisedAppearId);
    }), wantsHandoff.current = !1));
  }), visualElement;
}
function createProjectionNode(visualElement, props2, ProjectionNodeConstructor, initialPromotionConfig) {
  const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot } = props2;
  visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props2["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(visualElement.parent)), visualElement.projection.setOptions({
    layoutId,
    layout: layout2,
    alwaysMeasureLayout: !!drag2 || dragConstraints && isRefObject(dragConstraints),
    visualElement,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof layout2 == "string" ? layout2 : "both",
    initialPromotionConfig,
    layoutScroll,
    layoutRoot
  });
}
function getClosestProjectingNode(visualElement) {
  if (visualElement)
    return visualElement.options.allowProjection !== !1 ? visualElement.projection : getClosestProjectingNode(visualElement.parent);
}
function useMotionRef(visualState, visualElement, externalRef) {
  return useCallback$1(
    (instance) => {
      instance && visualState.mount && visualState.mount(instance), visualElement && (instance ? visualElement.mount(instance) : visualElement.unmount()), externalRef && (typeof externalRef == "function" ? externalRef(instance) : isRefObject(externalRef) && (externalRef.current = instance));
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [visualElement]
  );
}
function isControllingVariants(props2) {
  return isAnimationControls(props2.animate) || variantProps.some((name) => isVariantLabel(props2[name]));
}
function isVariantNode(props2) {
  return !!(isControllingVariants(props2) || props2.variants);
}
function getCurrentTreeVariants(props2, context) {
  if (isControllingVariants(props2)) {
    const { initial, animate } = props2;
    return {
      initial: initial === !1 || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate) ? animate : void 0
    };
  }
  return props2.inherit !== !1 ? context : {};
}
function useCreateMotionContext(props2) {
  const { initial, animate } = getCurrentTreeVariants(props2, useContext$1(MotionContext));
  return useMemo$1(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
}
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}
const featureProps = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, featureDefinitions = {};
for (const key in featureProps)
  featureDefinitions[key] = {
    isEnabled: (props2) => featureProps[key].some((name) => !!props2[name])
  };
function loadFeatures(features) {
  for (const key in features)
    featureDefinitions[key] = {
      ...featureDefinitions[key],
      ...features[key]
    };
}
const motionComponentSymbol = Symbol.for("motionComponentSymbol");
function createRendererMotionComponent({ preloadedFeatures, createVisualElement, useRender, useVisualState, Component: Component2 }) {
  preloadedFeatures && loadFeatures(preloadedFeatures);
  function MotionComponent(props2, externalRef) {
    let MeasureLayout2;
    const configAndProps = {
      ...useContext$1(MotionConfigContext),
      ...props2,
      layoutId: useLayoutId(props2)
    }, { isStatic } = configAndProps, context = useCreateMotionContext(props2), visualState = useVisualState(props2, isStatic);
    if (!isStatic && isBrowser$1) {
      useStrictMode();
      const layoutProjection = getProjectionFunctionality(configAndProps);
      MeasureLayout2 = layoutProjection.MeasureLayout, context.visualElement = useVisualElement(Component2, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);
    }
    return jsxs(MotionContext.Provider, { value: context, children: [MeasureLayout2 && context.visualElement ? jsx(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps }) : null, useRender(Component2, props2, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)] });
  }
  const ForwardRefMotionComponent = forwardRef$1(MotionComponent);
  return ForwardRefMotionComponent[motionComponentSymbol] = Component2, ForwardRefMotionComponent;
}
function useLayoutId({ layoutId }) {
  const layoutGroupId = useContext$1(LayoutGroupContext).id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}
function useStrictMode(configAndProps, preloadedFeatures) {
  useContext$1(LazyContext).strict;
}
function getProjectionFunctionality(props2) {
  const { drag: drag2, layout: layout2 } = featureDefinitions;
  if (!drag2 && !layout2)
    return {};
  const combined = { ...drag2, ...layout2 };
  return {
    MeasureLayout: drag2?.isEnabled(props2) || layout2?.isEnabled(props2) ? combined.MeasureLayout : void 0,
    ProjectionNode: combined.ProjectionNode
  };
}
const lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function isSVGComponent(Component2) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component2 != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    Component2.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(lowercaseSVGElements.indexOf(Component2) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/u.test(Component2))
    )
  );
}
function renderHTML(element, { style, vars: vars2 }, styleProp, projection) {
  Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
  for (const key in vars2)
    element.style.setProperty(key, vars2[key]);
}
const camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, void 0, projection);
  for (const key in renderState.attrs)
    element.setAttribute(camelCaseAttributes.has(key) ? key : camelToDash(key), renderState.attrs[key]);
}
function isForcedMotionValue(key, { layout: layout2, layoutId }) {
  return transformProps.has(key) || key.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
}
function scrapeMotionValuesFromProps$1(props2, prevProps, visualElement) {
  var _a2;
  const { style } = props2, newValues = {};
  for (const key in style)
    (isMotionValue(style[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props2) || ((_a2 = visualElement?.getValue(key)) === null || _a2 === void 0 ? void 0 : _a2.liveStyle) !== void 0) && (newValues[key] = style[key]);
  return newValues;
}
function scrapeMotionValuesFromProps(props2, prevProps, visualElement) {
  const newValues = scrapeMotionValuesFromProps$1(props2, prevProps, visualElement);
  for (const key in props2)
    if (isMotionValue(props2[key]) || isMotionValue(prevProps[key])) {
      const targetKey = transformPropOrder.indexOf(key) !== -1 ? "attr" + key.charAt(0).toUpperCase() + key.substring(1) : key;
      newValues[targetKey] = props2[key];
    }
  return newValues;
}
function useConstant(init) {
  const ref = useRef$1(null);
  return ref.current === null && (ref.current = init()), ref.current;
}
function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2, createRenderState, onMount: onMount2 }, props2, context, presenceContext) {
  const state = {
    latestValues: makeLatestValues(props2, context, presenceContext, scrapeMotionValuesFromProps2),
    renderState: createRenderState()
  };
  return onMount2 && (state.mount = (instance) => onMount2(props2, instance, state)), state;
}
const makeUseVisualState = (config) => (props2, isStatic) => {
  const context = useContext$1(MotionContext), presenceContext = useContext$1(PresenceContext), make = () => makeState(config, props2, context, presenceContext);
  return isStatic ? make() : useConstant(make);
};
function makeLatestValues(props2, context, presenceContext, scrapeMotionValues) {
  const values = {}, motionValues = scrapeMotionValues(props2, {});
  for (const key in motionValues)
    values[key] = resolveMotionValue(motionValues[key]);
  let { initial, animate } = props2;
  const isControllingVariants$1 = isControllingVariants(props2), isVariantNode$1 = isVariantNode(props2);
  context && isVariantNode$1 && !isControllingVariants$1 && props2.inherit !== !1 && (initial === void 0 && (initial = context.initial), animate === void 0 && (animate = context.animate));
  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === !1 : !1;
  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === !1;
  const variantToSet = isInitialAnimationBlocked ? animate : initial;
  if (variantToSet && typeof variantToSet != "boolean" && !isAnimationControls(variantToSet)) {
    const list2 = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    for (let i2 = 0; i2 < list2.length; i2++) {
      const resolved = resolveVariantFromProps(props2, list2[i2]);
      if (resolved) {
        const { transitionEnd, transition, ...target } = resolved;
        for (const key in target) {
          let valueTarget = target[key];
          if (Array.isArray(valueTarget)) {
            const index2 = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
            valueTarget = valueTarget[index2];
          }
          valueTarget !== null && (values[key] = valueTarget);
        }
        for (const key in transitionEnd)
          values[key] = transitionEnd[key];
      }
    }
  }
  return values;
}
const createHtmlRenderState = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
}), createSvgRenderState = () => ({
  ...createHtmlRenderState(),
  attrs: {}
}), getValueAsType = (value, type) => type && typeof value == "number" ? type.transform(value) : value, translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, numTransforms = transformPropOrder.length;
function buildTransform(latestValues, transform, transformTemplate) {
  let transformString = "", transformIsDefault = !0;
  for (let i2 = 0; i2 < numTransforms; i2++) {
    const key = transformPropOrder[i2], value = latestValues[key];
    if (value === void 0)
      continue;
    let valueIsDefault = !0;
    if (typeof value == "number" ? valueIsDefault = value === (key.startsWith("scale") ? 1 : 0) : valueIsDefault = parseFloat(value) === 0, !valueIsDefault || transformTemplate) {
      const valueAsType = getValueAsType(value, numberValueTypes[key]);
      if (!valueIsDefault) {
        transformIsDefault = !1;
        const transformName = translateAlias[key] || key;
        transformString += `${transformName}(${valueAsType}) `;
      }
      transformTemplate && (transform[key] = valueAsType);
    }
  }
  return transformString = transformString.trim(), transformTemplate ? transformString = transformTemplate(transform, transformIsDefault ? "" : transformString) : transformIsDefault && (transformString = "none"), transformString;
}
function buildHTMLStyles(state, latestValues, transformTemplate) {
  const { style, vars: vars2, transformOrigin } = state;
  let hasTransform2 = !1, hasTransformOrigin = !1;
  for (const key in latestValues) {
    const value = latestValues[key];
    if (transformProps.has(key)) {
      hasTransform2 = !0;
      continue;
    } else if (isCSSVariableName(key)) {
      vars2[key] = value;
      continue;
    } else {
      const valueAsType = getValueAsType(value, numberValueTypes[key]);
      key.startsWith("origin") ? (hasTransformOrigin = !0, transformOrigin[key] = valueAsType) : style[key] = valueAsType;
    }
  }
  if (latestValues.transform || (hasTransform2 || transformTemplate ? style.transform = buildTransform(latestValues, state.transform, transformTemplate) : style.transform && (style.transform = "none")), hasTransformOrigin) {
    const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
    style.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}
function calcOrigin(origin, offset, size) {
  return typeof origin == "string" ? origin : px.transform(offset + size * origin);
}
function calcSVGTransformOrigin(dimensions, originX, originY) {
  const pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width), pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);
  return `${pxOriginX} ${pxOriginY}`;
}
const dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = !0) {
  attrs.pathLength = 1;
  const keys2 = useDashCase ? dashKeys : camelKeys;
  attrs[keys2.offset] = px.transform(-offset);
  const pathLength = px.transform(length), pathSpacing = px.transform(spacing);
  attrs[keys2.array] = `${pathLength} ${pathSpacing}`;
}
function buildSVGAttrs(state, {
  attrX,
  attrY,
  attrScale,
  originX,
  originY,
  pathLength,
  pathSpacing = 1,
  pathOffset = 0,
  // This is object creation, which we try to avoid per-frame.
  ...latest
}, isSVGTag2, transformTemplate) {
  if (buildHTMLStyles(state, latest, transformTemplate), isSVGTag2) {
    state.style.viewBox && (state.attrs.viewBox = state.style.viewBox);
    return;
  }
  state.attrs = state.style, state.style = {};
  const { attrs, style, dimensions } = state;
  attrs.transform && (dimensions && (style.transform = attrs.transform), delete attrs.transform), dimensions && (originX !== void 0 || originY !== void 0 || style.transform) && (style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5)), attrX !== void 0 && (attrs.x = attrX), attrY !== void 0 && (attrs.y = attrY), attrScale !== void 0 && (attrs.scale = attrScale), pathLength !== void 0 && buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, !1);
}
const isSVGTag = (tag) => typeof tag == "string" && tag.toLowerCase() === "svg", svgMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createSvgRenderState,
    onMount: (props2, instance, { renderState, latestValues }) => {
      frame.read(() => {
        try {
          renderState.dimensions = typeof instance.getBBox == "function" ? instance.getBBox() : instance.getBoundingClientRect();
        } catch {
          renderState.dimensions = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
      }), frame.render(() => {
        buildSVGAttrs(renderState, latestValues, isSVGTag(instance.tagName), props2.transformTemplate), renderSVG(instance, renderState);
      });
    }
  })
}, htmlMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
    createRenderState: createHtmlRenderState
  })
};
function copyRawValuesOnly(target, source, props2) {
  for (const key in source)
    !isMotionValue(source[key]) && !isForcedMotionValue(key, props2) && (target[key] = source[key]);
}
function useInitialMotionValues({ transformTemplate }, visualState) {
  return useMemo$1(() => {
    const state = createHtmlRenderState();
    return buildHTMLStyles(state, visualState, transformTemplate), Object.assign({}, state.vars, state.style);
  }, [visualState]);
}
function useStyle(props2, visualState) {
  const styleProp = props2.style || {}, style = {};
  return copyRawValuesOnly(style, styleProp, props2), Object.assign(style, useInitialMotionValues(props2, visualState)), style;
}
function useHTMLProps(props2, visualState) {
  const htmlProps = {}, style = useStyle(props2, visualState);
  return props2.drag && props2.dragListener !== !1 && (htmlProps.draggable = !1, style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none", style.touchAction = props2.drag === !0 ? "none" : `pan-${props2.drag === "x" ? "y" : "x"}`), props2.tabIndex === void 0 && (props2.onTap || props2.onTapStart || props2.whileTap) && (htmlProps.tabIndex = 0), htmlProps.style = style, htmlProps;
}
const validMotionProps = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function isValidMotionProp(key) {
  return key.startsWith("while") || key.startsWith("drag") && key !== "draggable" || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || key.startsWith("onLayout") || validMotionProps.has(key);
}
let shouldForward = (key) => !isValidMotionProp(key);
function loadExternalIsValidProp(isValidProp) {
  isValidProp && (shouldForward = (key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key));
}
try {
  loadExternalIsValidProp((void 0).default);
} catch {
}
function filterProps(props2, isDom, forwardMotionProps) {
  const filteredProps = {};
  for (const key in props2)
    key === "values" && typeof props2.values == "object" || (shouldForward(key) || forwardMotionProps === !0 && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || // If trying to use native HTML drag events, forward drag listeners
    props2.draggable && key.startsWith("onDrag")) && (filteredProps[key] = props2[key]);
  return filteredProps;
}
function useSVGProps(props2, visualState, _isStatic, Component2) {
  const visualProps = useMemo$1(() => {
    const state = createSvgRenderState();
    return buildSVGAttrs(state, visualState, isSVGTag(Component2), props2.transformTemplate), {
      ...state.attrs,
      style: { ...state.style }
    };
  }, [visualState]);
  if (props2.style) {
    const rawStyles = {};
    copyRawValuesOnly(rawStyles, props2.style, props2), visualProps.style = { ...rawStyles, ...visualProps.style };
  }
  return visualProps;
}
function createUseRender(forwardMotionProps = !1) {
  return (Component2, props2, ref, { latestValues }, isStatic) => {
    const visualProps = (isSVGComponent(Component2) ? useSVGProps : useHTMLProps)(props2, latestValues, isStatic, Component2), filteredProps = filterProps(props2, typeof Component2 == "string", forwardMotionProps), elementProps = Component2 !== Fragment ? { ...filteredProps, ...visualProps, ref } : {}, { children } = props2, renderedChildren = useMemo$1(() => isMotionValue(children) ? children.get() : children, [children]);
    return createElement$1(Component2, {
      ...elementProps,
      children: renderedChildren
    });
  };
}
function createMotionComponentFactory(preloadedFeatures, createVisualElement) {
  return function(Component2, { forwardMotionProps } = { forwardMotionProps: !1 }) {
    const config = {
      ...isSVGComponent(Component2) ? svgMotionConfig : htmlMotionConfig,
      preloadedFeatures,
      useRender: createUseRender(forwardMotionProps),
      createVisualElement,
      Component: Component2
    };
    return createRendererMotionComponent(config);
  };
}
const prefersReducedMotion = { current: null }, hasReducedMotionListener = { current: !1 };
function initPrefersReducedMotion() {
  if (hasReducedMotionListener.current = !0, !!isBrowser$1)
    if (window.matchMedia) {
      const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)"), setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
      motionMediaQuery.addListener(setReducedMotionPreferences), setReducedMotionPreferences();
    } else
      prefersReducedMotion.current = !1;
}
function updateMotionValuesFromProps(element, next, prev) {
  for (const key in next) {
    const nextValue = next[key], prevValue = prev[key];
    if (isMotionValue(nextValue))
      element.addValue(key, nextValue);
    else if (isMotionValue(prevValue))
      element.addValue(key, motionValue(nextValue, { owner: element }));
    else if (prevValue !== nextValue)
      if (element.hasValue(key)) {
        const existingValue = element.getValue(key);
        existingValue.liveStyle === !0 ? existingValue.jump(nextValue) : existingValue.hasAnimated || existingValue.set(nextValue);
      } else {
        const latestValue = element.getStaticValue(key);
        element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
      }
  }
  for (const key in prev)
    next[key] === void 0 && element.removeValue(key);
  return next;
}
const visualElementStore = /* @__PURE__ */ new WeakMap(), valueTypes = [...dimensionValueTypes, color, complex], findValueType = (v) => valueTypes.find(testValueType(v)), propEventHandlers = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class VisualElement {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
    return {};
  }
  constructor({ parent, props: props2, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState }, options = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = KeyframeResolver, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.renderScheduledAt = 0, this.scheduleRender = () => {
      const now2 = time$1.now();
      this.renderScheduledAt < now2 && (this.renderScheduledAt = now2, frame.render(this.render, !1, !0));
    };
    const { latestValues, renderState } = visualState;
    this.latestValues = latestValues, this.baseTarget = { ...latestValues }, this.initialValues = props2.initial ? { ...latestValues } : {}, this.renderState = renderState, this.parent = parent, this.props = props2, this.presenceContext = presenceContext, this.depth = parent ? parent.depth + 1 : 0, this.reducedMotionConfig = reducedMotionConfig, this.options = options, this.blockInitialAnimation = !!blockInitialAnimation, this.isControllingVariants = isControllingVariants(props2), this.isVariantNode = isVariantNode(props2), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(parent && parent.current);
    const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props2, {}, this);
    for (const key in initialMotionValues) {
      const value = initialMotionValues[key];
      latestValues[key] !== void 0 && isMotionValue(value) && value.set(latestValues[key], !1);
    }
  }
  mount(instance) {
    this.current = instance, visualElementStore.set(instance, this), this.projection && !this.projection.instance && this.projection.mount(instance), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((value, key) => this.bindToMotionValue(key, value)), hasReducedMotionListener.current || initPrefersReducedMotion(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : prefersReducedMotion.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    visualElementStore.delete(this.current), this.projection && this.projection.unmount(), cancelFrame(this.notifyUpdate), cancelFrame(this.render), this.valueSubscriptions.forEach((remove) => remove()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
    for (const key in this.events)
      this.events[key].clear();
    for (const key in this.features) {
      const feature = this.features[key];
      feature && (feature.unmount(), feature.isMounted = !1);
    }
    this.current = null;
  }
  bindToMotionValue(key, value) {
    this.valueSubscriptions.has(key) && this.valueSubscriptions.get(key)();
    const valueIsTransform = transformProps.has(key), removeOnChange = value.on("change", (latestValue) => {
      this.latestValues[key] = latestValue, this.props.onUpdate && frame.preRender(this.notifyUpdate), valueIsTransform && this.projection && (this.projection.isTransformDirty = !0);
    }), removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
    let removeSyncCheck;
    window.MotionCheckAppearSync && (removeSyncCheck = window.MotionCheckAppearSync(this, key, value)), this.valueSubscriptions.set(key, () => {
      removeOnChange(), removeOnRenderRequest(), removeSyncCheck && removeSyncCheck(), value.owner && value.stop();
    });
  }
  sortNodePosition(other) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== other.type ? 0 : this.sortInstanceNodePosition(this.current, other.current);
  }
  updateFeatures() {
    let key = "animation";
    for (key in featureDefinitions) {
      const featureDefinition = featureDefinitions[key];
      if (!featureDefinition)
        continue;
      const { isEnabled, Feature: FeatureConstructor } = featureDefinition;
      if (!this.features[key] && FeatureConstructor && isEnabled(this.props) && (this.features[key] = new FeatureConstructor(this)), this.features[key]) {
        const feature = this.features[key];
        feature.isMounted ? feature.update() : (feature.mount(), feature.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
  }
  getStaticValue(key) {
    return this.latestValues[key];
  }
  setStaticValue(key, value) {
    this.latestValues[key] = value;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(props2, presenceContext) {
    (props2.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = props2, this.prevPresenceContext = this.presenceContext, this.presenceContext = presenceContext;
    for (let i2 = 0; i2 < propEventHandlers.length; i2++) {
      const key = propEventHandlers[i2];
      this.propEventSubscriptions[key] && (this.propEventSubscriptions[key](), delete this.propEventSubscriptions[key]);
      const listenerName = "on" + key, listener = props2[listenerName];
      listener && (this.propEventSubscriptions[key] = this.on(key, listener));
    }
    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props2, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(name) {
    return this.props.variants ? this.props.variants[name] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(child) {
    const closestVariantNode = this.getClosestVariantNode();
    if (closestVariantNode)
      return closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child), () => closestVariantNode.variantChildren.delete(child);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(key, value) {
    const existingValue = this.values.get(key);
    value !== existingValue && (existingValue && this.removeValue(key), this.bindToMotionValue(key, value), this.values.set(key, value), this.latestValues[key] = value.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(key) {
    this.values.delete(key);
    const unsubscribe = this.valueSubscriptions.get(key);
    unsubscribe && (unsubscribe(), this.valueSubscriptions.delete(key)), delete this.latestValues[key], this.removeValueFromRenderState(key, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(key) {
    return this.values.has(key);
  }
  getValue(key, defaultValue) {
    if (this.props.values && this.props.values[key])
      return this.props.values[key];
    let value = this.values.get(key);
    return value === void 0 && defaultValue !== void 0 && (value = motionValue(defaultValue === null ? void 0 : defaultValue, { owner: this }), this.addValue(key, value)), value;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(key, target) {
    var _a2;
    let value = this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : (_a2 = this.getBaseTargetFromProps(this.props, key)) !== null && _a2 !== void 0 ? _a2 : this.readValueFromInstance(this.current, key, this.options);
    return value != null && (typeof value == "string" && (isNumericalString(value) || isZeroValueString(value)) ? value = parseFloat(value) : !findValueType(value) && complex.test(target) && (value = getAnimatableNone(key, target)), this.setBaseTarget(key, isMotionValue(value) ? value.get() : value)), isMotionValue(value) ? value.get() : value;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(key, value) {
    this.baseTarget[key] = value;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(key) {
    var _a2;
    const { initial } = this.props;
    let valueFromInitial;
    if (typeof initial == "string" || typeof initial == "object") {
      const variant = resolveVariantFromProps(this.props, initial, (_a2 = this.presenceContext) === null || _a2 === void 0 ? void 0 : _a2.custom);
      variant && (valueFromInitial = variant[key]);
    }
    if (initial && valueFromInitial !== void 0)
      return valueFromInitial;
    const target = this.getBaseTargetFromProps(this.props, key);
    return target !== void 0 && !isMotionValue(target) ? target : this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];
  }
  on(eventName, callback) {
    return this.events[eventName] || (this.events[eventName] = new SubscriptionManager()), this.events[eventName].add(callback);
  }
  notify(eventName, ...args) {
    this.events[eventName] && this.events[eventName].notify(...args);
  }
}
class DOMVisualElement extends VisualElement {
  constructor() {
    super(...arguments), this.KeyframeResolver = DOMKeyframesResolver;
  }
  sortInstanceNodePosition(a2, b2) {
    return a2.compareDocumentPosition(b2) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(props2, key) {
    return props2.style ? props2.style[key] : void 0;
  }
  removeValueFromRenderState(key, { vars: vars2, style }) {
    delete vars2[key], delete style[key];
  }
}
function getComputedStyle$1(element) {
  return window.getComputedStyle(element);
}
class HTMLVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments), this.type = "html", this.renderInstance = renderHTML;
  }
  readValueFromInstance(instance, key) {
    if (transformProps.has(key)) {
      const defaultType = getDefaultValueType(key);
      return defaultType && defaultType.default || 0;
    } else {
      const computedStyle = getComputedStyle$1(instance), value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
      return typeof value == "string" ? value.trim() : value;
    }
  }
  measureInstanceViewportBox(instance, { transformPagePoint }) {
    return measureViewportBox(instance, transformPagePoint);
  }
  build(renderState, latestValues, props2) {
    buildHTMLStyles(renderState, latestValues, props2.transformTemplate);
  }
  scrapeMotionValuesFromProps(props2, prevProps, visualElement) {
    return scrapeMotionValuesFromProps$1(props2, prevProps, visualElement);
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children } = this.props;
    isMotionValue(children) && (this.childSubscription = children.on("change", (latest) => {
      this.current && (this.current.textContent = `${latest}`);
    }));
  }
}
class SVGVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = createBox;
  }
  getBaseTargetFromProps(props2, key) {
    return props2[key];
  }
  readValueFromInstance(instance, key) {
    if (transformProps.has(key)) {
      const defaultType = getDefaultValueType(key);
      return defaultType && defaultType.default || 0;
    }
    return key = camelCaseAttributes.has(key) ? key : camelToDash(key), instance.getAttribute(key);
  }
  scrapeMotionValuesFromProps(props2, prevProps, visualElement) {
    return scrapeMotionValuesFromProps(props2, prevProps, visualElement);
  }
  build(renderState, latestValues, props2) {
    buildSVGAttrs(renderState, latestValues, this.isSVGTag, props2.transformTemplate);
  }
  renderInstance(instance, renderState, styleProp, projection) {
    renderSVG(instance, renderState, styleProp, projection);
  }
  mount(instance) {
    this.isSVGTag = isSVGTag(instance.tagName), super.mount(instance);
  }
}
const createDomVisualElement = (Component2, options) => isSVGComponent(Component2) ? new SVGVisualElement(options) : new HTMLVisualElement(options, {
  allowProjection: Component2 !== Fragment
}), createMinimalMotionComponent = /* @__PURE__ */ createMotionComponentFactory(), m = /* @__PURE__ */ createDOMMotionComponentProxy(createMinimalMotionComponent);
class PopChildMeasure extends React.Component {
  getSnapshotBeforeUpdate(prevProps) {
    const element = this.props.childRef.current;
    if (element && prevProps.isPresent && !this.props.isPresent) {
      const size = this.props.sizeRef.current;
      size.height = element.offsetHeight || 0, size.width = element.offsetWidth || 0, size.top = element.offsetTop, size.left = element.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function PopChild({ children, isPresent }) {
  const id2 = useId$1(), ref = useRef$1(null), size = useRef$1({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  }), { nonce } = useContext$1(MotionConfigContext);
  return useInsertionEffect(() => {
    const { width: width2, height, top, left } = size.current;
    if (isPresent || !ref.current || !width2 || !height)
      return;
    ref.current.dataset.motionPopId = id2;
    const style = document.createElement("style");
    return nonce && (style.nonce = nonce), document.head.appendChild(style), style.sheet && style.sheet.insertRule(`
          [data-motion-pop-id="${id2}"] {
            position: absolute !important;
            width: ${width2}px !important;
            height: ${height}px !important;
            top: ${top}px !important;
            left: ${left}px !important;
          }
        `), () => {
      document.head.removeChild(style);
    };
  }, [isPresent]), jsx(PopChildMeasure, { isPresent, childRef: ref, sizeRef: size, children: React.cloneElement(children, { ref }) });
}
const PresenceChild = ({ children, initial, isPresent, onExitComplete, custom: custom5, presenceAffectsLayout, mode }) => {
  const presenceChildren = useConstant(newChildrenMap), id2 = useId$1(), memoizedOnExitComplete = useCallback$1((childId) => {
    presenceChildren.set(childId, !0);
    for (const isComplete of presenceChildren.values())
      if (!isComplete)
        return;
    onExitComplete && onExitComplete();
  }, [presenceChildren, onExitComplete]), context = useMemo$1(
    () => ({
      id: id2,
      initial,
      isPresent,
      custom: custom5,
      onExitComplete: memoizedOnExitComplete,
      register: (childId) => (presenceChildren.set(childId, !1), () => presenceChildren.delete(childId))
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    presenceAffectsLayout ? [Math.random(), memoizedOnExitComplete] : [isPresent, memoizedOnExitComplete]
  );
  return useMemo$1(() => {
    presenceChildren.forEach((_, key) => presenceChildren.set(key, !1));
  }, [isPresent]), React.useEffect(() => {
    !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
  }, [isPresent]), mode === "popLayout" && (children = jsx(PopChild, { isPresent, children })), jsx(PresenceContext.Provider, { value: context, children });
};
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}
const getChildKey = (child) => child.key || "";
function onlyElements(children) {
  const filtered = [];
  return Children.forEach(children, (child) => {
    isValidElement(child) && filtered.push(child);
  }), filtered;
}
const AnimatePresence = ({ children, exitBeforeEnter, custom: custom5, initial = !0, onExitComplete, presenceAffectsLayout = !0, mode = "sync" }) => {
  const presentChildren = useMemo$1(() => onlyElements(children), [children]), presentKeys = presentChildren.map(getChildKey), isInitialRender = useRef$1(!0), pendingPresentChildren = useRef$1(presentChildren), exitComplete = useConstant(() => /* @__PURE__ */ new Map()), [diffedChildren, setDiffedChildren] = useState$1(presentChildren), [renderedChildren, setRenderedChildren] = useState$1(presentChildren);
  useIsomorphicLayoutEffect$2(() => {
    isInitialRender.current = !1, pendingPresentChildren.current = presentChildren;
    for (let i2 = 0; i2 < renderedChildren.length; i2++) {
      const key = getChildKey(renderedChildren[i2]);
      presentKeys.includes(key) ? exitComplete.delete(key) : exitComplete.get(key) !== !0 && exitComplete.set(key, !1);
    }
  }, [renderedChildren, presentKeys.length, presentKeys.join("-")]);
  const exitingChildren = [];
  if (presentChildren !== diffedChildren) {
    let nextChildren = [...presentChildren];
    for (let i2 = 0; i2 < renderedChildren.length; i2++) {
      const child = renderedChildren[i2], key = getChildKey(child);
      presentKeys.includes(key) || (nextChildren.splice(i2, 0, child), exitingChildren.push(child));
    }
    mode === "wait" && exitingChildren.length && (nextChildren = exitingChildren), setRenderedChildren(onlyElements(nextChildren)), setDiffedChildren(presentChildren);
    return;
  }
  const { forceRender } = useContext$1(LayoutGroupContext);
  return jsx(Fragment$1, { children: renderedChildren.map((child) => {
    const key = getChildKey(child), isPresent = presentChildren === renderedChildren || presentKeys.includes(key), onExit = () => {
      if (exitComplete.has(key))
        exitComplete.set(key, !0);
      else
        return;
      let isEveryExitComplete = !0;
      exitComplete.forEach((isExitComplete) => {
        isExitComplete || (isEveryExitComplete = !1);
      }), isEveryExitComplete && (forceRender?.(), setRenderedChildren(pendingPresentChildren.current), onExitComplete && onExitComplete());
    };
    return jsx(PresenceChild, { isPresent, initial: !isInitialRender.current || initial ? void 0 : !1, custom: isPresent ? void 0 : custom5, presenceAffectsLayout, mode, onExitComplete: isPresent ? void 0 : onExit, children: child }, key);
  }) });
};
function MotionConfig({ children, isValidProp, ...config }) {
  isValidProp && loadExternalIsValidProp(isValidProp), config = { ...useContext$1(MotionConfigContext), ...config }, config.isStatic = useConstant(() => config.isStatic);
  const context = useMemo$1(() => config, [
    JSON.stringify(config.transition),
    config.transformPagePoint,
    config.reducedMotion
  ]);
  return jsx(MotionConfigContext.Provider, { value: context, children });
}
function LazyMotion({ children, features, strict = !1 }) {
  const [, setIsLoaded] = useState$1(!isLazyBundle(features)), loadedRenderer = useRef$1(void 0);
  if (!isLazyBundle(features)) {
    const { renderer, ...loadedFeatures } = features;
    loadedRenderer.current = renderer, loadFeatures(loadedFeatures);
  }
  return useEffect$1(() => {
    isLazyBundle(features) && features().then(({ renderer, ...loadedFeatures }) => {
      loadFeatures(loadedFeatures), loadedRenderer.current = renderer, setIsLoaded(!0);
    });
  }, []), jsx(LazyContext.Provider, { value: { renderer: loadedRenderer.current, strict }, children });
}
function isLazyBundle(features) {
  return typeof features == "function";
}
const DeprecatedLayoutGroupContext = createContext$1(null);
function useIsMounted() {
  const isMounted = useRef$1(!1);
  return useIsomorphicLayoutEffect$2(() => (isMounted.current = !0, () => {
    isMounted.current = !1;
  }), []), isMounted;
}
function useForceUpdate$1() {
  const isMounted = useIsMounted(), [forcedRenderCount, setForcedRenderCount] = useState$1(0), forceRender = useCallback$1(() => {
    isMounted.current && setForcedRenderCount(forcedRenderCount + 1);
  }, [forcedRenderCount]);
  return [useCallback$1(() => frame.postRender(forceRender), [forceRender]), forcedRenderCount];
}
const notify = (node2) => !node2.isLayoutDirty && node2.willUpdate(!1);
function nodeGroup() {
  const nodes = /* @__PURE__ */ new Set(), subscriptions = /* @__PURE__ */ new WeakMap(), dirtyAll = () => nodes.forEach(notify);
  return {
    add: (node2) => {
      nodes.add(node2), subscriptions.set(node2, node2.addEventListener("willUpdate", dirtyAll));
    },
    remove: (node2) => {
      nodes.delete(node2);
      const unsubscribe = subscriptions.get(node2);
      unsubscribe && (unsubscribe(), subscriptions.delete(node2)), dirtyAll();
    },
    dirty: dirtyAll
  };
}
const shouldInheritGroup = (inherit) => inherit === !0, shouldInheritId = (inherit) => shouldInheritGroup(inherit === !0) || inherit === "id", LayoutGroup = ({ children, id: id2, inherit = !0 }) => {
  const layoutGroupContext = useContext$1(LayoutGroupContext), deprecatedLayoutGroupContext = useContext$1(DeprecatedLayoutGroupContext), [forceRender, key] = useForceUpdate$1(), context = useRef$1(null), upstreamId = layoutGroupContext.id || deprecatedLayoutGroupContext;
  context.current === null && (shouldInheritId(inherit) && upstreamId && (id2 = id2 ? upstreamId + "-" + id2 : upstreamId), context.current = {
    id: id2,
    group: shouldInheritGroup(inherit) && layoutGroupContext.group || nodeGroup()
  });
  const memoizedContext = useMemo$1(() => ({ ...context.current, forceRender }), [key]);
  return jsx(LayoutGroupContext.Provider, { value: memoizedContext, children });
}, domAnimation = {
  renderer: createDomVisualElement,
  ...animations,
  ...gestureAnimations
}, domMax = {
  ...domAnimation,
  ...drag,
  ...layout$3
};
function useMotionValue(initial) {
  const value = useConstant(() => motionValue(initial)), { isStatic } = useContext$1(MotionConfigContext);
  if (isStatic) {
    const [, setLatest] = useState$1(initial);
    useEffect$1(() => value.on("change", setLatest), []);
  }
  return value;
}
function resolveElements(elements, scope, selectorCache) {
  var _a2;
  if (typeof elements == "string") {
    let root2 = document;
    scope && (invariant(!!scope.current), root2 = scope.current), selectorCache ? ((_a2 = selectorCache[elements]) !== null && _a2 !== void 0 || (selectorCache[elements] = root2.querySelectorAll(elements)), elements = selectorCache[elements]) : elements = root2.querySelectorAll(elements);
  } else elements instanceof Element && (elements = [elements]);
  return Array.from(elements || []);
}
function useUnmountEffect$1(callback) {
  return useEffect$1(() => () => callback(), []);
}
function createGeneratorEasing(options, scale2 = 100, createGenerator) {
  const generator = createGenerator({ ...options, keyframes: [0, scale2] }), duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
  return {
    type: "keyframes",
    ease: (progress2) => generator.next(duration * progress2).value / scale2,
    duration: millisecondsToSeconds(duration)
  };
}
function isDOMKeyframes(keyframes2) {
  return typeof keyframes2 == "object" && !Array.isArray(keyframes2);
}
function resolveSubjects(subject, keyframes2, scope, selectorCache) {
  return typeof subject == "string" && isDOMKeyframes(keyframes2) ? resolveElements(subject, scope, selectorCache) : subject instanceof NodeList ? Array.from(subject) : Array.isArray(subject) ? subject : [subject];
}
function calcNextTime(current, next, prev, labels) {
  var _a2;
  return typeof next == "number" ? next : next.startsWith("-") || next.startsWith("+") ? Math.max(0, current + parseFloat(next)) : next === "<" ? prev : (_a2 = labels.get(next)) !== null && _a2 !== void 0 ? _a2 : current;
}
const wrap = (min2, max2, v) => {
  const rangeSize = max2 - min2;
  return ((v - min2) % rangeSize + rangeSize) % rangeSize + min2;
};
function getEasingForSegment(easing, i2) {
  return isEasingArray(easing) ? easing[wrap(0, easing.length, i2)] : easing;
}
function eraseKeyframes(sequence, startTime, endTime) {
  for (let i2 = 0; i2 < sequence.length; i2++) {
    const keyframe = sequence[i2];
    keyframe.at > startTime && keyframe.at < endTime && (removeItem(sequence, keyframe), i2--);
  }
}
function addKeyframes(sequence, keyframes2, easing, offset, startTime, endTime) {
  eraseKeyframes(sequence, startTime, endTime);
  for (let i2 = 0; i2 < keyframes2.length; i2++)
    sequence.push({
      value: keyframes2[i2],
      at: mixNumber$1(startTime, endTime, offset[i2]),
      easing: getEasingForSegment(easing, i2)
    });
}
function compareByTime(a2, b2) {
  return a2.at === b2.at ? a2.value === null ? 1 : b2.value === null ? -1 : 0 : a2.at - b2.at;
}
const defaultSegmentEasing = "easeInOut";
function createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope, generators2) {
  const defaultDuration = defaultTransition.duration || 0.3, animationDefinitions = /* @__PURE__ */ new Map(), sequences = /* @__PURE__ */ new Map(), elementCache = {}, timeLabels = /* @__PURE__ */ new Map();
  let prevTime = 0, currentTime = 0, totalDuration = 0;
  for (let i2 = 0; i2 < sequence.length; i2++) {
    const segment = sequence[i2];
    if (typeof segment == "string") {
      timeLabels.set(segment, currentTime);
      continue;
    } else if (!Array.isArray(segment)) {
      timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));
      continue;
    }
    let [subject, keyframes2, transition = {}] = segment;
    transition.at !== void 0 && (currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels));
    let maxDuration2 = 0;
    const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numSubjects = 0) => {
      const valueKeyframesAsList = keyframesAsList(valueKeyframes), { delay: delay2 = 0, times = defaultOffset(valueKeyframesAsList), type = "keyframes", ...remainingTransition } = valueTransition;
      let { ease: ease2 = defaultTransition.ease || "easeOut", duration } = valueTransition;
      const calculatedDelay = typeof delay2 == "function" ? delay2(elementIndex, numSubjects) : delay2, numKeyframes = valueKeyframesAsList.length, createGenerator = isGenerator(type) ? type : generators2?.[type];
      if (numKeyframes <= 2 && createGenerator) {
        let absoluteDelta = 100;
        if (numKeyframes === 2 && isNumberKeyframesArray(valueKeyframesAsList)) {
          const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];
          absoluteDelta = Math.abs(delta);
        }
        const springTransition = { ...remainingTransition };
        duration !== void 0 && (springTransition.duration = secondsToMilliseconds(duration));
        const springEasing = createGeneratorEasing(springTransition, absoluteDelta, createGenerator);
        ease2 = springEasing.ease, duration = springEasing.duration;
      }
      duration ?? (duration = defaultDuration);
      const startTime = currentTime + calculatedDelay, targetTime = startTime + duration;
      times.length === 1 && times[0] === 0 && (times[1] = 1);
      const remainder = times.length - valueKeyframesAsList.length;
      remainder > 0 && fillOffset(times, remainder), valueKeyframesAsList.length === 1 && valueKeyframesAsList.unshift(null), addKeyframes(valueSequence, valueKeyframesAsList, ease2, times, startTime, targetTime), maxDuration2 = Math.max(calculatedDelay + duration, maxDuration2), totalDuration = Math.max(targetTime, totalDuration);
    };
    if (isMotionValue(subject)) {
      const subjectSequence = getSubjectSequence(subject, sequences);
      resolveValueSequence(keyframes2, transition, getValueSequence("default", subjectSequence));
    } else {
      const subjects = resolveSubjects(subject, keyframes2, scope, elementCache), numSubjects = subjects.length;
      for (let subjectIndex = 0; subjectIndex < numSubjects; subjectIndex++) {
        keyframes2 = keyframes2, transition = transition;
        const thisSubject = subjects[subjectIndex], subjectSequence = getSubjectSequence(thisSubject, sequences);
        for (const key in keyframes2)
          resolveValueSequence(keyframes2[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), subjectIndex, numSubjects);
      }
    }
    prevTime = currentTime, currentTime += maxDuration2;
  }
  return sequences.forEach((valueSequences, element) => {
    for (const key in valueSequences) {
      const valueSequence = valueSequences[key];
      valueSequence.sort(compareByTime);
      const keyframes2 = [], valueOffset = [], valueEasing = [];
      for (let i2 = 0; i2 < valueSequence.length; i2++) {
        const { at, value, easing } = valueSequence[i2];
        keyframes2.push(value), valueOffset.push(progress(0, totalDuration, at)), valueEasing.push(easing || "easeOut");
      }
      valueOffset[0] !== 0 && (valueOffset.unshift(0), keyframes2.unshift(keyframes2[0]), valueEasing.unshift(defaultSegmentEasing)), valueOffset[valueOffset.length - 1] !== 1 && (valueOffset.push(1), keyframes2.push(null)), animationDefinitions.has(element) || animationDefinitions.set(element, {
        keyframes: {},
        transition: {}
      });
      const definition = animationDefinitions.get(element);
      definition.keyframes[key] = keyframes2, definition.transition[key] = {
        ...defaultTransition,
        duration: totalDuration,
        ease: valueEasing,
        times: valueOffset,
        ...sequenceTransition
      };
    }
  }), animationDefinitions;
}
function getSubjectSequence(subject, sequences) {
  return !sequences.has(subject) && sequences.set(subject, {}), sequences.get(subject);
}
function getValueSequence(name, sequences) {
  return sequences[name] || (sequences[name] = []), sequences[name];
}
function keyframesAsList(keyframes2) {
  return Array.isArray(keyframes2) ? keyframes2 : [keyframes2];
}
function getValueTransition(transition, key) {
  return transition && transition[key] ? {
    ...transition,
    ...transition[key]
  } : { ...transition };
}
const isNumber = (keyframe) => typeof keyframe == "number", isNumberKeyframesArray = (keyframes2) => keyframes2.every(isNumber);
function isObjectKey(key, object2) {
  return key in object2;
}
class ObjectVisualElement extends VisualElement {
  constructor() {
    super(...arguments), this.type = "object";
  }
  readValueFromInstance(instance, key) {
    if (isObjectKey(key, instance)) {
      const value = instance[key];
      if (typeof value == "string" || typeof value == "number")
        return value;
    }
  }
  getBaseTargetFromProps() {
  }
  removeValueFromRenderState(key, renderState) {
    delete renderState.output[key];
  }
  measureInstanceViewportBox() {
    return createBox();
  }
  build(renderState, latestValues) {
    Object.assign(renderState.output, latestValues);
  }
  renderInstance(instance, { output }) {
    Object.assign(instance, output);
  }
  sortInstanceNodePosition() {
    return 0;
  }
}
function createDOMVisualElement(element) {
  const options = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        transform: {},
        transformOrigin: {},
        style: {},
        vars: {},
        attrs: {}
      },
      latestValues: {}
    }
  }, node2 = isSVGElement(element) ? new SVGVisualElement(options) : new HTMLVisualElement(options);
  node2.mount(element), visualElementStore.set(element, node2);
}
function createObjectVisualElement(subject) {
  const options = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        output: {}
      },
      latestValues: {}
    }
  }, node2 = new ObjectVisualElement(options);
  node2.mount(subject), visualElementStore.set(subject, node2);
}
function isSingleValue(subject, keyframes2) {
  return isMotionValue(subject) || typeof subject == "number" || typeof subject == "string" && !isDOMKeyframes(keyframes2);
}
function animateSubject(subject, keyframes2, options, scope) {
  const animations2 = [];
  if (isSingleValue(subject, keyframes2))
    animations2.push(animateSingleValue(subject, isDOMKeyframes(keyframes2) && keyframes2.default || keyframes2, options && (options.default || options)));
  else {
    const subjects = resolveSubjects(subject, keyframes2, scope), numSubjects = subjects.length;
    for (let i2 = 0; i2 < numSubjects; i2++) {
      const thisSubject = subjects[i2], createVisualElement = thisSubject instanceof Element ? createDOMVisualElement : createObjectVisualElement;
      visualElementStore.has(thisSubject) || createVisualElement(thisSubject);
      const visualElement = visualElementStore.get(thisSubject), transition = { ...options };
      "delay" in transition && typeof transition.delay == "function" && (transition.delay = transition.delay(i2, numSubjects)), animations2.push(...animateTarget(visualElement, { ...keyframes2, transition }, {}));
    }
  }
  return animations2;
}
function animateSequence(sequence, options, scope) {
  const animations2 = [];
  return createAnimationsFromSequence(sequence, options, scope, { spring }).forEach(({ keyframes: keyframes2, transition }, subject) => {
    animations2.push(...animateSubject(subject, keyframes2, transition));
  }), animations2;
}
function isSequence(value) {
  return Array.isArray(value) && Array.isArray(value[0]);
}
function createScopedAnimate(scope) {
  function scopedAnimate(subjectOrSequence, optionsOrKeyframes, options) {
    let animations2 = [];
    isSequence(subjectOrSequence) ? animations2 = animateSequence(subjectOrSequence, optionsOrKeyframes, scope) : animations2 = animateSubject(subjectOrSequence, optionsOrKeyframes, options, scope);
    const animation = new GroupPlaybackControls(animations2);
    return scope && scope.animations.push(animation), animation;
  }
  return scopedAnimate;
}
function useAnimate() {
  const scope = useConstant(() => ({
    current: null,
    // Will be hydrated by React
    animations: []
  })), animate = useConstant(() => createScopedAnimate(scope));
  return useUnmountEffect$1(() => {
    scope.animations.forEach((animation) => animation.stop());
  }), [scope, animate];
}
class DragControls {
  constructor() {
    this.componentControls = /* @__PURE__ */ new Set();
  }
  /**
   * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.
   *
   * @internal
   */
  subscribe(controls) {
    return this.componentControls.add(controls), () => this.componentControls.delete(controls);
  }
  /**
   * Start a drag gesture on every `motion` component that has this set of drag controls
   * passed into it via the `dragControls` prop.
   *
   * ```jsx
   * dragControls.start(e, {
   *   snapToCursor: true
   * })
   * ```
   *
   * @param event - PointerEvent
   * @param options - Options
   *
   * @public
   */
  start(event, options) {
    this.componentControls.forEach((controls) => {
      controls.start(event.nativeEvent || event, options);
    });
  }
}
const createDragControls = () => new DragControls();
function useDragControls() {
  return useConstant(createDragControls);
}
function useSyncedRef(value) {
  const ref = useRef$1(value);
  return ref.current = value, useMemo$1(() => Object.freeze({
    get current() {
      return ref.current;
    }
  }), []);
}
function useUnmountEffect(effect) {
  const effectRef = useSyncedRef(effect);
  useEffect$1(() => () => {
    effectRef.current();
  }, []);
}
function useDebouncedCallback(callback, deps, delay2, maxWait = 0) {
  const timeout = useRef$1(), waitTimeout = useRef$1(), cb = useRef$1(callback), lastCall = useRef$1(), clear = () => {
    timeout.current && (clearTimeout(timeout.current), timeout.current = void 0), waitTimeout.current && (clearTimeout(waitTimeout.current), waitTimeout.current = void 0);
  };
  return useUnmountEffect(clear), useEffect$1(() => {
    cb.current = callback;
  }, deps), useMemo$1(() => {
    const execute = () => {
      if (clear(), !lastCall.current)
        return;
      const context = lastCall.current;
      lastCall.current = void 0, cb.current.apply(context.this, context.args);
    }, wrapped = function(...args) {
      timeout.current && clearTimeout(timeout.current), lastCall.current = { args, this: this }, timeout.current = setTimeout(execute, delay2), maxWait > 0 && !waitTimeout.current && (waitTimeout.current = setTimeout(execute, maxWait));
    };
    return Object.defineProperties(wrapped, {
      length: { value: callback.length },
      name: { value: `${callback.name || "anonymous"}__debounced__${delay2}` }
    }), wrapped;
  }, [delay2, maxWait, ...deps]);
}
const noop$1 = () => {
}, isBrowser = typeof window < "u" && typeof navigator < "u" && typeof document < "u", basicDepsComparator = (d1, d2) => {
  if (d1 === d2)
    return !0;
  if (d1.length !== d2.length)
    return !1;
  for (const [i2, element] of d1.entries())
    if (element !== d2[i2])
      return !1;
  return !0;
};
function useCustomCompareEffect(callback, deps, comparator = basicDepsComparator, effectHook = useEffect$1, ...effectHookRestArgs) {
  const dependencies = useRef$1();
  (dependencies.current === void 0 || isBrowser && !comparator(dependencies.current, deps)) && (dependencies.current = deps), effectHook(callback, dependencies.current, ...effectHookRestArgs);
}
function useDebouncedEffect(callback, deps, delay2, maxWait = 0) {
  useEffect$1(useDebouncedCallback(callback, deps, delay2, maxWait), deps);
}
var compareDates = function(a2, b2) {
  return a2.getTime() === b2.getTime();
}, compareRegexps = function(a2, b2) {
  return a2.source === b2.source && a2.flags === b2.flags;
}, compareArrays = function(a2, b2, equal) {
  var l2 = a2.length;
  if (l2 !== b2.length)
    return !1;
  for (; l2-- && equal(a2[l2], b2[l2]); )
    ;
  return l2 === -1;
}, compareMaps = function(a2, b2, equal) {
  if (a2.size !== b2.size)
    return !1;
  for (var it = a2.entries(), i2; !(i2 = it.next()).done; )
    if (!b2.has(i2.value[0]) || !equal(i2.value[1], b2.get(i2.value[0])))
      return !1;
  return !0;
}, compareSets = function(a2, b2) {
  if (a2.size !== b2.size)
    return !1;
  for (var it = a2.values(), i2; !(i2 = it.next()).done; )
    if (!b2.has(i2.value))
      return !1;
  return !0;
}, compareDataViews = function(a2, b2) {
  var l2 = a2.byteLength;
  if (l2 !== b2.byteLength)
    return !1;
  for (; l2-- && a2.getInt8(l2) === b2.getInt8(l2); )
    ;
  return l2 === -1;
}, compareArrayBuffers = function(a2, b2) {
  var l2 = a2.length;
  if (l2 !== b2.length)
    return !1;
  for (; l2-- && a2[l2] === b2[l2]; )
    ;
  return l2 === -1;
}, hasOwnProperty$1 = Object.prototype.hasOwnProperty, oKeys = Object.keys, compareObjects = function(a2, b2, equal) {
  var i2, len = 0;
  for (i2 in a2)
    if (hasOwnProperty$1.call(a2, i2) && (len++, !hasOwnProperty$1.call(b2, i2) || !equal(a2[i2], b2[i2])))
      return !1;
  return oKeys(b2).length === len;
}, _a = Object.prototype, valueOf = _a.valueOf, toString$1 = _a.toString, isEqual = function(a2, b2) {
  if (a2 === b2)
    return !0;
  if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
    var ctor = a2.constructor;
    return ctor !== b2.constructor ? !1 : ctor === Array ? compareArrays(a2, b2, isEqual) : ctor === Date ? compareDates(a2, b2) : ctor === RegExp ? compareRegexps(a2, b2) : ctor === Map && a2 instanceof Map && b2 instanceof Map ? compareMaps(a2, b2, isEqual) : ctor === Set && a2 instanceof Set && b2 instanceof Set ? compareSets(a2, b2) : ctor === DataView ? compareDataViews(a2, b2) : ctor === ArrayBuffer ? compareArrayBuffers(new Uint8Array(a2), new Uint8Array(b2)) : ArrayBuffer.isView(a2) && ArrayBuffer.isView(b2) ? compareArrayBuffers(a2, b2) : a2.valueOf !== valueOf ? a2.valueOf() === b2.valueOf() : a2.toString !== toString$1 ? a2.toString() === b2.toString() : compareObjects(a2, b2, isEqual);
  }
  return a2 !== a2 && b2 !== b2;
};
function useDeepCompareEffect(callback, deps, effectHook = useEffect$1, ...effectHookRestArgs) {
  useCustomCompareEffect(callback, deps, isEqual, effectHook, ...effectHookRestArgs);
}
function useFirstMountState() {
  const isFirstMount = useRef$1(!0);
  return useEffect$1(() => {
    isFirstMount.current = !1;
  }, []), isFirstMount.current;
}
const useIsomorphicLayoutEffect$1 = isBrowser ? useLayoutEffect$1 : useEffect$1;
function useUpdateEffect$1(effect, deps) {
  const isFirstMount = useFirstMountState();
  useEffect$1(isFirstMount ? noop$1 : effect, deps);
}
function useAsync(asyncFn, initialValue) {
  const [state, setState] = useState$1({
    status: "not-executed",
    error: void 0,
    result: initialValue
  }), promiseRef = useRef$1(), argsRef = useRef$1(), methods = useSyncedRef({
    execute(...params) {
      argsRef.current = params;
      const promise = asyncFn(...params);
      return promiseRef.current = promise, setState((s2) => ({ ...s2, status: "loading" })), promise.then((result) => {
        promise === promiseRef.current && setState((s2) => ({ ...s2, status: "success", error: void 0, result }));
      }, (error) => {
        promise === promiseRef.current && setState((s2) => ({ ...s2, status: "error", error }));
      }), promise;
    },
    reset() {
      setState({
        status: "not-executed",
        error: void 0,
        result: initialValue
      }), promiseRef.current = void 0, argsRef.current = void 0;
    }
  });
  return [
    state,
    useMemo$1(() => ({
      reset() {
        methods.current.reset();
      },
      execute: (...params) => methods.current.execute(...params)
    }), []),
    { promise: promiseRef.current, lastArgs: argsRef.current }
  ];
}
const noop = () => {
}, depsShallowEqual = (d1, d2) => {
  if (d1 === d2)
    return !0;
  if (d1.length !== d2.length)
    return !1;
  for (const [i2, element] of d1.entries())
    if (!shallowEqual(element, d2[i2]))
      return !1;
  return !0;
};
function useUpdateEffect(callback, deps, equalityFn, effectHook) {
  const isFirstMount = useFirstMountState();
  useCustomCompareEffect(
    isFirstMount ? noop : callback,
    deps,
    equalityFn ?? depsShallowEqual,
    effectHook
  );
}
const useXYFlow = useReactFlow, useXYNodesData = useNodesData;
function useXYStore(selector2, equalityFn) {
  return useStore$1(
    selector2,
    shallowEqual
  );
}
const useXYStoreApi = useStoreApi, DEV = !1, __vite_import_meta_env__ = { BASE_URL: "/", DEV: !1, MODE: "production", PROD: !0, SSR: !1 }, trackedConnections = /* @__PURE__ */ new Map(), getTrackedConnectionState = (name) => {
  const api = trackedConnections.get(name);
  return api ? Object.fromEntries(
    Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])
  ) : {};
}, extractConnectionInformation = (store, extensionConnector, options) => {
  if (store === void 0)
    return {
      type: "untracked",
      connection: extensionConnector.connect(options)
    };
  const existingConnection = trackedConnections.get(options.name);
  if (existingConnection)
    return { type: "tracked", store, ...existingConnection };
  const newConnection = {
    connection: extensionConnector.connect(options),
    stores: {}
  };
  return trackedConnections.set(options.name, newConnection), { type: "tracked", store, ...newConnection };
}, devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {
  const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;
  let extensionConnector;
  try {
    extensionConnector = (enabled ?? (__vite_import_meta_env__ ? "production" : void 0) !== "production") && window.__REDUX_DEVTOOLS_EXTENSION__;
  } catch {
  }
  if (!extensionConnector)
    return (__vite_import_meta_env__ ? "production" : void 0) !== "production" && enabled && console.warn(
      "[zustand devtools middleware] Please install/enable Redux devtools extension"
    ), fn(set, get, api);
  const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);
  let isRecording = !0;
  api.setState = (state, replace, nameOrAction) => {
    const r2 = set(state, replace);
    if (!isRecording) return r2;
    const action = nameOrAction === void 0 ? { type: anonymousActionType || "anonymous" } : typeof nameOrAction == "string" ? { type: nameOrAction } : nameOrAction;
    return store === void 0 ? (connection?.send(action, get()), r2) : (connection?.send(
      {
        ...action,
        type: `${store}/${action.type}`
      },
      {
        ...getTrackedConnectionState(options.name),
        [store]: api.getState()
      }
    ), r2);
  };
  const setStateFromDevtools = (...a2) => {
    const originalIsRecording = isRecording;
    isRecording = !1, set(...a2), isRecording = originalIsRecording;
  }, initialState2 = fn(api.setState, get, api);
  if (connectionInformation.type === "untracked" ? connection?.init(initialState2) : (connectionInformation.stores[connectionInformation.store] = api, connection?.init(
    Object.fromEntries(
      Object.entries(connectionInformation.stores).map(([key, store2]) => [
        key,
        key === connectionInformation.store ? initialState2 : store2.getState()
      ])
    )
  )), api.dispatchFromDevtools && typeof api.dispatch == "function") {
    let didWarnAboutReservedActionType = !1;
    const originalDispatch = api.dispatch;
    api.dispatch = (...a2) => {
      (__vite_import_meta_env__ ? "production" : void 0) !== "production" && a2[0].type === "__setState" && !didWarnAboutReservedActionType && (console.warn(
        '[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'
      ), didWarnAboutReservedActionType = !0), originalDispatch(...a2);
    };
  }
  return connection.subscribe((message) => {
    var _a2;
    switch (message.type) {
      case "ACTION":
        if (typeof message.payload != "string") {
          console.error(
            "[zustand devtools middleware] Unsupported action format"
          );
          return;
        }
        return parseJsonThen(
          message.payload,
          (action) => {
            if (action.type === "__setState") {
              if (store === void 0) {
                setStateFromDevtools(action.state);
                return;
              }
              Object.keys(action.state).length !== 1 && console.error(
                `
                    [zustand devtools middleware] Unsupported __setState action format. 
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `
              );
              const stateFromDevtools = action.state[store];
              if (stateFromDevtools == null)
                return;
              JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools) && setStateFromDevtools(stateFromDevtools);
              return;
            }
            api.dispatchFromDevtools && typeof api.dispatch == "function" && api.dispatch(action);
          }
        );
      case "DISPATCH":
        switch (message.payload.type) {
          case "RESET":
            return setStateFromDevtools(initialState2), store === void 0 ? connection?.init(api.getState()) : connection?.init(getTrackedConnectionState(options.name));
          case "COMMIT":
            if (store === void 0) {
              connection?.init(api.getState());
              return;
            }
            return connection?.init(getTrackedConnectionState(options.name));
          case "ROLLBACK":
            return parseJsonThen(message.state, (state) => {
              if (store === void 0) {
                setStateFromDevtools(state), connection?.init(api.getState());
                return;
              }
              setStateFromDevtools(state[store]), connection?.init(getTrackedConnectionState(options.name));
            });
          case "JUMP_TO_STATE":
          case "JUMP_TO_ACTION":
            return parseJsonThen(message.state, (state) => {
              if (store === void 0) {
                setStateFromDevtools(state);
                return;
              }
              JSON.stringify(api.getState()) !== JSON.stringify(state[store]) && setStateFromDevtools(state[store]);
            });
          case "IMPORT_STATE": {
            const { nextLiftedState } = message.payload, lastComputedState = (_a2 = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a2.state;
            if (!lastComputedState) return;
            setStateFromDevtools(store === void 0 ? lastComputedState : lastComputedState[store]), connection?.send(
              null,
              // FIXME no-any
              nextLiftedState
            );
            return;
          }
          case "PAUSE_RECORDING":
            return isRecording = !isRecording;
        }
        return;
    }
  }), initialState2;
}, devtools = devtoolsImpl, parseJsonThen = (stringified, f2) => {
  let parsed;
  try {
    parsed = JSON.parse(stringified);
  } catch (e2) {
    console.error(
      "[zustand devtools middleware] Could not parse the received json",
      e2
    );
  }
  parsed !== void 0 && f2(parsed);
}, subscribeWithSelectorImpl = (fn) => (set, get, api) => {
  const origSubscribe = api.subscribe;
  return api.subscribe = (selector2, optListener, options) => {
    let listener = selector2;
    if (optListener) {
      const equalityFn = options?.equalityFn || Object.is;
      let currentSlice = selector2(api.getState());
      listener = (state) => {
        const nextSlice = selector2(state);
        if (!equalityFn(currentSlice, nextSlice)) {
          const previousSlice = currentSlice;
          optListener(currentSlice = nextSlice, previousSlice);
        }
      }, options?.fireImmediately && optListener(currentSlice, currentSlice);
    }
    return origSubscribe(listener);
  }, fn(set, get, api);
}, subscribeWithSelector = subscribeWithSelectorImpl;
class VectorImpl {
  constructor(x2, y2) {
    this.x = x2, this.y = y2;
  }
  static create(position2) {
    return new VectorImpl(position2.x, position2.y);
  }
  static add(a2, b2) {
    return { x: a2.x + b2.x, y: a2.y + b2.y };
  }
  static sub(a2, b2) {
    return { x: a2.x - b2.x, y: a2.y - b2.y };
  }
  static mul(a2, b2) {
    return { x: a2.x * b2, y: a2.y * b2 };
  }
  static dot(a2, b2) {
    return a2.x * b2.x + a2.y * b2.y;
  }
  static cross(a2, b2) {
    return new VectorImpl(a2.y * b2.x - a2.x * b2.y, a2.x * b2.y - a2.y * b2.x);
  }
  static setLength(a2, length) {
    return vector(a2).setLength(length);
  }
  add(b2) {
    return new VectorImpl(this.x + b2.x, this.y + b2.y);
  }
  sub(b2) {
    return new VectorImpl(this.x - b2.x, this.y - b2.y);
  }
  mul(b2) {
    return new VectorImpl(this.x * b2, this.y * b2);
  }
  dot(b2) {
    return this.x * b2.x + this.y * b2.y;
  }
  cross(b2) {
    return new VectorImpl(this.y * b2.x - this.x * b2.y, this.x * b2.y - this.y * b2.x);
  }
  abs() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  setLength(length) {
    return this.mul(length / this.abs());
  }
}
function vector(source) {
  return VectorImpl.create(source);
}
const ZIndexes$2 = {
  Compound: 2,
  Edge: 4,
  Element: 6
}, MinZoom = 0.1, MaxZoom = 2;
function useMantinePortalProps() {
  const target = useDiagramState((s2) => s2.getContainer());
  return useMemo$1(() => target ? { portalProps: { target }, withinPortal: !0 } : { withinPortal: !1 }, [target]);
}
class Rect {
  static LeftPadding = 40;
  static RightPadding = 40;
  static TopPadding = 55;
  static BottomPadding = 40;
  id;
  minX = 1 / 0;
  minY = 1 / 0;
  maxX = -1 / 0;
  maxY = -1 / 0;
  get positionAbsolute() {
    return {
      x: this.minX,
      y: this.minY
    };
  }
  set positionAbsolute(pos) {
    this.maxX += pos.x - this.minX, this.maxY += pos.y - this.minY, this.minX = pos.x, this.minY = pos.y;
  }
  get dimensions() {
    return {
      width: this.maxX - this.minX,
      height: this.maxY - this.minY
    };
  }
  // Position relative to parent
  get position() {
    const positionAbsolute = this.positionAbsolute;
    if (!this.parent)
      return positionAbsolute;
    const parentPosition = this.parent.positionAbsolute;
    return {
      x: positionAbsolute.x - parentPosition.x,
      y: positionAbsolute.y - parentPosition.y
    };
  }
}
class Compound extends Rect {
  constructor(xynode, parent = null) {
    super(), this.parent = parent, this.id = xynode.id, parent && parent.children.push(this);
  }
  children = [];
}
class Leaf extends Rect {
  constructor(xynode, parent = null) {
    super(), this.parent = parent, this.id = xynode.id, this.positionAbsolute = xynode.internals.positionAbsolute;
    const { width: width2, height } = getNodeDimensions(xynode);
    this.maxX = this.minX + Math.ceil(width2), this.maxY = this.minY + Math.ceil(height), parent && parent.children.push(this);
  }
}
function createLayoutConstraints(xyflowApi, editingNodeIds) {
  const { parentLookup, nodeLookup } = xyflowApi.getState(), rects = /* @__PURE__ */ new Map(), ancestorsOf = (nodeId) => {
    const ancestors = [];
    let parent = nodeLookup.get(nodeId)?.parentId, parentNode;
    for (; parent && (parentNode = nodeLookup.get(parent)); )
      ancestors.push(parentNode.id), parent = parentNode.parentId;
    return ancestors;
  }, ancestorsOfDraggingNodes = new Set(
    editingNodeIds.flatMap(ancestorsOf)
  ), traverse = new Array();
  for (const [, xynode] of nodeLookup)
    n$2(xynode.parentId) && traverse.push({
      xynode,
      parent: null
    });
  for (; traverse.length > 0; ) {
    const { xynode, parent } = traverse.shift(), shouldTraverse = !editingNodeIds.includes(xynode.id) && xynode.type === "compound" && ancestorsOfDraggingNodes.has(xynode.id), rect = shouldTraverse ? new Compound(xynode, parent) : new Leaf(xynode, parent);
    rects.set(xynode.id, rect), shouldTraverse && parentLookup.get(xynode.id)?.forEach((child) => {
      traverse.push({
        xynode: child,
        parent: rect
      });
    });
  }
  const rectsToUpdate = [...rects.values()];
  applyConstraints2(rectsToUpdate);
  function applyConstraints2(targets) {
    targets.filter((x2) => x2 instanceof Compound).forEach((r2) => {
      applyConstraints2(r2.children);
      const childrenBB = r2.children.reduce((acc, r22) => ({
        minX: Math.min(acc.minX, r22.minX),
        minY: Math.min(acc.minY, r22.minY),
        maxX: Math.max(acc.maxX, r22.maxX),
        maxY: Math.max(acc.maxY, r22.maxY)
      }), {
        minX: 1 / 0,
        minY: 1 / 0,
        maxX: -1 / 0,
        maxY: -1 / 0
      });
      r2.minX = childrenBB.minX - Rect.LeftPadding, r2.minY = childrenBB.minY - Rect.TopPadding, r2.maxX = childrenBB.maxX + Rect.RightPadding, r2.maxY = childrenBB.maxY + Rect.BottomPadding;
    });
  }
  function updateXYFlowNodes() {
    applyConstraints2(rectsToUpdate), xyflowApi.getState().triggerNodeChanges(
      rectsToUpdate.reduce((acc, r2) => (acc.push({
        id: r2.id,
        type: "position",
        dragging: !1,
        position: r2.position,
        positionAbsolute: r2.positionAbsolute
      }), r2 instanceof Compound && acc.push({
        id: r2.id,
        type: "dimensions",
        setAttributes: !0,
        dimensions: r2.dimensions
      }), acc), [])
    );
  }
  let animationFrameId = null;
  function onMove(updater) {
    rectsToUpdate.length !== 0 && (animationFrameId ??= requestAnimationFrame(() => {
      animationFrameId = null, updater(
        x$1(
          editingNodeIds,
          T((id2) => rects.has(id2) && nodeLookup.has(id2)),
          m$1((id2) => ({
            rect: nonNullable(rects.get(id2)),
            node: nonNullable(nodeLookup.get(id2))
          }))
        )
      ), updateXYFlowNodes();
    }));
  }
  return {
    updateXYFlowNodes,
    onMove
  };
}
function useLayoutConstraints() {
  const diagramApi = useDiagramStoreApi(), solverRef = useRef$1();
  return useMemo$1(() => ({
    onNodeDragStart: (_event, xynode) => {
      const { cancelSaveManualLayout, xystore } = diagramApi.getState(), { nodeLookup } = xystore.getState();
      cancelSaveManualLayout();
      const draggingNodes = x$1(
        Array.from(nodeLookup.values()),
        T((n2) => n2.dragging === !0 || n2.id === xynode.id || n2.selected === !0),
        T((n2) => n2.draggable !== !1),
        m$1((x2) => x2.id)
      );
      i$8(draggingNodes, 1) && (solverRef.current = createLayoutConstraints(xystore, draggingNodes));
    },
    onNodeDrag: () => {
      solverRef.current?.onMove((nodes) => {
        nodes.forEach(({ rect, node: node2 }) => {
          rect.positionAbsolute = node2.internals.positionAbsolute;
        });
      });
    },
    onNodeDragStop: () => {
      solverRef.current?.updateXYFlowNodes(), diagramApi.getState().scheduleSaveManualLayout(), solverRef.current = void 0;
    }
  }), [diagramApi]);
}
const { abs: abs$1, cos: cos$1, sin: sin$1, acos: acos$1, atan2, sqrt: sqrt$1, pow } = Math;
function crt(v) {
  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);
}
const pi$2 = Math.PI, tau$1 = 2 * pi$2, quart = pi$2 / 2, epsilon$2 = 1e-6, nMax = Number.MAX_SAFE_INTEGER || 9007199254740991, nMin = Number.MIN_SAFE_INTEGER || -9007199254740991, ZERO = { x: 0, y: 0, z: 0 }, utils = {
  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
  Tvalues: [
    -0.06405689286260563,
    0.06405689286260563,
    -0.1911188674736163,
    0.1911188674736163,
    -0.3150426796961634,
    0.3150426796961634,
    -0.4337935076260451,
    0.4337935076260451,
    -0.5454214713888396,
    0.5454214713888396,
    -0.6480936519369755,
    0.6480936519369755,
    -0.7401241915785544,
    0.7401241915785544,
    -0.820001985973903,
    0.820001985973903,
    -0.8864155270044011,
    0.8864155270044011,
    -0.9382745520027328,
    0.9382745520027328,
    -0.9747285559713095,
    0.9747285559713095,
    -0.9951872199970213,
    0.9951872199970213
  ],
  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
  Cvalues: [
    0.12793819534675216,
    0.12793819534675216,
    0.1258374563468283,
    0.1258374563468283,
    0.12167047292780339,
    0.12167047292780339,
    0.1155056680537256,
    0.1155056680537256,
    0.10744427011596563,
    0.10744427011596563,
    0.09761865210411388,
    0.09761865210411388,
    0.08619016153195327,
    0.08619016153195327,
    0.0733464814110803,
    0.0733464814110803,
    0.05929858491543678,
    0.05929858491543678,
    0.04427743881741981,
    0.04427743881741981,
    0.028531388628933663,
    0.028531388628933663,
    0.0123412297999872,
    0.0123412297999872
  ],
  arcfn: function(t2, derivativeFn) {
    const d2 = derivativeFn(t2);
    let l2 = d2.x * d2.x + d2.y * d2.y;
    return typeof d2.z < "u" && (l2 += d2.z * d2.z), sqrt$1(l2);
  },
  compute: function(t2, points, _3d) {
    if (t2 === 0)
      return points[0].t = 0, points[0];
    const order2 = points.length - 1;
    if (t2 === 1)
      return points[order2].t = 1, points[order2];
    const mt = 1 - t2;
    let p2 = points;
    if (order2 === 0)
      return points[0].t = t2, points[0];
    if (order2 === 1) {
      const ret = {
        x: mt * p2[0].x + t2 * p2[1].x,
        y: mt * p2[0].y + t2 * p2[1].y,
        t: t2
      };
      return _3d && (ret.z = mt * p2[0].z + t2 * p2[1].z), ret;
    }
    if (order2 < 4) {
      let mt2 = mt * mt, t22 = t2 * t2, a2, b2, c, d2 = 0;
      order2 === 2 ? (p2 = [p2[0], p2[1], p2[2], ZERO], a2 = mt2, b2 = mt * t2 * 2, c = t22) : order2 === 3 && (a2 = mt2 * mt, b2 = mt2 * t2 * 3, c = mt * t22 * 3, d2 = t2 * t22);
      const ret = {
        x: a2 * p2[0].x + b2 * p2[1].x + c * p2[2].x + d2 * p2[3].x,
        y: a2 * p2[0].y + b2 * p2[1].y + c * p2[2].y + d2 * p2[3].y,
        t: t2
      };
      return _3d && (ret.z = a2 * p2[0].z + b2 * p2[1].z + c * p2[2].z + d2 * p2[3].z), ret;
    }
    const dCpts = JSON.parse(JSON.stringify(points));
    for (; dCpts.length > 1; ) {
      for (let i2 = 0; i2 < dCpts.length - 1; i2++)
        dCpts[i2] = {
          x: dCpts[i2].x + (dCpts[i2 + 1].x - dCpts[i2].x) * t2,
          y: dCpts[i2].y + (dCpts[i2 + 1].y - dCpts[i2].y) * t2
        }, typeof dCpts[i2].z < "u" && (dCpts[i2].z = dCpts[i2].z + (dCpts[i2 + 1].z - dCpts[i2].z) * t2);
      dCpts.splice(dCpts.length - 1, 1);
    }
    return dCpts[0].t = t2, dCpts[0];
  },
  computeWithRatios: function(t2, points, ratios, _3d) {
    const mt = 1 - t2, r2 = ratios, p2 = points;
    let f1 = r2[0], f2 = r2[1], f3 = r2[2], f4 = r2[3], d2;
    if (f1 *= mt, f2 *= t2, p2.length === 2)
      return d2 = f1 + f2, {
        x: (f1 * p2[0].x + f2 * p2[1].x) / d2,
        y: (f1 * p2[0].y + f2 * p2[1].y) / d2,
        z: _3d ? (f1 * p2[0].z + f2 * p2[1].z) / d2 : !1,
        t: t2
      };
    if (f1 *= mt, f2 *= 2 * mt, f3 *= t2 * t2, p2.length === 3)
      return d2 = f1 + f2 + f3, {
        x: (f1 * p2[0].x + f2 * p2[1].x + f3 * p2[2].x) / d2,
        y: (f1 * p2[0].y + f2 * p2[1].y + f3 * p2[2].y) / d2,
        z: _3d ? (f1 * p2[0].z + f2 * p2[1].z + f3 * p2[2].z) / d2 : !1,
        t: t2
      };
    if (f1 *= mt, f2 *= 1.5 * mt, f3 *= 3 * mt, f4 *= t2 * t2 * t2, p2.length === 4)
      return d2 = f1 + f2 + f3 + f4, {
        x: (f1 * p2[0].x + f2 * p2[1].x + f3 * p2[2].x + f4 * p2[3].x) / d2,
        y: (f1 * p2[0].y + f2 * p2[1].y + f3 * p2[2].y + f4 * p2[3].y) / d2,
        z: _3d ? (f1 * p2[0].z + f2 * p2[1].z + f3 * p2[2].z + f4 * p2[3].z) / d2 : !1,
        t: t2
      };
  },
  derive: function(points, _3d) {
    const dpoints = [];
    for (let p2 = points, d2 = p2.length, c = d2 - 1; d2 > 1; d2--, c--) {
      const list2 = [];
      for (let j = 0, dpt; j < c; j++)
        dpt = {
          x: c * (p2[j + 1].x - p2[j].x),
          y: c * (p2[j + 1].y - p2[j].y)
        }, _3d && (dpt.z = c * (p2[j + 1].z - p2[j].z)), list2.push(dpt);
      dpoints.push(list2), p2 = list2;
    }
    return dpoints;
  },
  between: function(v, m2, M) {
    return m2 <= v && v <= M || utils.approximately(v, m2) || utils.approximately(v, M);
  },
  approximately: function(a2, b2, precision) {
    return abs$1(a2 - b2) <= (precision || epsilon$2);
  },
  length: function(derivativeFn) {
    const len = utils.Tvalues.length;
    let sum = 0;
    for (let i2 = 0, t2; i2 < len; i2++)
      t2 = 0.5 * utils.Tvalues[i2] + 0.5, sum += utils.Cvalues[i2] * utils.arcfn(t2, derivativeFn);
    return 0.5 * sum;
  },
  map: function(v, ds, de, ts, te) {
    const d1 = de - ds, d2 = te - ts, v2 = v - ds, r2 = v2 / d1;
    return ts + d2 * r2;
  },
  lerp: function(r2, v1, v2) {
    const ret = {
      x: v1.x + r2 * (v2.x - v1.x),
      y: v1.y + r2 * (v2.y - v1.y)
    };
    return v1.z !== void 0 && v2.z !== void 0 && (ret.z = v1.z + r2 * (v2.z - v1.z)), ret;
  },
  pointToString: function(p2) {
    let s2 = p2.x + "/" + p2.y;
    return typeof p2.z < "u" && (s2 += "/" + p2.z), s2;
  },
  pointsToString: function(points) {
    return "[" + points.map(utils.pointToString).join(", ") + "]";
  },
  copy: function(obj) {
    return JSON.parse(JSON.stringify(obj));
  },
  angle: function(o2, v1, v2) {
    const dx1 = v1.x - o2.x, dy1 = v1.y - o2.y, dx2 = v2.x - o2.x, dy2 = v2.y - o2.y, cross = dx1 * dy2 - dy1 * dx2, dot = dx1 * dx2 + dy1 * dy2;
    return atan2(cross, dot);
  },
  // round as string, to avoid rounding errors
  round: function(v, d2) {
    const s2 = "" + v, pos = s2.indexOf(".");
    return parseFloat(s2.substring(0, pos + 1 + d2));
  },
  dist: function(p1, p2) {
    const dx = p1.x - p2.x, dy = p1.y - p2.y;
    return sqrt$1(dx * dx + dy * dy);
  },
  closest: function(LUT, point2) {
    let mdist = pow(2, 63), mpos, d2;
    return LUT.forEach(function(p2, idx) {
      d2 = utils.dist(point2, p2), d2 < mdist && (mdist = d2, mpos = idx);
    }), { mdist, mpos };
  },
  abcratio: function(t2, n2) {
    if (n2 !== 2 && n2 !== 3)
      return !1;
    if (typeof t2 > "u")
      t2 = 0.5;
    else if (t2 === 0 || t2 === 1)
      return t2;
    const bottom = pow(t2, n2) + pow(1 - t2, n2), top = bottom - 1;
    return abs$1(top / bottom);
  },
  projectionratio: function(t2, n2) {
    if (n2 !== 2 && n2 !== 3)
      return !1;
    if (typeof t2 > "u")
      t2 = 0.5;
    else if (t2 === 0 || t2 === 1)
      return t2;
    const top = pow(1 - t2, n2), bottom = pow(t2, n2) + top;
    return top / bottom;
  },
  lli8: function(x1, y1, x2, y2, x3, y3, x4, y4) {
    const nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4), ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4), d2 = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    return d2 == 0 ? !1 : { x: nx / d2, y: ny / d2 };
  },
  lli4: function(p1, p2, p3, p4) {
    const x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y, x3 = p3.x, y3 = p3.y, x4 = p4.x, y4 = p4.y;
    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);
  },
  lli: function(v1, v2) {
    return utils.lli4(v1, v1.c, v2, v2.c);
  },
  makeline: function(p1, p2) {
    return new Bezier(
      p1.x,
      p1.y,
      (p1.x + p2.x) / 2,
      (p1.y + p2.y) / 2,
      p2.x,
      p2.y
    );
  },
  findbbox: function(sections) {
    let mx = nMax, my = nMax, MX = nMin, MY = nMin;
    return sections.forEach(function(s2) {
      const bbox = s2.bbox();
      mx > bbox.x.min && (mx = bbox.x.min), my > bbox.y.min && (my = bbox.y.min), MX < bbox.x.max && (MX = bbox.x.max), MY < bbox.y.max && (MY = bbox.y.max);
    }), {
      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },
      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my }
    };
  },
  shapeintersections: function(s1, bbox1, s2, bbox2, curveIntersectionThreshold) {
    if (!utils.bboxoverlap(bbox1, bbox2)) return [];
    const intersections = [], a1 = [s1.startcap, s1.forward, s1.back, s1.endcap], a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];
    return a1.forEach(function(l1) {
      l1.virtual || a2.forEach(function(l2) {
        if (l2.virtual) return;
        const iss = l1.intersects(l2, curveIntersectionThreshold);
        iss.length > 0 && (iss.c1 = l1, iss.c2 = l2, iss.s1 = s1, iss.s2 = s2, intersections.push(iss));
      });
    }), intersections;
  },
  makeshape: function(forward, back, curveIntersectionThreshold) {
    const bpl = back.points.length, fpl = forward.points.length, start = utils.makeline(back.points[bpl - 1], forward.points[0]), end = utils.makeline(forward.points[fpl - 1], back.points[0]), shape = {
      startcap: start,
      forward,
      back,
      endcap: end,
      bbox: utils.findbbox([start, forward, back, end])
    };
    return shape.intersections = function(s2) {
      return utils.shapeintersections(
        shape,
        shape.bbox,
        s2,
        s2.bbox,
        curveIntersectionThreshold
      );
    }, shape;
  },
  getminmax: function(curve2, d2, list2) {
    if (!list2) return { min: 0, max: 0 };
    let min2 = nMax, max2 = nMin, t2, c;
    list2.indexOf(0) === -1 && (list2 = [0].concat(list2)), list2.indexOf(1) === -1 && list2.push(1);
    for (let i2 = 0, len = list2.length; i2 < len; i2++)
      t2 = list2[i2], c = curve2.get(t2), c[d2] < min2 && (min2 = c[d2]), c[d2] > max2 && (max2 = c[d2]);
    return { min: min2, mid: (min2 + max2) / 2, max: max2, size: max2 - min2 };
  },
  align: function(points, line) {
    const tx = line.p1.x, ty = line.p1.y, a2 = -atan2(line.p2.y - ty, line.p2.x - tx), d2 = function(v) {
      return {
        x: (v.x - tx) * cos$1(a2) - (v.y - ty) * sin$1(a2),
        y: (v.x - tx) * sin$1(a2) + (v.y - ty) * cos$1(a2)
      };
    };
    return points.map(d2);
  },
  roots: function(points, line) {
    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };
    const order2 = points.length - 1, aligned = utils.align(points, line), reduce = function(t2) {
      return 0 <= t2 && t2 <= 1;
    };
    if (order2 === 2) {
      const a3 = aligned[0].y, b3 = aligned[1].y, c2 = aligned[2].y, d3 = a3 - 2 * b3 + c2;
      if (d3 !== 0) {
        const m1 = -sqrt$1(b3 * b3 - a3 * c2), m2 = -a3 + b3, v12 = -(m1 + m2) / d3, v2 = -(-m1 + m2) / d3;
        return [v12, v2].filter(reduce);
      } else if (b3 !== c2 && d3 === 0)
        return [(2 * b3 - c2) / (2 * b3 - 2 * c2)].filter(reduce);
      return [];
    }
    const pa = aligned[0].y, pb = aligned[1].y, pc = aligned[2].y, pd = aligned[3].y;
    let d2 = -pa + 3 * pb - 3 * pc + pd, a2 = 3 * pa - 6 * pb + 3 * pc, b2 = -3 * pa + 3 * pb, c = pa;
    if (utils.approximately(d2, 0)) {
      if (utils.approximately(a2, 0))
        return utils.approximately(b2, 0) ? [] : [-c / b2].filter(reduce);
      const q3 = sqrt$1(b2 * b2 - 4 * a2 * c), a22 = 2 * a2;
      return [(q3 - b2) / a22, (-b2 - q3) / a22].filter(reduce);
    }
    a2 /= d2, b2 /= d2, c /= d2;
    const p2 = (3 * b2 - a2 * a2) / 3, p3 = p2 / 3, q = (2 * a2 * a2 * a2 - 9 * a2 * b2 + 27 * c) / 27, q2 = q / 2, discriminant = q2 * q2 + p3 * p3 * p3;
    let u1, v1, x1, x2, x3;
    if (discriminant < 0) {
      const mp3 = -p2 / 3, mp33 = mp3 * mp3 * mp3, r2 = sqrt$1(mp33), t2 = -q / (2 * r2), cosphi = t2 < -1 ? -1 : t2 > 1 ? 1 : t2, phi = acos$1(cosphi), crtr = crt(r2), t1 = 2 * crtr;
      return x1 = t1 * cos$1(phi / 3) - a2 / 3, x2 = t1 * cos$1((phi + tau$1) / 3) - a2 / 3, x3 = t1 * cos$1((phi + 2 * tau$1) / 3) - a2 / 3, [x1, x2, x3].filter(reduce);
    } else {
      if (discriminant === 0)
        return u1 = q2 < 0 ? crt(-q2) : -crt(q2), x1 = 2 * u1 - a2 / 3, x2 = -u1 - a2 / 3, [x1, x2].filter(reduce);
      {
        const sd = sqrt$1(discriminant);
        return u1 = crt(-q2 + sd), v1 = crt(q2 + sd), [u1 - v1 - a2 / 3].filter(reduce);
      }
    }
  },
  droots: function(p2) {
    if (p2.length === 3) {
      const a2 = p2[0], b2 = p2[1], c = p2[2], d2 = a2 - 2 * b2 + c;
      if (d2 !== 0) {
        const m1 = -sqrt$1(b2 * b2 - a2 * c), m2 = -a2 + b2, v1 = -(m1 + m2) / d2, v2 = -(-m1 + m2) / d2;
        return [v1, v2];
      } else if (b2 !== c && d2 === 0)
        return [(2 * b2 - c) / (2 * (b2 - c))];
      return [];
    }
    if (p2.length === 2) {
      const a2 = p2[0], b2 = p2[1];
      return a2 !== b2 ? [a2 / (a2 - b2)] : [];
    }
    return [];
  },
  curvature: function(t2, d1, d2, _3d, kOnly) {
    let num, dnm, adk, dk, k = 0, r2 = 0;
    const d3 = utils.compute(t2, d1), dd = utils.compute(t2, d2), qdsum = d3.x * d3.x + d3.y * d3.y;
    if (_3d ? (num = sqrt$1(
      pow(d3.y * dd.z - dd.y * d3.z, 2) + pow(d3.z * dd.x - dd.z * d3.x, 2) + pow(d3.x * dd.y - dd.x * d3.y, 2)
    ), dnm = pow(qdsum + d3.z * d3.z, 3 / 2)) : (num = d3.x * dd.y - d3.y * dd.x, dnm = pow(qdsum, 3 / 2)), num === 0 || dnm === 0)
      return { k: 0, r: 0 };
    if (k = num / dnm, r2 = dnm / num, !kOnly) {
      const pk = utils.curvature(t2 - 1e-3, d1, d2, _3d, !0).k, nk = utils.curvature(t2 + 1e-3, d1, d2, _3d, !0).k;
      dk = (nk - k + (k - pk)) / 2, adk = (abs$1(nk - k) + abs$1(k - pk)) / 2;
    }
    return { k, r: r2, dk, adk };
  },
  inflections: function(points) {
    if (points.length < 4) return [];
    const p2 = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }), a2 = p2[2].x * p2[1].y, b2 = p2[3].x * p2[1].y, c = p2[1].x * p2[2].y, d2 = p2[3].x * p2[2].y, v1 = 18 * (-3 * a2 + 2 * b2 + 3 * c - d2), v2 = 18 * (3 * a2 - b2 - 3 * c), v3 = 18 * (c - a2);
    if (utils.approximately(v1, 0)) {
      if (!utils.approximately(v2, 0)) {
        let t2 = -v3 / v2;
        if (0 <= t2 && t2 <= 1) return [t2];
      }
      return [];
    }
    const d22 = 2 * v1;
    if (utils.approximately(d22, 0)) return [];
    const trm = v2 * v2 - 4 * v1 * v3;
    if (trm < 0) return [];
    const sq = Math.sqrt(trm);
    return [(sq - v2) / d22, -(v2 + sq) / d22].filter(function(r2) {
      return 0 <= r2 && r2 <= 1;
    });
  },
  bboxoverlap: function(b1, b2) {
    const dims = ["x", "y"], len = dims.length;
    for (let i2 = 0, dim, l2, t2, d2; i2 < len; i2++)
      if (dim = dims[i2], l2 = b1[dim].mid, t2 = b2[dim].mid, d2 = (b1[dim].size + b2[dim].size) / 2, abs$1(l2 - t2) >= d2) return !1;
    return !0;
  },
  expandbox: function(bbox, _bbox) {
    _bbox.x.min < bbox.x.min && (bbox.x.min = _bbox.x.min), _bbox.y.min < bbox.y.min && (bbox.y.min = _bbox.y.min), _bbox.z && _bbox.z.min < bbox.z.min && (bbox.z.min = _bbox.z.min), _bbox.x.max > bbox.x.max && (bbox.x.max = _bbox.x.max), _bbox.y.max > bbox.y.max && (bbox.y.max = _bbox.y.max), _bbox.z && _bbox.z.max > bbox.z.max && (bbox.z.max = _bbox.z.max), bbox.x.mid = (bbox.x.min + bbox.x.max) / 2, bbox.y.mid = (bbox.y.min + bbox.y.max) / 2, bbox.z && (bbox.z.mid = (bbox.z.min + bbox.z.max) / 2), bbox.x.size = bbox.x.max - bbox.x.min, bbox.y.size = bbox.y.max - bbox.y.min, bbox.z && (bbox.z.size = bbox.z.max - bbox.z.min);
  },
  pairiteration: function(c1, c2, curveIntersectionThreshold) {
    const c1b = c1.bbox(), c2b = c2.bbox(), r2 = 1e5, threshold = curveIntersectionThreshold || 0.5;
    if (c1b.x.size + c1b.y.size < threshold && c2b.x.size + c2b.y.size < threshold)
      return [
        (r2 * (c1._t1 + c1._t2) / 2 | 0) / r2 + "/" + (r2 * (c2._t1 + c2._t2) / 2 | 0) / r2
      ];
    let cc1 = c1.split(0.5), cc2 = c2.split(0.5), pairs = [
      { left: cc1.left, right: cc2.left },
      { left: cc1.left, right: cc2.right },
      { left: cc1.right, right: cc2.right },
      { left: cc1.right, right: cc2.left }
    ];
    pairs = pairs.filter(function(pair) {
      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());
    });
    let results = [];
    return pairs.length === 0 || (pairs.forEach(function(pair) {
      results = results.concat(
        utils.pairiteration(pair.left, pair.right, threshold)
      );
    }), results = results.filter(function(v, i2) {
      return results.indexOf(v) === i2;
    })), results;
  },
  getccenter: function(p1, p2, p3) {
    const dx1 = p2.x - p1.x, dy1 = p2.y - p1.y, dx2 = p3.x - p2.x, dy2 = p3.y - p2.y, dx1p = dx1 * cos$1(quart) - dy1 * sin$1(quart), dy1p = dx1 * sin$1(quart) + dy1 * cos$1(quart), dx2p = dx2 * cos$1(quart) - dy2 * sin$1(quart), dy2p = dx2 * sin$1(quart) + dy2 * cos$1(quart), mx1 = (p1.x + p2.x) / 2, my1 = (p1.y + p2.y) / 2, mx2 = (p2.x + p3.x) / 2, my2 = (p2.y + p3.y) / 2, mx1n = mx1 + dx1p, my1n = my1 + dy1p, mx2n = mx2 + dx2p, my2n = my2 + dy2p, arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n), r2 = utils.dist(arc, p1);
    let s2 = atan2(p1.y - arc.y, p1.x - arc.x), m2 = atan2(p2.y - arc.y, p2.x - arc.x), e2 = atan2(p3.y - arc.y, p3.x - arc.x), _;
    return s2 < e2 ? ((s2 > m2 || m2 > e2) && (s2 += tau$1), s2 > e2 && (_ = e2, e2 = s2, s2 = _)) : e2 < m2 && m2 < s2 ? (_ = e2, e2 = s2, s2 = _) : e2 += tau$1, arc.s = s2, arc.e = e2, arc.r = r2, arc;
  },
  numberSort: function(a2, b2) {
    return a2 - b2;
  }
};
class PolyBezier {
  constructor(curves) {
    this.curves = [], this._3d = !1, curves && (this.curves = curves, this._3d = this.curves[0]._3d);
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return "[" + this.curves.map(function(curve2) {
      return utils.pointsToString(curve2.points);
    }).join(", ") + "]";
  }
  addCurve(curve2) {
    this.curves.push(curve2), this._3d = this._3d || curve2._3d;
  }
  length() {
    return this.curves.map(function(v) {
      return v.length();
    }).reduce(function(a2, b2) {
      return a2 + b2;
    });
  }
  curve(idx) {
    return this.curves[idx];
  }
  bbox() {
    const c = this.curves;
    for (var bbox = c[0].bbox(), i2 = 1; i2 < c.length; i2++)
      utils.expandbox(bbox, c[i2].bbox());
    return bbox;
  }
  offset(d2) {
    const offset = [];
    return this.curves.forEach(function(v) {
      offset.push(...v.offset(d2));
    }), new PolyBezier(offset);
  }
}
const { abs, min, max, cos, sin, acos, sqrt } = Math, pi$1 = Math.PI;
class Bezier {
  constructor(coords) {
    let args = coords && coords.forEach ? coords : Array.from(arguments).slice(), coordlen = !1;
    if (typeof args[0] == "object") {
      coordlen = args.length;
      const newargs = [];
      args.forEach(function(point3) {
        ["x", "y", "z"].forEach(function(d2) {
          typeof point3[d2] < "u" && newargs.push(point3[d2]);
        });
      }), args = newargs;
    }
    let higher = !1;
    const len = args.length;
    if (coordlen) {
      if (coordlen > 4) {
        if (arguments.length !== 1)
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        higher = !0;
      }
    } else if (len !== 6 && len !== 8 && len !== 9 && len !== 12 && arguments.length !== 1)
      throw new Error(
        "Only new Bezier(point[]) is accepted for 4th and higher order curves"
      );
    const _3d = this._3d = !higher && (len === 9 || len === 12) || coords && coords[0] && typeof coords[0].z < "u", points = this.points = [];
    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {
      var point2 = {
        x: args[idx],
        y: args[idx + 1]
      };
      _3d && (point2.z = args[idx + 2]), points.push(point2);
    }
    const order2 = this.order = points.length - 1, dims = this.dims = ["x", "y"];
    _3d && dims.push("z"), this.dimlen = dims.length;
    const aligned = utils.align(points, { p1: points[0], p2: points[order2] }), baselength = utils.dist(points[0], points[order2]);
    this._linear = aligned.reduce((t2, p2) => t2 + abs(p2.y), 0) < baselength / 50, this._lut = [], this._t1 = 0, this._t2 = 1, this.update();
  }
  static quadraticFromPoints(p1, p2, p3, t2) {
    if (typeof t2 > "u" && (t2 = 0.5), t2 === 0)
      return new Bezier(p2, p2, p3);
    if (t2 === 1)
      return new Bezier(p1, p2, p2);
    const abc = Bezier.getABC(2, p1, p2, p3, t2);
    return new Bezier(p1, abc.A, p3);
  }
  static cubicFromPoints(S, B2, E, t2, d1) {
    typeof t2 > "u" && (t2 = 0.5);
    const abc = Bezier.getABC(3, S, B2, E, t2);
    typeof d1 > "u" && (d1 = utils.dist(B2, abc.C));
    const d2 = d1 * (1 - t2) / t2, selen = utils.dist(S, E), lx = (E.x - S.x) / selen, ly = (E.y - S.y) / selen, bx1 = d1 * lx, by1 = d1 * ly, bx2 = d2 * lx, by2 = d2 * ly, e1 = { x: B2.x - bx1, y: B2.y - by1 }, e2 = { x: B2.x + bx2, y: B2.y + by2 }, A2 = abc.A, v1 = { x: A2.x + (e1.x - A2.x) / (1 - t2), y: A2.y + (e1.y - A2.y) / (1 - t2) }, v2 = { x: A2.x + (e2.x - A2.x) / t2, y: A2.y + (e2.y - A2.y) / t2 }, nc1 = { x: S.x + (v1.x - S.x) / t2, y: S.y + (v1.y - S.y) / t2 }, nc2 = {
      x: E.x + (v2.x - E.x) / (1 - t2),
      y: E.y + (v2.y - E.y) / (1 - t2)
    };
    return new Bezier(S, nc1, nc2, E);
  }
  static getUtils() {
    return utils;
  }
  getUtils() {
    return Bezier.getUtils();
  }
  static get PolyBezier() {
    return PolyBezier;
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return utils.pointsToString(this.points);
  }
  toSVG() {
    if (this._3d) return !1;
    const p2 = this.points, x2 = p2[0].x, y2 = p2[0].y, s2 = ["M", x2, y2, this.order === 2 ? "Q" : "C"];
    for (let i2 = 1, last = p2.length; i2 < last; i2++)
      s2.push(p2[i2].x), s2.push(p2[i2].y);
    return s2.join(" ");
  }
  setRatios(ratios) {
    if (ratios.length !== this.points.length)
      throw new Error("incorrect number of ratio values");
    this.ratios = ratios, this._lut = [];
  }
  verify() {
    const print = this.coordDigest();
    print !== this._print && (this._print = print, this.update());
  }
  coordDigest() {
    return this.points.map(function(c, pos) {
      return "" + pos + c.x + c.y + (c.z ? c.z : 0);
    }).join("");
  }
  update() {
    this._lut = [], this.dpoints = utils.derive(this.points, this._3d), this.computedirection();
  }
  computedirection() {
    const points = this.points, angle = utils.angle(points[0], points[this.order], points[1]);
    this.clockwise = angle > 0;
  }
  length() {
    return utils.length(this.derivative.bind(this));
  }
  static getABC(order2 = 2, S, B2, E, t2 = 0.5) {
    const u2 = utils.projectionratio(t2, order2), um = 1 - u2, C = {
      x: u2 * S.x + um * E.x,
      y: u2 * S.y + um * E.y
    }, s2 = utils.abcratio(t2, order2);
    return { A: {
      x: B2.x + (B2.x - C.x) / s2,
      y: B2.y + (B2.y - C.y) / s2
    }, B: B2, C, S, E };
  }
  getABC(t2, B2) {
    B2 = B2 || this.get(t2);
    let S = this.points[0], E = this.points[this.order];
    return Bezier.getABC(this.order, S, B2, E, t2);
  }
  getLUT(steps) {
    if (this.verify(), steps = steps || 100, this._lut.length === steps + 1)
      return this._lut;
    this._lut = [], steps++, this._lut = [];
    for (let i2 = 0, p2, t2; i2 < steps; i2++)
      t2 = i2 / (steps - 1), p2 = this.compute(t2), p2.t = t2, this._lut.push(p2);
    return this._lut;
  }
  on(point2, error) {
    error = error || 5;
    const lut = this.getLUT(), hits = [];
    for (let i2 = 0, c, t2 = 0; i2 < lut.length; i2++)
      c = lut[i2], utils.dist(c, point2) < error && (hits.push(c), t2 += i2 / lut.length);
    return hits.length ? t /= hits.length : !1;
  }
  project(point2) {
    const LUT = this.getLUT(), l2 = LUT.length - 1, closest = utils.closest(LUT, point2), mpos = closest.mpos, t1 = (mpos - 1) / l2, t2 = (mpos + 1) / l2, step = 0.1 / l2;
    let mdist = closest.mdist, t3 = t1, ft = t3, p2;
    mdist += 1;
    for (let d2; t3 < t2 + step; t3 += step)
      p2 = this.compute(t3), d2 = utils.dist(point2, p2), d2 < mdist && (mdist = d2, ft = t3);
    return ft = ft < 0 ? 0 : ft > 1 ? 1 : ft, p2 = this.compute(ft), p2.t = ft, p2.d = mdist, p2;
  }
  get(t2) {
    return this.compute(t2);
  }
  point(idx) {
    return this.points[idx];
  }
  compute(t2) {
    return this.ratios ? utils.computeWithRatios(t2, this.points, this.ratios, this._3d) : utils.compute(t2, this.points, this._3d, this.ratios);
  }
  raise() {
    const p2 = this.points, np = [p2[0]], k = p2.length;
    for (let i2 = 1, pi2, pim; i2 < k; i2++)
      pi2 = p2[i2], pim = p2[i2 - 1], np[i2] = {
        x: (k - i2) / k * pi2.x + i2 / k * pim.x,
        y: (k - i2) / k * pi2.y + i2 / k * pim.y
      };
    return np[k] = p2[k - 1], new Bezier(np);
  }
  derivative(t2) {
    return utils.compute(t2, this.dpoints[0], this._3d);
  }
  dderivative(t2) {
    return utils.compute(t2, this.dpoints[1], this._3d);
  }
  align() {
    let p2 = this.points;
    return new Bezier(utils.align(p2, { p1: p2[0], p2: p2[p2.length - 1] }));
  }
  curvature(t2) {
    return utils.curvature(t2, this.dpoints[0], this.dpoints[1], this._3d);
  }
  inflections() {
    return utils.inflections(this.points);
  }
  normal(t2) {
    return this._3d ? this.__normal3(t2) : this.__normal2(t2);
  }
  __normal2(t2) {
    const d2 = this.derivative(t2), q = sqrt(d2.x * d2.x + d2.y * d2.y);
    return { t: t2, x: -d2.y / q, y: d2.x / q };
  }
  __normal3(t2) {
    const r1 = this.derivative(t2), r2 = this.derivative(t2 + 0.01), q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z), q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);
    r1.x /= q1, r1.y /= q1, r1.z /= q1, r2.x /= q2, r2.y /= q2, r2.z /= q2;
    const c = {
      x: r2.y * r1.z - r2.z * r1.y,
      y: r2.z * r1.x - r2.x * r1.z,
      z: r2.x * r1.y - r2.y * r1.x
    }, m2 = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);
    c.x /= m2, c.y /= m2, c.z /= m2;
    const R = [
      c.x * c.x,
      c.x * c.y - c.z,
      c.x * c.z + c.y,
      c.x * c.y + c.z,
      c.y * c.y,
      c.y * c.z - c.x,
      c.x * c.z - c.y,
      c.y * c.z + c.x,
      c.z * c.z
    ];
    return {
      t: t2,
      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,
      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,
      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z
    };
  }
  hull(t2) {
    let p2 = this.points, _p = [], q = [], idx = 0;
    for (q[idx++] = p2[0], q[idx++] = p2[1], q[idx++] = p2[2], this.order === 3 && (q[idx++] = p2[3]); p2.length > 1; ) {
      _p = [];
      for (let i2 = 0, pt, l2 = p2.length - 1; i2 < l2; i2++)
        pt = utils.lerp(t2, p2[i2], p2[i2 + 1]), q[idx++] = pt, _p.push(pt);
      p2 = _p;
    }
    return q;
  }
  split(t1, t2) {
    if (t1 === 0 && t2)
      return this.split(t2).left;
    if (t2 === 1)
      return this.split(t1).right;
    const q = this.hull(t1), result = {
      left: this.order === 2 ? new Bezier([q[0], q[3], q[5]]) : new Bezier([q[0], q[4], q[7], q[9]]),
      right: this.order === 2 ? new Bezier([q[5], q[4], q[2]]) : new Bezier([q[9], q[8], q[6], q[3]]),
      span: q
    };
    return result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2), result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2), result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2), result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2), t2 ? (t2 = utils.map(t2, t1, 1, 0, 1), result.right.split(t2).left) : result;
  }
  extrema() {
    const result = {};
    let roots = [];
    return this.dims.forEach(
      function(dim) {
        let mfn = function(v) {
          return v[dim];
        }, p2 = this.dpoints[0].map(mfn);
        result[dim] = utils.droots(p2), this.order === 3 && (p2 = this.dpoints[1].map(mfn), result[dim] = result[dim].concat(utils.droots(p2))), result[dim] = result[dim].filter(function(t2) {
          return t2 >= 0 && t2 <= 1;
        }), roots = roots.concat(result[dim].sort(utils.numberSort));
      }.bind(this)
    ), result.values = roots.sort(utils.numberSort).filter(function(v, idx) {
      return roots.indexOf(v) === idx;
    }), result;
  }
  bbox() {
    const extrema = this.extrema(), result = {};
    return this.dims.forEach(
      function(d2) {
        result[d2] = utils.getminmax(this, d2, extrema[d2]);
      }.bind(this)
    ), result;
  }
  overlaps(curve2) {
    const lbbox = this.bbox(), tbbox = curve2.bbox();
    return utils.bboxoverlap(lbbox, tbbox);
  }
  offset(t2, d2) {
    if (typeof d2 < "u") {
      const c = this.get(t2), n2 = this.normal(t2), ret = {
        c,
        n: n2,
        x: c.x + n2.x * d2,
        y: c.y + n2.y * d2
      };
      return this._3d && (ret.z = c.z + n2.z * d2), ret;
    }
    if (this._linear) {
      const nv = this.normal(0), coords = this.points.map(function(p2) {
        const ret = {
          x: p2.x + t2 * nv.x,
          y: p2.y + t2 * nv.y
        };
        return p2.z && nv.z && (ret.z = p2.z + t2 * nv.z), ret;
      });
      return [new Bezier(coords)];
    }
    return this.reduce().map(function(s2) {
      return s2._linear ? s2.offset(t2)[0] : s2.scale(t2);
    });
  }
  simple() {
    if (this.order === 3) {
      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]), a2 = utils.angle(this.points[0], this.points[3], this.points[2]);
      if (a1 > 0 && a2 < 0 || a1 < 0 && a2 > 0) return !1;
    }
    const n1 = this.normal(0), n2 = this.normal(1);
    let s2 = n1.x * n2.x + n1.y * n2.y;
    return this._3d && (s2 += n1.z * n2.z), abs(acos(s2)) < pi$1 / 3;
  }
  reduce() {
    let i2, t1 = 0, t2 = 0, step = 0.01, segment, pass1 = [], pass2 = [], extrema = this.extrema().values;
    for (extrema.indexOf(0) === -1 && (extrema = [0].concat(extrema)), extrema.indexOf(1) === -1 && extrema.push(1), t1 = extrema[0], i2 = 1; i2 < extrema.length; i2++)
      t2 = extrema[i2], segment = this.split(t1, t2), segment._t1 = t1, segment._t2 = t2, pass1.push(segment), t1 = t2;
    return pass1.forEach(function(p1) {
      for (t1 = 0, t2 = 0; t2 <= 1; )
        for (t2 = t1 + step; t2 <= 1 + step; t2 += step)
          if (segment = p1.split(t1, t2), !segment.simple()) {
            if (t2 -= step, abs(t1 - t2) < step)
              return [];
            segment = p1.split(t1, t2), segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2), segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2), pass2.push(segment), t1 = t2;
            break;
          }
      t1 < 1 && (segment = p1.split(t1, 1), segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2), segment._t2 = p1._t2, pass2.push(segment));
    }), pass2;
  }
  translate(v, d1, d2) {
    d2 = typeof d2 == "number" ? d2 : d1;
    const o2 = this.order;
    let d3 = this.points.map((_, i2) => (1 - i2 / o2) * d1 + i2 / o2 * d2);
    return new Bezier(
      this.points.map((p2, i2) => ({
        x: p2.x + v.x * d3[i2],
        y: p2.y + v.y * d3[i2]
      }))
    );
  }
  scale(d2) {
    const order2 = this.order;
    let distanceFn = !1;
    if (typeof d2 == "function" && (distanceFn = d2), distanceFn && order2 === 2)
      return this.raise().scale(distanceFn);
    const clockwise = this.clockwise, points = this.points;
    if (this._linear)
      return this.translate(
        this.normal(0),
        distanceFn ? distanceFn(0) : d2,
        distanceFn ? distanceFn(1) : d2
      );
    const r1 = distanceFn ? distanceFn(0) : d2, r2 = distanceFn ? distanceFn(1) : d2, v = [this.offset(0, 10), this.offset(1, 10)], np = [], o2 = utils.lli4(v[0], v[0].c, v[1], v[1].c);
    if (!o2)
      throw new Error("cannot scale this curve. Try reducing it first.");
    return [0, 1].forEach(function(t2) {
      const p2 = np[t2 * order2] = utils.copy(points[t2 * order2]);
      p2.x += (t2 ? r2 : r1) * v[t2].n.x, p2.y += (t2 ? r2 : r1) * v[t2].n.y;
    }), distanceFn ? ([0, 1].forEach(function(t2) {
      if (!(order2 === 2 && t2)) {
        var p2 = points[t2 + 1], ov = {
          x: p2.x - o2.x,
          y: p2.y - o2.y
        }, rc = distanceFn ? distanceFn((t2 + 1) / order2) : d2;
        distanceFn && !clockwise && (rc = -rc);
        var m2 = sqrt(ov.x * ov.x + ov.y * ov.y);
        ov.x /= m2, ov.y /= m2, np[t2 + 1] = {
          x: p2.x + rc * ov.x,
          y: p2.y + rc * ov.y
        };
      }
    }), new Bezier(np)) : ([0, 1].forEach((t2) => {
      if (order2 === 2 && t2) return;
      const p2 = np[t2 * order2], d3 = this.derivative(t2), p22 = { x: p2.x + d3.x, y: p2.y + d3.y };
      np[t2 + 1] = utils.lli4(p2, p22, o2, points[t2 + 1]);
    }), new Bezier(np));
  }
  outline(d1, d2, d3, d4) {
    if (d2 = d2 === void 0 ? d1 : d2, this._linear) {
      const n2 = this.normal(0), start = this.points[0], end = this.points[this.points.length - 1];
      let s2, mid, e2;
      d3 === void 0 && (d3 = d1, d4 = d2), s2 = { x: start.x + n2.x * d1, y: start.y + n2.y * d1 }, e2 = { x: end.x + n2.x * d3, y: end.y + n2.y * d3 }, mid = { x: (s2.x + e2.x) / 2, y: (s2.y + e2.y) / 2 };
      const fline = [s2, mid, e2];
      s2 = { x: start.x - n2.x * d2, y: start.y - n2.y * d2 }, e2 = { x: end.x - n2.x * d4, y: end.y - n2.y * d4 }, mid = { x: (s2.x + e2.x) / 2, y: (s2.y + e2.y) / 2 };
      const bline = [e2, mid, s2], ls2 = utils.makeline(bline[2], fline[0]), le2 = utils.makeline(fline[2], bline[0]), segments2 = [ls2, new Bezier(fline), le2, new Bezier(bline)];
      return new PolyBezier(segments2);
    }
    const reduced = this.reduce(), len = reduced.length, fcurves = [];
    let bcurves = [], p2, alen = 0, tlen = this.length();
    const graduated = typeof d3 < "u" && typeof d4 < "u";
    function linearDistanceFunction(s2, e2, tlen2, alen2, slen) {
      return function(v) {
        const f1 = alen2 / tlen2, f2 = (alen2 + slen) / tlen2, d5 = e2 - s2;
        return utils.map(v, 0, 1, s2 + f1 * d5, s2 + f2 * d5);
      };
    }
    reduced.forEach(function(segment) {
      const slen = segment.length();
      graduated ? (fcurves.push(
        segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))
      ), bcurves.push(
        segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))
      )) : (fcurves.push(segment.scale(d1)), bcurves.push(segment.scale(-d2))), alen += slen;
    }), bcurves = bcurves.map(function(s2) {
      return p2 = s2.points, p2[3] ? s2.points = [p2[3], p2[2], p2[1], p2[0]] : s2.points = [p2[2], p2[1], p2[0]], s2;
    }).reverse();
    const fs = fcurves[0].points[0], fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1], bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1], be = bcurves[0].points[0], ls = utils.makeline(bs, fs), le = utils.makeline(fe, be), segments = [ls].concat(fcurves).concat([le]).concat(bcurves);
    return new PolyBezier(segments);
  }
  outlineshapes(d1, d2, curveIntersectionThreshold) {
    d2 = d2 || d1;
    const outline = this.outline(d1, d2).curves, shapes = [];
    for (let i2 = 1, len = outline.length; i2 < len / 2; i2++) {
      const shape = utils.makeshape(
        outline[i2],
        outline[len - i2],
        curveIntersectionThreshold
      );
      shape.startcap.virtual = i2 > 1, shape.endcap.virtual = i2 < len / 2 - 1, shapes.push(shape);
    }
    return shapes;
  }
  intersects(curve2, curveIntersectionThreshold) {
    return curve2 ? curve2.p1 && curve2.p2 ? this.lineIntersects(curve2) : (curve2 instanceof Bezier && (curve2 = curve2.reduce()), this.curveintersects(
      this.reduce(),
      curve2,
      curveIntersectionThreshold
    )) : this.selfintersects(curveIntersectionThreshold);
  }
  lineIntersects(line) {
    const mx = min(line.p1.x, line.p2.x), my = min(line.p1.y, line.p2.y), MX = max(line.p1.x, line.p2.x), MY = max(line.p1.y, line.p2.y);
    return utils.roots(this.points, line).filter((t2) => {
      var p2 = this.get(t2);
      return utils.between(p2.x, mx, MX) && utils.between(p2.y, my, MY);
    });
  }
  selfintersects(curveIntersectionThreshold) {
    const reduced = this.reduce(), len = reduced.length - 2, results = [];
    for (let i2 = 0, result, left, right; i2 < len; i2++)
      left = reduced.slice(i2, i2 + 1), right = reduced.slice(i2 + 2), result = this.curveintersects(left, right, curveIntersectionThreshold), results.push(...result);
    return results;
  }
  curveintersects(c1, c2, curveIntersectionThreshold) {
    const pairs = [];
    c1.forEach(function(l2) {
      c2.forEach(function(r2) {
        l2.overlaps(r2) && pairs.push({ left: l2, right: r2 });
      });
    });
    let intersections = [];
    return pairs.forEach(function(pair) {
      const result = utils.pairiteration(
        pair.left,
        pair.right,
        curveIntersectionThreshold
      );
      result.length > 0 && (intersections = intersections.concat(result));
    }), intersections;
  }
  arcs(errorThreshold) {
    return errorThreshold = errorThreshold || 0.5, this._iterate(errorThreshold, []);
  }
  _error(pc, np1, s2, e2) {
    const q = (e2 - s2) / 4, c1 = this.get(s2 + q), c2 = this.get(e2 - q), ref = utils.dist(pc, np1), d1 = utils.dist(pc, c1), d2 = utils.dist(pc, c2);
    return abs(d1 - ref) + abs(d2 - ref);
  }
  _iterate(errorThreshold, circles) {
    let t_s = 0, t_e = 1, safety;
    do {
      safety = 0, t_e = 1;
      let np1 = this.get(t_s), np2, np3, arc, prev_arc, curr_good = !1, prev_good = !1, done, t_m = t_e, prev_e = 1;
      do
        if (prev_good = curr_good, prev_arc = arc, t_m = (t_s + t_e) / 2, np2 = this.get(t_m), np3 = this.get(t_e), arc = utils.getccenter(np1, np2, np3), arc.interval = {
          start: t_s,
          end: t_e
        }, curr_good = this._error(arc, np1, t_s, t_e) <= errorThreshold, done = prev_good && !curr_good, done || (prev_e = t_e), curr_good) {
          if (t_e >= 1) {
            if (arc.interval.end = prev_e = 1, prev_arc = arc, t_e > 1) {
              let d2 = {
                x: arc.x + arc.r * cos(arc.e),
                y: arc.y + arc.r * sin(arc.e)
              };
              arc.e += utils.angle({ x: arc.x, y: arc.y }, d2, this.get(1));
            }
            break;
          }
          t_e = t_e + (t_e - t_s) / 2;
        } else
          t_e = t_m;
      while (!done && safety++ < 100);
      if (safety >= 100)
        break;
      prev_arc = prev_arc || arc, circles.push(prev_arc), t_s = prev_e;
    } while (t_e < 1);
    return circles;
  }
}
function toDomPrecision(v) {
  return v === null ? 0.01 : Math.round(v * 100) / 100;
}
const nodeToRect = (nd) => ({
  x: nd.internals.positionAbsolute.x,
  y: nd.internals.positionAbsolute.y,
  width: nd.measured.width ?? nd.width ?? nd.data.element.width,
  height: nd.measured.height ?? nd.height ?? nd.data.element.height
}), isInside = (test2, target) => test2.x >= target.x && test2.y >= target.y && test2.x + test2.width <= target.x + target.width && test2.y + test2.height <= target.y + target.height;
function bezierControlPoints(diagramEdge) {
  let [start, ...bezierPoints] = diagramEdge.points;
  invariant$1(start, "start should be defined");
  const handles = [
    // start
  ];
  for (; i$8(bezierPoints, 3); ) {
    const [cp1, cp2, end, ...rest] = bezierPoints, bezier = new Bezier(start[0], start[1], cp1[0], cp1[1], cp2[0], cp2[1], end[0], end[1]), inflections = bezier.inflections();
    inflections.length === 0 && inflections.push(0.5), inflections.forEach((t2) => {
      const { x: x2, y: y2 } = bezier.get(t2);
      handles.push({
        x: Math.round(x2),
        y: Math.round(y2)
      });
    }), bezierPoints = rest, start = end;
  }
  return invariant$1(bezierPoints.length === 0, "all points should be consumed"), handles;
}
const isClose = (a2, b2) => Math.abs(a2 - b2) < 3.1;
function isSamePoint$1(a2, b2) {
  const [ax, ay] = o$3(a2) ? a2 : [a2.x, a2.y], [bx, by] = o$3(b2) ? b2 : [b2.x, b2.y];
  return isClose(ax, bx) && isClose(ay, by);
}
function stopPropagation$1(e2) {
  return e2.stopPropagation();
}
function centerXYInternalNode(nd) {
  const { width: width2, height } = getNodeDimensions(nd);
  return {
    x: nd.internals.positionAbsolute.x + width2 / 2,
    y: nd.internals.positionAbsolute.y + height / 2
  };
}
function diagramViewToXYFlowData(view, opts) {
  view.__;
  const xynodes = [], xyedges = [], nodeLookup = /* @__PURE__ */ new Map(), traverse = view.nodes.reduce(
    (acc, node2) => (nodeLookup.set(node2.id, node2), node2.parent || acc.push({ node: node2, parent: null }), acc),
    new Array()
  );
  let visiblePredicate = (_nodeOrEdge) => !0;
  if (opts.where)
    try {
      visiblePredicate = whereOperatorAsPredicate(opts.where);
    } catch (e2) {
      console.error("Error in where filter:", e2);
    }
  const ns = "", nodeById = (id2) => nonNullable(nodeLookup.get(id2), `Node not found: ${id2}`);
  let next;
  for (; next = traverse.shift(); ) {
    const { node: node2, parent } = next, isCompound = i$8(node2.children, 1) || node2.kind == ElementKind.Group;
    isCompound && traverse.push(...node2.children.map((child) => ({ node: nodeById(child), parent: node2 })));
    const position2 = {
      x: node2.position[0],
      y: node2.position[1]
    };
    parent && (position2.x -= parent.position[0], position2.y -= parent.position[1]);
    const base = {
      id: ns + node2.id,
      draggable: opts.draggable,
      selectable: opts.selectable && node2.kind !== ElementKind.Group,
      focusable: opts.selectable && !isCompound,
      deletable: !1,
      position: position2,
      zIndex: isCompound ? ZIndexes$2.Compound : ZIndexes$2.Element,
      width: node2.width,
      height: node2.height,
      hidden: node2.kind !== ElementKind.Group && !visiblePredicate(node2),
      ...parent && {
        parentId: ns + parent.id
      }
    };
    xynodes.push(
      isCompound ? {
        ...base,
        type: "compound",
        data: {
          fqn: node2.id,
          isViewGroup: node2.kind === ElementKind.Group,
          element: node2
        },
        dragHandle: ".likec4-compound-title"
      } : {
        ...base,
        type: "element",
        data: {
          fqn: node2.id,
          element: node2
        }
      }
    );
  }
  for (const edge of view.edges) {
    const source = edge.source, target = edge.target, id2 = ns + edge.id;
    if (!i$8(edge.points, 2)) {
      console.error("edge should have at least 2 points", edge);
      continue;
    }
    xyedges.push({
      id: id2,
      type: "relationship",
      source: ns + source,
      target: ns + target,
      zIndex: ZIndexes$2.Edge,
      selectable: opts.selectable,
      hidden: !visiblePredicate(edge),
      deletable: !1,
      data: {
        edge,
        controlPoints: edge.controlPoints || null,
        label: edge.labelBBox ? {
          bbox: edge.labelBBox,
          text: edge.label ?? ""
        } : null
      },
      interactionWidth: 20
    });
  }
  return {
    xynodes,
    xyedges
  };
}
class Aligner {
}
class LinearAligner extends Aligner {
  constructor(getEdgePosition, computePosition, propertyToEdit) {
    super(), this.getEdgePosition = getEdgePosition, this.computePosition = computePosition, this.propertyToEdit = propertyToEdit;
  }
  alignTo;
  computeLayout(nodes) {
    this.alignTo = this.getEdgePosition(nodes);
  }
  applyPosition(node2) {
    return {
      [this.propertyToEdit]: this.computePosition(this.alignTo, node2)
    };
  }
}
class GridAligner extends Aligner {
  layout = /* @__PURE__ */ new Map();
  axisPreset;
  get primaryAxisCoord() {
    return this.axisPreset.primaryAxisCoord;
  }
  get secondaryAxisCoord() {
    return this.axisPreset.secondaryAxisCoord;
  }
  get primaryAxisDimension() {
    return this.axisPreset.primaryAxisDimension;
  }
  get secondaryAxisDimension() {
    return this.axisPreset.secondaryAxisDimension;
  }
  constructor(alignmentMode) {
    super(), this.axisPreset = alignmentMode === "Column" ? {
      primaryAxisDimension: "width",
      secondaryAxisDimension: "height",
      primaryAxisCoord: "x",
      secondaryAxisCoord: "y"
    } : {
      primaryAxisDimension: "height",
      secondaryAxisDimension: "width",
      primaryAxisCoord: "y",
      secondaryAxisCoord: "x"
    };
  }
  applyPosition(node2) {
    return this.layout?.get(node2.id) ?? {};
  }
  computeLayout(nodes) {
    const sortedNodeRects = x$1(
      nodes,
      a$3((r2) => r2[this.primaryAxisCoord])
    ), layoutRect = this.getLayoutRect(sortedNodeRects), layers = this.getLayers(sortedNodeRects);
    this.layout = this.buildLayout(layers, layoutRect, sortedNodeRects);
  }
  getLayoutRect(nodeRects) {
    const x2 = Math.min(...nodeRects.map((n2) => n2.x)), y2 = Math.min(...nodeRects.map((n2) => n2.y)), right = Math.max(...nodeRects.map((n2) => n2.x + n2.width)), bottom = Math.max(...nodeRects.map((n2) => n2.y + n2.height));
    return {
      x: x2,
      y: y2,
      width: right - x2,
      height: bottom - y2
    };
  }
  getLayers(sortedNodeRects) {
    const layers = [];
    let layerEnd = 0, layer = null;
    for (let node2 of sortedNodeRects)
      if (layer && node2[this.primaryAxisCoord] < layerEnd)
        layer.nodes.push(node2), layer.primaryAxisSize = Math.max(layer.primaryAxisSize, node2[this.primaryAxisDimension]), layer.occupiedSpace += node2[this.secondaryAxisDimension], layerEnd = Math.max(
          node2[this.primaryAxisCoord] + node2[this.primaryAxisDimension],
          layerEnd
        );
      else {
        layer = {
          primaryAxisSize: node2[this.primaryAxisDimension],
          nodes: [node2],
          occupiedSpace: node2[this.secondaryAxisDimension],
          layout: null
        }, layers.push(layer), layerEnd = node2[this.primaryAxisCoord] + node2[this.primaryAxisDimension];
        continue;
      }
    return layers.forEach(
      (l2) => l2.nodes.sort((a2, b2) => a2[this.secondaryAxisCoord] - b2[this.secondaryAxisCoord])
    ), layers;
  }
  buildLayout(layers, layoutRect, nodeRects) {
    const nodeMap = new Map(nodeRects.map((n2) => [n2.id, n2])), layout2 = [], occupiedSpace = layers.reduce((a2, b2) => a2 + b2.primaryAxisSize, 0), rowMargin = layers.length > 1 ? (layoutRect[this.primaryAxisDimension] - occupiedSpace) / (layers.length - 1) : 0, baseLayerIndex = layers.reduce(
      (widestLayerIndex, layer, i2) => layers[widestLayerIndex].occupiedSpace < layer.occupiedSpace ? i2 : widestLayerIndex,
      0
    ), baseLayer = layers[baseLayerIndex], baseLayerPosition = layers.slice(0, baseLayerIndex).reduce(
      (a2, layer) => a2 + layer.primaryAxisSize + rowMargin,
      layoutRect[this.primaryAxisCoord]
    ), baseLayerLayout = this.buildLayerLayout(
      baseLayer,
      layoutRect,
      baseLayerPosition,
      nodeMap,
      null
    );
    baseLayer.layout = baseLayerLayout, layout2.push(...baseLayerLayout.nodePositions);
    let placeNextLayerAt = baseLayerPosition + baseLayer.primaryAxisSize + rowMargin, refLayer = baseLayer;
    for (let i2 = baseLayerIndex + 1; i2 < layers.length; i2++) {
      const layer = layers[i2];
      layer.layout = this.buildLayerLayout(layer, layoutRect, placeNextLayerAt, nodeMap, refLayer), layout2.push(...layer.layout.nodePositions), refLayer = layer.layout.refLayer ?? layer, placeNextLayerAt += layer.primaryAxisSize + rowMargin;
    }
    placeNextLayerAt = baseLayerPosition, refLayer = baseLayer;
    for (let i2 = baseLayerIndex - 1; i2 >= 0; i2--) {
      const layer = layers[i2];
      placeNextLayerAt -= layer.primaryAxisSize + rowMargin, layer.layout = this.buildLayerLayout(layer, layoutRect, placeNextLayerAt, nodeMap, refLayer), layout2.push(...layer.layout.nodePositions), refLayer = layer.layout.refLayer ?? layer;
    }
    return new Map(layout2);
  }
  buildLayerLayout(layer, layoutRect, placeNextLayerAt, nodeMap, refLayer) {
    let bestLayerLayout = this.scoreLayout(
      this.spaceAround(layer, layoutRect, placeNextLayerAt),
      nodeMap
    );
    if (layer.nodes.length != 1) {
      const currentlayerLayout = this.scoreLayout(
        this.spaceBetween(layer, layoutRect, placeNextLayerAt),
        nodeMap
      );
      bestLayerLayout = currentlayerLayout[0] < bestLayerLayout[0] ? currentlayerLayout : bestLayerLayout;
    }
    if (refLayer && refLayer.nodes.length - 1 >= layer.nodes.length) {
      const currentlayerLayout = this.scoreLayout(
        this.placeInGaps(layer, placeNextLayerAt, refLayer),
        nodeMap
      );
      bestLayerLayout = currentlayerLayout[0] < bestLayerLayout[0] ? currentlayerLayout : bestLayerLayout;
    }
    if (refLayer && refLayer.nodes.length >= layer.nodes.length) {
      const currentlayerLayout = this.scoreLayout(
        this.placeInCells(layer, placeNextLayerAt, refLayer),
        nodeMap
      );
      bestLayerLayout = currentlayerLayout[0] < bestLayerLayout[0] ? currentlayerLayout : bestLayerLayout;
    }
    return bestLayerLayout[1];
  }
  spaceBetween(layer, layoutRect, placeNextLayerAt) {
    const margin = (layoutRect[this.secondaryAxisDimension] - layer.occupiedSpace) / (layer.nodes.length - 1);
    let placeNextNodeAt = layoutRect[this.secondaryAxisCoord];
    const result = /* @__PURE__ */ new Map();
    for (let node2 of layer.nodes)
      result.set(node2.id, {
        [this.secondaryAxisCoord]: placeNextNodeAt,
        [this.primaryAxisCoord]: placeNextLayerAt
      }), placeNextNodeAt += node2[this.secondaryAxisDimension] + margin;
    return { nodePositions: result, refLayer: null };
  }
  spaceAround(layer, layoutRect, placeNextLayerAt) {
    const margin = (layoutRect[this.secondaryAxisDimension] - layer.occupiedSpace) / (layer.nodes.length + 1);
    let placeNextNodeAt = layoutRect[this.secondaryAxisCoord] + margin;
    const result = /* @__PURE__ */ new Map();
    for (let node2 of a$3(layer.nodes, (n2) => n2[this.secondaryAxisCoord]))
      result.set(node2.id, {
        [this.secondaryAxisCoord]: placeNextNodeAt,
        [this.primaryAxisCoord]: placeNextLayerAt
      }), placeNextNodeAt += node2[this.secondaryAxisDimension] + margin;
    return { nodePositions: result, refLayer: null };
  }
  placeInGaps(layer, placeNextLayerAt, refLayer) {
    const result = /* @__PURE__ */ new Map(), nodes = layer.nodes, placementOptions = this.getGapsPositions(refLayer);
    let optionIndex = 0;
    for (let i2 = 0, node2 = nodes[i2]; i2 < nodes.length; i2++, node2 = nodes[i2]) {
      const nodeCenter = node2[this.secondaryAxisCoord] + node2[this.secondaryAxisDimension] / 2;
      let bestOffset = 1 / 0;
      for (; optionIndex - i2 <= placementOptions.length - nodes.length; ) {
        const offset = placementOptions[optionIndex] - nodeCenter;
        if (Math.abs(offset) < Math.abs(bestOffset))
          bestOffset = offset, optionIndex++;
        else
          break;
      }
      result.set(node2.id, {
        [this.secondaryAxisCoord]: node2[this.secondaryAxisCoord] + bestOffset,
        [this.primaryAxisCoord]: placeNextLayerAt
      });
    }
    return { nodePositions: result, refLayer };
  }
  placeInCells(layer, placeNextLayerAt, refLayer) {
    const result = /* @__PURE__ */ new Map(), nodes = layer.nodes, placementOptions = this.getNodePositions(refLayer);
    let optionIndex = 0;
    for (let i2 = 0, node2 = nodes[i2]; i2 < nodes.length; i2++, node2 = nodes[i2]) {
      const nodeCenter = node2[this.secondaryAxisCoord] + node2[this.secondaryAxisDimension] / 2;
      let bestOffset = 1 / 0;
      for (; optionIndex - i2 <= placementOptions.length - nodes.length; ) {
        const offset = placementOptions[optionIndex] - nodeCenter;
        if (Math.abs(offset) < Math.abs(bestOffset))
          bestOffset = offset, optionIndex++;
        else
          break;
      }
      result.set(node2.id, {
        [this.secondaryAxisCoord]: node2[this.secondaryAxisCoord] + bestOffset,
        [this.primaryAxisCoord]: placeNextLayerAt
      });
    }
    return { nodePositions: result, refLayer };
  }
  scoreLayout(layout2, originalRects) {
    return [
      x$1(
        Array.from(layout2.nodePositions),
        m$1(([id2, position2]) => {
          const originalRect = originalRects.get(id2);
          return invariant$1(originalRect, `Could not find original rect for node ${id2}`), [i$6(originalRect, ["x", "y"]), position2];
        }),
        m$1(
          ([original, suggested]) => Math.abs(original[this.secondaryAxisCoord] - suggested[this.secondaryAxisCoord])
        ),
        l$4((a2, b2) => a2 + b2, 0)
      ),
      layout2
    ];
  }
  getGapsPositions(layer) {
    const result = [], { layout: layout2, nodes } = layer;
    invariant$1(layout2, "Layout of the layer must be computed before calling getGapsPositions");
    for (let i2 = 1; i2 < nodes.length; i2++) {
      const previousNode = nodes[i2 - 1], currentNode = nodes[i2], previousNodePosition = layout2.nodePositions.get(previousNode.id), currentNodePosition = layout2.nodePositions.get(currentNode.id);
      result.push(
        (currentNodePosition[this.secondaryAxisCoord] + previousNodePosition[this.secondaryAxisCoord] + previousNode[this.secondaryAxisDimension]) / 2
      );
    }
    return result;
  }
  getNodePositions(layer) {
    const result = [], { layout: layout2, nodes } = layer;
    invariant$1(layout2, "Layout of the layer must be computed before calling getGapsPositions");
    for (let i2 = 0; i2 < nodes.length; i2++) {
      const node2 = nodes[i2], nodePosition = layout2.nodePositions.get(node2.id);
      result.push(
        nodePosition[this.secondaryAxisCoord] + node2[this.secondaryAxisDimension] / 2
      );
    }
    return result;
  }
}
function getLinearAligner(mode) {
  switch (mode) {
    case "Left":
      return new LinearAligner(
        (nodes) => Math.min(...nodes.map((n2) => n2.x)),
        (alignTo, _) => Math.floor(alignTo),
        "x"
      );
    case "Top":
      return new LinearAligner(
        (nodes) => Math.min(...nodes.map((n2) => n2.y)),
        (alignTo, _) => Math.floor(alignTo),
        "y"
      );
    case "Right":
      return new LinearAligner(
        (nodes) => Math.max(...nodes.map((n2) => n2.x + n2.width)),
        (alignTo, node2) => Math.floor(alignTo - node2.width),
        "x"
      );
    case "Bottom":
      return new LinearAligner(
        (nodes) => Math.max(...nodes.map((n2) => n2.y + n2.height)),
        (alignTo, node2) => Math.floor(alignTo - node2.height),
        "y"
      );
    case "Center":
      return new LinearAligner(
        (nodes) => Math.min(...nodes.map((n2) => n2.x + n2.width / 2)),
        (alignTo, node2) => Math.floor(alignTo - node2.width / 2),
        "x"
      );
    case "Middle":
      return new LinearAligner(
        (nodes) => Math.min(...nodes.map((n2) => n2.y + n2.height / 2)),
        (alignTo, node2) => Math.floor(alignTo - node2.height / 2),
        "y"
      );
  }
}
function align(get) {
  return (mode) => {
    const { scheduleSaveManualLayout, xystore } = get(), { nodeLookup, parentLookup } = xystore.getState(), nodesToAlign = [...new Set(nodeLookup.values().filter((n2) => n2.selected).map((n2) => n2.id)).difference(new Set(parentLookup.keys()))];
    if (!i$8(nodesToAlign, 2)) {
      console.warn("At least 2 nodes must be selected to align");
      return;
    }
    const constraints = createLayoutConstraints(xystore, nodesToAlign), aligner = getAligner(mode);
    constraints.onMove((nodes) => {
      aligner.computeLayout(nodes.map(({ node: node2 }) => toNodeRect(node2))), nodes.forEach(({ rect, node: node2 }) => {
        rect.positionAbsolute = {
          ...rect.positionAbsolute,
          ...aligner.applyPosition(toNodeRect(node2))
        };
      });
    }), scheduleSaveManualLayout();
  };
}
function toNodeRect(node2) {
  return {
    ...node2.internals.positionAbsolute,
    id: node2.id,
    width: getNodeDimensions(node2).width,
    height: getNodeDimensions(node2).height
  };
}
function getAligner(mode) {
  switch (mode) {
    case "Left":
    case "Right":
    case "Top":
    case "Bottom":
    case "Center":
    case "Middle":
      return getLinearAligner(mode);
    case "Column":
    case "Row":
      return new GridAligner(mode);
    default:
      nonexhaustive(mode);
  }
}
const StringSet = Set, DEFAULT_PROPS = {
  xyedges: [],
  xynodes: [],
  isDynamicView: !1,
  viewSyncDebounceTimeout: null,
  initialized: !1,
  navigationHistoryIndex: 0,
  viewportChanged: !1,
  activeOverlay: null,
  activeWalkthrough: null,
  focusedNodeId: null,
  hoveredNodeId: null,
  hoveredEdgeId: null,
  lastClickedNodeId: null,
  lastClickedEdgeId: null,
  dimmed: new StringSet(),
  lastOnNavigate: null
}, noReplace = !1;
let StoreDevId = 1;
const EmptyStringSet = new StringSet();
function createDiagramStore(props2) {
  const storeDevId = "DiagramStore" + String(StoreDevId++).padStart(2, "0"), {
    xynodes,
    xyedges
  } = diagramViewToXYFlowData(props2.view, {
    where: props2.whereFilter,
    draggable: props2.nodesDraggable,
    selectable: props2.nodesSelectable
  });
  return createWithEqualityFn(
    subscribeWithSelector(
      devtools(
        (set, get) => ({
          ...DEFAULT_PROPS,
          ...props2,
          storeDevId,
          isDynamicView: props2.view.__ === "dynamic",
          xynodes,
          xyedges,
          navigationHistory: [{
            viewId: props2.view.id,
            nodeId: null
          }],
          navigationHistoryIndex: 0,
          onNodesChange: (changes) => {
            set({
              xynodes: applyNodeChanges(changes, get().xynodes)
            });
          },
          onEdgesChange: (changes) => {
            set({
              xyedges: applyEdgeChanges(changes, get().xyedges)
            });
          },
          updateView: (nextView) => {
            let {
              viewSyncDebounceTimeout,
              xyflow: xyflow2,
              xystore,
              dimmed: dimmed2,
              whereFilter,
              view: current,
              lastOnNavigate,
              navigationHistory,
              navigationHistoryIndex,
              focusedNodeId,
              lastClickedNodeId,
              lastClickedEdgeId,
              activeWalkthrough,
              activeOverlay,
              nodesDraggable,
              nodesSelectable,
              hoveredEdgeId,
              hoveredNodeId,
              xyedges: xyedges2,
              xynodes: xynodes2
            } = get();
            viewSyncDebounceTimeout !== null && (clearTimeout(viewSyncDebounceTimeout), viewSyncDebounceTimeout = null);
            const isSameView = current.id === nextView.id;
            if (isSameView) {
              const nodeIds = new StringSet(nextView.nodes.map((n2) => n2.id)), edgeIds = new StringSet(nextView.edges.map((e2) => e2.id));
              if (lastClickedNodeId && !nodeIds.has(lastClickedNodeId) && (lastClickedNodeId = null), hoveredNodeId && !nodeIds.has(hoveredNodeId) && (hoveredNodeId = null), focusedNodeId && !nodeIds.has(focusedNodeId) && (focusedNodeId = null, dimmed2 = EmptyStringSet), lastClickedEdgeId && !edgeIds.has(lastClickedEdgeId) && (lastClickedEdgeId = null), hoveredEdgeId && !edgeIds.has(hoveredEdgeId) && (hoveredEdgeId = null), activeWalkthrough && !edgeIds.has(activeWalkthrough.stepId) && (activeWalkthrough = null, dimmed2 = EmptyStringSet), dimmed2.size > 0) {
                let nextDimmed = new StringSet([...dimmed2].filter((id2) => nodeIds.has(id2) || edgeIds.has(id2)));
                nextDimmed.size !== dimmed2.size && (dimmed2 = nextDimmed);
              }
            } else {
              const stepCurrent = nonNullable(navigationHistory[navigationHistoryIndex]);
              stepCurrent.viewId !== nextView.id ? (navigationHistory = [
                ...navigationHistory.slice(0, navigationHistoryIndex + 1),
                {
                  viewId: nextView.id,
                  nodeId: lastOnNavigate?.fromNode || null
                }
              ], navigationHistoryIndex = navigationHistory.length - 1) : stepCurrent.nodeId && (lastOnNavigate ??= {
                fromView: current.id,
                toView: nextView.id,
                fromNode: stepCurrent.nodeId
              }), lastOnNavigate && lastOnNavigate.toView !== nextView.id && (lastOnNavigate = null);
              const elTo = lastOnNavigate && nextView.nodes.find((n2) => n2.id === lastOnNavigate?.fromNode), xynodeFrom = elTo && xyflow2.getInternalNode(elTo.id);
              if (!lastOnNavigate || n$2(elTo) || n$2(xynodeFrom)) {
                const zoom = xyflow2.getZoom(), { x: x2, y: y2 } = getBBoxCenter(nextView.bounds);
                xyflow2.setCenter(x2, y2, { zoom }), lastOnNavigate = null;
              }
              if (lastOnNavigate && elTo && xynodeFrom) {
                const fromPos = xyflow2.flowToScreenPosition({
                  x: xynodeFrom.internals.positionAbsolute.x,
                  // + dimensions.width / 2,
                  y: xynodeFrom.internals.positionAbsolute.y
                  // + dimensions.height / 2
                }), toPos = xyflow2.flowToScreenPosition({
                  x: elTo.position[0],
                  // + elFrom.width / 2,
                  y: elTo.position[1]
                  // + elFrom.height / 2
                }), diff = {
                  x: toDomPrecision(fromPos.x - toPos.x),
                  y: toDomPrecision(fromPos.y - toPos.y)
                };
                xystore.getState().panBy(diff), lastOnNavigate = null;
              }
              lastClickedEdgeId = null, lastClickedNodeId = null, hoveredEdgeId = null, hoveredNodeId = null, focusedNodeId = null, activeWalkthrough = null, activeOverlay = null, dimmed2 = EmptyStringSet;
            }
            const update = diagramViewToXYFlowData(nextView, {
              where: whereFilter,
              draggable: nodesDraggable,
              selectable: nodesSelectable
            });
            update.xynodes = update.xynodes.map((update2) => {
              const existing = xynodes2.find((n2) => n2.id === update2.id);
              return existing && existing.type === update2.type && deepEqual(existing.parentId ?? null, update2.parentId ?? null) ? existing.width === update2.width && existing.height === update2.height && deepEqual(existing.hidden ?? !1, update2.hidden ?? !1) && deepEqual(existing.position, update2.position) && deepEqual(existing.data, update2.data) ? existing : {
                ...existing,
                ...update2
              } : update2;
            }), isSameView && !nextView.hasLayoutDrift && (update.xyedges = update.xyedges.map((update2) => {
              const existing = xyedges2.find((n2) => n2.id === update2.id);
              return existing ? deepEqual(existing.hidden ?? !1, update2.hidden ?? !1) && deepEqual(existing.data.label, update2.data.label) && deepEqual(existing.data.controlPoints, update2.data.controlPoints) && deepEqual(existing.data.edge, update2.data.edge) ? existing : {
                ...existing,
                ...update2,
                data: {
                  ...existing.data,
                  ...update2.data
                }
              } : update2;
            })), set(
              {
                isDynamicView: nextView.__ === "dynamic",
                viewSyncDebounceTimeout,
                view: nextView,
                activeWalkthrough,
                activeOverlay,
                lastOnNavigate,
                lastClickedNodeId,
                lastClickedEdgeId,
                focusedNodeId,
                hoveredEdgeId,
                hoveredNodeId,
                navigationHistory,
                navigationHistoryIndex,
                dimmed: dimmed2,
                xynodes: !isSameView || !shallowEqual(update.xynodes, xynodes2) ? update.xynodes : xynodes2,
                xyedges: !isSameView || !shallowEqual(update.xyedges, xyedges2) ? update.xyedges : xyedges2
              },
              noReplace,
              isSameView ? "update-view [same]" : "update-view [another]"
            );
          },
          focusOnNode: (nodeId) => {
            const { focusedNodeId, view, enableFocusMode } = get();
            if (invariant$1(enableFocusMode, "focus mode is not enabled"), nodeId === !1) {
              set(
                {
                  activeWalkthrough: null,
                  activeOverlay: null,
                  focusedNodeId: null,
                  dimmed: EmptyStringSet
                },
                noReplace,
                "unfocus"
              );
              return;
            }
            if (nodeId !== focusedNodeId) {
              const notDimmed = new StringSet([nodeId]), dimmed2 = new StringSet();
              for (const edge of view.edges)
                edge.source === nodeId || edge.target === nodeId ? (notDimmed.add(edge.source), notDimmed.add(edge.target)) : dimmed2.add(edge.id);
              for (const node2 of view.nodes)
                notDimmed.has(node2.id) || dimmed2.add(node2.id);
              set(
                {
                  activeWalkthrough: null,
                  activeOverlay: null,
                  focusedNodeId: nodeId,
                  dimmed: dimmed2
                },
                noReplace,
                `focus on node: ${nodeId}`
              );
            }
          },
          setHoveredNode: (nodeId) => {
            nodeId !== get().hoveredNodeId && set({ hoveredNodeId: nodeId });
          },
          setHoveredEdge: (edgeId) => {
            edgeId !== get().hoveredEdgeId && set({ hoveredEdgeId: edgeId });
          },
          setLastClickedNode: (nodeId) => {
            nodeId !== get().lastClickedNodeId && set({ lastClickedNodeId: nodeId });
          },
          setLastClickedEdge: (edgeId) => {
            edgeId !== get().lastClickedEdgeId && set({ lastClickedEdgeId: edgeId });
          },
          resetFocusAndLastClicked: () => {
            set(
              {
                activeWalkthrough: null,
                activeOverlay: null,
                focusedNodeId: null,
                lastClickedNodeId: null,
                lastClickedEdgeId: null,
                dimmed: EmptyStringSet
              },
              noReplace,
              "resetLastClicked"
            ), get().xystore.getState().resetSelectedElements();
          },
          getElement: (fqn2) => {
            const { view } = get();
            return view.nodes.find(({ id: id2 }) => id2 === fqn2) ?? null;
          },
          isEditable: () => {
            const { readonly, onChange } = get();
            return !readonly && !!onChange;
          },
          triggerChangeElementStyle: (change) => {
            const { view, updateView, onChange } = get();
            let hasChanges = !1;
            const nodes = view.nodes.map((origin) => {
              if (!change.targets.includes(origin.id))
                return origin;
              let element = origin;
              for (const [key, value] of t$2(change.style))
                switch (key) {
                  case "shape":
                    value !== element.shape && (element = {
                      ...element,
                      shape: value
                    });
                    break;
                  case "color":
                    value !== element.color && (element = {
                      ...element,
                      color: value
                    });
                    break;
                  case "opacity":
                    value !== element.style?.opacity && (element = {
                      ...element,
                      style: {
                        ...element.style,
                        opacity: value
                      }
                    });
                    break;
                  case "border":
                    value !== element.style?.border && (element = {
                      ...element,
                      style: {
                        ...element.style,
                        border: value
                      }
                    });
                    break;
                  default:
                    nonexhaustive(key);
                }
              return element !== origin ? (hasChanges = !0, element) : origin;
            });
            hasChanges && updateView({
              ...view,
              nodes
            }), onChange?.({ change });
          },
          cancelSaveManualLayout: () => {
            let { viewSyncDebounceTimeout } = get();
            return viewSyncDebounceTimeout !== null ? (clearTimeout(viewSyncDebounceTimeout), set({ viewSyncDebounceTimeout: null }), !0) : !1;
          },
          triggerSaveManualLayout: () => {
            const { xyflow: xyflow2, view, onChange, xystore, viewSyncDebounceTimeout } = get();
            viewSyncDebounceTimeout !== null && (clearTimeout(viewSyncDebounceTimeout), set({ viewSyncDebounceTimeout: null }));
            const { nodeLookup } = xystore.getState(), movedNodes = new StringSet();
            let bounds = {
              x: 0,
              y: 0,
              width: 1,
              height: 1
            };
            const nodes = l$4([...nodeLookup.values()], (acc, node2) => {
              const dimensions = getNodeDimensions(node2);
              isSamePoint$1(node2.internals.positionAbsolute, node2.data.element.position) || movedNodes.add(node2.id);
              const rect = acc[node2.data.fqn] = {
                isCompound: node2.data.element.children.length > 0,
                x: Math.floor(node2.internals.positionAbsolute.x),
                y: Math.floor(node2.internals.positionAbsolute.y),
                width: Math.ceil(dimensions.width),
                height: Math.ceil(dimensions.height)
              };
              return bounds = getBoundsOfRects(bounds, rect), acc;
            }, {}), edges = l$4(xyflow2.getEdges(), (acc, { source, target, data }) => {
              let controlPoints = data.controlPoints ?? [];
              const sourceOrTargetMoved = movedNodes.has(source) || movedNodes.has(target);
              if (controlPoints.length === 0 && sourceOrTargetMoved && (controlPoints = bezierControlPoints(data.edge)), data.edge.points.length === 0 && controlPoints.length === 0)
                return acc;
              const _updated = acc[data.edge.id] = {
                points: data.edge.points
              };
              data.label?.bbox && (_updated.labelBBox = data.label.bbox), data.edge.labelBBox && (_updated.labelBBox ??= data.edge.labelBBox), i$8(controlPoints, 1) && (_updated.controlPoints = controlPoints), !sourceOrTargetMoved && data.edge.dotpos && (_updated.dotpos = data.edge.dotpos);
              const allX = [
                ...data.edge.points.map((p2) => p2[0]),
                ...controlPoints.map((p2) => p2.x),
                ..._updated.labelBBox ? [_updated.labelBBox.x, _updated.labelBBox.x + _updated.labelBBox.width] : []
              ], allY = [
                ...data.edge.points.map((p2) => p2[1]),
                ...controlPoints.map((p2) => p2.y),
                ..._updated.labelBBox ? [_updated.labelBBox.y, _updated.labelBBox.y + _updated.labelBBox.height] : []
              ], rect = boxToRect({
                x: Math.floor(Math.min(...allX)),
                y: Math.floor(Math.min(...allY)),
                x2: Math.ceil(Math.max(...allX)),
                y2: Math.ceil(Math.max(...allY))
              });
              return bounds = getBoundsOfRects(bounds, rect), acc;
            }, {}), change = {
              op: "save-manual-layout",
              layout: {
                hash: view.hash,
                autoLayout: view.autoLayout,
                nodes,
                edges,
                ...bounds
              }
            };
            isInside(bounds, view.bounds) || set(
              {
                view: {
                  ...view,
                  bounds
                }
              },
              noReplace,
              "update view bounds"
            ), onChange?.({ change });
          },
          scheduleSaveManualLayout: () => {
            clearTimeout(get().viewSyncDebounceTimeout ?? void 0), set(
              {
                viewSyncDebounceTimeout: setTimeout(() => {
                  get().triggerSaveManualLayout();
                }, 1e3)
                // explicit typecast to number to suppress TS error in astro build
              },
              noReplace,
              "debounce sync state"
            );
          },
          triggerOnNavigateTo: (xynodeId, event) => {
            const { view, xynodes: xynodes2, onNavigateTo, cancelSaveManualLayout } = get();
            if (!onNavigateTo)
              return;
            const xynode = xynodes2.find(({ id: id2 }) => id2 === xynodeId);
            invariant$1(xynode, `xynode not found: ${xynodeId}`);
            const element = xynode.data.element;
            invariant$1(element?.navigateTo, `node is not navigable: ${xynodeId}`), cancelSaveManualLayout(), set(
              {
                lastClickedNodeId: xynodeId,
                lastOnNavigate: {
                  fromView: view.id,
                  toView: element.navigateTo,
                  fromNode: element.id
                }
              },
              noReplace,
              "triggerOnNavigateTo"
            ), onNavigateTo(
              element.navigateTo,
              event,
              element
            );
          },
          goBack: () => {
            const { navigationHistory, navigationHistoryIndex, onNavigateTo } = get(), { viewId, nodeId } = nonNullable(navigationHistory[navigationHistoryIndex]), stepBack = navigationHistoryIndex > 0 && navigationHistory[navigationHistoryIndex - 1] || null;
            stepBack && onNavigateTo && (set(
              {
                lastClickedEdgeId: null,
                lastClickedNodeId: null,
                navigationHistoryIndex: navigationHistoryIndex - 1,
                lastOnNavigate: nodeId ? {
                  fromView: viewId,
                  toView: stepBack.viewId,
                  fromNode: nodeId
                } : null
              },
              noReplace,
              "goBack"
            ), onNavigateTo(stepBack.viewId));
          },
          goForward: () => {
            const { navigationHistory, navigationHistoryIndex, onNavigateTo } = get(), { viewId } = nonNullable(navigationHistory[navigationHistoryIndex]), stepForward = navigationHistoryIndex < navigationHistory.length - 1 ? navigationHistory[navigationHistoryIndex + 1] : null;
            stepForward && onNavigateTo && (set(
              {
                lastClickedEdgeId: null,
                lastClickedNodeId: null,
                navigationHistoryIndex: navigationHistoryIndex + 1,
                lastOnNavigate: stepForward.nodeId ? {
                  fromView: viewId,
                  toView: stepForward.viewId,
                  fromNode: stepForward.nodeId
                } : null
              },
              noReplace,
              "goForward"
            ), onNavigateTo(stepForward.viewId));
          },
          openOverlay: (overlay) => {
            deepEqual(overlay, get().activeOverlay) || set(
              {
                activeWalkthrough: null,
                activeOverlay: overlay
              },
              noReplace,
              "openOverlay"
            );
          },
          closeOverlay: () => {
            get().activeOverlay !== null && set(
              {
                activeOverlay: null
              },
              noReplace,
              "closeOverlay"
            );
          },
          fitDiagram: (duration = 500) => {
            const { fitViewPadding, view, xystore } = get(), { width: width2, height, panZoom, transform } = xystore.getState(), bounds = view.bounds, maxZoom = Math.max(1, transform[2]), viewport = getViewportForBounds(bounds, width2, height, MinZoom, maxZoom, fitViewPadding);
            panZoom?.setViewport(viewport, duration > 0 ? { duration } : void 0);
          },
          nextDynamicStep: (increment = 1) => {
            const { activeWalkthrough, xyedges: xyedges2, activateWalkthrough } = get(), stepId = activeWalkthrough?.stepId;
            let nextStep;
            if (stepId) {
              const nextIndex = xyedges2.findIndex(({ id: id2 }) => id2 === stepId) + increment;
              nextStep = xyedges2[nextIndex];
            } else
              nextStep = d(xyedges2);
            if (nextStep) {
              activateWalkthrough(nextStep.data.edge.id);
              return;
            }
          },
          activateWalkthrough: (step) => {
            const stepId = typeof step == "string" ? step : step.data.edge.id;
            invariant$1(isStepEdgeId(stepId), `stepId ${stepId} is not a step edge id`);
            let {
              isDynamicView,
              xyflow: xyflow2,
              xyedges: xyedges2,
              xystore,
              fitViewPadding,
              activeWalkthrough
            } = get();
            invariant$1(isDynamicView, "view is not dynamic");
            const edge = typeof step == "string" ? xyedges2.find(({ id: id2 }) => id2 === stepId) : step;
            invariant$1(edge, `edge not found: ${stepId}`);
            const currentIndex = xyedges2.findIndex(({ id: id2 }) => id2 === stepId);
            activeWalkthrough = {
              stepId,
              hasPrevious: currentIndex > 0,
              hasNext: currentIndex < xyedges2.length - 1,
              parallelPrefix: getParallelStepsPrefix(stepId)
            };
            const dimmed2 = new StringSet(
              xyedges2.filter(
                ({ id: id2 }) => id2 !== stepId && !(activeWalkthrough.parallelPrefix && id2.startsWith(activeWalkthrough.parallelPrefix))
              ).map(({ id: id2 }) => id2)
            ), selected = [];
            for (const n2 of xyflow2.getNodes()) {
              if (n2.id === edge.source || n2.id === edge.target) {
                selected.push(n2);
                continue;
              }
              dimmed2.add(n2.id);
            }
            const { fitView, transform } = xystore.getState();
            fitView({
              duration: 400,
              includeHiddenNodes: !0,
              maxZoom: Math.max(1, transform[2]),
              minZoom: MinZoom,
              padding: Math.max(fitViewPadding, 0.2),
              nodes: selected
            }), set(
              {
                focusedNodeId: null,
                activeWalkthrough,
                dimmed: dimmed2
              },
              noReplace,
              "activateWalkthrough"
            );
          },
          stopWalkthrough: () => {
            get().activeWalkthrough !== null && (set(
              {
                activeWalkthrough: null,
                focusedNodeId: null,
                dimmed: EmptyStringSet
              },
              noReplace,
              "stopWalkthrough"
            ), get().fitDiagram());
          },
          onInit: (instance) => {
            const { xyflow: xyflow2, initialized, fitViewEnabled, fitDiagram } = get();
            (!initialized || xyflow2 !== instance) && (fitViewEnabled && fitDiagram(0), set(
              {
                xyflow: instance,
                initialized: !0
              },
              noReplace,
              "onInit"
            ));
          },
          highlightByElementNotation: (notation, onlyOfKind) => {
            const { xynodes: xynodes2, xyedges: xyedges2 } = get(), dimmed2 = new StringSet(m$1(xyedges2, p$3("id")));
            xynodes2.forEach(({ id: id2, data }) => {
              const node2 = data.element;
              (node2.shape !== notation.shape || node2.color !== notation.color || !notation.kinds.includes(node2.kind) || onlyOfKind && node2.kind !== onlyOfKind) && dimmed2.add(id2);
            }), set({ dimmed: dimmed2 }, noReplace, "highlightByElementNotation");
          },
          resetEdgeControlPoints: () => {
            const { xyflow: xyflow2, scheduleSaveManualLayout, xynodes: xynodes2, xyedges: xyedges2 } = get();
            xyedges2.forEach((edge) => {
              xyflow2.updateEdgeData(edge.id, {
                controlPoints: getControlPointForEdge(edge)
              });
            }), scheduleSaveManualLayout();
            function getNodeCenter(node2, nodes) {
              const dimensions = vector({ x: node2.width || 0, y: node2.height || 0 });
              let position2 = vector(node2.position).add(dimensions.mul(0.5)), currentNode = node2;
              do {
                const parent = currentNode.parentId && nodes.find((x2) => x2.id == currentNode.parentId);
                if (!parent)
                  break;
                currentNode = parent, position2 = position2.add(parent.position);
              } while (!0);
              return position2;
            }
            function getControlPointForEdge(edge) {
              const source = xynodes2.find((x2) => x2.id == edge.source), target = xynodes2.find((x2) => x2.id == edge.target);
              if (!source || !target)
                return [];
              const sourceCenter = getNodeCenter(source, xynodes2), targetCenter = getNodeCenter(target, xynodes2);
              if (sourceCenter && targetCenter) {
                const sourceToTargetVector = targetCenter.sub(sourceCenter), sourceBorderPoint = getBorderPointOnVector(source, sourceCenter, sourceToTargetVector), targetBorderPoint = getBorderPointOnVector(target, targetCenter, sourceToTargetVector.mul(-1));
                return [sourceBorderPoint.add(targetBorderPoint.sub(sourceBorderPoint).mul(0.3))];
              }
              return [];
            }
            function getBorderPointOnVector(node2, nodeCenter, v) {
              const xScale = (node2.width || 0) / 2 / v.x, yScale = (node2.height || 0) / 2 / v.y, scale2 = Math.min(Math.abs(xScale), Math.abs(yScale));
              return vector(v).mul(scale2).add(nodeCenter);
            }
          },
          align: align(get)
        }),
        {
          name: `${storeDevId} - ${props2.view.id}`,
          enabled: DEV
        }
      )
    ),
    shallow$1
  );
}
const DiagramContext = createContext$1(null);
function DiagramContextProvider({
  children,
  view,
  className,
  keepAspectRatio,
  whereFilter,
  ...props2
}) {
  const isMotionReduced = useReducedMotion() ?? !1, [scope, animate] = useAnimate(), containerRef = useRef$1(null), ref = useMergedRef(scope, containerRef), xystore = useXYStoreApi(), xyflow2 = useXYFlow(), store = useRef$1(), getContainer = useCallback$1(() => containerRef.current, [containerRef]);
  store.current || (store.current = createDiagramStore({
    xystore,
    xyflow: xyflow2,
    view,
    getContainer,
    whereFilter: p(whereFilter),
    ...props2
  })), useUpdateEffect(
    () => store.current?.setState({ xyflow: xyflow2, xystore, getContainer }, !1, "update xyflow and xystore"),
    [xyflow2, xystore, getContainer]
  ), useUpdateEffect(
    () => store.current?.setState(props2, !1, "update incoming props"),
    [props2]
  ), useUpdateEffect(
    () => {
      const current = store.current;
      invariant$1(current, "DiagramContext.store.current is not defined"), deepEqual(whereFilter, current.getState().whereFilter) || current.setState({ whereFilter: p(whereFilter) }, !1, "update where filter"), current.getState().updateView(view);
    },
    [view, whereFilter],
    (a2, b2) => shallowEqual(a2[0], b2[0]) && deepEqual(a2[1], b2[1])
  );
  const api = store.current;
  return useEffect$1(() => {
    if (!isMotionReduced)
      return api.subscribe((s2) => !!s2.activeOverlay, (isActiveOverlay) => {
        animate(".likec4-diagram .react-flow__renderer", {
          opacity: isActiveOverlay ? 0.7 : 1,
          filter: isActiveOverlay ? "grayscale(1)" : "grayscale(0)",
          transform: isActiveOverlay ? "perspective(300px) translateZ(-10px) translateY(2px)" : "translateY(0)"
        }, {
          duration: isActiveOverlay ? 0.4 : 0.2
        });
      }, {
        fireImmediately: !0
      });
  }, [api, isMotionReduced]), /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      className,
      ...keepAspectRatio && {
        style: {
          aspectRatio: `${Math.ceil(view.bounds.width)}/${Math.ceil(view.bounds.height)}`,
          maxHeight: Math.ceil(view.bounds.height)
        }
      },
      children: /* @__PURE__ */ jsx(DiagramContext.Provider, { value: api, children })
    }
  );
}
DiagramContextProvider.displayName = "DiagramContextProvider";
function useDiagramState(selector2, equalityFn) {
  const store = useContext$1(DiagramContext);
  if (store === null)
    throw new Error("useDiagramStore could be used only inside DiagramContext");
  return useStoreWithEqualityFn(store, selector2, equalityFn ?? shallowEqual);
}
function useDiagramStoreApi() {
  const store = useContext$1(DiagramContext);
  if (store === null)
    throw new Error("useDiagramStoreApi could be used only inside DiagramContext");
  return store;
}
var stylesheets = {}, injectStyles = (_ref) => {
  var {
    fileScope,
    css
  } = _ref, fileScopeId = fileScope.packageName ? [fileScope.packageName, fileScope.filePath].join("/") : fileScope.filePath, stylesheet = stylesheets[fileScopeId];
  if (!stylesheet) {
    var styleEl = document.createElement("style");
    fileScope.packageName && styleEl.setAttribute("data-package", fileScope.packageName), styleEl.setAttribute("data-file", fileScope.filePath), styleEl.setAttribute("type", "text/css"), stylesheet = stylesheets[fileScopeId] = styleEl, document.head.appendChild(styleEl);
  }
  stylesheet.innerHTML = css;
};
function getVarName(variable) {
  var matches = variable.match(/^var\((.*)\)$/);
  return matches ? matches[1] : variable;
}
function walkObject(obj, fn) {
  var path = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], clone = {};
  for (var key in obj) {
    var _value = obj[key], currentPath = [...path, key];
    typeof _value == "string" || typeof _value == "number" || _value == null ? clone[key] = fn(_value, currentPath) : typeof _value == "object" && !Array.isArray(_value) ? clone[key] = walkObject(_value, fn, currentPath) : console.warn('Skipping invalid key "'.concat(currentPath.join("."), '". Should be a string, number, null or object. Received: "').concat(Array.isArray(_value) ? "Array" : typeof _value, '"'));
  }
  return clone;
}
/*! https://mths.be/cssesc v3.0.0 by @mathias */
var object = {}, hasOwnProperty = object.hasOwnProperty, merge = function(options, defaults) {
  if (!options)
    return defaults;
  var result = {};
  for (var key in defaults)
    result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];
  return result;
}, regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/, regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/, regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g, cssesc = function cssesc2(string, options) {
  options = merge(options, cssesc2.options), options.quotes != "single" && options.quotes != "double" && (options.quotes = "single");
  for (var quote = options.quotes == "double" ? '"' : "'", isIdentifier = options.isIdentifier, firstChar = string.charAt(0), output = "", counter2 = 0, length = string.length; counter2 < length; ) {
    var character = string.charAt(counter2++), codePoint = character.charCodeAt(), value = void 0;
    if (codePoint < 32 || codePoint > 126) {
      if (codePoint >= 55296 && codePoint <= 56319 && counter2 < length) {
        var extra = string.charCodeAt(counter2++);
        (extra & 64512) == 56320 ? codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536 : counter2--;
      }
      value = "\\" + codePoint.toString(16).toUpperCase() + " ";
    } else
      options.escapeEverything ? regexAnySingleEscape.test(character) ? value = "\\" + character : value = "\\" + codePoint.toString(16).toUpperCase() + " " : /[\t\n\f\r\x0B]/.test(character) ? value = "\\" + codePoint.toString(16).toUpperCase() + " " : character == "\\" || !isIdentifier && (character == '"' && quote == character || character == "'" && quote == character) || isIdentifier && regexSingleEscape.test(character) ? value = "\\" + character : value = character;
    output += value;
  }
  return isIdentifier && (/^-[-\d]/.test(output) ? output = "\\-" + output.slice(1) : /\d/.test(firstChar) && (output = "\\3" + firstChar + " " + output.slice(1))), output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
    return $1 && $1.length % 2 ? $0 : ($1 || "") + $2;
  }), !isIdentifier && options.wrap ? quote + output + quote : output;
};
cssesc.options = {
  escapeEverything: !1,
  isIdentifier: !1,
  quotes: "single",
  wrap: !1
};
cssesc.version = "3.0.0";
var cssesc_1 = cssesc;
const cssesc$1 = /* @__PURE__ */ getDefaultExportFromCjs(cssesc_1);
class AhoCorasick {
  constructor(keywords) {
    const { failure, gotoFn, output } = this._buildTables(keywords);
    this.gotoFn = gotoFn, this.output = output, this.failure = failure;
  }
  _buildTables(keywords) {
    const gotoFn = {
      0: {}
    }, output = {};
    let state = 0;
    for (const word of keywords) {
      let curr = 0;
      for (const l2 of word)
        gotoFn[curr] && l2 in gotoFn[curr] ? curr = gotoFn[curr][l2] : (state++, gotoFn[curr][l2] = state, gotoFn[state] = {}, curr = state, output[state] = []);
      output[curr].push(word);
    }
    const failure = {}, xs = [];
    for (const l2 in gotoFn[0]) {
      const state2 = gotoFn[0][l2];
      failure[state2] = 0, xs.push(state2);
    }
    for (; xs.length > 0; ) {
      const r2 = xs.shift();
      if (r2 !== void 0)
        for (const l2 in gotoFn[r2]) {
          const s2 = gotoFn[r2][l2];
          xs.push(s2);
          let state2 = failure[r2];
          for (; state2 > 0 && !(l2 in gotoFn[state2]); )
            state2 = failure[state2];
          if (l2 in gotoFn[state2]) {
            const fs = gotoFn[state2][l2];
            failure[s2] = fs, output[s2] = [...output[s2], ...output[fs]];
          } else
            failure[s2] = 0;
        }
    }
    return {
      gotoFn,
      output,
      failure
    };
  }
  search(str) {
    let state = 0;
    const results = [];
    for (let i2 = 0; i2 < str.length; i2++) {
      const l2 = str[i2];
      for (; state > 0 && !(l2 in this.gotoFn[state]); )
        state = this.failure[state];
      if (l2 in this.gotoFn[state] && (state = this.gotoFn[state][l2], this.output[state].length > 0)) {
        const foundStrs = this.output[state];
        results.push([i2, foundStrs]);
      }
    }
    return results;
  }
}
var mockAdapter = {
  appendCss: () => {
  },
  registerClassName: () => {
  },
  onEndFileScope: () => {
  },
  registerComposition: () => {
  },
  markCompositionUsed: () => {
  },
  getIdentOption: () => "short"
}, adapterStack = [mockAdapter], currentAdapter = () => {
  if (adapterStack.length < 1)
    throw new Error("No adapter configured");
  return adapterStack[adapterStack.length - 1];
}, hasConfiguredAdapter = !1, setAdapterIfNotSet = (newAdapter) => {
  hasConfiguredAdapter || setAdapter(newAdapter);
}, setAdapter = (newAdapter) => {
  if (!newAdapter)
    throw new Error('No adapter provided when calling "setAdapter"');
  hasConfiguredAdapter = !0, adapterStack.push(newAdapter);
}, markCompositionUsed = function() {
  return currentAdapter().markCompositionUsed(...arguments);
};
function _taggedTemplateLiteral(strings, raw) {
  return raw || (raw = strings.slice(0)), Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}
var SelectorType;
(function(SelectorType2) {
  SelectorType2.Attribute = "attribute", SelectorType2.Pseudo = "pseudo", SelectorType2.PseudoElement = "pseudo-element", SelectorType2.Tag = "tag", SelectorType2.Universal = "universal", SelectorType2.Adjacent = "adjacent", SelectorType2.Child = "child", SelectorType2.Descendant = "descendant", SelectorType2.Parent = "parent", SelectorType2.Sibling = "sibling", SelectorType2.ColumnCombinator = "column-combinator";
})(SelectorType || (SelectorType = {}));
var AttributeAction;
(function(AttributeAction2) {
  AttributeAction2.Any = "any", AttributeAction2.Element = "element", AttributeAction2.End = "end", AttributeAction2.Equals = "equals", AttributeAction2.Exists = "exists", AttributeAction2.Hyphen = "hyphen", AttributeAction2.Not = "not", AttributeAction2.Start = "start";
})(AttributeAction || (AttributeAction = {}));
const reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/, reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi, actionTypes = /* @__PURE__ */ new Map([
  [126, AttributeAction.Element],
  [94, AttributeAction.Start],
  [36, AttributeAction.End],
  [42, AttributeAction.Any],
  [33, AttributeAction.Not],
  [124, AttributeAction.Hyphen]
]), unpackPseudos = /* @__PURE__ */ new Set([
  "has",
  "not",
  "matches",
  "is",
  "where",
  "host",
  "host-context"
]);
function isTraversal(selector2) {
  switch (selector2.type) {
    case SelectorType.Adjacent:
    case SelectorType.Child:
    case SelectorType.Descendant:
    case SelectorType.Parent:
    case SelectorType.Sibling:
    case SelectorType.ColumnCombinator:
      return !0;
    default:
      return !1;
  }
}
const stripQuotesFromPseudos = /* @__PURE__ */ new Set(["contains", "icontains"]);
function funescape(_, escaped, escapedWhitespace) {
  const high = parseInt(escaped, 16) - 65536;
  return high !== high || escapedWhitespace ? escaped : high < 0 ? (
    // BMP codepoint
    String.fromCharCode(high + 65536)
  ) : (
    // Supplemental Plane codepoint (surrogate pair)
    String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
  );
}
function unescapeCSS(str) {
  return str.replace(reEscape, funescape);
}
function isQuote(c) {
  return c === 39 || c === 34;
}
function isWhitespace(c) {
  return c === 32 || c === 9 || c === 10 || c === 12 || c === 13;
}
function parse(selector2) {
  const subselects = [], endIndex = parseSelector(subselects, `${selector2}`, 0);
  if (endIndex < selector2.length)
    throw new Error(`Unmatched selector: ${selector2.slice(endIndex)}`);
  return subselects;
}
function parseSelector(subselects, selector2, selectorIndex) {
  let tokens = [];
  function getName(offset) {
    const match = selector2.slice(selectorIndex + offset).match(reName);
    if (!match)
      throw new Error(`Expected name, found ${selector2.slice(selectorIndex)}`);
    const [name] = match;
    return selectorIndex += offset + name.length, unescapeCSS(name);
  }
  function stripWhitespace(offset) {
    for (selectorIndex += offset; selectorIndex < selector2.length && isWhitespace(selector2.charCodeAt(selectorIndex)); )
      selectorIndex++;
  }
  function readValueWithParenthesis() {
    selectorIndex += 1;
    const start = selectorIndex;
    let counter2 = 1;
    for (; counter2 > 0 && selectorIndex < selector2.length; selectorIndex++)
      selector2.charCodeAt(selectorIndex) === 40 && !isEscaped(selectorIndex) ? counter2++ : selector2.charCodeAt(selectorIndex) === 41 && !isEscaped(selectorIndex) && counter2--;
    if (counter2)
      throw new Error("Parenthesis not matched");
    return unescapeCSS(selector2.slice(start, selectorIndex - 1));
  }
  function isEscaped(pos) {
    let slashCount = 0;
    for (; selector2.charCodeAt(--pos) === 92; )
      slashCount++;
    return (slashCount & 1) === 1;
  }
  function ensureNotTraversal() {
    if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1]))
      throw new Error("Did not expect successive traversals.");
  }
  function addTraversal(type) {
    if (tokens.length > 0 && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens[tokens.length - 1].type = type;
      return;
    }
    ensureNotTraversal(), tokens.push({ type });
  }
  function addSpecialAttribute(name, action) {
    tokens.push({
      type: SelectorType.Attribute,
      name,
      action,
      value: getName(1),
      namespace: null,
      ignoreCase: "quirks"
    });
  }
  function finalizeSubselector() {
    if (tokens.length && tokens[tokens.length - 1].type === SelectorType.Descendant && tokens.pop(), tokens.length === 0)
      throw new Error("Empty sub-selector");
    subselects.push(tokens);
  }
  if (stripWhitespace(0), selector2.length === selectorIndex)
    return selectorIndex;
  loop: for (; selectorIndex < selector2.length; ) {
    const firstChar = selector2.charCodeAt(selectorIndex);
    switch (firstChar) {
      case 32:
      case 9:
      case 10:
      case 12:
      case 13: {
        (tokens.length === 0 || tokens[0].type !== SelectorType.Descendant) && (ensureNotTraversal(), tokens.push({ type: SelectorType.Descendant })), stripWhitespace(1);
        break;
      }
      case 62: {
        addTraversal(SelectorType.Child), stripWhitespace(1);
        break;
      }
      case 60: {
        addTraversal(SelectorType.Parent), stripWhitespace(1);
        break;
      }
      case 126: {
        addTraversal(SelectorType.Sibling), stripWhitespace(1);
        break;
      }
      case 43: {
        addTraversal(SelectorType.Adjacent), stripWhitespace(1);
        break;
      }
      case 46: {
        addSpecialAttribute("class", AttributeAction.Element);
        break;
      }
      case 35: {
        addSpecialAttribute("id", AttributeAction.Equals);
        break;
      }
      case 91: {
        stripWhitespace(1);
        let name, namespace = null;
        selector2.charCodeAt(selectorIndex) === 124 ? name = getName(1) : selector2.startsWith("*|", selectorIndex) ? (namespace = "*", name = getName(2)) : (name = getName(0), selector2.charCodeAt(selectorIndex) === 124 && selector2.charCodeAt(selectorIndex + 1) !== 61 && (namespace = name, name = getName(1))), stripWhitespace(0);
        let action = AttributeAction.Exists;
        const possibleAction = actionTypes.get(selector2.charCodeAt(selectorIndex));
        if (possibleAction) {
          if (action = possibleAction, selector2.charCodeAt(selectorIndex + 1) !== 61)
            throw new Error("Expected `=`");
          stripWhitespace(2);
        } else selector2.charCodeAt(selectorIndex) === 61 && (action = AttributeAction.Equals, stripWhitespace(1));
        let value = "", ignoreCase = null;
        if (action !== "exists") {
          if (isQuote(selector2.charCodeAt(selectorIndex))) {
            const quote = selector2.charCodeAt(selectorIndex);
            let sectionEnd = selectorIndex + 1;
            for (; sectionEnd < selector2.length && (selector2.charCodeAt(sectionEnd) !== quote || isEscaped(sectionEnd)); )
              sectionEnd += 1;
            if (selector2.charCodeAt(sectionEnd) !== quote)
              throw new Error("Attribute value didn't end");
            value = unescapeCSS(selector2.slice(selectorIndex + 1, sectionEnd)), selectorIndex = sectionEnd + 1;
          } else {
            const valueStart = selectorIndex;
            for (; selectorIndex < selector2.length && (!isWhitespace(selector2.charCodeAt(selectorIndex)) && selector2.charCodeAt(selectorIndex) !== 93 || isEscaped(selectorIndex)); )
              selectorIndex += 1;
            value = unescapeCSS(selector2.slice(valueStart, selectorIndex));
          }
          stripWhitespace(0);
          const forceIgnore = selector2.charCodeAt(selectorIndex) | 32;
          forceIgnore === 115 ? (ignoreCase = !1, stripWhitespace(1)) : forceIgnore === 105 && (ignoreCase = !0, stripWhitespace(1));
        }
        if (selector2.charCodeAt(selectorIndex) !== 93)
          throw new Error("Attribute selector didn't terminate");
        selectorIndex += 1;
        const attributeSelector = {
          type: SelectorType.Attribute,
          name,
          action,
          value,
          namespace,
          ignoreCase
        };
        tokens.push(attributeSelector);
        break;
      }
      case 58: {
        if (selector2.charCodeAt(selectorIndex + 1) === 58) {
          tokens.push({
            type: SelectorType.PseudoElement,
            name: getName(2).toLowerCase(),
            data: selector2.charCodeAt(selectorIndex) === 40 ? readValueWithParenthesis() : null
          });
          continue;
        }
        const name = getName(1).toLowerCase();
        let data = null;
        if (selector2.charCodeAt(selectorIndex) === 40)
          if (unpackPseudos.has(name)) {
            if (isQuote(selector2.charCodeAt(selectorIndex + 1)))
              throw new Error(`Pseudo-selector ${name} cannot be quoted`);
            if (data = [], selectorIndex = parseSelector(data, selector2, selectorIndex + 1), selector2.charCodeAt(selectorIndex) !== 41)
              throw new Error(`Missing closing parenthesis in :${name} (${selector2})`);
            selectorIndex += 1;
          } else {
            if (data = readValueWithParenthesis(), stripQuotesFromPseudos.has(name)) {
              const quot = data.charCodeAt(0);
              quot === data.charCodeAt(data.length - 1) && isQuote(quot) && (data = data.slice(1, -1));
            }
            data = unescapeCSS(data);
          }
        tokens.push({ type: SelectorType.Pseudo, name, data });
        break;
      }
      case 44: {
        finalizeSubselector(), tokens = [], stripWhitespace(1);
        break;
      }
      default: {
        if (selector2.startsWith("/*", selectorIndex)) {
          const endIndex = selector2.indexOf("*/", selectorIndex + 2);
          if (endIndex < 0)
            throw new Error("Comment was not terminated");
          selectorIndex = endIndex + 2, tokens.length === 0 && stripWhitespace(0);
          break;
        }
        let namespace = null, name;
        if (firstChar === 42)
          selectorIndex += 1, name = "*";
        else if (firstChar === 124) {
          if (name = "", selector2.charCodeAt(selectorIndex + 1) === 124) {
            addTraversal(SelectorType.ColumnCombinator), stripWhitespace(2);
            break;
          }
        } else if (reName.test(selector2.slice(selectorIndex)))
          name = getName(0);
        else
          break loop;
        selector2.charCodeAt(selectorIndex) === 124 && selector2.charCodeAt(selectorIndex + 1) !== 124 && (namespace = name, selector2.charCodeAt(selectorIndex + 1) === 42 ? (name = "*", selectorIndex += 2) : name = getName(1)), tokens.push(name === "*" ? { type: SelectorType.Universal, namespace } : { type: SelectorType.Tag, name, namespace });
      }
    }
  }
  return finalizeSubselector(), selectorIndex;
}
function ownKeys$1(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    i2 % 2 ? ownKeys$1(Object(source), !0).forEach(function(key) {
      _defineProperty$1(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$1(obj, key, value) {
  return key = _toPropertyKey(key), key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key == "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (typeof input != "object" || input === null) return input;
  var prim2 = input[Symbol.toPrimitive];
  if (prim2 !== void 0) {
    var res = prim2.call(input, hint);
    if (typeof res != "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(input);
}
const dedent = createDedent({});
function createDedent(options) {
  return dedent2.withOptions = (newOptions) => createDedent(_objectSpread(_objectSpread({}, options), newOptions)), dedent2;
  function dedent2(strings, ...values) {
    const raw = typeof strings == "string" ? [strings] : strings.raw, {
      escapeSpecialCharacters = Array.isArray(strings)
    } = options;
    let result = "";
    for (let i2 = 0; i2 < raw.length; i2++) {
      let next = raw[i2];
      escapeSpecialCharacters && (next = next.replace(/\\\n[ \t]*/g, "").replace(/\\`/g, "`").replace(/\\\$/g, "$").replace(/\\\{/g, "{")), result += next, i2 < values.length && (result += values[i2]);
    }
    const lines = result.split(`
`);
    let mindent = null;
    for (const l2 of lines) {
      const m2 = l2.match(/^(\s+)\S+/);
      if (m2) {
        const indent = m2[1].length;
        mindent ? mindent = Math.min(mindent, indent) : mindent = indent;
      }
    }
    if (mindent !== null) {
      const m2 = mindent;
      result = lines.map((l2) => l2[0] === " " || l2[0] === "	" ? l2.slice(m2) : l2).join(`
`);
    }
    return result = result.trim(), escapeSpecialCharacters && (result = result.replace(/\\n/g, `
`)), result;
  }
}
/*! @license MediaQueryParser - MIT License - Tom Golden (github@tbjgolden.com) */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign = function() {
  return __assign = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && (t2[p2] = s2[p2]);
    }
    return t2;
  }, __assign.apply(this, arguments);
};
function __rest(s2, e2) {
  var t2 = {};
  for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0 && (t2[p2] = s2[p2]);
  if (s2 != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++)
      e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]) && (t2[p2[i2]] = s2[p2[i2]]);
  return t2;
}
function __values(o2) {
  var s2 = typeof Symbol == "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2) return m2.call(o2);
  if (o2 && typeof o2.length == "number") return {
    next: function() {
      return o2 && i2 >= o2.length && (o2 = void 0), { value: o2 && o2[i2++], done: !o2 };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o2, n2) {
  var m2 = typeof Symbol == "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    for (; (n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done; ) ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      r2 && !r2.done && (m2 = i2.return) && m2.call(i2);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
}
var weirdNewlines = /(\u000D|\u000C|\u000D\u000A)/g, nullOrSurrogates = /[\u0000\uD800-\uDFFF]/g, commentRegex = /(\/\*)[\s\S]*?(\*\/)/g, lexicalAnalysis = function(str, index2) {
  index2 === void 0 && (index2 = 0), str = str.replace(weirdNewlines, `
`).replace(nullOrSurrogates, ""), str = str.replace(commentRegex, "");
  for (var tokens = []; index2 < str.length; index2 += 1) {
    var code = str.charCodeAt(index2);
    if (code === 9 || code === 32 || code === 10) {
      for (var code_1 = str.charCodeAt(++index2); code_1 === 9 || code_1 === 32 || code_1 === 10; )
        code_1 = str.charCodeAt(++index2);
      index2 -= 1, tokens.push({
        type: "<whitespace-token>"
      });
    } else if (code === 34) {
      var result = consumeString(str, index2);
      if (result === null)
        return null;
      var _a2 = __read(result, 2), lastIndex = _a2[0], value = _a2[1];
      tokens.push({
        type: "<string-token>",
        value
      }), index2 = lastIndex;
    } else if (code === 35) {
      if (index2 + 1 < str.length) {
        var nextCode = str.charCodeAt(index2 + 1);
        if (nextCode === 95 || nextCode >= 65 && nextCode <= 90 || nextCode >= 97 && nextCode <= 122 || nextCode >= 128 || nextCode >= 48 && nextCode <= 57 || nextCode === 92 && index2 + 2 < str.length && str.charCodeAt(index2 + 2) !== 10) {
          var flag = wouldStartIdentifier(str, index2 + 1) ? "id" : "unrestricted", result = consumeIdentUnsafe(str, index2 + 1);
          if (result !== null) {
            var _b = __read(result, 2), lastIndex = _b[0], value = _b[1];
            tokens.push({
              type: "<hash-token>",
              value: value.toLowerCase(),
              flag
            }), index2 = lastIndex;
            continue;
          }
        }
      }
      tokens.push({
        type: "<delim-token>",
        value: code
      });
    } else if (code === 39) {
      var result = consumeString(str, index2);
      if (result === null)
        return null;
      var _c = __read(result, 2), lastIndex = _c[0], value = _c[1];
      tokens.push({
        type: "<string-token>",
        value
      }), index2 = lastIndex;
    } else if (code === 40)
      tokens.push({
        type: "<(-token>"
      });
    else if (code === 41)
      tokens.push({
        type: "<)-token>"
      });
    else if (code === 43) {
      var plusNumeric = consumeNumeric(str, index2);
      if (plusNumeric === null)
        tokens.push({
          type: "<delim-token>",
          value: code
        });
      else {
        var _d = __read(plusNumeric, 2), lastIndex = _d[0], tokenTuple = _d[1];
        tokenTuple[0] === "<dimension-token>" ? tokens.push({
          type: "<dimension-token>",
          value: tokenTuple[1],
          unit: tokenTuple[2].toLowerCase(),
          flag: "number"
        }) : tokenTuple[0] === "<number-token>" ? tokens.push({
          type: tokenTuple[0],
          value: tokenTuple[1],
          flag: tokenTuple[2]
        }) : tokens.push({
          type: tokenTuple[0],
          value: tokenTuple[1],
          flag: "number"
        }), index2 = lastIndex;
      }
    } else if (code === 44)
      tokens.push({
        type: "<comma-token>"
      });
    else if (code === 45) {
      var minusNumeric = consumeNumeric(str, index2);
      if (minusNumeric !== null) {
        var _e = __read(minusNumeric, 2), lastIndex = _e[0], tokenTuple = _e[1];
        tokenTuple[0] === "<dimension-token>" ? tokens.push({
          type: "<dimension-token>",
          value: tokenTuple[1],
          unit: tokenTuple[2].toLowerCase(),
          flag: "number"
        }) : tokenTuple[0] === "<number-token>" ? tokens.push({
          type: tokenTuple[0],
          value: tokenTuple[1],
          flag: tokenTuple[2]
        }) : tokens.push({
          type: tokenTuple[0],
          value: tokenTuple[1],
          flag: "number"
        }), index2 = lastIndex;
        continue;
      }
      if (index2 + 2 < str.length) {
        var nextCode = str.charCodeAt(index2 + 1), nextNextCode = str.charCodeAt(index2 + 2);
        if (nextCode === 45 && nextNextCode === 62) {
          tokens.push({
            type: "<CDC-token>"
          }), index2 += 2;
          continue;
        }
      }
      var result = consumeIdentLike(str, index2);
      if (result !== null) {
        var _f = __read(result, 3), lastIndex = _f[0], value = _f[1], type = _f[2];
        tokens.push({
          type,
          value
        }), index2 = lastIndex;
        continue;
      }
      tokens.push({
        type: "<delim-token>",
        value: code
      });
    } else if (code === 46) {
      var minusNumeric = consumeNumeric(str, index2);
      if (minusNumeric === null)
        tokens.push({
          type: "<delim-token>",
          value: code
        });
      else {
        var _g = __read(minusNumeric, 2), lastIndex = _g[0], tokenTuple = _g[1];
        tokenTuple[0] === "<dimension-token>" ? tokens.push({
          type: "<dimension-token>",
          value: tokenTuple[1],
          unit: tokenTuple[2].toLowerCase(),
          flag: "number"
        }) : tokenTuple[0] === "<number-token>" ? tokens.push({
          type: tokenTuple[0],
          value: tokenTuple[1],
          flag: tokenTuple[2]
        }) : tokens.push({
          type: tokenTuple[0],
          value: tokenTuple[1],
          flag: "number"
        }), index2 = lastIndex;
        continue;
      }
    } else if (code === 58)
      tokens.push({
        type: "<colon-token>"
      });
    else if (code === 59)
      tokens.push({
        type: "<semicolon-token>"
      });
    else if (code === 60) {
      if (index2 + 3 < str.length) {
        var nextCode = str.charCodeAt(index2 + 1), nextNextCode = str.charCodeAt(index2 + 2), nextNextNextCode = str.charCodeAt(index2 + 3);
        if (nextCode === 33 && nextNextCode === 45 && nextNextNextCode === 45) {
          tokens.push({
            type: "<CDO-token>"
          }), index2 += 3;
          continue;
        }
      }
      tokens.push({
        type: "<delim-token>",
        value: code
      });
    } else if (code === 64) {
      var result = consumeIdent(str, index2 + 1);
      if (result !== null) {
        var _h = __read(result, 2), lastIndex = _h[0], value = _h[1];
        tokens.push({
          type: "<at-keyword-token>",
          value: value.toLowerCase()
        }), index2 = lastIndex;
        continue;
      }
      tokens.push({
        type: "<delim-token>",
        value: code
      });
    } else if (code === 91)
      tokens.push({
        type: "<[-token>"
      });
    else if (code === 92) {
      var result = consumeEscape(str, index2);
      if (result === null)
        return null;
      var _j = __read(result, 2), lastIndex = _j[0], value = _j[1];
      str = str.slice(0, index2) + value + str.slice(lastIndex + 1), index2 -= 1;
    } else if (code === 93)
      tokens.push({
        type: "<]-token>"
      });
    else if (code === 123)
      tokens.push({
        type: "<{-token>"
      });
    else if (code === 125)
      tokens.push({
        type: "<}-token>"
      });
    else if (code >= 48 && code <= 57) {
      var result = consumeNumeric(str, index2), _k = __read(result, 2), lastIndex = _k[0], tokenTuple = _k[1];
      tokenTuple[0] === "<dimension-token>" ? tokens.push({
        type: "<dimension-token>",
        value: tokenTuple[1],
        unit: tokenTuple[2].toLowerCase(),
        flag: "number"
      }) : tokenTuple[0] === "<number-token>" ? tokens.push({
        type: tokenTuple[0],
        value: tokenTuple[1],
        flag: tokenTuple[2]
      }) : tokens.push({
        type: tokenTuple[0],
        value: tokenTuple[1],
        flag: "number"
      }), index2 = lastIndex;
    } else if (code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122 || code >= 128) {
      var result = consumeIdentLike(str, index2);
      if (result === null)
        return null;
      var _l = __read(result, 3), lastIndex = _l[0], value = _l[1], type = _l[2];
      tokens.push({
        type,
        value
      }), index2 = lastIndex;
    } else
      tokens.push({
        type: "<delim-token>",
        value: code
      });
  }
  return tokens.push({
    type: "<EOF-token>"
  }), tokens;
}, consumeString = function(str, index2) {
  if (str.length <= index2 + 1) return null;
  for (var firstCode = str.charCodeAt(index2), charCodes = [], i2 = index2 + 1; i2 < str.length; i2 += 1) {
    var code = str.charCodeAt(i2);
    if (code === firstCode)
      return [i2, String.fromCharCode.apply(null, charCodes)];
    if (code === 92) {
      var result = consumeEscape(str, i2);
      if (result === null) return null;
      var _a2 = __read(result, 2), lastIndex = _a2[0], charCode = _a2[1];
      charCodes.push(charCode), i2 = lastIndex;
    } else {
      if (code === 10)
        return null;
      charCodes.push(code);
    }
  }
  return null;
}, wouldStartIdentifier = function(str, index2) {
  if (str.length <= index2) return !1;
  var code = str.charCodeAt(index2);
  if (code === 45) {
    if (str.length <= index2 + 1) return !1;
    var nextCode = str.charCodeAt(index2 + 1);
    if (nextCode === 45 || nextCode === 95 || nextCode >= 65 && nextCode <= 90 || nextCode >= 97 && nextCode <= 122 || nextCode >= 128)
      return !0;
    if (nextCode === 92) {
      if (str.length <= index2 + 2) return !1;
      var nextNextCode = str.charCodeAt(index2 + 2);
      return nextNextCode !== 10;
    } else
      return !1;
  } else {
    if (code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122 || code >= 128)
      return !0;
    if (code === 92) {
      if (str.length <= index2 + 1) return !1;
      var nextCode = str.charCodeAt(index2 + 1);
      return nextCode !== 10;
    } else
      return !1;
  }
}, consumeEscape = function(str, index2) {
  if (str.length <= index2 + 1 || str.charCodeAt(index2) !== 92) return null;
  var code = str.charCodeAt(index2 + 1);
  if (code === 10)
    return null;
  if (code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102) {
    for (var hexCharCodes = [code], min2 = Math.min(index2 + 7, str.length), i2 = index2 + 2; i2 < min2; i2 += 1) {
      var code_2 = str.charCodeAt(i2);
      if (code_2 >= 48 && code_2 <= 57 || code_2 >= 65 && code_2 <= 70 || code_2 >= 97 && code_2 <= 102)
        hexCharCodes.push(code_2);
      else
        break;
    }
    if (i2 < str.length) {
      var code_3 = str.charCodeAt(i2);
      (code_3 === 9 || code_3 === 32 || code_3 === 10) && (i2 += 1);
    }
    return [i2 - 1, parseInt(String.fromCharCode.apply(null, hexCharCodes), 16)];
  } else
    return [index2 + 1, code];
}, consumeNumeric = function(str, index2) {
  var numberResult = consumeNumber(str, index2);
  if (numberResult === null) return null;
  var _a2 = __read(numberResult, 3), numberEndIndex = _a2[0], numberValue = _a2[1], numberFlag = _a2[2], identResult = consumeIdent(str, numberEndIndex + 1);
  if (identResult !== null) {
    var _b = __read(identResult, 2), identEndIndex = _b[0], identValue = _b[1];
    return [identEndIndex, ["<dimension-token>", numberValue, identValue]];
  }
  return numberEndIndex + 1 < str.length && str.charCodeAt(numberEndIndex + 1) === 37 ? [numberEndIndex + 1, ["<percentage-token>", numberValue]] : [numberEndIndex, ["<number-token>", numberValue, numberFlag]];
}, consumeNumber = function(str, index2) {
  if (str.length <= index2) return null;
  var flag = "integer", numberChars = [], firstCode = str.charCodeAt(index2);
  for ((firstCode === 43 || firstCode === 45) && (index2 += 1, firstCode === 45 && numberChars.push(45)); index2 < str.length; ) {
    var code = str.charCodeAt(index2);
    if (code >= 48 && code <= 57)
      numberChars.push(code), index2 += 1;
    else
      break;
  }
  if (index2 + 1 < str.length) {
    var nextCode = str.charCodeAt(index2), nextNextCode = str.charCodeAt(index2 + 1);
    if (nextCode === 46 && nextNextCode >= 48 && nextNextCode <= 57)
      for (numberChars.push(nextCode, nextNextCode), flag = "number", index2 += 2; index2 < str.length; ) {
        var code = str.charCodeAt(index2);
        if (code >= 48 && code <= 57)
          numberChars.push(code), index2 += 1;
        else
          break;
      }
  }
  if (index2 + 1 < str.length) {
    var nextCode = str.charCodeAt(index2), nextNextCode = str.charCodeAt(index2 + 1), nextNextNextCode = str.charCodeAt(index2 + 2);
    if (nextCode === 69 || nextCode === 101) {
      var nextNextIsDigit = nextNextCode >= 48 && nextNextCode <= 57;
      if (nextNextIsDigit || (nextNextCode === 43 || nextNextCode === 45) && nextNextNextCode >= 48 && nextNextNextCode <= 57)
        for (flag = "number", nextNextIsDigit ? (numberChars.push(69, nextNextCode), index2 += 2) : nextNextCode === 45 ? (numberChars.push(69, 45, nextNextNextCode), index2 += 3) : (numberChars.push(69, nextNextNextCode), index2 += 3); index2 < str.length; ) {
          var code = str.charCodeAt(index2);
          if (code >= 48 && code <= 57)
            numberChars.push(code), index2 += 1;
          else
            break;
        }
    }
  }
  var numberString = String.fromCharCode.apply(null, numberChars), value = flag === "number" ? parseFloat(numberString) : parseInt(numberString);
  return value === -0 && (value = 0), Number.isNaN(value) ? null : [index2 - 1, value, flag];
}, consumeIdentUnsafe = function(str, index2) {
  if (str.length <= index2)
    return null;
  for (var identChars = [], code = str.charCodeAt(index2); index2 < str.length; code = str.charCodeAt(++index2)) {
    if (code === 45 || code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122 || code >= 128 || code >= 48 && code <= 57) {
      identChars.push(code);
      continue;
    } else {
      var result = consumeEscape(str, index2);
      if (result !== null) {
        var _a2 = __read(result, 2), lastIndex = _a2[0], code_4 = _a2[1];
        identChars.push(code_4), index2 = lastIndex;
        continue;
      }
    }
    break;
  }
  return index2 === 0 ? null : [index2 - 1, String.fromCharCode.apply(null, identChars)];
}, consumeIdent = function(str, index2) {
  if (str.length <= index2 || !wouldStartIdentifier(str, index2))
    return null;
  for (var identChars = [], code = str.charCodeAt(index2); index2 < str.length; code = str.charCodeAt(++index2)) {
    if (code === 45 || code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122 || code >= 128 || code >= 48 && code <= 57) {
      identChars.push(code);
      continue;
    } else {
      var result = consumeEscape(str, index2);
      if (result !== null) {
        var _a2 = __read(result, 2), lastIndex = _a2[0], code_5 = _a2[1];
        identChars.push(code_5), index2 = lastIndex;
        continue;
      }
    }
    break;
  }
  return [index2 - 1, String.fromCharCode.apply(null, identChars)];
}, consumeUrl = function(str, index2) {
  for (var code = str.charCodeAt(index2); code === 9 || code === 32 || code === 10; )
    code = str.charCodeAt(++index2);
  for (var urlChars = [], hasFinishedWord = !1; index2 < str.length; ) {
    if (code === 41)
      return [index2, String.fromCharCode.apply(null, urlChars)];
    if (code === 34 || code === 39 || code === 40)
      return null;
    if (code === 9 || code === 32 || code === 10)
      !hasFinishedWord && urlChars.length !== 0 && (hasFinishedWord = !0);
    else if (code === 92) {
      var result = consumeEscape(str, index2);
      if (result === null || hasFinishedWord) return null;
      var _a2 = __read(result, 2), lastIndex = _a2[0], value = _a2[1];
      urlChars.push(value), index2 = lastIndex;
    } else {
      if (hasFinishedWord) return null;
      urlChars.push(code);
    }
    code = str.charCodeAt(++index2);
  }
  return null;
}, consumeIdentLike = function(str, index2) {
  var result = consumeIdent(str, index2);
  if (result === null) return null;
  var _a2 = __read(result, 2), lastIndex = _a2[0], value = _a2[1];
  if (value.toLowerCase() === "url") {
    if (str.length > lastIndex + 1) {
      var nextCode = str.charCodeAt(lastIndex + 1);
      if (nextCode === 40) {
        for (var offset = 2; lastIndex + offset < str.length; offset += 1) {
          var nextNextCode = str.charCodeAt(lastIndex + offset);
          if (nextNextCode === 34 || nextNextCode === 39)
            return [lastIndex + 1, value.toLowerCase(), "<function-token>"];
          if (nextNextCode !== 9 && nextNextCode !== 32 && nextNextCode !== 10) {
            var result_1 = consumeUrl(str, lastIndex + offset);
            if (result_1 === null) return null;
            var _b = __read(result_1, 2), lastUrlIndex = _b[0], value_1 = _b[1];
            return [lastUrlIndex, value_1, "<url-token>"];
          }
        }
        return [lastIndex + 1, value.toLowerCase(), "<function-token>"];
      }
    }
  } else if (str.length > lastIndex + 1) {
    var nextCode = str.charCodeAt(lastIndex + 1);
    if (nextCode === 40)
      return [lastIndex + 1, value.toLowerCase(), "<function-token>"];
  }
  return [lastIndex, value.toLowerCase(), "<ident-token>"];
}, simplifyAST = function(ast) {
  for (var i2 = ast.length - 1; i2 >= 0; i2--)
    ast[i2] = simplifyMediaQuery(ast[i2]);
  return ast;
}, simplifyMediaQuery = function(mediaQuery) {
  if (mediaQuery.mediaCondition === null) return mediaQuery;
  var mediaCondition = simplifyMediaCondition(mediaQuery.mediaCondition);
  return mediaCondition.operator === null && mediaCondition.children.length === 1 && "children" in mediaCondition.children[0] && (mediaCondition = mediaCondition.children[0]), {
    mediaPrefix: mediaQuery.mediaPrefix,
    mediaType: mediaQuery.mediaType,
    mediaCondition
  };
}, simplifyMediaCondition = function simplifyMediaCondition2(mediaCondition) {
  for (var i2 = mediaCondition.children.length - 1; i2 >= 0; i2--) {
    var unsimplifiedChild = mediaCondition.children[i2];
    if (!("context" in unsimplifiedChild)) {
      var child = simplifyMediaCondition2(unsimplifiedChild);
      if (child.operator === null && child.children.length === 1)
        mediaCondition.children[i2] = child.children[0];
      else if (child.operator === mediaCondition.operator && (child.operator === "and" || child.operator === "or")) {
        for (var spliceArgs = [i2, 1], i_1 = 0; i_1 < child.children.length; i_1++)
          spliceArgs.push(child.children[i_1]);
        mediaCondition.children.splice.apply(mediaCondition.children, spliceArgs);
      }
    }
  }
  return mediaCondition;
}, createError = function(message, err) {
  return err instanceof Error ? new Error("".concat(err.message.trim(), `
`).concat(message.trim())) : new Error(message.trim());
}, toAST = function(str) {
  return simplifyAST(toUnflattenedAST(str));
}, toUnflattenedAST = function(str) {
  var tokenList = lexicalAnalysis(str.trim());
  if (tokenList === null)
    throw createError("Failed tokenizing");
  var startIndex = 0, endIndex = tokenList.length - 1;
  if (tokenList[0].type === "<at-keyword-token>" && tokenList[0].value === "media") {
    if (tokenList[1].type !== "<whitespace-token>")
      throw createError("Expected whitespace after media");
    startIndex = 2;
    for (var i2 = 2; i2 < tokenList.length - 1; i2++) {
      var token = tokenList[i2];
      if (token.type === "<{-token>") {
        endIndex = i2;
        break;
      } else if (token.type === "<semicolon-token>")
        throw createError("Expected '{' in media query but found ';'");
    }
  }
  return tokenList = tokenList.slice(startIndex, endIndex), syntacticAnalysis(tokenList);
}, removeWhitespace = function(tokenList) {
  for (var newTokenList = [], before = !1, i2 = 0; i2 < tokenList.length; i2++)
    tokenList[i2].type === "<whitespace-token>" ? (before = !0, newTokenList.length > 0 && (newTokenList[newTokenList.length - 1].wsAfter = !0)) : (newTokenList.push(__assign(__assign({}, tokenList[i2]), {
      wsBefore: before,
      wsAfter: !1
    })), before = !1);
  return newTokenList;
}, syntacticAnalysis = function(tokenList) {
  for (var e_1, _a2, mediaQueryList = [[]], i2 = 0; i2 < tokenList.length; i2++) {
    var token = tokenList[i2];
    token.type === "<comma-token>" ? mediaQueryList.push([]) : mediaQueryList[mediaQueryList.length - 1].push(token);
  }
  var mediaQueries = mediaQueryList.map(removeWhitespace);
  if (mediaQueries.length === 1 && mediaQueries[0].length === 0)
    return [{
      mediaCondition: null,
      mediaPrefix: null,
      mediaType: "all"
    }];
  var mediaQueryTokens = mediaQueries.map(function(mediaQueryTokens2) {
    return mediaQueryTokens2.length === 0 ? null : tokenizeMediaQuery(mediaQueryTokens2);
  }), nonNullMediaQueryTokens = [];
  try {
    for (var mediaQueryTokens_1 = __values(mediaQueryTokens), mediaQueryTokens_1_1 = mediaQueryTokens_1.next(); !mediaQueryTokens_1_1.done; mediaQueryTokens_1_1 = mediaQueryTokens_1.next()) {
      var mediaQueryToken = mediaQueryTokens_1_1.value;
      mediaQueryToken !== null && nonNullMediaQueryTokens.push(mediaQueryToken);
    }
  } catch (e_1_1) {
    e_1 = {
      error: e_1_1
    };
  } finally {
    try {
      mediaQueryTokens_1_1 && !mediaQueryTokens_1_1.done && (_a2 = mediaQueryTokens_1.return) && _a2.call(mediaQueryTokens_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
  if (nonNullMediaQueryTokens.length === 0)
    throw createError("No valid media queries");
  return nonNullMediaQueryTokens;
}, tokenizeMediaQuery = function(tokens) {
  var firstToken = tokens[0];
  if (firstToken.type === "<(-token>")
    try {
      return {
        mediaPrefix: null,
        mediaType: "all",
        mediaCondition: tokenizeMediaCondition(tokens, !0)
      };
    } catch (err) {
      throw createError("Expected media condition after '('", err);
    }
  else if (firstToken.type === "<ident-token>") {
    var mediaPrefix = null, mediaType = void 0, value = firstToken.value;
    (value === "only" || value === "not") && (mediaPrefix = value);
    var firstIndex = mediaPrefix === null ? 0 : 1;
    if (tokens.length <= firstIndex)
      throw createError("Expected extra token in media query");
    var firstNonUnaryToken = tokens[firstIndex];
    if (firstNonUnaryToken.type === "<ident-token>") {
      var value_1 = firstNonUnaryToken.value;
      if (value_1 === "all")
        mediaType = "all";
      else if (value_1 === "print" || value_1 === "screen")
        mediaType = value_1;
      else if (value_1 === "tty" || value_1 === "tv" || value_1 === "projection" || value_1 === "handheld" || value_1 === "braille" || value_1 === "embossed" || value_1 === "aural" || value_1 === "speech")
        mediaPrefix = mediaPrefix === "not" ? null : "not", mediaType = "all";
      else
        throw createError("Unknown ident '".concat(value_1, "' in media query"));
    } else if (mediaPrefix === "not" && firstNonUnaryToken.type === "<(-token>") {
      var tokensWithParens = [{
        type: "<(-token>",
        wsBefore: !1,
        wsAfter: !1
      }];
      tokensWithParens.push.apply(tokensWithParens, tokens), tokensWithParens.push({
        type: "<)-token>",
        wsBefore: !1,
        wsAfter: !1
      });
      try {
        return {
          mediaPrefix: null,
          mediaType: "all",
          mediaCondition: tokenizeMediaCondition(tokensWithParens, !0)
        };
      } catch (err) {
        throw createError("Expected media condition after '('", err);
      }
    } else
      throw createError("Invalid media query");
    if (firstIndex + 1 === tokens.length)
      return {
        mediaPrefix,
        mediaType,
        mediaCondition: null
      };
    if (firstIndex + 4 < tokens.length) {
      var secondNonUnaryToken = tokens[firstIndex + 1];
      if (secondNonUnaryToken.type === "<ident-token>" && secondNonUnaryToken.value === "and")
        try {
          return {
            mediaPrefix,
            mediaType,
            mediaCondition: tokenizeMediaCondition(tokens.slice(firstIndex + 2), !1)
          };
        } catch (err) {
          throw createError("Expected media condition after 'and'", err);
        }
      else
        throw createError("Expected 'and' after media prefix");
    } else
      throw createError("Expected media condition after media prefix");
  } else
    throw createError("Expected media condition or media prefix");
}, tokenizeMediaCondition = function tokenizeMediaCondition2(tokens, mayContainOr, previousOperator) {
  if (previousOperator === void 0 && (previousOperator = null), tokens.length < 3 || tokens[0].type !== "<(-token>" || tokens[tokens.length - 1].type !== "<)-token>")
    throw new Error("Invalid media condition");
  for (var endIndexOfFirstFeature = tokens.length - 1, maxDepth = 0, count = 0, i2 = 0; i2 < tokens.length; i2++) {
    var token = tokens[i2];
    if (token.type === "<(-token>" ? (count += 1, maxDepth = Math.max(maxDepth, count)) : token.type === "<)-token>" && (count -= 1), count === 0) {
      endIndexOfFirstFeature = i2;
      break;
    }
  }
  if (count !== 0)
    throw new Error(`Mismatched parens
Invalid media condition`);
  var child, featureTokens = tokens.slice(0, endIndexOfFirstFeature + 1);
  if (maxDepth === 1 ? child = tokenizeMediaFeature(featureTokens) : featureTokens[1].type === "<ident-token>" && featureTokens[1].value === "not" ? child = tokenizeMediaCondition2(featureTokens.slice(2, -1), !0, "not") : child = tokenizeMediaCondition2(featureTokens.slice(1, -1), !0), endIndexOfFirstFeature === tokens.length - 1)
    return {
      operator: previousOperator,
      children: [child]
    };
  var nextToken = tokens[endIndexOfFirstFeature + 1];
  if (nextToken.type !== "<ident-token>")
    throw new Error(`Invalid operator
Invalid media condition`);
  if (previousOperator !== null && previousOperator !== nextToken.value)
    throw new Error("'".concat(nextToken.value, "' and '").concat(previousOperator, `' must not be at same level
Invalid media condition`));
  if (nextToken.value === "or" && !mayContainOr)
    throw new Error(`Cannot use 'or' at top level of a media query
Invalid media condition`);
  if (nextToken.value !== "and" && nextToken.value !== "or")
    throw new Error("Invalid operator: '".concat(nextToken.value, `'
Invalid media condition`));
  var siblings = tokenizeMediaCondition2(tokens.slice(endIndexOfFirstFeature + 2), mayContainOr, nextToken.value);
  return {
    operator: nextToken.value,
    children: [child].concat(siblings.children)
  };
}, tokenizeMediaFeature = function(rawTokens) {
  if (rawTokens.length < 3 || rawTokens[0].type !== "<(-token>" || rawTokens[rawTokens.length - 1].type !== "<)-token>")
    throw new Error("Invalid media feature");
  for (var tokens = [rawTokens[0]], i2 = 1; i2 < rawTokens.length; i2++) {
    if (i2 < rawTokens.length - 2) {
      var a2 = rawTokens[i2], b2 = rawTokens[i2 + 1], c = rawTokens[i2 + 2];
      if (a2.type === "<number-token>" && a2.value > 0 && b2.type === "<delim-token>" && b2.value === 47 && c.type === "<number-token>" && c.value > 0) {
        tokens.push({
          type: "<ratio-token>",
          numerator: a2.value,
          denominator: c.value,
          wsBefore: a2.wsBefore,
          wsAfter: c.wsAfter
        }), i2 += 2;
        continue;
      }
    }
    tokens.push(rawTokens[i2]);
  }
  var nextToken = tokens[1];
  if (nextToken.type === "<ident-token>" && tokens.length === 3)
    return {
      context: "boolean",
      feature: nextToken.value
    };
  if (tokens.length === 5 && tokens[1].type === "<ident-token>" && tokens[2].type === "<colon-token>") {
    var valueToken = tokens[3];
    if (valueToken.type === "<number-token>" || valueToken.type === "<dimension-token>" || valueToken.type === "<ratio-token>" || valueToken.type === "<ident-token>") {
      var feature = tokens[1].value, prefix = null, slice = feature.slice(0, 4);
      slice === "min-" ? (prefix = "min", feature = feature.slice(4)) : slice === "max-" && (prefix = "max", feature = feature.slice(4)), valueToken.wsBefore, valueToken.wsAfter;
      var value = __rest(valueToken, ["wsBefore", "wsAfter"]);
      return {
        context: "value",
        prefix,
        feature,
        value
      };
    }
  } else if (tokens.length >= 5)
    try {
      var range2 = tokenizeRange(tokens);
      return {
        context: "range",
        feature: range2.featureName,
        range: range2
      };
    } catch (err) {
      throw createError("Invalid media feature", err);
    }
  throw new Error("Invalid media feature");
}, tokenizeRange = function(tokens) {
  var _a2, _b, _c, _d;
  if (tokens.length < 5 || tokens[0].type !== "<(-token>" || tokens[tokens.length - 1].type !== "<)-token>")
    throw new Error("Invalid range");
  var range2 = {
    leftToken: null,
    leftOp: null,
    featureName: "",
    rightOp: null,
    rightToken: null
  }, hasLeft = tokens[1].type === "<number-token>" || tokens[1].type === "<dimension-token>" || tokens[1].type === "<ratio-token>" || tokens[1].type === "<ident-token>" && tokens[1].value === "infinite";
  if (tokens[2].type === "<delim-token>") {
    if (tokens[2].value === 60)
      tokens[3].type === "<delim-token>" && tokens[3].value === 61 && !tokens[3].wsBefore ? range2[hasLeft ? "leftOp" : "rightOp"] = "<=" : range2[hasLeft ? "leftOp" : "rightOp"] = "<";
    else if (tokens[2].value === 62)
      tokens[3].type === "<delim-token>" && tokens[3].value === 61 && !tokens[3].wsBefore ? range2[hasLeft ? "leftOp" : "rightOp"] = ">=" : range2[hasLeft ? "leftOp" : "rightOp"] = ">";
    else if (tokens[2].value === 61)
      range2[hasLeft ? "leftOp" : "rightOp"] = "=";
    else
      throw new Error("Invalid range");
    if (hasLeft)
      range2.leftToken = tokens[1];
    else if (tokens[1].type === "<ident-token>")
      range2.featureName = tokens[1].value;
    else
      throw new Error("Invalid range");
    var tokenIndexAfterFirstOp = 2 + ((_b = (_a2 = range2[hasLeft ? "leftOp" : "rightOp"]) === null || _a2 === void 0 ? void 0 : _a2.length) !== null && _b !== void 0 ? _b : 0), tokenAfterFirstOp = tokens[tokenIndexAfterFirstOp];
    if (hasLeft)
      if (tokenAfterFirstOp.type === "<ident-token>") {
        if (range2.featureName = tokenAfterFirstOp.value, tokens.length >= 7) {
          var secondOpToken = tokens[tokenIndexAfterFirstOp + 1], followingToken = tokens[tokenIndexAfterFirstOp + 2];
          if (secondOpToken.type === "<delim-token>") {
            var charCode = secondOpToken.value;
            if (charCode === 60)
              followingToken.type === "<delim-token>" && followingToken.value === 61 && !followingToken.wsBefore ? range2.rightOp = "<=" : range2.rightOp = "<";
            else if (charCode === 62)
              followingToken.type === "<delim-token>" && followingToken.value === 61 && !followingToken.wsBefore ? range2.rightOp = ">=" : range2.rightOp = ">";
            else
              throw new Error("Invalid range");
            var tokenAfterSecondOp = tokens[tokenIndexAfterFirstOp + 1 + ((_d = (_c = range2.rightOp) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0)];
            range2.rightToken = tokenAfterSecondOp;
          } else
            throw new Error("Invalid range");
        } else if (tokenIndexAfterFirstOp + 2 !== tokens.length)
          throw new Error("Invalid range");
      } else
        throw new Error("Invalid range");
    else
      range2.rightToken = tokenAfterFirstOp;
    var validRange = null, lt = range2.leftToken, leftOp = range2.leftOp, featureName = range2.featureName, rightOp = range2.rightOp, rt = range2.rightToken, leftToken = null;
    if (lt !== null) {
      if (lt.type === "<ident-token>") {
        var type = lt.type, value = lt.value;
        value === "infinite" && (leftToken = {
          type,
          value
        });
      } else if (lt.type === "<number-token>" || lt.type === "<dimension-token>" || lt.type === "<ratio-token>") {
        lt.wsBefore, lt.wsAfter;
        var ltNoWS = __rest(lt, ["wsBefore", "wsAfter"]);
        leftToken = ltNoWS;
      }
    }
    var rightToken = null;
    if (rt !== null) {
      if (rt.type === "<ident-token>") {
        var type = rt.type, value = rt.value;
        value === "infinite" && (rightToken = {
          type,
          value
        });
      } else if (rt.type === "<number-token>" || rt.type === "<dimension-token>" || rt.type === "<ratio-token>") {
        rt.wsBefore, rt.wsAfter;
        var rtNoWS = __rest(rt, ["wsBefore", "wsAfter"]);
        rightToken = rtNoWS;
      }
    }
    if (leftToken !== null && rightToken !== null)
      if ((leftOp === "<" || leftOp === "<=") && (rightOp === "<" || rightOp === "<="))
        validRange = {
          leftToken,
          leftOp,
          featureName,
          rightOp,
          rightToken
        };
      else if ((leftOp === ">" || leftOp === ">=") && (rightOp === ">" || rightOp === ">="))
        validRange = {
          leftToken,
          leftOp,
          featureName,
          rightOp,
          rightToken
        };
      else
        throw new Error("Invalid range");
    else leftToken === null && leftOp === null && rightOp !== null && rightToken !== null ? validRange = {
      leftToken,
      leftOp,
      featureName,
      rightOp,
      rightToken
    } : leftToken !== null && leftOp !== null && rightOp === null && rightToken === null && (validRange = {
      leftToken,
      leftOp,
      featureName,
      rightOp,
      rightToken
    });
    return validRange;
  } else
    throw new Error("Invalid range");
};
function toPrimitive(t2, r2) {
  if (typeof t2 != "object" || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (e2 !== void 0) {
    var i2 = e2.call(t2, r2);
    if (typeof i2 != "object") return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t2);
}
function toPropertyKey(t2) {
  var i2 = toPrimitive(t2, "string");
  return typeof i2 == "symbol" ? i2 : String(i2);
}
function _defineProperty(obj, key, value) {
  return key = toPropertyKey(key), key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function ownKeys(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread2(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = arguments[r2] != null ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t2), !0).forEach(function(r3) {
      _defineProperty(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {}, sourceKeys = Object.keys(source), key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++)
    key = sourceKeys[i2], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded), key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++)
      key = sourceSymbolKeys[i2], !(excluded.indexOf(key) >= 0) && Object.prototype.propertyIsEnumerable.call(source, key) && (target[key] = source[key]);
  }
  return target;
}
function forEach(obj, fn) {
  for (var _key in obj)
    fn(obj[_key], _key);
}
function omit(obj, omitKeys) {
  var result = {};
  for (var _key2 in obj)
    omitKeys.indexOf(_key2) === -1 && (result[_key2] = obj[_key2]);
  return result;
}
function mapKeys(obj, fn) {
  var result = {};
  for (var _key3 in obj)
    result[fn(obj[_key3], _key3)] = obj[_key3];
  return result;
}
var _templateObject$1;
function escapeRegex(string) {
  return string.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var validateSelector = (selector2, targetClassName) => {
  var replaceTarget = () => {
    var targetRegex = new RegExp(".".concat(escapeRegex(cssesc$1(targetClassName, {
      isIdentifier: !0
    }))), "g");
    return selector2.replace(targetRegex, "&");
  }, selectorParts;
  try {
    selectorParts = parse(selector2);
  } catch {
    throw new Error("Invalid selector: ".concat(replaceTarget()));
  }
  selectorParts.forEach((tokens) => {
    try {
      for (var i2 = tokens.length - 1; i2 >= -1; i2--) {
        if (!tokens[i2])
          throw new Error();
        var token = tokens[i2];
        if (token.type === "child" || token.type === "parent" || token.type === "sibling" || token.type === "adjacent" || token.type === "descendant")
          throw new Error();
        if (token.type === "attribute" && token.name === "class" && token.value === targetClassName)
          return;
      }
    } catch {
      throw new Error(dedent(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteral([`
        Invalid selector: `, `
    
        Style selectors must target the '&' character (along with any modifiers), e.g. `, " or ", `.
        
        This is to ensure that each style block only affects the styling of a single class.
        
        If your selector is targeting another class, you should move it to the style definition for that class, e.g. given we have styles for 'parent' and 'child' elements, instead of adding a selector of `, ") to 'parent', you should add ", ` to 'child').
        
        If your selector is targeting something global, use the 'globalStyle' function instead, e.g. if you wanted to write `, ", you should instead write 'globalStyle(", `, { ... })'
      `])), replaceTarget(), "`${parent} &`", "`${parent} &:hover`", "`& ${child}`", "`${parent} &`", "`& h1`", "`${parent} h1`"));
    }
  });
};
class ConditionalRuleset {
  /**
   * Stores information about where conditions must be in relation to other conditions
   *
   * e.g. mobile -> tablet, desktop
   */
  constructor() {
    this.ruleset = /* @__PURE__ */ new Map(), this.precedenceLookup = /* @__PURE__ */ new Map();
  }
  findOrCreateCondition(conditionQuery) {
    var targetCondition = this.ruleset.get(conditionQuery);
    return targetCondition || (targetCondition = {
      query: conditionQuery,
      rules: [],
      children: new ConditionalRuleset()
    }, this.ruleset.set(conditionQuery, targetCondition)), targetCondition;
  }
  getConditionalRulesetByPath(conditionPath) {
    var currRuleset = this;
    for (var query of conditionPath) {
      var condition = currRuleset.findOrCreateCondition(query);
      currRuleset = condition.children;
    }
    return currRuleset;
  }
  addRule(rule, conditionQuery, conditionPath) {
    var ruleset = this.getConditionalRulesetByPath(conditionPath), targetCondition = ruleset.findOrCreateCondition(conditionQuery);
    if (!targetCondition)
      throw new Error("Failed to add conditional rule");
    targetCondition.rules.push(rule);
  }
  addConditionPrecedence(conditionPath, conditionOrder) {
    for (var ruleset = this.getConditionalRulesetByPath(conditionPath), i2 = 0; i2 < conditionOrder.length; i2++) {
      var _ruleset$precedenceLo, query = conditionOrder[i2], conditionPrecedence = (_ruleset$precedenceLo = ruleset.precedenceLookup.get(query)) !== null && _ruleset$precedenceLo !== void 0 ? _ruleset$precedenceLo : /* @__PURE__ */ new Set();
      for (var lowerPrecedenceCondition of conditionOrder.slice(i2 + 1))
        conditionPrecedence.add(lowerPrecedenceCondition);
      ruleset.precedenceLookup.set(query, conditionPrecedence);
    }
  }
  isCompatible(incomingRuleset) {
    for (var [condition, orderPrecedence] of this.precedenceLookup.entries())
      for (var lowerPrecedenceCondition of orderPrecedence) {
        var _incomingRuleset$prec;
        if ((_incomingRuleset$prec = incomingRuleset.precedenceLookup.get(lowerPrecedenceCondition)) !== null && _incomingRuleset$prec !== void 0 && _incomingRuleset$prec.has(condition))
          return !1;
      }
    for (var {
      query,
      children
    } of incomingRuleset.ruleset.values()) {
      var matchingCondition = this.ruleset.get(query);
      if (matchingCondition && !matchingCondition.children.isCompatible(children))
        return !1;
    }
    return !0;
  }
  merge(incomingRuleset) {
    for (var {
      query,
      rules,
      children
    } of incomingRuleset.ruleset.values()) {
      var matchingCondition = this.ruleset.get(query);
      matchingCondition ? (matchingCondition.rules.push(...rules), matchingCondition.children.merge(children)) : this.ruleset.set(query, {
        query,
        rules,
        children
      });
    }
    for (var [condition, incomingOrderPrecedence] of incomingRuleset.precedenceLookup.entries()) {
      var _this$precedenceLooku, orderPrecedence = (_this$precedenceLooku = this.precedenceLookup.get(condition)) !== null && _this$precedenceLooku !== void 0 ? _this$precedenceLooku : /* @__PURE__ */ new Set();
      this.precedenceLookup.set(condition, /* @__PURE__ */ new Set([...orderPrecedence, ...incomingOrderPrecedence]));
    }
  }
  /**
   * Merge another ConditionalRuleset into this one if they are compatible
   *
   * @returns true if successful, false if the ruleset is incompatible
   */
  mergeIfCompatible(incomingRuleset) {
    return this.isCompatible(incomingRuleset) ? (this.merge(incomingRuleset), !0) : !1;
  }
  getSortedRuleset() {
    var _this = this, sortedRuleset = [], _loop = function(dependents2) {
      var conditionForQuery = _this.ruleset.get(query);
      if (!conditionForQuery)
        throw new Error("Can't find condition for ".concat(query));
      var firstMatchingDependent = sortedRuleset.findIndex((condition) => dependents2.has(condition.query));
      firstMatchingDependent > -1 ? sortedRuleset.splice(firstMatchingDependent, 0, conditionForQuery) : sortedRuleset.push(conditionForQuery);
    };
    for (var [query, dependents] of this.precedenceLookup.entries())
      _loop(dependents);
    return sortedRuleset;
  }
  renderToArray() {
    var arr = [];
    for (var {
      query,
      rules,
      children
    } of this.getSortedRuleset()) {
      var selectors = {};
      for (var rule of rules)
        selectors[rule.selector] = _objectSpread2(_objectSpread2({}, selectors[rule.selector]), rule.rule);
      Object.assign(selectors, ...children.renderToArray()), arr.push({
        [query]: selectors
      });
    }
    return arr;
  }
}
var simplePseudoMap = {
  ":-moz-any-link": !0,
  ":-moz-full-screen": !0,
  ":-moz-placeholder": !0,
  ":-moz-read-only": !0,
  ":-moz-read-write": !0,
  ":-ms-fullscreen": !0,
  ":-ms-input-placeholder": !0,
  ":-webkit-any-link": !0,
  ":-webkit-full-screen": !0,
  "::-moz-color-swatch": !0,
  "::-moz-list-bullet": !0,
  "::-moz-list-number": !0,
  "::-moz-page-sequence": !0,
  "::-moz-page": !0,
  "::-moz-placeholder": !0,
  "::-moz-progress-bar": !0,
  "::-moz-range-progress": !0,
  "::-moz-range-thumb": !0,
  "::-moz-range-track": !0,
  "::-moz-scrolled-page-sequence": !0,
  "::-moz-selection": !0,
  "::-ms-backdrop": !0,
  "::-ms-browse": !0,
  "::-ms-check": !0,
  "::-ms-clear": !0,
  "::-ms-fill-lower": !0,
  "::-ms-fill-upper": !0,
  "::-ms-fill": !0,
  "::-ms-reveal": !0,
  "::-ms-thumb": !0,
  "::-ms-ticks-after": !0,
  "::-ms-ticks-before": !0,
  "::-ms-tooltip": !0,
  "::-ms-track": !0,
  "::-ms-value": !0,
  "::-webkit-backdrop": !0,
  "::-webkit-calendar-picker-indicator": !0,
  "::-webkit-inner-spin-button": !0,
  "::-webkit-input-placeholder": !0,
  "::-webkit-meter-bar": !0,
  "::-webkit-meter-even-less-good-value": !0,
  "::-webkit-meter-inner-element": !0,
  "::-webkit-meter-optimum-value": !0,
  "::-webkit-meter-suboptimum-value": !0,
  "::-webkit-outer-spin-button": !0,
  "::-webkit-progress-bar": !0,
  "::-webkit-progress-inner-element": !0,
  "::-webkit-progress-inner-value": !0,
  "::-webkit-progress-value": !0,
  "::-webkit-resizer": !0,
  "::-webkit-scrollbar-button": !0,
  "::-webkit-scrollbar-corner": !0,
  "::-webkit-scrollbar-thumb": !0,
  "::-webkit-scrollbar-track-piece": !0,
  "::-webkit-scrollbar-track": !0,
  "::-webkit-scrollbar": !0,
  "::-webkit-search-cancel-button": !0,
  "::-webkit-search-results-button": !0,
  "::-webkit-slider-runnable-track": !0,
  "::-webkit-slider-thumb": !0,
  "::after": !0,
  "::backdrop": !0,
  "::before": !0,
  "::cue": !0,
  "::file-selector-button": !0,
  "::first-letter": !0,
  "::first-line": !0,
  "::grammar-error": !0,
  "::marker": !0,
  "::placeholder": !0,
  "::selection": !0,
  "::spelling-error": !0,
  "::target-text": !0,
  "::view-transition-group": !0,
  "::view-transition-image-pair": !0,
  "::view-transition-new": !0,
  "::view-transition-old": !0,
  "::view-transition": !0,
  ":active": !0,
  ":after": !0,
  ":any-link": !0,
  ":before": !0,
  ":blank": !0,
  ":checked": !0,
  ":default": !0,
  ":defined": !0,
  ":disabled": !0,
  ":empty": !0,
  ":enabled": !0,
  ":first-child": !0,
  ":first-letter": !0,
  ":first-line": !0,
  ":first-of-type": !0,
  ":first": !0,
  ":focus-visible": !0,
  ":focus-within": !0,
  ":focus": !0,
  ":fullscreen": !0,
  ":hover": !0,
  ":in-range": !0,
  ":indeterminate": !0,
  ":invalid": !0,
  ":last-child": !0,
  ":last-of-type": !0,
  ":left": !0,
  ":link": !0,
  ":only-child": !0,
  ":only-of-type": !0,
  ":optional": !0,
  ":out-of-range": !0,
  ":placeholder-shown": !0,
  ":read-only": !0,
  ":read-write": !0,
  ":required": !0,
  ":right": !0,
  ":root": !0,
  ":scope": !0,
  ":target": !0,
  ":valid": !0,
  ":visited": !0
}, simplePseudos = Object.keys(simplePseudoMap), simplePseudoLookup = simplePseudoMap, _templateObject, createMediaQueryError = (mediaQuery, msg) => new Error(dedent(_templateObject || (_templateObject = _taggedTemplateLiteral([`
    Invalid media query: "`, `"

    `, `

    Read more on MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries
  `])), mediaQuery, msg)), validateMediaQuery = (mediaQuery) => {
  if (mediaQuery === "@media ")
    throw createMediaQueryError(mediaQuery, "Query is empty");
  try {
    toAST(mediaQuery);
  } catch (e2) {
    throw createMediaQueryError(mediaQuery, e2.message);
  }
}, _excluded = ["vars"], _excluded2 = ["content"], DECLARATION = "__DECLARATION", UNITLESS = {
  animationIterationCount: !0,
  borderImage: !0,
  borderImageOutset: !0,
  borderImageSlice: !0,
  borderImageWidth: !0,
  boxFlex: !0,
  boxFlexGroup: !0,
  columnCount: !0,
  columns: !0,
  flex: !0,
  flexGrow: !0,
  flexShrink: !0,
  fontWeight: !0,
  gridArea: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnStart: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowStart: !0,
  initialLetter: !0,
  lineClamp: !0,
  lineHeight: !0,
  maxLines: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  scale: !0,
  tabSize: !0,
  WebkitLineClamp: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  // svg properties
  fillOpacity: !0,
  floodOpacity: !0,
  maskBorder: !0,
  maskBorderOutset: !0,
  maskBorderSlice: !0,
  maskBorderWidth: !0,
  shapeImageThreshold: !0,
  stopOpacity: !0,
  strokeDashoffset: !0,
  strokeMiterlimit: !0,
  strokeOpacity: !0,
  strokeWidth: !0
};
function dashify(str) {
  return str.replace(/([A-Z])/g, "-$1").replace(/^ms-/, "-ms-").toLowerCase();
}
function replaceBetweenIndexes(target, startIndex, endIndex, replacement) {
  var start = target.slice(0, startIndex), end = target.slice(endIndex);
  return "".concat(start).concat(replacement).concat(end);
}
var DOUBLE_SPACE = "  ", specialKeys = [...simplePseudos, "@layer", "@media", "@supports", "@container", "selectors"];
class Stylesheet {
  constructor(localClassNames2, composedClassLists2) {
    this.rules = [], this.conditionalRulesets = [new ConditionalRuleset()], this.fontFaceRules = [], this.keyframesRules = [], this.localClassNamesMap = new Map(localClassNames2.map((localClassName) => [localClassName, localClassName])), this.localClassNamesSearch = new AhoCorasick(localClassNames2), this.layers = /* @__PURE__ */ new Map(), this.composedClassLists = composedClassLists2.map((_ref) => {
      var {
        identifier,
        classList
      } = _ref;
      return {
        identifier,
        regex: RegExp("(".concat(classList, ")"), "g")
      };
    }).reverse();
  }
  processCssObj(root2) {
    if (root2.type === "fontFace") {
      this.fontFaceRules.push(root2.rule);
      return;
    }
    if (root2.type === "keyframes") {
      root2.rule = Object.fromEntries(Object.entries(root2.rule).map((_ref2) => {
        var [keyframe, rule] = _ref2;
        return [keyframe, this.transformProperties(rule)];
      })), this.keyframesRules.push(root2);
      return;
    }
    if (this.currConditionalRuleset = new ConditionalRuleset(), root2.type === "layer") {
      var layerDefinition = "@layer ".concat(root2.name);
      this.addLayer([layerDefinition]);
    } else {
      var mainRule = omit(root2.rule, specialKeys);
      this.addRule({
        selector: root2.selector,
        rule: mainRule
      }), this.transformLayer(root2, root2.rule["@layer"]), this.transformMedia(root2, root2.rule["@media"]), this.transformSupports(root2, root2.rule["@supports"]), this.transformContainer(root2, root2.rule["@container"]), this.transformSimplePseudos(root2, root2.rule), this.transformSelectors(root2, root2.rule);
    }
    var activeConditionalRuleset = this.conditionalRulesets[this.conditionalRulesets.length - 1];
    activeConditionalRuleset.mergeIfCompatible(this.currConditionalRuleset) || this.conditionalRulesets.push(this.currConditionalRuleset);
  }
  addConditionalRule(cssRule, conditions) {
    var rule = this.transformVars(this.transformProperties(cssRule.rule)), selector2 = this.transformSelector(cssRule.selector);
    if (!this.currConditionalRuleset)
      throw new Error("Couldn't add conditional rule");
    var conditionQuery = conditions[conditions.length - 1], parentConditions = conditions.slice(0, conditions.length - 1);
    this.currConditionalRuleset.addRule({
      selector: selector2,
      rule
    }, conditionQuery, parentConditions);
  }
  addRule(cssRule) {
    var rule = this.transformVars(this.transformProperties(cssRule.rule)), selector2 = this.transformSelector(cssRule.selector);
    this.rules.push({
      selector: selector2,
      rule
    });
  }
  addLayer(layer) {
    var uniqueLayerKey = layer.join(" - ");
    this.layers.set(uniqueLayerKey, layer);
  }
  transformProperties(cssRule) {
    return this.transformContent(this.pixelifyProperties(cssRule));
  }
  pixelifyProperties(cssRule) {
    return forEach(cssRule, (value, key) => {
      typeof value == "number" && value !== 0 && !UNITLESS[key] && (cssRule[key] = "".concat(value, "px"));
    }), cssRule;
  }
  transformVars(_ref3) {
    var {
      vars: vars2
    } = _ref3, rest = _objectWithoutProperties(_ref3, _excluded);
    return vars2 ? _objectSpread2(_objectSpread2({}, mapKeys(vars2, (_value, key) => getVarName(key))), rest) : rest;
  }
  transformContent(_ref4) {
    var {
      content: content2
    } = _ref4, rest = _objectWithoutProperties(_ref4, _excluded2);
    if (typeof content2 > "u")
      return rest;
    var contentArray = Array.isArray(content2) ? content2 : [content2];
    return _objectSpread2({
      content: contentArray.map((value) => (
        // This logic was adapted from Stitches :)
        value && (value.includes('"') || value.includes("'") || /^([A-Za-z\-]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)(\s|$)/.test(value)) ? value : '"'.concat(value, '"')
      ))
    }, rest);
  }
  transformClassname(identifier) {
    return ".".concat(cssesc$1(identifier, {
      isIdentifier: !0
    }));
  }
  transformSelector(selector2) {
    var transformedSelector = selector2, _loop = function(identifier2) {
      transformedSelector = transformedSelector.replace(regex, () => (markCompositionUsed(identifier2), identifier2));
    };
    for (var {
      identifier,
      regex
    } of this.composedClassLists)
      _loop(identifier);
    if (this.localClassNamesMap.has(transformedSelector))
      return this.transformClassname(transformedSelector);
    for (var results = this.localClassNamesSearch.search(transformedSelector), lastReplaceIndex = transformedSelector.length, i2 = results.length - 1; i2 >= 0; i2--) {
      var [endIndex, [firstMatch]] = results[i2], startIndex = endIndex - firstMatch.length + 1, skipReplacement = lastReplaceIndex <= endIndex;
      skipReplacement || (lastReplaceIndex = startIndex, transformedSelector[startIndex - 1] !== "." && (transformedSelector = replaceBetweenIndexes(transformedSelector, startIndex, endIndex + 1, this.transformClassname(firstMatch))));
    }
    return transformedSelector;
  }
  transformSelectors(root2, rule, conditions) {
    forEach(rule.selectors, (selectorRule, selector2) => {
      if (root2.type !== "local")
        throw new Error("Selectors are not allowed within ".concat(root2.type === "global" ? '"globalStyle"' : '"selectors"'));
      var transformedSelector = this.transformSelector(selector2.replace(RegExp("&", "g"), root2.selector));
      validateSelector(transformedSelector, root2.selector);
      var rule2 = {
        selector: transformedSelector,
        rule: omit(selectorRule, specialKeys)
      };
      conditions ? this.addConditionalRule(rule2, conditions) : this.addRule(rule2);
      var selectorRoot = {
        type: "selector",
        selector: transformedSelector,
        rule: selectorRule
      };
      this.transformLayer(selectorRoot, selectorRule["@layer"], conditions), this.transformSupports(selectorRoot, selectorRule["@supports"], conditions), this.transformMedia(selectorRoot, selectorRule["@media"], conditions);
    });
  }
  transformMedia(root2, rules) {
    var parentConditions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    if (rules) {
      var _this$currConditional;
      (_this$currConditional = this.currConditionalRuleset) === null || _this$currConditional === void 0 || _this$currConditional.addConditionPrecedence(parentConditions, Object.keys(rules).map((query2) => "@media ".concat(query2)));
      for (var [query, mediaRule] of Object.entries(rules)) {
        var mediaQuery = "@media ".concat(query);
        validateMediaQuery(mediaQuery);
        var conditions = [...parentConditions, mediaQuery];
        this.addConditionalRule({
          selector: root2.selector,
          rule: omit(mediaRule, specialKeys)
        }, conditions), root2.type === "local" && (this.transformSimplePseudos(root2, mediaRule, conditions), this.transformSelectors(root2, mediaRule, conditions)), this.transformLayer(root2, mediaRule["@layer"], conditions), this.transformSupports(root2, mediaRule["@supports"], conditions), this.transformContainer(root2, mediaRule["@container"], conditions);
      }
    }
  }
  transformContainer(root2, rules) {
    var parentConditions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    if (rules) {
      var _this$currConditional2;
      (_this$currConditional2 = this.currConditionalRuleset) === null || _this$currConditional2 === void 0 || _this$currConditional2.addConditionPrecedence(parentConditions, Object.keys(rules).map((query) => "@container ".concat(query))), forEach(rules, (containerRule, query) => {
        var containerQuery = "@container ".concat(query), conditions = [...parentConditions, containerQuery];
        this.addConditionalRule({
          selector: root2.selector,
          rule: omit(containerRule, specialKeys)
        }, conditions), root2.type === "local" && (this.transformSimplePseudos(root2, containerRule, conditions), this.transformSelectors(root2, containerRule, conditions)), this.transformLayer(root2, containerRule["@layer"], conditions), this.transformSupports(root2, containerRule["@supports"], conditions), this.transformMedia(root2, containerRule["@media"], conditions);
      });
    }
  }
  transformLayer(root2, rules) {
    var parentConditions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    if (rules) {
      var _this$currConditional3;
      (_this$currConditional3 = this.currConditionalRuleset) === null || _this$currConditional3 === void 0 || _this$currConditional3.addConditionPrecedence(parentConditions, Object.keys(rules).map((name) => "@layer ".concat(name))), forEach(rules, (layerRule, name) => {
        var conditions = [...parentConditions, "@layer ".concat(name)];
        this.addLayer(conditions), this.addConditionalRule({
          selector: root2.selector,
          rule: omit(layerRule, specialKeys)
        }, conditions), root2.type === "local" && (this.transformSimplePseudos(root2, layerRule, conditions), this.transformSelectors(root2, layerRule, conditions)), this.transformMedia(root2, layerRule["@media"], conditions), this.transformSupports(root2, layerRule["@supports"], conditions), this.transformContainer(root2, layerRule["@container"], conditions);
      });
    }
  }
  transformSupports(root2, rules) {
    var parentConditions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    if (rules) {
      var _this$currConditional4;
      (_this$currConditional4 = this.currConditionalRuleset) === null || _this$currConditional4 === void 0 || _this$currConditional4.addConditionPrecedence(parentConditions, Object.keys(rules).map((query) => "@supports ".concat(query))), forEach(rules, (supportsRule, query) => {
        var conditions = [...parentConditions, "@supports ".concat(query)];
        this.addConditionalRule({
          selector: root2.selector,
          rule: omit(supportsRule, specialKeys)
        }, conditions), root2.type === "local" && (this.transformSimplePseudos(root2, supportsRule, conditions), this.transformSelectors(root2, supportsRule, conditions)), this.transformLayer(root2, supportsRule["@layer"], conditions), this.transformMedia(root2, supportsRule["@media"], conditions), this.transformContainer(root2, supportsRule["@container"], conditions);
      });
    }
  }
  transformSimplePseudos(root2, rule, conditions) {
    for (var key of Object.keys(rule))
      if (simplePseudoLookup[key]) {
        if (root2.type !== "local")
          throw new Error("Simple pseudos are not valid in ".concat(root2.type === "global" ? '"globalStyle"' : '"selectors"'));
        conditions ? this.addConditionalRule({
          selector: "".concat(root2.selector).concat(key),
          rule: rule[key]
        }, conditions) : this.addRule({
          conditions,
          selector: "".concat(root2.selector).concat(key),
          rule: rule[key]
        });
      }
  }
  toCss() {
    var css = [];
    for (var fontFaceRule of this.fontFaceRules)
      css.push(renderCss({
        "@font-face": fontFaceRule
      }));
    for (var keyframe of this.keyframesRules)
      css.push(renderCss({
        ["@keyframes ".concat(keyframe.name)]: keyframe.rule
      }));
    for (var layer of this.layers.values()) {
      var [definition, ...nesting] = layer.reverse(), cssObj = {
        [definition]: DECLARATION
      };
      for (var part of nesting)
        cssObj = {
          [part]: cssObj
        };
      css.push(renderCss(cssObj));
    }
    for (var rule of this.rules)
      css.push(renderCss({
        [rule.selector]: rule.rule
      }));
    for (var conditionalRuleset of this.conditionalRulesets)
      for (var conditionalRule of conditionalRuleset.renderToArray())
        css.push(renderCss(conditionalRule));
    return css.filter(Boolean);
  }
}
function renderCss(v) {
  var indent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", rules = [], _loop2 = function(key2) {
    var value = v[key2];
    if (value && Array.isArray(value))
      rules.push(...value.map((v2) => renderCss({
        [key2]: v2
      }, indent)));
    else if (value && typeof value == "object") {
      var isEmpty = Object.keys(value).length === 0;
      isEmpty || rules.push("".concat(indent).concat(key2, ` {
`).concat(renderCss(value, indent + DOUBLE_SPACE), `
`).concat(indent, "}"));
    } else value === DECLARATION ? rules.push("".concat(indent).concat(key2, ";")) : rules.push("".concat(indent).concat(key2.startsWith("--") ? key2 : dashify(key2), ": ").concat(value, ";"));
  };
  for (var key of Object.keys(v))
    _loop2(key);
  return rules.join(`
`);
}
function transformCss(_ref5) {
  var {
    localClassNames: localClassNames2,
    cssObjs,
    composedClassLists: composedClassLists2
  } = _ref5, stylesheet = new Stylesheet(localClassNames2, composedClassLists2);
  for (var root2 of cssObjs)
    stylesheet.processCssObj(root2);
  return stylesheet.toCss();
}
const perf = typeof performance == "object" && performance && typeof performance.now == "function" ? performance : Date, warned = /* @__PURE__ */ new Set(), PROCESS = typeof process == "object" && process ? process : {}, emitWarning = (msg, type, code, fn) => {
  typeof PROCESS.emitWarning == "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
};
let AC = globalThis.AbortController, AS = globalThis.AbortSignal;
if (typeof AC > "u") {
  AS = class {
    onabort;
    _onabort = [];
    reason;
    aborted = !1;
    addEventListener(_, fn) {
      this._onabort.push(fn);
    }
  }, AC = class {
    constructor() {
      warnACPolyfill();
    }
    signal = new AS();
    abort(reason) {
      if (!this.signal.aborted) {
        this.signal.reason = reason, this.signal.aborted = !0;
        for (const fn of this.signal._onabort)
          fn(reason);
        this.signal.onabort?.(reason);
      }
    }
  };
  let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
  const warnACPolyfill = () => {
    printACPolyfillWarning && (printACPolyfillWarning = !1, emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill));
  };
}
const shouldWarn = (code) => !warned.has(code), isPosInt = (n2) => n2 && n2 === Math.floor(n2) && n2 > 0 && isFinite(n2), getUintArray = (max2) => isPosInt(max2) ? max2 <= Math.pow(2, 8) ? Uint8Array : max2 <= Math.pow(2, 16) ? Uint16Array : max2 <= Math.pow(2, 32) ? Uint32Array : max2 <= Number.MAX_SAFE_INTEGER ? ZeroArray : null : null;
class ZeroArray extends Array {
  constructor(size) {
    super(size), this.fill(0);
  }
}
class Stack {
  heap;
  length;
  // private constructor
  static #constructing = !1;
  static create(max2) {
    const HeapCls = getUintArray(max2);
    if (!HeapCls)
      return [];
    Stack.#constructing = !0;
    const s2 = new Stack(max2, HeapCls);
    return Stack.#constructing = !1, s2;
  }
  constructor(max2, HeapCls) {
    if (!Stack.#constructing)
      throw new TypeError("instantiate Stack using Stack.create(n)");
    this.heap = new HeapCls(max2), this.length = 0;
  }
  push(n2) {
    this.heap[this.length++] = n2;
  }
  pop() {
    return this.heap[--this.length];
  }
}
class LRUCache {
  // options that cannot be changed without disaster
  #max;
  #maxSize;
  #dispose;
  #disposeAfter;
  #fetchMethod;
  #memoMethod;
  /**
   * {@link LRUCache.OptionsBase.ttl}
   */
  ttl;
  /**
   * {@link LRUCache.OptionsBase.ttlResolution}
   */
  ttlResolution;
  /**
   * {@link LRUCache.OptionsBase.ttlAutopurge}
   */
  ttlAutopurge;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnGet}
   */
  updateAgeOnGet;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnHas}
   */
  updateAgeOnHas;
  /**
   * {@link LRUCache.OptionsBase.allowStale}
   */
  allowStale;
  /**
   * {@link LRUCache.OptionsBase.noDisposeOnSet}
   */
  noDisposeOnSet;
  /**
   * {@link LRUCache.OptionsBase.noUpdateTTL}
   */
  noUpdateTTL;
  /**
   * {@link LRUCache.OptionsBase.maxEntrySize}
   */
  maxEntrySize;
  /**
   * {@link LRUCache.OptionsBase.sizeCalculation}
   */
  sizeCalculation;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
   */
  noDeleteOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
   */
  noDeleteOnStaleGet;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
   */
  allowStaleOnFetchAbort;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
   */
  allowStaleOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.ignoreFetchAbort}
   */
  ignoreFetchAbort;
  // computed properties
  #size;
  #calculatedSize;
  #keyMap;
  #keyList;
  #valList;
  #next;
  #prev;
  #head;
  #tail;
  #free;
  #disposed;
  #sizes;
  #starts;
  #ttls;
  #hasDispose;
  #hasFetchMethod;
  #hasDisposeAfter;
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(c) {
    return {
      // properties
      starts: c.#starts,
      ttls: c.#ttls,
      sizes: c.#sizes,
      keyMap: c.#keyMap,
      keyList: c.#keyList,
      valList: c.#valList,
      next: c.#next,
      prev: c.#prev,
      get head() {
        return c.#head;
      },
      get tail() {
        return c.#tail;
      },
      free: c.#free,
      // methods
      isBackgroundFetch: (p2) => c.#isBackgroundFetch(p2),
      backgroundFetch: (k, index2, options, context) => c.#backgroundFetch(k, index2, options, context),
      moveToTail: (index2) => c.#moveToTail(index2),
      indexes: (options) => c.#indexes(options),
      rindexes: (options) => c.#rindexes(options),
      isStale: (index2) => c.#isStale(index2)
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return this.#max;
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return this.#maxSize;
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return this.#calculatedSize;
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return this.#size;
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return this.#fetchMethod;
  }
  get memoMethod() {
    return this.#memoMethod;
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return this.#dispose;
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return this.#disposeAfter;
  }
  constructor(options) {
    const { max: max2 = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
    if (max2 !== 0 && !isPosInt(max2))
      throw new TypeError("max option must be a nonnegative integer");
    const UintArray = max2 ? getUintArray(max2) : Array;
    if (!UintArray)
      throw new Error("invalid max value: " + max2);
    if (this.#max = max2, this.#maxSize = maxSize, this.maxEntrySize = maxEntrySize || this.#maxSize, this.sizeCalculation = sizeCalculation, this.sizeCalculation) {
      if (!this.#maxSize && !this.maxEntrySize)
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      if (typeof this.sizeCalculation != "function")
        throw new TypeError("sizeCalculation set to non-function");
    }
    if (memoMethod !== void 0 && typeof memoMethod != "function")
      throw new TypeError("memoMethod must be a function if defined");
    if (this.#memoMethod = memoMethod, fetchMethod !== void 0 && typeof fetchMethod != "function")
      throw new TypeError("fetchMethod must be a function if specified");
    if (this.#fetchMethod = fetchMethod, this.#hasFetchMethod = !!fetchMethod, this.#keyMap = /* @__PURE__ */ new Map(), this.#keyList = new Array(max2).fill(void 0), this.#valList = new Array(max2).fill(void 0), this.#next = new UintArray(max2), this.#prev = new UintArray(max2), this.#head = 0, this.#tail = 0, this.#free = Stack.create(max2), this.#size = 0, this.#calculatedSize = 0, typeof dispose == "function" && (this.#dispose = dispose), typeof disposeAfter == "function" ? (this.#disposeAfter = disposeAfter, this.#disposed = []) : (this.#disposeAfter = void 0, this.#disposed = void 0), this.#hasDispose = !!this.#dispose, this.#hasDisposeAfter = !!this.#disposeAfter, this.noDisposeOnSet = !!noDisposeOnSet, this.noUpdateTTL = !!noUpdateTTL, this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection, this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection, this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort, this.ignoreFetchAbort = !!ignoreFetchAbort, this.maxEntrySize !== 0) {
      if (this.#maxSize !== 0 && !isPosInt(this.#maxSize))
        throw new TypeError("maxSize must be a positive integer if specified");
      if (!isPosInt(this.maxEntrySize))
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      this.#initializeSizeTracking();
    }
    if (this.allowStale = !!allowStale, this.noDeleteOnStaleGet = !!noDeleteOnStaleGet, this.updateAgeOnGet = !!updateAgeOnGet, this.updateAgeOnHas = !!updateAgeOnHas, this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1, this.ttlAutopurge = !!ttlAutopurge, this.ttl = ttl || 0, this.ttl) {
      if (!isPosInt(this.ttl))
        throw new TypeError("ttl must be a positive integer if specified");
      this.#initializeTTLTracking();
    }
    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0)
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
      const code = "LRU_CACHE_UNBOUNDED";
      shouldWarn(code) && (warned.add(code), emitWarning("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", code, LRUCache));
    }
  }
  /**
   * Return the number of ms left in the item's TTL. If item is not in cache,
   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
   */
  getRemainingTTL(key) {
    return this.#keyMap.has(key) ? 1 / 0 : 0;
  }
  #initializeTTLTracking() {
    const ttls = new ZeroArray(this.#max), starts = new ZeroArray(this.#max);
    this.#ttls = ttls, this.#starts = starts, this.#setItemTTL = (index2, ttl, start = perf.now()) => {
      if (starts[index2] = ttl !== 0 ? start : 0, ttls[index2] = ttl, ttl !== 0 && this.ttlAutopurge) {
        const t2 = setTimeout(() => {
          this.#isStale(index2) && this.#delete(this.#keyList[index2], "expire");
        }, ttl + 1);
        t2.unref && t2.unref();
      }
    }, this.#updateItemAge = (index2) => {
      starts[index2] = ttls[index2] !== 0 ? perf.now() : 0;
    }, this.#statusTTL = (status, index2) => {
      if (ttls[index2]) {
        const ttl = ttls[index2], start = starts[index2];
        if (!ttl || !start)
          return;
        status.ttl = ttl, status.start = start, status.now = cachedNow || getNow();
        const age = status.now - start;
        status.remainingTTL = ttl - age;
      }
    };
    let cachedNow = 0;
    const getNow = () => {
      const n2 = perf.now();
      if (this.ttlResolution > 0) {
        cachedNow = n2;
        const t2 = setTimeout(() => cachedNow = 0, this.ttlResolution);
        t2.unref && t2.unref();
      }
      return n2;
    };
    this.getRemainingTTL = (key) => {
      const index2 = this.#keyMap.get(key);
      if (index2 === void 0)
        return 0;
      const ttl = ttls[index2], start = starts[index2];
      if (!ttl || !start)
        return 1 / 0;
      const age = (cachedNow || getNow()) - start;
      return ttl - age;
    }, this.#isStale = (index2) => {
      const s2 = starts[index2], t2 = ttls[index2];
      return !!t2 && !!s2 && (cachedNow || getNow()) - s2 > t2;
    };
  }
  // conditionally set private methods related to TTL
  #updateItemAge = () => {
  };
  #statusTTL = () => {
  };
  #setItemTTL = () => {
  };
  /* c8 ignore stop */
  #isStale = () => !1;
  #initializeSizeTracking() {
    const sizes = new ZeroArray(this.#max);
    this.#calculatedSize = 0, this.#sizes = sizes, this.#removeItemSize = (index2) => {
      this.#calculatedSize -= sizes[index2], sizes[index2] = 0;
    }, this.#requireSize = (k, v, size, sizeCalculation) => {
      if (this.#isBackgroundFetch(v))
        return 0;
      if (!isPosInt(size))
        if (sizeCalculation) {
          if (typeof sizeCalculation != "function")
            throw new TypeError("sizeCalculation must be a function");
          if (size = sizeCalculation(v, k), !isPosInt(size))
            throw new TypeError("sizeCalculation return invalid (expect positive integer)");
        } else
          throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
      return size;
    }, this.#addItemSize = (index2, size, status) => {
      if (sizes[index2] = size, this.#maxSize) {
        const maxSize = this.#maxSize - sizes[index2];
        for (; this.#calculatedSize > maxSize; )
          this.#evict(!0);
      }
      this.#calculatedSize += sizes[index2], status && (status.entrySize = size, status.totalCalculatedSize = this.#calculatedSize);
    };
  }
  #removeItemSize = (_i) => {
  };
  #addItemSize = (_i, _s, _st) => {
  };
  #requireSize = (_k, _v, size, sizeCalculation) => {
    if (size || sizeCalculation)
      throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
    return 0;
  };
  *#indexes({ allowStale = this.allowStale } = {}) {
    if (this.#size)
      for (let i2 = this.#tail; !(!this.#isValidIndex(i2) || ((allowStale || !this.#isStale(i2)) && (yield i2), i2 === this.#head)); )
        i2 = this.#prev[i2];
  }
  *#rindexes({ allowStale = this.allowStale } = {}) {
    if (this.#size)
      for (let i2 = this.#head; !(!this.#isValidIndex(i2) || ((allowStale || !this.#isStale(i2)) && (yield i2), i2 === this.#tail)); )
        i2 = this.#next[i2];
  }
  #isValidIndex(index2) {
    return index2 !== void 0 && this.#keyMap.get(this.#keyList[index2]) === index2;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const i2 of this.#indexes())
      this.#valList[i2] !== void 0 && this.#keyList[i2] !== void 0 && !this.#isBackgroundFetch(this.#valList[i2]) && (yield [this.#keyList[i2], this.#valList[i2]]);
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const i2 of this.#rindexes())
      this.#valList[i2] !== void 0 && this.#keyList[i2] !== void 0 && !this.#isBackgroundFetch(this.#valList[i2]) && (yield [this.#keyList[i2], this.#valList[i2]]);
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const i2 of this.#indexes()) {
      const k = this.#keyList[i2];
      k !== void 0 && !this.#isBackgroundFetch(this.#valList[i2]) && (yield k);
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const i2 of this.#rindexes()) {
      const k = this.#keyList[i2];
      k !== void 0 && !this.#isBackgroundFetch(this.#valList[i2]) && (yield k);
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const i2 of this.#indexes())
      this.#valList[i2] !== void 0 && !this.#isBackgroundFetch(this.#valList[i2]) && (yield this.#valList[i2]);
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const i2 of this.#rindexes())
      this.#valList[i2] !== void 0 && !this.#isBackgroundFetch(this.#valList[i2]) && (yield this.#valList[i2]);
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * A String value that is used in the creation of the default string
   * description of an object. Called by the built-in method
   * `Object.prototype.toString`.
   */
  [Symbol.toStringTag] = "LRUCache";
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
   */
  find(fn, getOptions = {}) {
    for (const i2 of this.#indexes()) {
      const v = this.#valList[i2], value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value !== void 0 && fn(value, this.#keyList[i2], this))
        return this.get(this.#keyList[i2], getOptions);
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from most
   * recently used to least recently used.
   *
   * `fn` is called as `fn(value, key, cache)`.
   *
   * If `thisp` is provided, function will be called in the `this`-context of
   * the provided object, or the cache if no `thisp` object is provided.
   *
   * Does not update age or recenty of use, or iterate over stale values.
   */
  forEach(fn, thisp = this) {
    for (const i2 of this.#indexes()) {
      const v = this.#valList[i2], value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      value !== void 0 && fn.call(thisp, value, this.#keyList[i2], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(fn, thisp = this) {
    for (const i2 of this.#rindexes()) {
      const v = this.#valList[i2], value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      value !== void 0 && fn.call(thisp, value, this.#keyList[i2], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let deleted = !1;
    for (const i2 of this.#rindexes({ allowStale: !0 }))
      this.#isStale(i2) && (this.#delete(this.#keyList[i2], "expire"), deleted = !0);
    return deleted;
  }
  /**
   * Get the extended info about a given entry, to get its value, size, and
   * TTL info simultaneously. Returns `undefined` if the key is not present.
   *
   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
   * serialization, the `start` value is always the current timestamp, and the
   * `ttl` is a calculated remaining time to live (negative if expired).
   *
   * Always returns stale values, if their info is found in the cache, so be
   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
   * if relevant.
   */
  info(key) {
    const i2 = this.#keyMap.get(key);
    if (i2 === void 0)
      return;
    const v = this.#valList[i2], value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    if (value === void 0)
      return;
    const entry = { value };
    if (this.#ttls && this.#starts) {
      const ttl = this.#ttls[i2], start = this.#starts[i2];
      if (ttl && start) {
        const remain = ttl - (perf.now() - start);
        entry.ttl = remain, entry.start = Date.now();
      }
    }
    return this.#sizes && (entry.size = this.#sizes[i2]), entry;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to {@link LRLUCache#load}.
   *
   * The `start` fields are calculated relative to a portable `Date.now()`
   * timestamp, even if `performance.now()` is available.
   *
   * Stale entries are always included in the `dump`, even if
   * {@link LRUCache.OptionsBase.allowStale} is false.
   *
   * Note: this returns an actual array, not a generator, so it can be more
   * easily passed around.
   */
  dump() {
    const arr = [];
    for (const i2 of this.#indexes({ allowStale: !0 })) {
      const key = this.#keyList[i2], v = this.#valList[i2], value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0 || key === void 0)
        continue;
      const entry = { value };
      if (this.#ttls && this.#starts) {
        entry.ttl = this.#ttls[i2];
        const age = perf.now() - this.#starts[i2];
        entry.start = Math.floor(Date.now() - age);
      }
      this.#sizes && (entry.size = this.#sizes[i2]), arr.unshift([key, entry]);
    }
    return arr;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   *
   * The shape of the resulting cache may be different if the same options are
   * not used in both caches.
   *
   * The `start` fields are assumed to be calculated relative to a portable
   * `Date.now()` timestamp, even if `performance.now()` is available.
   */
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  /**
   * Add a value to the cache.
   *
   * Note: if `undefined` is specified as a value, this is an alias for
   * {@link LRUCache#delete}
   *
   * Fields on the {@link LRUCache.SetOptions} options param will override
   * their corresponding values in the constructor options for the scope
   * of this single `set()` operation.
   *
   * If `start` is provided, then that will set the effective start
   * time for the TTL calculation. Note that this must be a previous
   * value of `performance.now()` if supported, or a previous value of
   * `Date.now()` if not.
   *
   * Options object may also include `size`, which will prevent
   * calling the `sizeCalculation` function and just use the specified
   * number if it is a positive integer, and `noDisposeOnSet` which
   * will prevent calling a `dispose` function in the case of
   * overwrites.
   *
   * If the `size` (or return value of `sizeCalculation`) for a given
   * entry is greater than `maxEntrySize`, then the item will not be
   * added to the cache.
   *
   * Will update the recency of the entry.
   *
   * If the value is `undefined`, then this is an alias for
   * `cache.delete(key)`. `undefined` is never stored in the cache.
   */
  set(k, v, setOptions = {}) {
    if (v === void 0)
      return this.delete(k), this;
    const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size > this.maxEntrySize)
      return status && (status.set = "miss", status.maxEntrySizeExceeded = !0), this.#delete(k, "set"), this;
    let index2 = this.#size === 0 ? void 0 : this.#keyMap.get(k);
    if (index2 === void 0)
      index2 = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(!1) : this.#size, this.#keyList[index2] = k, this.#valList[index2] = v, this.#keyMap.set(k, index2), this.#next[this.#tail] = index2, this.#prev[index2] = this.#tail, this.#tail = index2, this.#size++, this.#addItemSize(index2, size, status), status && (status.set = "add"), noUpdateTTL = !1;
    else {
      this.#moveToTail(index2);
      const oldVal = this.#valList[index2];
      if (v !== oldVal) {
        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: s2 } = oldVal;
          s2 !== void 0 && !noDisposeOnSet && (this.#hasDispose && this.#dispose?.(s2, k, "set"), this.#hasDisposeAfter && this.#disposed?.push([s2, k, "set"]));
        } else noDisposeOnSet || (this.#hasDispose && this.#dispose?.(oldVal, k, "set"), this.#hasDisposeAfter && this.#disposed?.push([oldVal, k, "set"]));
        if (this.#removeItemSize(index2), this.#addItemSize(index2, size, status), this.#valList[index2] = v, status) {
          status.set = "replace";
          const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
          oldValue !== void 0 && (status.oldValue = oldValue);
        }
      } else status && (status.set = "update");
    }
    if (ttl !== 0 && !this.#ttls && this.#initializeTTLTracking(), this.#ttls && (noUpdateTTL || this.#setItemTTL(index2, ttl, start), status && this.#statusTTL(status, index2)), !noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      for (; task = dt?.shift(); )
        this.#disposeAfter?.(...task);
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    try {
      for (; this.#size; ) {
        const val = this.#valList[this.#head];
        if (this.#evict(!0), this.#isBackgroundFetch(val)) {
          if (val.__staleWhileFetching)
            return val.__staleWhileFetching;
        } else if (val !== void 0)
          return val;
      }
    } finally {
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        for (; task = dt?.shift(); )
          this.#disposeAfter?.(...task);
      }
    }
  }
  #evict(free) {
    const head = this.#head, k = this.#keyList[head], v = this.#valList[head];
    return this.#hasFetchMethod && this.#isBackgroundFetch(v) ? v.__abortController.abort(new Error("evicted")) : (this.#hasDispose || this.#hasDisposeAfter) && (this.#hasDispose && this.#dispose?.(v, k, "evict"), this.#hasDisposeAfter && this.#disposed?.push([v, k, "evict"])), this.#removeItemSize(head), free && (this.#keyList[head] = void 0, this.#valList[head] = void 0, this.#free.push(head)), this.#size === 1 ? (this.#head = this.#tail = 0, this.#free.length = 0) : this.#head = this.#next[head], this.#keyMap.delete(k), this.#size--, head;
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Check if a key is in the cache, without updating the recency of
   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
   * to `true` in either the options or the constructor.
   *
   * Will return `false` if the item is stale, even though it is technically in
   * the cache. The difference can be determined (if it matters) by using a
   * `status` argument, and inspecting the `has` field.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(k, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions, index2 = this.#keyMap.get(k);
    if (index2 !== void 0) {
      const v = this.#valList[index2];
      if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === void 0)
        return !1;
      if (this.#isStale(index2))
        status && (status.has = "stale", this.#statusTTL(status, index2));
      else return updateAgeOnHas && this.#updateItemAge(index2), status && (status.has = "hit", this.#statusTTL(status, index2)), !0;
    } else status && (status.has = "miss");
    return !1;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(k, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions, index2 = this.#keyMap.get(k);
    if (index2 === void 0 || !allowStale && this.#isStale(index2))
      return;
    const v = this.#valList[index2];
    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
  }
  #backgroundFetch(k, index2, options, context) {
    const v = index2 === void 0 ? void 0 : this.#valList[index2];
    if (this.#isBackgroundFetch(v))
      return v;
    const ac = new AC(), { signal } = options;
    signal?.addEventListener("abort", () => ac.abort(signal.reason), {
      signal: ac.signal
    });
    const fetchOpts = {
      signal: ac.signal,
      options,
      context
    }, cb = (v2, updateCache = !1) => {
      const { aborted } = ac.signal, ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
      if (options.status && (aborted && !updateCache ? (options.status.fetchAborted = !0, options.status.fetchError = ac.signal.reason, ignoreAbort && (options.status.fetchAbortIgnored = !0)) : options.status.fetchResolved = !0), aborted && !ignoreAbort && !updateCache)
        return fetchFail(ac.signal.reason);
      const bf2 = p2;
      return this.#valList[index2] === p2 && (v2 === void 0 ? bf2.__staleWhileFetching ? this.#valList[index2] = bf2.__staleWhileFetching : this.#delete(k, "fetch") : (options.status && (options.status.fetchUpdated = !0), this.set(k, v2, fetchOpts.options))), v2;
    }, eb = (er) => (options.status && (options.status.fetchRejected = !0, options.status.fetchError = er), fetchFail(er)), fetchFail = (er) => {
      const { aborted } = ac.signal, allowStaleAborted = aborted && options.allowStaleOnFetchAbort, allowStale = allowStaleAborted || options.allowStaleOnFetchRejection, noDelete = allowStale || options.noDeleteOnFetchRejection, bf2 = p2;
      if (this.#valList[index2] === p2 && (!noDelete || bf2.__staleWhileFetching === void 0 ? this.#delete(k, "fetch") : allowStaleAborted || (this.#valList[index2] = bf2.__staleWhileFetching)), allowStale)
        return options.status && bf2.__staleWhileFetching !== void 0 && (options.status.returnedStale = !0), bf2.__staleWhileFetching;
      if (bf2.__returned === bf2)
        throw er;
    }, pcall = (res, rej) => {
      const fmp = this.#fetchMethod?.(k, v, fetchOpts);
      fmp && fmp instanceof Promise && fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej), ac.signal.addEventListener("abort", () => {
        (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) && (res(void 0), options.allowStaleOnFetchAbort && (res = (v2) => cb(v2, !0)));
      });
    };
    options.status && (options.status.fetchDispatched = !0);
    const p2 = new Promise(pcall).then(cb, eb), bf = Object.assign(p2, {
      __abortController: ac,
      __staleWhileFetching: v,
      __returned: void 0
    });
    return index2 === void 0 ? (this.set(k, bf, { ...fetchOpts.options, status: void 0 }), index2 = this.#keyMap.get(k)) : this.#valList[index2] = bf, bf;
  }
  #isBackgroundFetch(p2) {
    if (!this.#hasFetchMethod)
      return !1;
    const b2 = p2;
    return !!b2 && b2 instanceof Promise && b2.hasOwnProperty("__staleWhileFetching") && b2.__abortController instanceof AC;
  }
  async fetch(k, fetchOptions = {}) {
    const {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = !1,
      status,
      signal
    } = fetchOptions;
    if (!this.#hasFetchMethod)
      return status && (status.fetch = "get"), this.get(k, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index2 = this.#keyMap.get(k);
    if (index2 === void 0) {
      status && (status.fetch = "miss");
      const p2 = this.#backgroundFetch(k, index2, options, context);
      return p2.__returned = p2;
    } else {
      const v = this.#valList[index2];
      if (this.#isBackgroundFetch(v)) {
        const stale = allowStale && v.__staleWhileFetching !== void 0;
        return status && (status.fetch = "inflight", stale && (status.returnedStale = !0)), stale ? v.__staleWhileFetching : v.__returned = v;
      }
      const isStale = this.#isStale(index2);
      if (!forceRefresh && !isStale)
        return status && (status.fetch = "hit"), this.#moveToTail(index2), updateAgeOnGet && this.#updateItemAge(index2), status && this.#statusTTL(status, index2), v;
      const p2 = this.#backgroundFetch(k, index2, options, context), staleVal = p2.__staleWhileFetching !== void 0 && allowStale;
      return status && (status.fetch = isStale ? "stale" : "refresh", staleVal && isStale && (status.returnedStale = !0)), staleVal ? p2.__staleWhileFetching : p2.__returned = p2;
    }
  }
  async forceFetch(k, fetchOptions = {}) {
    const v = await this.fetch(k, fetchOptions);
    if (v === void 0)
      throw new Error("fetch() returned undefined");
    return v;
  }
  memo(k, memoOptions = {}) {
    const memoMethod = this.#memoMethod;
    if (!memoMethod)
      throw new Error("no memoMethod provided to constructor");
    const { context, forceRefresh, ...options } = memoOptions, v = this.get(k, options);
    if (!forceRefresh && v !== void 0)
      return v;
    const vv = memoMethod(k, v, {
      options,
      context
    });
    return this.set(k, vv, options), vv;
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(k, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions, index2 = this.#keyMap.get(k);
    if (index2 !== void 0) {
      const value = this.#valList[index2], fetching = this.#isBackgroundFetch(value);
      return status && this.#statusTTL(status, index2), this.#isStale(index2) ? (status && (status.get = "stale"), fetching ? (status && allowStale && value.__staleWhileFetching !== void 0 && (status.returnedStale = !0), allowStale ? value.__staleWhileFetching : void 0) : (noDeleteOnStaleGet || this.#delete(k, "expire"), status && allowStale && (status.returnedStale = !0), allowStale ? value : void 0)) : (status && (status.get = "hit"), fetching ? value.__staleWhileFetching : (this.#moveToTail(index2), updateAgeOnGet && this.#updateItemAge(index2), value));
    } else status && (status.get = "miss");
  }
  #connect(p2, n2) {
    this.#prev[n2] = p2, this.#next[p2] = n2;
  }
  #moveToTail(index2) {
    index2 !== this.#tail && (index2 === this.#head ? this.#head = this.#next[index2] : this.#connect(this.#prev[index2], this.#next[index2]), this.#connect(this.#tail, index2), this.#tail = index2);
  }
  /**
   * Deletes a key out of the cache.
   *
   * Returns true if the key was deleted, false otherwise.
   */
  delete(k) {
    return this.#delete(k, "delete");
  }
  #delete(k, reason) {
    let deleted = !1;
    if (this.#size !== 0) {
      const index2 = this.#keyMap.get(k);
      if (index2 !== void 0)
        if (deleted = !0, this.#size === 1)
          this.#clear(reason);
        else {
          this.#removeItemSize(index2);
          const v = this.#valList[index2];
          if (this.#isBackgroundFetch(v) ? v.__abortController.abort(new Error("deleted")) : (this.#hasDispose || this.#hasDisposeAfter) && (this.#hasDispose && this.#dispose?.(v, k, reason), this.#hasDisposeAfter && this.#disposed?.push([v, k, reason])), this.#keyMap.delete(k), this.#keyList[index2] = void 0, this.#valList[index2] = void 0, index2 === this.#tail)
            this.#tail = this.#prev[index2];
          else if (index2 === this.#head)
            this.#head = this.#next[index2];
          else {
            const pi2 = this.#prev[index2];
            this.#next[pi2] = this.#next[index2];
            const ni = this.#next[index2];
            this.#prev[ni] = this.#prev[index2];
          }
          this.#size--, this.#free.push(index2);
        }
    }
    if (this.#hasDisposeAfter && this.#disposed?.length) {
      const dt = this.#disposed;
      let task;
      for (; task = dt?.shift(); )
        this.#disposeAfter?.(...task);
    }
    return deleted;
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    return this.#clear("delete");
  }
  #clear(reason) {
    for (const index2 of this.#rindexes({ allowStale: !0 })) {
      const v = this.#valList[index2];
      if (this.#isBackgroundFetch(v))
        v.__abortController.abort(new Error("deleted"));
      else {
        const k = this.#keyList[index2];
        this.#hasDispose && this.#dispose?.(v, k, reason), this.#hasDisposeAfter && this.#disposed?.push([v, k, reason]);
      }
    }
    if (this.#keyMap.clear(), this.#valList.fill(void 0), this.#keyList.fill(void 0), this.#ttls && this.#starts && (this.#ttls.fill(0), this.#starts.fill(0)), this.#sizes && this.#sizes.fill(0), this.#head = 0, this.#tail = 0, this.#free.length = 0, this.#calculatedSize = 0, this.#size = 0, this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      for (; task = dt?.shift(); )
        this.#disposeAfter?.(...task);
    }
  }
}
var isMergeableObject = function(value) {
  return isNonNullObject(value) && !isSpecial(value);
};
function isNonNullObject(value) {
  return !!value && typeof value == "object";
}
function isSpecial(value) {
  var stringValue = Object.prototype.toString.call(value);
  return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
}
var canUseSymbol = typeof Symbol == "function" && Symbol.for, REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
function isReactElement(value) {
  return value.$$typeof === REACT_ELEMENT_TYPE;
}
function emptyTarget(val) {
  return Array.isArray(val) ? [] : {};
}
function cloneUnlessOtherwiseSpecified(value, options) {
  return options.clone !== !1 && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
}
function defaultArrayMerge(target, source, options) {
  return target.concat(source).map(function(element) {
    return cloneUnlessOtherwiseSpecified(element, options);
  });
}
function getMergeFunction(key, options) {
  if (!options.customMerge)
    return deepmerge;
  var customMerge = options.customMerge(key);
  return typeof customMerge == "function" ? customMerge : deepmerge;
}
function getEnumerableOwnPropertySymbols(target) {
  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
    return Object.propertyIsEnumerable.call(target, symbol);
  }) : [];
}
function getKeys(target) {
  return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
}
function propertyIsOnObject(object2, property) {
  try {
    return property in object2;
  } catch {
    return !1;
  }
}
function propertyIsUnsafe(target, key) {
  return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
}
function mergeObject(target, source, options) {
  var destination = {};
  return options.isMergeableObject(target) && getKeys(target).forEach(function(key) {
    destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
  }), getKeys(source).forEach(function(key) {
    propertyIsUnsafe(target, key) || (propertyIsOnObject(target, key) && options.isMergeableObject(source[key]) ? destination[key] = getMergeFunction(key, options)(target[key], source[key], options) : destination[key] = cloneUnlessOtherwiseSpecified(source[key], options));
  }), destination;
}
function deepmerge(target, source, options) {
  options = options || {}, options.arrayMerge = options.arrayMerge || defaultArrayMerge, options.isMergeableObject = options.isMergeableObject || isMergeableObject, options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
  var sourceIsArray = Array.isArray(source), targetIsArray = Array.isArray(target), sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
  return sourceAndTargetTypesMatch ? sourceIsArray ? options.arrayMerge(target, source, options) : mergeObject(target, source, options) : cloneUnlessOtherwiseSpecified(source, options);
}
deepmerge.all = function(array2, options) {
  if (!Array.isArray(array2))
    throw new Error("first argument should be an array");
  return array2.reduce(function(prev, next) {
    return deepmerge(prev, next, options);
  }, {});
};
var localClassNames = /* @__PURE__ */ new Set(), composedClassLists = [], bufferedCSSObjs = [], browserRuntimeAdapter = {
  appendCss: (cssObj) => {
    bufferedCSSObjs.push(cssObj);
  },
  registerClassName: (className) => {
    localClassNames.add(className);
  },
  registerComposition: (composition) => {
    composedClassLists.push(composition);
  },
  markCompositionUsed: () => {
  },
  onEndFileScope: (fileScope) => {
    var css = transformCss({
      localClassNames: Array.from(localClassNames),
      composedClassLists,
      cssObjs: bufferedCSSObjs
    }).join(`
`);
    injectStyles({
      fileScope,
      css
    }), bufferedCSSObjs = [];
  },
  getIdentOption: () => "short"
};
setAdapterIfNotSet(browserRuntimeAdapter);
var getLastSlashBeforeIndex = (path, index2) => {
  for (var pathIndex = index2 - 1; pathIndex >= 0; ) {
    if (path[pathIndex] === "/")
      return pathIndex;
    pathIndex--;
  }
  return -1;
}, _getDebugFileName = (path) => {
  var file, lastIndexOfDotCss = path.lastIndexOf(".css");
  if (lastIndexOfDotCss === -1)
    return "";
  var lastSlashIndex = getLastSlashBeforeIndex(path, lastIndexOfDotCss);
  if (file = path.slice(lastSlashIndex + 1, lastIndexOfDotCss), lastSlashIndex === -1)
    return file;
  var secondLastSlashIndex = getLastSlashBeforeIndex(path, lastSlashIndex - 1), dir = path.slice(secondLastSlashIndex + 1, lastSlashIndex), debugFileName = file !== "index" ? file : dir;
  return debugFileName;
}, memoizedGetDebugFileName = () => {
  var cache = new LRUCache({
    max: 500
  });
  return (path) => {
    var cachedResult = cache.get(path);
    if (cachedResult)
      return cachedResult;
    var result = _getDebugFileName(path);
    return cache.set(path, result), result;
  };
};
memoizedGetDebugFileName();
function createGlobalThemeContract(tokens, mapFn) {
  return walkObject(tokens, (value, path) => {
    var rawVarName = typeof mapFn == "function" ? mapFn(value, path) : value, varName = typeof rawVarName == "string" ? rawVarName.replace(/^\-\-/, "") : null;
    if (typeof varName != "string" || varName !== cssesc$1(varName, {
      isIdentifier: !0
    }))
      throw new Error('Invalid variable name for "'.concat(path.join("."), '": ').concat(varName));
    return "var(--".concat(varName, ")");
  });
}
const vars = createGlobalThemeContract({
  safariAnimationHook: "safari-animation-hook",
  default: {
    font: "default-font-family"
  },
  likec4: {
    font: "font-family",
    background: {
      color: "background-color",
      pattern: {
        color: "background-pattern-color"
      }
    }
  },
  compound: {
    font: "compound-font-family",
    titleColor: "compound-title-color"
  },
  element: {
    font: "element-font-family",
    fill: "element-fill",
    stroke: "element-stroke",
    hiContrast: "element-hiContrast",
    loContrast: "element-loContrast"
  },
  relation: {
    lineColor: "relation-lineColor",
    labelColor: "relation-labelColor",
    labelBgColor: "relation-labelBg"
  },
  optionsPanel: {
    top: "options-webview-top",
    right: "options-webview-right"
  },
  navigationPanel: {
    top: "navigation-webview-top",
    left: "navigation-webview-left"
  }
}, (value) => `likec4-${value}`);
createGlobalThemeContract({
  background: {
    color: "background-color",
    pattern: {
      color: "background-pattern-color"
      // dots: 'background-pattern-dots-color',
      // lines: 'background-pattern-lines-color',
      // cross: 'background-pattern-cross-color'
    }
  },
  edge: {
    stroke: "edge-stroke",
    strokeSelected: "edge-stroke-selected",
    labelColor: "edge-label-color",
    labelBgColor: "edge-label-background-color",
    strokeWidth: "edge-stroke-width"
  },
  node: {
    color: "node-color",
    border: "node-border",
    backgroundColor: "node-background-color",
    groupBackgroundColor: "node-group-background-color",
    boxshadowHover: "node-boxshadow-hover",
    boxshadowSelected: "node-boxshadow-selected",
    borderRadius: "node-border-radius"
  }
}, (value) => `xy-${value}`);
const mantine = themeToVars({});
function toStyle(name, colorValues) {
  const rules = [
    ...t$2(colorValues.elements).map(([key, value]) => `${stripCssVarReference(vars.element[key])}: ${value};`),
    ...t$2(colorValues.relationships).map(([key, value]) => `${stripCssVarReference(vars.relation[key])}: ${value};`)
  ].join(`
`);
  return `:where([data-likec4-color=${name}]) {
  ${rules}
}`;
}
function stripCssVarReference(ref) {
  const end = ref.indexOf(",");
  return ref.substring(4, end == -1 ? ref.length - 1 : end);
}
const LikeC4CustomColors = memo$1(({ customColors }) => {
  const styles = t$2(customColors).map(([name, color2]) => toStyle(name, color2)).join(`
`), nonce = useMantineStyleNonce()?.();
  return /* @__PURE__ */ jsx(Fragment$1, { children: /* @__PURE__ */ jsx("style", { type: "text/css", dangerouslySetInnerHTML: { __html: styles }, nonce }) });
}, deepEqual);
LikeC4CustomColors.displayName = "LikeC4CustomColors";
var cssReactFlow = "_17jps3v0", notInitialized = "_17jps3v1", cssDisablePan = "_17jps3v2", cssTransparentBg = "_17jps3v3", cssNoControls = "_17jps3v4";
const LikeC4ModelContext = createContext$1(null);
function useLikeC4Model(strict, type) {
  const model = useContext$1(LikeC4ModelContext);
  if (t$3(type) && l$2(model) && model.type !== type)
    throw new Error(`Invalid LikeC4ModelContext, expected "${type}" but got "${model.type}" in context`);
  if (n$1(strict) && strict === !0 && !model)
    throw new Error("No LikeC4Model found in context");
  return model;
}
function useLikeC4Views() {
  return useLikeC4Model(!0).sourcemodel.views;
}
function useLikeC4View(viewId) {
  const model = useLikeC4Model(!0);
  try {
    return model.view(viewId).view;
  } catch (error) {
    return console.warn(error), null;
  }
}
function useLikeC4DiagramView(viewId) {
  const model = useLikeC4Model(!0, "layouted");
  try {
    return model.view(viewId).view;
  } catch (error) {
    return console.warn(error), null;
  }
}
const sortByLabel = (a2, b2) => compareNatural(a2.label, b2.label);
function buildNode(element) {
  return {
    label: element.title,
    value: element.id,
    children: element.children().map(buildNode).sort(sortByLabel)
  };
}
function useLikeC4ElementsTree(viewId) {
  const model = useLikeC4Model(!0);
  return useMemo$1(() => viewId ? model.view(viewId).roots().map(buildNode).sort(sortByLabel) : model.roots().map(buildNode).sort(sortByLabel), [model, viewId ?? null]);
}
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var defaultAttributes = {
  outline: {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  },
  filled: {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    stroke: "none"
  }
};
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
const createReactComponent = (type, iconName, iconNamePascal, iconNode) => {
  const Component2 = forwardRef$1(
    ({ color: color2 = "currentColor", size = 24, stroke = 2, title: title2, className, children, ...rest }, ref) => createElement$1(
      "svg",
      {
        ref,
        ...defaultAttributes[type],
        width: size,
        height: size,
        className: ["tabler-icon", `tabler-icon-${iconName}`, className].join(" "),
        ...type === "filled" ? {
          fill: color2
        } : {
          strokeWidth: stroke,
          stroke: color2
        },
        ...rest
      },
      [
        title2 && createElement$1("title", { key: "svg-title" }, title2),
        ...iconNode.map(([tag, attrs]) => createElement$1(tag, attrs)),
        ...Array.isArray(children) ? children : [children]
      ]
    )
  );
  return Component2.displayName = `${iconNamePascal}`, Component2;
};
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconAlertTriangle = createReactComponent("outline", "alert-triangle", "IconAlertTriangle", [["path", { d: "M12 9v4", key: "svg-0" }], ["path", { d: "M10.363 3.591l-8.106 13.534a1.914 1.914 0 0 0 1.636 2.871h16.214a1.914 1.914 0 0 0 1.636 -2.87l-8.106 -13.536a1.914 1.914 0 0 0 -3.274 0z", key: "svg-1" }], ["path", { d: "M12 16h.01", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconArrowDownRight = createReactComponent("outline", "arrow-down-right", "IconArrowDownRight", [["path", { d: "M7 7l10 10", key: "svg-0" }], ["path", { d: "M17 8l0 9l-9 0", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconArrowLeft = createReactComponent("outline", "arrow-left", "IconArrowLeft", [["path", { d: "M5 12l14 0", key: "svg-0" }], ["path", { d: "M5 12l6 6", key: "svg-1" }], ["path", { d: "M5 12l6 -6", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconArrowRight = createReactComponent("outline", "arrow-right", "IconArrowRight", [["path", { d: "M5 12l14 0", key: "svg-0" }], ["path", { d: "M13 18l6 -6", key: "svg-1" }], ["path", { d: "M13 6l6 6", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconCheck = createReactComponent("outline", "check", "IconCheck", [["path", { d: "M5 12l5 5l10 -10", key: "svg-0" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconChevronDown = createReactComponent("outline", "chevron-down", "IconChevronDown", [["path", { d: "M6 9l6 6l6 -6", key: "svg-0" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconChevronLeft = createReactComponent("outline", "chevron-left", "IconChevronLeft", [["path", { d: "M15 6l-6 6l6 6", key: "svg-0" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconChevronRight = createReactComponent("outline", "chevron-right", "IconChevronRight", [["path", { d: "M9 6l6 6l-6 6", key: "svg-0" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconCopy = createReactComponent("outline", "copy", "IconCopy", [["path", { d: "M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z", key: "svg-0" }], ["path", { d: "M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconExternalLink = createReactComponent("outline", "external-link", "IconExternalLink", [["path", { d: "M12 6h-6a2 2 0 0 0 -2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-6", key: "svg-0" }], ["path", { d: "M11 13l9 -9", key: "svg-1" }], ["path", { d: "M15 4h5v5", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconFileCode = createReactComponent("outline", "file-code", "IconFileCode", [["path", { d: "M14 3v4a1 1 0 0 0 1 1h4", key: "svg-0" }], ["path", { d: "M17 21h-10a2 2 0 0 1 -2 -2v-14a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2z", key: "svg-1" }], ["path", { d: "M10 13l-1 2l1 2", key: "svg-2" }], ["path", { d: "M14 13l1 2l-1 2", key: "svg-3" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconFileSymlink = createReactComponent("outline", "file-symlink", "IconFileSymlink", [["path", { d: "M4 21v-4a3 3 0 0 1 3 -3h5", key: "svg-0" }], ["path", { d: "M9 17l3 -3l-3 -3", key: "svg-1" }], ["path", { d: "M14 3v4a1 1 0 0 0 1 1h4", key: "svg-2" }], ["path", { d: "M5 11v-6a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2h-9.5", key: "svg-3" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconFocusCentered = createReactComponent("outline", "focus-centered", "IconFocusCentered", [["path", { d: "M12 12m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0", key: "svg-0" }], ["path", { d: "M4 8v-2a2 2 0 0 1 2 -2h2", key: "svg-1" }], ["path", { d: "M4 16v2a2 2 0 0 0 2 2h2", key: "svg-2" }], ["path", { d: "M16 4h2a2 2 0 0 1 2 2v2", key: "svg-3" }], ["path", { d: "M16 20h2a2 2 0 0 0 2 -2v-2", key: "svg-4" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconFolderOpen = createReactComponent("outline", "folder-open", "IconFolderOpen", [["path", { d: "M5 19l2.757 -7.351a1 1 0 0 1 .936 -.649h12.307a1 1 0 0 1 .986 1.164l-.996 5.211a2 2 0 0 1 -1.964 1.625h-14.026a2 2 0 0 1 -2 -2v-11a2 2 0 0 1 2 -2h4l3 3h7a2 2 0 0 1 2 2v2", key: "svg-0" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconHelpCircle = createReactComponent("outline", "help-circle", "IconHelpCircle", [["path", { d: "M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0", key: "svg-0" }], ["path", { d: "M12 16v.01", key: "svg-1" }], ["path", { d: "M12 13a2 2 0 0 0 .914 -3.782a1.98 1.98 0 0 0 -2.414 .483", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconId = createReactComponent("outline", "id", "IconId", [["path", { d: "M3 4m0 3a3 3 0 0 1 3 -3h12a3 3 0 0 1 3 3v10a3 3 0 0 1 -3 3h-12a3 3 0 0 1 -3 -3z", key: "svg-0" }], ["path", { d: "M9 10m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0", key: "svg-1" }], ["path", { d: "M15 8l2 0", key: "svg-2" }], ["path", { d: "M15 12l2 0", key: "svg-3" }], ["path", { d: "M7 16l10 0", key: "svg-4" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconInfoCircle = createReactComponent("outline", "info-circle", "IconInfoCircle", [["path", { d: "M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0", key: "svg-0" }], ["path", { d: "M12 9h.01", key: "svg-1" }], ["path", { d: "M11 12h1v4h1", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconLayoutAlignBottom = createReactComponent("outline", "layout-align-bottom", "IconLayoutAlignBottom", [["path", { d: "M4 20l16 0", key: "svg-0" }], ["path", { d: "M9 4m0 2a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-2a2 2 0 0 1 -2 -2z", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconLayoutAlignCenter = createReactComponent("outline", "layout-align-center", "IconLayoutAlignCenter", [["path", { d: "M12 4l0 5", key: "svg-0" }], ["path", { d: "M12 15l0 5", key: "svg-1" }], ["path", { d: "M6 9m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v2a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconLayoutAlignLeft = createReactComponent("outline", "layout-align-left", "IconLayoutAlignLeft", [["path", { d: "M4 4l0 16", key: "svg-0" }], ["path", { d: "M8 9m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v2a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconLayoutAlignMiddle = createReactComponent("outline", "layout-align-middle", "IconLayoutAlignMiddle", [["path", { d: "M4 12l5 0", key: "svg-0" }], ["path", { d: "M15 12l5 0", key: "svg-1" }], ["path", { d: "M9 6m0 2a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-2a2 2 0 0 1 -2 -2z", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconLayoutAlignRight = createReactComponent("outline", "layout-align-right", "IconLayoutAlignRight", [["path", { d: "M20 4l0 16", key: "svg-0" }], ["path", { d: "M4 9m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v2a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconLayoutAlignTop = createReactComponent("outline", "layout-align-top", "IconLayoutAlignTop", [["path", { d: "M4 4l16 0", key: "svg-0" }], ["path", { d: "M9 8m0 2a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-2a2 2 0 0 1 -2 -2z", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconLayoutBoardSplit = createReactComponent("outline", "layout-board-split", "IconLayoutBoardSplit", [["path", { d: "M4 4m0 2a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v12a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2z", key: "svg-0" }], ["path", { d: "M4 12h8", key: "svg-1" }], ["path", { d: "M12 15h8", key: "svg-2" }], ["path", { d: "M12 9h8", key: "svg-3" }], ["path", { d: "M12 4v16", key: "svg-4" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconLayoutCollage = createReactComponent("outline", "layout-collage", "IconLayoutCollage", [["path", { d: "M4 4m0 2a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v12a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2z", key: "svg-0" }], ["path", { d: "M10 4l4 16", key: "svg-1" }], ["path", { d: "M12 12l-8 2", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconLayoutDashboard = createReactComponent("outline", "layout-dashboard", "IconLayoutDashboard", [["path", { d: "M5 4h4a1 1 0 0 1 1 1v6a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1v-6a1 1 0 0 1 1 -1", key: "svg-0" }], ["path", { d: "M5 16h4a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1v-2a1 1 0 0 1 1 -1", key: "svg-1" }], ["path", { d: "M15 12h4a1 1 0 0 1 1 1v6a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1v-6a1 1 0 0 1 1 -1", key: "svg-2" }], ["path", { d: "M15 4h4a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1v-2a1 1 0 0 1 1 -1", key: "svg-3" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconMenu2 = createReactComponent("outline", "menu-2", "IconMenu2", [["path", { d: "M4 6l16 0", key: "svg-0" }], ["path", { d: "M4 12l16 0", key: "svg-1" }], ["path", { d: "M4 18l16 0", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconMenu = createReactComponent("outline", "menu", "IconMenu", [["path", { d: "M4 8l16 0", key: "svg-0" }], ["path", { d: "M4 16l16 0", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconMoonStars = createReactComponent("outline", "moon-stars", "IconMoonStars", [["path", { d: "M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z", key: "svg-0" }], ["path", { d: "M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2", key: "svg-1" }], ["path", { d: "M19 11h2m-1 -1v2", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconRectangularPrism = createReactComponent("outline", "rectangular-prism", "IconRectangularPrism", [["path", { d: "M21 14.008v-5.018a1.98 1.98 0 0 0 -1 -1.717l-4 -2.008a2.016 2.016 0 0 0 -2 0l-10 5.008c-.619 .355 -1 1.01 -1 1.718v5.018c0 .709 .381 1.363 1 1.717l4 2.008a2.016 2.016 0 0 0 2 0l10 -5.008c.619 -.355 1 -1.01 1 -1.718z", key: "svg-0" }], ["path", { d: "M9 21v-7.5", key: "svg-1" }], ["path", { d: "M9 13.5l11.5 -5.5", key: "svg-2" }], ["path", { d: "M3.5 11l5.5 2.5", key: "svg-3" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconRouteOff = createReactComponent("outline", "route-off", "IconRouteOff", [["path", { d: "M6 19m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0", key: "svg-0" }], ["path", { d: "M18 5m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0", key: "svg-1" }], ["path", { d: "M12 19h4.5c.71 0 1.372 -.212 1.924 -.576m1.545 -2.459a3.5 3.5 0 0 0 -3.469 -3.965h-.499m-4 0h-3.501a3.5 3.5 0 0 1 -2.477 -5.972m2.477 -1.028h3.5", key: "svg-2" }], ["path", { d: "M3 3l18 18", key: "svg-3" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconSearch = createReactComponent("outline", "search", "IconSearch", [["path", { d: "M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0", key: "svg-0" }], ["path", { d: "M21 21l-6 -6", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconSelector = createReactComponent("outline", "selector", "IconSelector", [["path", { d: "M8 9l4 -4l4 4", key: "svg-0" }], ["path", { d: "M16 15l-4 4l-4 -4", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconShare = createReactComponent("outline", "share", "IconShare", [["path", { d: "M6 12m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0", key: "svg-0" }], ["path", { d: "M18 6m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0", key: "svg-1" }], ["path", { d: "M18 18m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0", key: "svg-2" }], ["path", { d: "M8.7 10.7l6.6 -3.4", key: "svg-3" }], ["path", { d: "M8.7 13.3l6.6 3.4", key: "svg-4" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconSitemap = createReactComponent("outline", "sitemap", "IconSitemap", [["path", { d: "M3 15m0 2a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v2a2 2 0 0 1 -2 2h-2a2 2 0 0 1 -2 -2z", key: "svg-0" }], ["path", { d: "M15 15m0 2a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v2a2 2 0 0 1 -2 2h-2a2 2 0 0 1 -2 -2z", key: "svg-1" }], ["path", { d: "M9 3m0 2a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v2a2 2 0 0 1 -2 2h-2a2 2 0 0 1 -2 -2z", key: "svg-2" }], ["path", { d: "M6 15v-1a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v1", key: "svg-3" }], ["path", { d: "M12 9l0 3", key: "svg-4" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconSun = createReactComponent("outline", "sun", "IconSun", [["path", { d: "M12 12m-4 0a4 4 0 1 0 8 0a4 4 0 1 0 -8 0", key: "svg-0" }], ["path", { d: "M3 12h1m8 -9v1m8 8h1m-9 8v1m-6.4 -15.4l.7 .7m12.1 -.7l-.7 .7m0 11.4l.7 .7m-12.1 -.7l-.7 .7", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconTransform = createReactComponent("outline", "transform", "IconTransform", [["path", { d: "M3 6a3 3 0 1 0 6 0a3 3 0 0 0 -6 0", key: "svg-0" }], ["path", { d: "M21 11v-3a2 2 0 0 0 -2 -2h-6l3 3m0 -6l-3 3", key: "svg-1" }], ["path", { d: "M3 13v3a2 2 0 0 0 2 2h6l-3 -3m0 6l3 -3", key: "svg-2" }], ["path", { d: "M15 18a3 3 0 1 0 6 0a3 3 0 0 0 -6 0", key: "svg-3" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconX = createReactComponent("outline", "x", "IconX", [["path", { d: "M18 6l-12 12", key: "svg-0" }], ["path", { d: "M6 6l12 12", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconZoomScan = createReactComponent("outline", "zoom-scan", "IconZoomScan", [["path", { d: "M4 8v-2a2 2 0 0 1 2 -2h2", key: "svg-0" }], ["path", { d: "M4 16v2a2 2 0 0 0 2 2h2", key: "svg-1" }], ["path", { d: "M16 4h2a2 2 0 0 1 2 2v2", key: "svg-2" }], ["path", { d: "M16 20h2a2 2 0 0 0 2 -2v-2", key: "svg-3" }], ["path", { d: "M8 11a3 3 0 1 0 6 0a3 3 0 0 0 -6 0", key: "svg-4" }], ["path", { d: "M16 16l-2.5 -2.5", key: "svg-5" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconBoxMultipleFilled = createReactComponent("filled", "box-multiple-filled", "IconBoxMultipleFilled", [["path", { d: "M6 5.667a3.667 3.667 0 0 1 3.667 -3.667h8.666a3.667 3.667 0 0 1 3.667 3.667v8.666a3.667 3.667 0 0 1 -3.667 3.667h-8.666a3.667 3.667 0 0 1 -3.667 -3.667z", key: "svg-0" }], ["path", { d: "M2 9c0 -1.094 .533 -1.828 1.514 -2.374a1 1 0 1 1 .972 1.748c-.398 .221 -.486 .342 -.486 .626v10c0 .548 .452 1 1 1h9.998c.32 0 .618 -.154 .805 -.407l.065 -.1a1 1 0 1 1 1.738 .99a3 3 0 0 1 -2.606 1.517h-10c-1.652 0 -3 -1.348 -3 -3z", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconFolderFilled = createReactComponent("filled", "folder-filled", "IconFolderFilled", [["path", { d: "M9 3a1 1 0 0 1 .608 .206l.1 .087l2.706 2.707h6.586a3 3 0 0 1 2.995 2.824l.005 .176v8a3 3 0 0 1 -2.824 2.995l-.176 .005h-14a3 3 0 0 1 -2.995 -2.824l-.005 -.176v-11a3 3 0 0 1 2.824 -2.995l.176 -.005h4z", key: "svg-0" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconPlayerPlayFilled = createReactComponent("filled", "player-play-filled", "IconPlayerPlayFilled", [["path", { d: "M6 4v16a1 1 0 0 0 1.524 .852l13 -8a1 1 0 0 0 0 -1.704l-13 -8a1 1 0 0 0 -1.524 .852z", key: "svg-0" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconPlayerSkipBackFilled = createReactComponent("filled", "player-skip-back-filled", "IconPlayerSkipBackFilled", [["path", { d: "M19.496 4.136l-12 7a1 1 0 0 0 0 1.728l12 7a1 1 0 0 0 1.504 -.864v-14a1 1 0 0 0 -1.504 -.864z", key: "svg-0" }], ["path", { d: "M4 4a1 1 0 0 1 .993 .883l.007 .117v14a1 1 0 0 1 -1.993 .117l-.007 -.117v-14a1 1 0 0 1 1 -1z", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconPlayerSkipForwardFilled = createReactComponent("filled", "player-skip-forward-filled", "IconPlayerSkipForwardFilled", [["path", { d: "M3 5v14a1 1 0 0 0 1.504 .864l12 -7a1 1 0 0 0 0 -1.728l-12 -7a1 1 0 0 0 -1.504 .864z", key: "svg-0" }], ["path", { d: "M20 4a1 1 0 0 1 .993 .883l.007 .117v14a1 1 0 0 1 -1.993 .117l-.007 -.117v-14a1 1 0 0 1 1 -1z", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconPlayerStopFilled = createReactComponent("filled", "player-stop-filled", "IconPlayerStopFilled", [["path", { d: "M17 4h-10a3 3 0 0 0 -3 3v10a3 3 0 0 0 3 3h10a3 3 0 0 0 3 -3v-10a3 3 0 0 0 -3 -3z", key: "svg-0" }]]);
/**
 * @license @tabler/icons-react v3.17.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconStarFilled = createReactComponent("filled", "star-filled", "IconStarFilled", [["path", { d: "M8.243 7.34l-6.38 .925l-.113 .023a1 1 0 0 0 -.44 1.684l4.622 4.499l-1.09 6.355l-.013 .11a1 1 0 0 0 1.464 .944l5.706 -3l5.693 3l.1 .046a1 1 0 0 0 1.352 -1.1l-1.091 -6.355l4.624 -4.5l.078 -.085a1 1 0 0 0 -.633 -1.62l-6.38 -.926l-2.852 -5.78a1 1 0 0 0 -1.794 0l-2.853 5.78z", key: "svg-0" }]]);
function filterAction(actionData, query) {
  const queryLower = query.toLowerCase(), keywordMatch = (Array.isArray(actionData.keywords) ? actionData.keywords : []).map((keyword) => {
    const index2 = keyword.toLowerCase().indexOf(queryLower);
    return index2 !== -1 ? {
      keyword,
      match: keyword.substring(index2, index2 + query.length)
    } : null;
  }).find((match) => !!match);
  return keywordMatch ? {
    data: actionData,
    keyword: keywordMatch.keyword,
    match: keywordMatch.match
  } : void 0;
}
function buildFilteredActions(actionsData, query) {
  return x$1(
    actionsData,
    m$1((a2) => filterAction(a2, query)),
    T((qm) => !!qm),
    m$1((qm) => buildSpotlightAction(qm))
  );
}
function highlightMatch(match) {
  return /* @__PURE__ */ jsx(Highlight, { highlight: match.match, children: match.keyword });
}
function buildSpotlightAction(matchedAction) {
  const isMatchInLabel = matchedAction.keyword == matchedAction.data.label;
  return /* @__PURE__ */ jsxs(Spotlight.Action, { onClick: matchedAction.data.onClick, children: [
    /* @__PURE__ */ jsx(Center, { style: { marginRight: "8px " }, children: matchedAction.data.leftSection }),
    /* @__PURE__ */ jsx(Group, { wrap: "nowrap", w: "100%", children: /* @__PURE__ */ jsxs("div", { style: { flex: 1 }, children: [
      /* @__PURE__ */ jsx(Text$6, { children: isMatchInLabel ? highlightMatch(matchedAction) : matchedAction.data.label }),
      !isMatchInLabel && /* @__PURE__ */ jsx(Text$6, { opacity: 0.6, size: "xs", children: highlightMatch(matchedAction) })
    ] }) })
  ] });
}
const LikeC4Search = memo$1(() => {
  const view = useDiagramState((s2) => s2.view), model = useLikeC4Model(!0), store = useDiagramStoreApi(), [query, setQuery] = useState$1(""), getNodeActionsData = () => {
    const { focusOnNode } = store.getState();
    return x$1(
      view.nodes,
      T((n2) => !!n2.title),
      m$1((n2) => ({
        id: n2.id,
        label: n2.title,
        keywords: [
          n2.title,
          ...(n2.tags ?? []).map((t2) => `#${t2}`),
          ...n2.description ? [n2.description] : []
        ].filter((k) => k.toLowerCase()),
        onClick: () => focusOnNode(n2.id),
        leftSection: /* @__PURE__ */ jsx(IconRectangularPrism, {})
      }))
    );
  }, getViewActionsData = () => {
    const { onNavigateTo } = store.getState(), views = model.views();
    return m$1(views, (v) => ({
      id: v.id,
      label: v.title ?? v.id,
      keywords: [
        v.title ?? v.id,
        ...v.tags ?? [],
        ...v.view.description ? [v.view.description] : []
      ],
      onClick: () => {
        store.setState({
          hoveredNodeId: null,
          lastOnNavigate: {
            fromView: view.id,
            toView: v.id,
            fromNode: null
          }
        }), onNavigateTo?.(v.id);
      },
      leftSection: /* @__PURE__ */ jsx(IconSitemap, {})
    }));
  }, { nodeActions, viewActions } = useMemo$1(
    () => ({
      nodeActions: buildFilteredActions(getNodeActionsData(), query),
      viewActions: buildFilteredActions(getViewActionsData(), query)
    }),
    [model, store, view, query]
  ), portalProps = useMantinePortalProps();
  return /* @__PURE__ */ jsxs(
    Spotlight.Root,
    {
      ...portalProps,
      shortcut: ["mod + f", "mod + k"],
      query,
      onQueryChange: setQuery,
      scrollable: !0,
      maxHeight: "calc(100vh - 100px)",
      children: [
        /* @__PURE__ */ jsx(
          Spotlight.Search,
          {
            placeholder: "Search elements in current view and other views...",
            leftSection: /* @__PURE__ */ jsx(IconSearch, { stroke: 1.5 })
          }
        ),
        /* @__PURE__ */ jsxs(Spotlight.ActionsList, { children: [
          nodeActions.length > 0 && /* @__PURE__ */ jsx(SpotlightActionsGroup, { label: "Elements", children: nodeActions }),
          viewActions.length > 0 && /* @__PURE__ */ jsx(SpotlightActionsGroup, { label: "Views", children: viewActions }),
          nodeActions.length == 0 && viewActions.length == 0 && /* @__PURE__ */ jsx(Spotlight.Empty, { children: "Nothing found..." })
        ] })
      ]
    }
  );
}), OverlayContext = createContext$1({});
function useOverlayDialog() {
  return useContext$1(OverlayContext);
}
var edgeSource = "qaevzq1 qaevzq0", edgeArrow = "qaevzq2 qaevzq0", edgeTarget = "qaevzq3 qaevzq0", edgeLabel$3 = "qaevzq4", edgeRow = "qaevzq5", edgeGrid = "qaevzq6", edgeDataGrid = "qaevzq7";
const SelectEdge = ({
  edge,
  view
}) => {
  const overlay = useOverlayDialog(), viewport = useRef$1(null), theme2 = useComputedColorScheme(), edgeSource$1 = view.nodes.find((n2) => n2.id === edge.source), edgeTarget$1 = view.nodes.find((n2) => n2.id === edge.target), edges = view.edges.map((edge2) => {
    const source = view.nodes.find((n2) => n2.id === edge2.source), target = view.nodes.find((n2) => n2.id === edge2.target);
    return {
      id: edge2.id,
      source,
      target,
      label: edge2.label
    };
  });
  return /* @__PURE__ */ jsxs(
    Popover,
    {
      position: "bottom",
      shadow: "md",
      keepMounted: !0,
      withinPortal: !1,
      closeOnClickOutside: !0,
      clickOutsideEvents: ["pointerdown", "mousedown", "click"],
      onOpen: () => {
        setTimeout(() => {
          viewport.current?.querySelector(`[data-edge-id="${edge.id}"]`)?.scrollIntoView({ behavior: "instant", block: "nearest" });
        }, 100);
      },
      children: [
        /* @__PURE__ */ jsx(PopoverTarget, { children: /* @__PURE__ */ jsxs(
          Button,
          {
            size: "xs",
            variant: "light",
            color: theme2 === "light" ? "dark" : "gray",
            fw: "500",
            style: { padding: "0.25rem 0.75rem" },
            rightSection: /* @__PURE__ */ jsx(IconSelector, { size: 16 }),
            children: [
              /* @__PURE__ */ jsx(
                Box,
                {
                  className: edgeSource,
                  maw: 160,
                  p: 0,
                  mod: {
                    "likec4-color": edgeSource$1.color
                  },
                  children: /* @__PURE__ */ jsx(Text$6, { component: "span", truncate: !0, children: edgeSource$1.title })
                }
              ),
              /* @__PURE__ */ jsx(ThemeIcon, { color: "dark", variant: "transparent", size: "xs", children: /* @__PURE__ */ jsx(IconArrowRight, { style: { width: "80%" } }) }),
              /* @__PURE__ */ jsx(
                Box,
                {
                  className: edgeTarget,
                  maw: 160,
                  p: 0,
                  mod: {
                    "likec4-color": edgeTarget$1.color
                  },
                  children: /* @__PURE__ */ jsx(Text$6, { component: "span", truncate: !0, children: edgeTarget$1.title })
                }
              )
            ]
          }
        ) }),
        /* @__PURE__ */ jsx(PopoverDropdown, { p: 0, miw: 250, maw: 420, children: /* @__PURE__ */ jsx(ScrollAreaAutosize, { mah: "70vh", scrollbars: "y", type: "never", viewportRef: viewport, children: /* @__PURE__ */ jsx(Box, { className: edgeGrid, p: "xs", children: edges.map((e2) => /* @__PURE__ */ jsxs(
          "div",
          {
            className: edgeRow,
            "data-selected": e2.id === edge.id,
            onClick: (event) => {
              event.stopPropagation(), overlay.openOverlay({
                edgeDetails: e2.id
              });
            },
            children: [
              /* @__PURE__ */ jsx(
                Box,
                {
                  className: edgeSource,
                  maw: 160,
                  mod: {
                    "edge-id": e2.id,
                    "likec4-color": e2.source.color
                  },
                  children: /* @__PURE__ */ jsx(Text$6, { component: "span", truncate: !0, children: e2.source.title })
                }
              ),
              /* @__PURE__ */ jsx(Box, { className: edgeArrow, children: /* @__PURE__ */ jsx(ThemeIcon, { color: "dark", variant: "transparent", size: "xs", children: /* @__PURE__ */ jsx(IconArrowRight, { style: { width: "80%" } }) }) }),
              /* @__PURE__ */ jsx(
                Box,
                {
                  className: edgeTarget,
                  maw: 160,
                  mod: {
                    "likec4-color": e2.target.color
                  },
                  children: /* @__PURE__ */ jsx(Text$6, { component: "span", truncate: !0, children: e2.target.title })
                }
              ),
              /* @__PURE__ */ jsx(Box, { className: edgeLabel$3, children: /* @__PURE__ */ jsx(Text$6, { component: "span", truncate: !0, children: e2.label || "untitled" }) })
            ]
          },
          e2.id
        )) }) }) })
      ]
    }
  );
};
var DEFAULT_EDGE_NAME = "\0", GRAPH_NODE = "\0", EDGE_KEY_DELIM = "";
let Graph$a = class {
  _isDirected = !0;
  _isMultigraph = !1;
  _isCompound = !1;
  // Label for the graph itself
  _label;
  // Defaults to be set when creating a new node
  _defaultNodeLabelFn = () => {
  };
  // Defaults to be set when creating a new edge
  _defaultEdgeLabelFn = () => {
  };
  // v -> label
  _nodes = {};
  // v -> edgeObj
  _in = {};
  // u -> v -> Number
  _preds = {};
  // v -> edgeObj
  _out = {};
  // v -> w -> Number
  _sucs = {};
  // e -> edgeObj
  _edgeObjs = {};
  // e -> label
  _edgeLabels = {};
  /* Number of nodes in the graph. Should only be changed by the implementation. */
  _nodeCount = 0;
  /* Number of edges in the graph. Should only be changed by the implementation. */
  _edgeCount = 0;
  _parent;
  _children;
  constructor(opts) {
    opts && (this._isDirected = Object.hasOwn(opts, "directed") ? opts.directed : !0, this._isMultigraph = Object.hasOwn(opts, "multigraph") ? opts.multigraph : !1, this._isCompound = Object.hasOwn(opts, "compound") ? opts.compound : !1), this._isCompound && (this._parent = {}, this._children = {}, this._children[GRAPH_NODE] = {});
  }
  /* === Graph functions ========= */
  /**
   * Whether graph was created with 'directed' flag set to true or not.
   */
  isDirected() {
    return this._isDirected;
  }
  /**
   * Whether graph was created with 'multigraph' flag set to true or not.
   */
  isMultigraph() {
    return this._isMultigraph;
  }
  /**
   * Whether graph was created with 'compound' flag set to true or not.
   */
  isCompound() {
    return this._isCompound;
  }
  /**
   * Sets the label of the graph.
   */
  setGraph(label2) {
    return this._label = label2, this;
  }
  /**
   * Gets the graph label.
   */
  graph() {
    return this._label;
  }
  /* === Node functions ========== */
  /**
   * Sets the default node label. If newDefault is a function, it will be
   * invoked ach time when setting a label for a node. Otherwise, this label
   * will be assigned as default label in case if no label was specified while
   * setting a node.
   * Complexity: O(1).
   */
  setDefaultNodeLabel(newDefault) {
    return this._defaultNodeLabelFn = newDefault, typeof newDefault != "function" && (this._defaultNodeLabelFn = () => newDefault), this;
  }
  /**
   * Gets the number of nodes in the graph.
   * Complexity: O(1).
   */
  nodeCount() {
    return this._nodeCount;
  }
  /**
   * Gets all nodes of the graph. Note, the in case of compound graph subnodes are
   * not included in list.
   * Complexity: O(1).
   */
  nodes() {
    return Object.keys(this._nodes);
  }
  /**
   * Gets list of nodes without in-edges.
   * Complexity: O(|V|).
   */
  sources() {
    var self = this;
    return this.nodes().filter((v) => Object.keys(self._in[v]).length === 0);
  }
  /**
   * Gets list of nodes without out-edges.
   * Complexity: O(|V|).
   */
  sinks() {
    var self = this;
    return this.nodes().filter((v) => Object.keys(self._out[v]).length === 0);
  }
  /**
   * Invokes setNode method for each node in names list.
   * Complexity: O(|names|).
   */
  setNodes(vs, value) {
    var args = arguments, self = this;
    return vs.forEach(function(v) {
      args.length > 1 ? self.setNode(v, value) : self.setNode(v);
    }), this;
  }
  /**
   * Creates or updates the value for the node v in the graph. If label is supplied
   * it is set as the value for the node. If label is not supplied and the node was
   * created by this call then the default node label will be assigned.
   * Complexity: O(1).
   */
  setNode(v, value) {
    return Object.hasOwn(this._nodes, v) ? (arguments.length > 1 && (this._nodes[v] = value), this) : (this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v), this._isCompound && (this._parent[v] = GRAPH_NODE, this._children[v] = {}, this._children[GRAPH_NODE][v] = !0), this._in[v] = {}, this._preds[v] = {}, this._out[v] = {}, this._sucs[v] = {}, ++this._nodeCount, this);
  }
  /**
   * Gets the label of node with specified name.
   * Complexity: O(|V|).
   */
  node(v) {
    return this._nodes[v];
  }
  /**
   * Detects whether graph has a node with specified name or not.
   */
  hasNode(v) {
    return Object.hasOwn(this._nodes, v);
  }
  /**
   * Remove the node with the name from the graph or do nothing if the node is not in
   * the graph. If the node was removed this function also removes any incident
   * edges.
   * Complexity: O(1).
   */
  removeNode(v) {
    var self = this;
    if (Object.hasOwn(this._nodes, v)) {
      var removeEdge = (e2) => self.removeEdge(self._edgeObjs[e2]);
      delete this._nodes[v], this._isCompound && (this._removeFromParentsChildList(v), delete this._parent[v], this.children(v).forEach(function(child) {
        self.setParent(child);
      }), delete this._children[v]), Object.keys(this._in[v]).forEach(removeEdge), delete this._in[v], delete this._preds[v], Object.keys(this._out[v]).forEach(removeEdge), delete this._out[v], delete this._sucs[v], --this._nodeCount;
    }
    return this;
  }
  /**
   * Sets node p as a parent for node v if it is defined, or removes the
   * parent for v if p is undefined. Method throws an exception in case of
   * invoking it in context of noncompound graph.
   * Average-case complexity: O(1).
   */
  setParent(v, parent) {
    if (!this._isCompound)
      throw new Error("Cannot set parent in a non-compound graph");
    if (parent === void 0)
      parent = GRAPH_NODE;
    else {
      parent += "";
      for (var ancestor = parent; ancestor !== void 0; ancestor = this.parent(ancestor))
        if (ancestor === v)
          throw new Error("Setting " + parent + " as parent of " + v + " would create a cycle");
      this.setNode(parent);
    }
    return this.setNode(v), this._removeFromParentsChildList(v), this._parent[v] = parent, this._children[parent][v] = !0, this;
  }
  _removeFromParentsChildList(v) {
    delete this._children[this._parent[v]][v];
  }
  /**
   * Gets parent node for node v.
   * Complexity: O(1).
   */
  parent(v) {
    if (this._isCompound) {
      var parent = this._parent[v];
      if (parent !== GRAPH_NODE)
        return parent;
    }
  }
  /**
   * Gets list of direct children of node v.
   * Complexity: O(1).
   */
  children(v = GRAPH_NODE) {
    if (this._isCompound) {
      var children = this._children[v];
      if (children)
        return Object.keys(children);
    } else {
      if (v === GRAPH_NODE)
        return this.nodes();
      if (this.hasNode(v))
        return [];
    }
  }
  /**
   * Return all nodes that are predecessors of the specified node or undefined if node v is not in
   * the graph. Behavior is undefined for undirected graphs - use neighbors instead.
   * Complexity: O(|V|).
   */
  predecessors(v) {
    var predsV = this._preds[v];
    if (predsV)
      return Object.keys(predsV);
  }
  /**
   * Return all nodes that are successors of the specified node or undefined if node v is not in
   * the graph. Behavior is undefined for undirected graphs - use neighbors instead.
   * Complexity: O(|V|).
   */
  successors(v) {
    var sucsV = this._sucs[v];
    if (sucsV)
      return Object.keys(sucsV);
  }
  /**
   * Return all nodes that are predecessors or successors of the specified node or undefined if
   * node v is not in the graph.
   * Complexity: O(|V|).
   */
  neighbors(v) {
    var preds = this.predecessors(v);
    if (preds) {
      const union = new Set(preds);
      for (var succ of this.successors(v))
        union.add(succ);
      return Array.from(union.values());
    }
  }
  isLeaf(v) {
    var neighbors;
    return this.isDirected() ? neighbors = this.successors(v) : neighbors = this.neighbors(v), neighbors.length === 0;
  }
  /**
   * Creates new graph with nodes filtered via filter. Edges incident to rejected node
   * are also removed. In case of compound graph, if parent is rejected by filter,
   * than all its children are rejected too.
   * Average-case complexity: O(|E|+|V|).
   */
  filterNodes(filter2) {
    var copy = new this.constructor({
      directed: this._isDirected,
      multigraph: this._isMultigraph,
      compound: this._isCompound
    });
    copy.setGraph(this.graph());
    var self = this;
    Object.entries(this._nodes).forEach(function([v, value]) {
      filter2(v) && copy.setNode(v, value);
    }), Object.values(this._edgeObjs).forEach(function(e2) {
      copy.hasNode(e2.v) && copy.hasNode(e2.w) && copy.setEdge(e2, self.edge(e2));
    });
    var parents = {};
    function findParent(v) {
      var parent = self.parent(v);
      return parent === void 0 || copy.hasNode(parent) ? (parents[v] = parent, parent) : parent in parents ? parents[parent] : findParent(parent);
    }
    return this._isCompound && copy.nodes().forEach((v) => copy.setParent(v, findParent(v))), copy;
  }
  /* === Edge functions ========== */
  /**
   * Sets the default edge label or factory function. This label will be
   * assigned as default label in case if no label was specified while setting
   * an edge or this function will be invoked each time when setting an edge
   * with no label specified and returned value * will be used as a label for edge.
   * Complexity: O(1).
   */
  setDefaultEdgeLabel(newDefault) {
    return this._defaultEdgeLabelFn = newDefault, typeof newDefault != "function" && (this._defaultEdgeLabelFn = () => newDefault), this;
  }
  /**
   * Gets the number of edges in the graph.
   * Complexity: O(1).
   */
  edgeCount() {
    return this._edgeCount;
  }
  /**
   * Gets edges of the graph. In case of compound graph subgraphs are not considered.
   * Complexity: O(|E|).
   */
  edges() {
    return Object.values(this._edgeObjs);
  }
  /**
   * Establish an edges path over the nodes in nodes list. If some edge is already
   * exists, it will update its label, otherwise it will create an edge between pair
   * of nodes with label provided or default label if no label provided.
   * Complexity: O(|nodes|).
   */
  setPath(vs, value) {
    var self = this, args = arguments;
    return vs.reduce(function(v, w) {
      return args.length > 1 ? self.setEdge(v, w, value) : self.setEdge(v, w), w;
    }), this;
  }
  /**
   * Creates or updates the label for the edge (v, w) with the optionally supplied
   * name. If label is supplied it is set as the value for the edge. If label is not
   * supplied and the edge was created by this call then the default edge label will
   * be assigned. The name parameter is only useful with multigraphs.
   */
  setEdge() {
    var v, w, name, value, valueSpecified = !1, arg0 = arguments[0];
    typeof arg0 == "object" && arg0 !== null && "v" in arg0 ? (v = arg0.v, w = arg0.w, name = arg0.name, arguments.length === 2 && (value = arguments[1], valueSpecified = !0)) : (v = arg0, w = arguments[1], name = arguments[3], arguments.length > 2 && (value = arguments[2], valueSpecified = !0)), v = "" + v, w = "" + w, name !== void 0 && (name = "" + name);
    var e2 = edgeArgsToId(this._isDirected, v, w, name);
    if (Object.hasOwn(this._edgeLabels, e2))
      return valueSpecified && (this._edgeLabels[e2] = value), this;
    if (name !== void 0 && !this._isMultigraph)
      throw new Error("Cannot set a named edge when isMultigraph = false");
    this.setNode(v), this.setNode(w), this._edgeLabels[e2] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w, name);
    var edgeObj = edgeArgsToObj(this._isDirected, v, w, name);
    return v = edgeObj.v, w = edgeObj.w, Object.freeze(edgeObj), this._edgeObjs[e2] = edgeObj, incrementOrInitEntry(this._preds[w], v), incrementOrInitEntry(this._sucs[v], w), this._in[w][e2] = edgeObj, this._out[v][e2] = edgeObj, this._edgeCount++, this;
  }
  /**
   * Gets the label for the specified edge.
   * Complexity: O(1).
   */
  edge(v, w, name) {
    var e2 = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
    return this._edgeLabels[e2];
  }
  /**
   * Gets the label for the specified edge and converts it to an object.
   * Complexity: O(1)
   */
  edgeAsObj() {
    const edge = this.edge(...arguments);
    return typeof edge != "object" ? { label: edge } : edge;
  }
  /**
   * Detects whether the graph contains specified edge or not. No subgraphs are considered.
   * Complexity: O(1).
   */
  hasEdge(v, w, name) {
    var e2 = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
    return Object.hasOwn(this._edgeLabels, e2);
  }
  /**
   * Removes the specified edge from the graph. No subgraphs are considered.
   * Complexity: O(1).
   */
  removeEdge(v, w, name) {
    var e2 = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name), edge = this._edgeObjs[e2];
    return edge && (v = edge.v, w = edge.w, delete this._edgeLabels[e2], delete this._edgeObjs[e2], decrementOrRemoveEntry(this._preds[w], v), decrementOrRemoveEntry(this._sucs[v], w), delete this._in[w][e2], delete this._out[v][e2], this._edgeCount--), this;
  }
  /**
   * Return all edges that point to the node v. Optionally filters those edges down to just those
   * coming from node u. Behavior is undefined for undirected graphs - use nodeEdges instead.
   * Complexity: O(|E|).
   */
  inEdges(v, u2) {
    var inV = this._in[v];
    if (inV) {
      var edges = Object.values(inV);
      return u2 ? edges.filter((edge) => edge.v === u2) : edges;
    }
  }
  /**
   * Return all edges that are pointed at by node v. Optionally filters those edges down to just
   * those point to w. Behavior is undefined for undirected graphs - use nodeEdges instead.
   * Complexity: O(|E|).
   */
  outEdges(v, w) {
    var outV = this._out[v];
    if (outV) {
      var edges = Object.values(outV);
      return w ? edges.filter((edge) => edge.w === w) : edges;
    }
  }
  /**
   * Returns all edges to or from node v regardless of direction. Optionally filters those edges
   * down to just those between nodes v and w regardless of direction.
   * Complexity: O(|E|).
   */
  nodeEdges(v, w) {
    var inEdges = this.inEdges(v, w);
    if (inEdges)
      return inEdges.concat(this.outEdges(v, w));
  }
};
function incrementOrInitEntry(map, k) {
  map[k] ? map[k]++ : map[k] = 1;
}
function decrementOrRemoveEntry(map, k) {
  --map[k] || delete map[k];
}
function edgeArgsToId(isDirected, v_, w_, name) {
  var v = "" + v_, w = "" + w_;
  if (!isDirected && v > w) {
    var tmp = v;
    v = w, w = tmp;
  }
  return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM + (name === void 0 ? DEFAULT_EDGE_NAME : name);
}
function edgeArgsToObj(isDirected, v_, w_, name) {
  var v = "" + v_, w = "" + w_;
  if (!isDirected && v > w) {
    var tmp = v;
    v = w, w = tmp;
  }
  var edgeObj = { v, w };
  return name && (edgeObj.name = name), edgeObj;
}
function edgeObjToId(isDirected, edgeObj) {
  return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
}
var graph = Graph$a, version$1 = "2.2.4", lib$1 = {
  Graph: graph,
  version: version$1
}, Graph$9 = graph, json = {
  write,
  read
};
function write(g) {
  var json2 = {
    options: {
      directed: g.isDirected(),
      multigraph: g.isMultigraph(),
      compound: g.isCompound()
    },
    nodes: writeNodes(g),
    edges: writeEdges(g)
  };
  return g.graph() !== void 0 && (json2.value = structuredClone(g.graph())), json2;
}
function writeNodes(g) {
  return g.nodes().map(function(v) {
    var nodeValue = g.node(v), parent = g.parent(v), node2 = { v };
    return nodeValue !== void 0 && (node2.value = nodeValue), parent !== void 0 && (node2.parent = parent), node2;
  });
}
function writeEdges(g) {
  return g.edges().map(function(e2) {
    var edgeValue = g.edge(e2), edge = { v: e2.v, w: e2.w };
    return e2.name !== void 0 && (edge.name = e2.name), edgeValue !== void 0 && (edge.value = edgeValue), edge;
  });
}
function read(json2) {
  var g = new Graph$9(json2.options).setGraph(json2.value);
  return json2.nodes.forEach(function(entry) {
    g.setNode(entry.v, entry.value), entry.parent && g.setParent(entry.v, entry.parent);
  }), json2.edges.forEach(function(entry) {
    g.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);
  }), g;
}
var components_1 = components;
function components(g) {
  var visited = {}, cmpts = [], cmpt;
  function dfs2(v) {
    Object.hasOwn(visited, v) || (visited[v] = !0, cmpt.push(v), g.successors(v).forEach(dfs2), g.predecessors(v).forEach(dfs2));
  }
  return g.nodes().forEach(function(v) {
    cmpt = [], dfs2(v), cmpt.length && cmpts.push(cmpt);
  }), cmpts;
}
let PriorityQueue$2 = class {
  _arr = [];
  _keyIndices = {};
  /**
   * Returns the number of elements in the queue. Takes `O(1)` time.
   */
  size() {
    return this._arr.length;
  }
  /**
   * Returns the keys that are in the queue. Takes `O(n)` time.
   */
  keys() {
    return this._arr.map(function(x2) {
      return x2.key;
    });
  }
  /**
   * Returns `true` if **key** is in the queue and `false` if not.
   */
  has(key) {
    return Object.hasOwn(this._keyIndices, key);
  }
  /**
   * Returns the priority for **key**. If **key** is not present in the queue
   * then this function returns `undefined`. Takes `O(1)` time.
   *
   * @param {Object} key
   */
  priority(key) {
    var index2 = this._keyIndices[key];
    if (index2 !== void 0)
      return this._arr[index2].priority;
  }
  /**
   * Returns the key for the minimum element in this queue. If the queue is
   * empty this function throws an Error. Takes `O(1)` time.
   */
  min() {
    if (this.size() === 0)
      throw new Error("Queue underflow");
    return this._arr[0].key;
  }
  /**
   * Inserts a new key into the priority queue. If the key already exists in
   * the queue this function returns `false`; otherwise it will return `true`.
   * Takes `O(n)` time.
   *
   * @param {Object} key the key to add
   * @param {Number} priority the initial priority for the key
   */
  add(key, priority) {
    var keyIndices = this._keyIndices;
    if (key = String(key), !Object.hasOwn(keyIndices, key)) {
      var arr = this._arr, index2 = arr.length;
      return keyIndices[key] = index2, arr.push({ key, priority }), this._decrease(index2), !0;
    }
    return !1;
  }
  /**
   * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
   */
  removeMin() {
    this._swap(0, this._arr.length - 1);
    var min2 = this._arr.pop();
    return delete this._keyIndices[min2.key], this._heapify(0), min2.key;
  }
  /**
   * Decreases the priority for **key** to **priority**. If the new priority is
   * greater than the previous priority, this function will throw an Error.
   *
   * @param {Object} key the key for which to raise priority
   * @param {Number} priority the new priority for the key
   */
  decrease(key, priority) {
    var index2 = this._keyIndices[key];
    if (priority > this._arr[index2].priority)
      throw new Error("New priority is greater than current priority. Key: " + key + " Old: " + this._arr[index2].priority + " New: " + priority);
    this._arr[index2].priority = priority, this._decrease(index2);
  }
  _heapify(i2) {
    var arr = this._arr, l2 = 2 * i2, r2 = l2 + 1, largest = i2;
    l2 < arr.length && (largest = arr[l2].priority < arr[largest].priority ? l2 : largest, r2 < arr.length && (largest = arr[r2].priority < arr[largest].priority ? r2 : largest), largest !== i2 && (this._swap(i2, largest), this._heapify(largest)));
  }
  _decrease(index2) {
    for (var arr = this._arr, priority = arr[index2].priority, parent; index2 !== 0 && (parent = index2 >> 1, !(arr[parent].priority < priority)); )
      this._swap(index2, parent), index2 = parent;
  }
  _swap(i2, j) {
    var arr = this._arr, keyIndices = this._keyIndices, origArrI = arr[i2], origArrJ = arr[j];
    arr[i2] = origArrJ, arr[j] = origArrI, keyIndices[origArrJ.key] = i2, keyIndices[origArrI.key] = j;
  }
};
var priorityQueue = PriorityQueue$2, PriorityQueue$1 = priorityQueue, dijkstra_1 = dijkstra$1, DEFAULT_WEIGHT_FUNC$1 = () => 1;
function dijkstra$1(g, source, weightFn, edgeFn) {
  return runDijkstra(
    g,
    String(source),
    weightFn || DEFAULT_WEIGHT_FUNC$1,
    edgeFn || function(v) {
      return g.outEdges(v);
    }
  );
}
function runDijkstra(g, source, weightFn, edgeFn) {
  var results = {}, pq = new PriorityQueue$1(), v, vEntry, updateNeighbors = function(edge) {
    var w = edge.v !== v ? edge.v : edge.w, wEntry = results[w], weight = weightFn(edge), distance2 = vEntry.distance + weight;
    if (weight < 0)
      throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + edge + " Weight: " + weight);
    distance2 < wEntry.distance && (wEntry.distance = distance2, wEntry.predecessor = v, pq.decrease(w, distance2));
  };
  for (g.nodes().forEach(function(v2) {
    var distance2 = v2 === source ? 0 : Number.POSITIVE_INFINITY;
    results[v2] = { distance: distance2 }, pq.add(v2, distance2);
  }); pq.size() > 0 && (v = pq.removeMin(), vEntry = results[v], vEntry.distance !== Number.POSITIVE_INFINITY); )
    edgeFn(v).forEach(updateNeighbors);
  return results;
}
var dijkstra = dijkstra_1, dijkstraAll_1 = dijkstraAll;
function dijkstraAll(g, weightFunc, edgeFunc) {
  return g.nodes().reduce(function(acc, v) {
    return acc[v] = dijkstra(g, v, weightFunc, edgeFunc), acc;
  }, {});
}
var tarjan_1 = tarjan$1;
function tarjan$1(g) {
  var index2 = 0, stack = [], visited = {}, results = [];
  function dfs2(v) {
    var entry = visited[v] = {
      onStack: !0,
      lowlink: index2,
      index: index2++
    };
    if (stack.push(v), g.successors(v).forEach(function(w2) {
      Object.hasOwn(visited, w2) ? visited[w2].onStack && (entry.lowlink = Math.min(entry.lowlink, visited[w2].index)) : (dfs2(w2), entry.lowlink = Math.min(entry.lowlink, visited[w2].lowlink));
    }), entry.lowlink === entry.index) {
      var cmpt = [], w;
      do
        w = stack.pop(), visited[w].onStack = !1, cmpt.push(w);
      while (v !== w);
      results.push(cmpt);
    }
  }
  return g.nodes().forEach(function(v) {
    Object.hasOwn(visited, v) || dfs2(v);
  }), results;
}
var tarjan = tarjan_1, findCycles_1 = findCycles;
function findCycles(g) {
  return tarjan(g).filter(function(cmpt) {
    return cmpt.length > 1 || cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]);
  });
}
var floydWarshall_1 = floydWarshall, DEFAULT_WEIGHT_FUNC = () => 1;
function floydWarshall(g, weightFn, edgeFn) {
  return runFloydWarshall(
    g,
    weightFn || DEFAULT_WEIGHT_FUNC,
    edgeFn || function(v) {
      return g.outEdges(v);
    }
  );
}
function runFloydWarshall(g, weightFn, edgeFn) {
  var results = {}, nodes = g.nodes();
  return nodes.forEach(function(v) {
    results[v] = {}, results[v][v] = { distance: 0 }, nodes.forEach(function(w) {
      v !== w && (results[v][w] = { distance: Number.POSITIVE_INFINITY });
    }), edgeFn(v).forEach(function(edge) {
      var w = edge.v === v ? edge.w : edge.v, d2 = weightFn(edge);
      results[v][w] = { distance: d2, predecessor: v };
    });
  }), nodes.forEach(function(k) {
    var rowK = results[k];
    nodes.forEach(function(i2) {
      var rowI = results[i2];
      nodes.forEach(function(j) {
        var ik = rowI[k], kj = rowK[j], ij = rowI[j], altDistance = ik.distance + kj.distance;
        altDistance < ij.distance && (ij.distance = altDistance, ij.predecessor = kj.predecessor);
      });
    });
  }), results;
}
function topsort$1(g) {
  var visited = {}, stack = {}, results = [];
  function visit(node2) {
    if (Object.hasOwn(stack, node2))
      throw new CycleException();
    Object.hasOwn(visited, node2) || (stack[node2] = !0, visited[node2] = !0, g.predecessors(node2).forEach(visit), delete stack[node2], results.push(node2));
  }
  if (g.sinks().forEach(visit), Object.keys(visited).length !== g.nodeCount())
    throw new CycleException();
  return results;
}
class CycleException extends Error {
  constructor() {
    super(...arguments);
  }
}
var topsort_1 = topsort$1;
topsort$1.CycleException = CycleException;
var topsort = topsort_1, isAcyclic_1 = isAcyclic;
function isAcyclic(g) {
  try {
    topsort(g);
  } catch (e2) {
    if (e2 instanceof topsort.CycleException)
      return !1;
    throw e2;
  }
  return !0;
}
var dfs_1 = dfs$3;
function dfs$3(g, vs, order2) {
  Array.isArray(vs) || (vs = [vs]);
  var navigation = g.isDirected() ? (v) => g.successors(v) : (v) => g.neighbors(v), orderFunc = order2 === "post" ? postOrderDfs : preOrderDfs, acc = [], visited = {};
  return vs.forEach((v) => {
    if (!g.hasNode(v))
      throw new Error("Graph does not have node: " + v);
    orderFunc(v, navigation, visited, acc);
  }), acc;
}
function postOrderDfs(v, navigation, visited, acc) {
  for (var stack = [[v, !1]]; stack.length > 0; ) {
    var curr = stack.pop();
    curr[1] ? acc.push(curr[0]) : Object.hasOwn(visited, curr[0]) || (visited[curr[0]] = !0, stack.push([curr[0], !0]), forEachRight(navigation(curr[0]), (w) => stack.push([w, !1])));
  }
}
function preOrderDfs(v, navigation, visited, acc) {
  for (var stack = [v]; stack.length > 0; ) {
    var curr = stack.pop();
    Object.hasOwn(visited, curr) || (visited[curr] = !0, acc.push(curr), forEachRight(navigation(curr), (w) => stack.push(w)));
  }
}
function forEachRight(array2, iteratee) {
  for (var length = array2.length; length--; )
    iteratee(array2[length], length, array2);
  return array2;
}
var dfs$2 = dfs_1, postorder_1 = postorder$2;
function postorder$2(g, vs) {
  return dfs$2(g, vs, "post");
}
var dfs$1 = dfs_1, preorder_1 = preorder$1;
function preorder$1(g, vs) {
  return dfs$1(g, vs, "pre");
}
var Graph$8 = graph, PriorityQueue2 = priorityQueue, prim_1 = prim;
function prim(g, weightFunc) {
  var result = new Graph$8(), parents = {}, pq = new PriorityQueue2(), v;
  function updateNeighbors(edge) {
    var w = edge.v === v ? edge.w : edge.v, pri = pq.priority(w);
    if (pri !== void 0) {
      var edgeWeight = weightFunc(edge);
      edgeWeight < pri && (parents[w] = v, pq.decrease(w, edgeWeight));
    }
  }
  if (g.nodeCount() === 0)
    return result;
  g.nodes().forEach(function(v2) {
    pq.add(v2, Number.POSITIVE_INFINITY), result.setNode(v2);
  }), pq.decrease(g.nodes()[0], 0);
  for (var init = !1; pq.size() > 0; ) {
    if (v = pq.removeMin(), Object.hasOwn(parents, v))
      result.setEdge(v, parents[v]);
    else {
      if (init)
        throw new Error("Input graph is not connected: " + g);
      init = !0;
    }
    g.nodeEdges(v).forEach(updateNeighbors);
  }
  return result;
}
var alg = {
  components: components_1,
  dijkstra: dijkstra_1,
  dijkstraAll: dijkstraAll_1,
  findCycles: findCycles_1,
  floydWarshall: floydWarshall_1,
  isAcyclic: isAcyclic_1,
  postorder: postorder_1,
  preorder: preorder_1,
  prim: prim_1,
  tarjan: tarjan_1,
  topsort: topsort_1
}, lib = lib$1, graphlib = {
  Graph: lib.Graph,
  json,
  alg,
  version: lib.version
};
let List$1 = class {
  constructor() {
    let sentinel = {};
    sentinel._next = sentinel._prev = sentinel, this._sentinel = sentinel;
  }
  dequeue() {
    let sentinel = this._sentinel, entry = sentinel._prev;
    if (entry !== sentinel)
      return unlink(entry), entry;
  }
  enqueue(entry) {
    let sentinel = this._sentinel;
    entry._prev && entry._next && unlink(entry), entry._next = sentinel._next, sentinel._next._prev = entry, sentinel._next = entry, entry._prev = sentinel;
  }
  toString() {
    let strs = [], sentinel = this._sentinel, curr = sentinel._prev;
    for (; curr !== sentinel; )
      strs.push(JSON.stringify(curr, filterOutLinks)), curr = curr._prev;
    return "[" + strs.join(", ") + "]";
  }
};
function unlink(entry) {
  entry._prev._next = entry._next, entry._next._prev = entry._prev, delete entry._next, delete entry._prev;
}
function filterOutLinks(k, v) {
  if (k !== "_next" && k !== "_prev")
    return v;
}
var list = List$1;
let Graph$7 = graphlib.Graph, List2 = list;
var greedyFas = greedyFAS$1;
let DEFAULT_WEIGHT_FN = () => 1;
function greedyFAS$1(g, weightFn) {
  if (g.nodeCount() <= 1)
    return [];
  let state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);
  return doGreedyFAS(state.graph, state.buckets, state.zeroIdx).flatMap((e2) => g.outEdges(e2.v, e2.w));
}
function doGreedyFAS(g, buckets, zeroIdx) {
  let results = [], sources = buckets[buckets.length - 1], sinks = buckets[0], entry;
  for (; g.nodeCount(); ) {
    for (; entry = sinks.dequeue(); )
      removeNode(g, buckets, zeroIdx, entry);
    for (; entry = sources.dequeue(); )
      removeNode(g, buckets, zeroIdx, entry);
    if (g.nodeCount()) {
      for (let i2 = buckets.length - 2; i2 > 0; --i2)
        if (entry = buckets[i2].dequeue(), entry) {
          results = results.concat(removeNode(g, buckets, zeroIdx, entry, !0));
          break;
        }
    }
  }
  return results;
}
function removeNode(g, buckets, zeroIdx, entry, collectPredecessors) {
  let results = collectPredecessors ? [] : void 0;
  return g.inEdges(entry.v).forEach((edge) => {
    let weight = g.edge(edge), uEntry = g.node(edge.v);
    collectPredecessors && results.push({ v: edge.v, w: edge.w }), uEntry.out -= weight, assignBucket(buckets, zeroIdx, uEntry);
  }), g.outEdges(entry.v).forEach((edge) => {
    let weight = g.edge(edge), w = edge.w, wEntry = g.node(w);
    wEntry.in -= weight, assignBucket(buckets, zeroIdx, wEntry);
  }), g.removeNode(entry.v), results;
}
function buildState(g, weightFn) {
  let fasGraph = new Graph$7(), maxIn = 0, maxOut = 0;
  g.nodes().forEach((v) => {
    fasGraph.setNode(v, { v, in: 0, out: 0 });
  }), g.edges().forEach((e2) => {
    let prevWeight = fasGraph.edge(e2.v, e2.w) || 0, weight = weightFn(e2), edgeWeight = prevWeight + weight;
    fasGraph.setEdge(e2.v, e2.w, edgeWeight), maxOut = Math.max(maxOut, fasGraph.node(e2.v).out += weight), maxIn = Math.max(maxIn, fasGraph.node(e2.w).in += weight);
  });
  let buckets = range$1(maxOut + maxIn + 3).map(() => new List2()), zeroIdx = maxIn + 1;
  return fasGraph.nodes().forEach((v) => {
    assignBucket(buckets, zeroIdx, fasGraph.node(v));
  }), { graph: fasGraph, buckets, zeroIdx };
}
function assignBucket(buckets, zeroIdx, entry) {
  entry.out ? entry.in ? buckets[entry.out - entry.in + zeroIdx].enqueue(entry) : buckets[buckets.length - 1].enqueue(entry) : buckets[0].enqueue(entry);
}
function range$1(limit) {
  const range2 = [];
  for (let i2 = 0; i2 < limit; i2++)
    range2.push(i2);
  return range2;
}
let Graph$6 = graphlib.Graph;
var util$d = {
  addBorderNode: addBorderNode$1,
  addDummyNode,
  applyWithChunking: applyWithChunking$1,
  asNonCompoundGraph,
  buildLayerMatrix,
  intersectRect,
  mapValues,
  maxRank,
  normalizeRanks: normalizeRanks$1,
  notime,
  partition,
  pick,
  predecessorWeights,
  range,
  removeEmptyRanks: removeEmptyRanks$1,
  simplify: simplify$1,
  successorWeights,
  time,
  uniqueId: uniqueId$1,
  zipObject: zipObject$1
};
function addDummyNode(g, type, attrs, name) {
  let v;
  do
    v = uniqueId$1(name);
  while (g.hasNode(v));
  return attrs.dummy = type, g.setNode(v, attrs), v;
}
function simplify$1(g) {
  let simplified = new Graph$6().setGraph(g.graph());
  return g.nodes().forEach((v) => simplified.setNode(v, g.node(v))), g.edges().forEach((e2) => {
    let simpleLabel = simplified.edge(e2.v, e2.w) || { weight: 0, minlen: 1 }, label2 = g.edge(e2);
    simplified.setEdge(e2.v, e2.w, {
      weight: simpleLabel.weight + label2.weight,
      minlen: Math.max(simpleLabel.minlen, label2.minlen)
    });
  }), simplified;
}
function asNonCompoundGraph(g) {
  let simplified = new Graph$6({ multigraph: g.isMultigraph() }).setGraph(g.graph());
  return g.nodes().forEach((v) => {
    g.children(v).length || simplified.setNode(v, g.node(v));
  }), g.edges().forEach((e2) => {
    simplified.setEdge(e2, g.edge(e2));
  }), simplified;
}
function successorWeights(g) {
  let weightMap = g.nodes().map((v) => {
    let sucs = {};
    return g.outEdges(v).forEach((e2) => {
      sucs[e2.w] = (sucs[e2.w] || 0) + g.edge(e2).weight;
    }), sucs;
  });
  return zipObject$1(g.nodes(), weightMap);
}
function predecessorWeights(g) {
  let weightMap = g.nodes().map((v) => {
    let preds = {};
    return g.inEdges(v).forEach((e2) => {
      preds[e2.v] = (preds[e2.v] || 0) + g.edge(e2).weight;
    }), preds;
  });
  return zipObject$1(g.nodes(), weightMap);
}
function intersectRect(rect, point2) {
  let x2 = rect.x, y2 = rect.y, dx = point2.x - x2, dy = point2.y - y2, w = rect.width / 2, h = rect.height / 2;
  if (!dx && !dy)
    throw new Error("Not possible to find intersection inside of the rectangle");
  let sx, sy;
  return Math.abs(dy) * w > Math.abs(dx) * h ? (dy < 0 && (h = -h), sx = h * dx / dy, sy = h) : (dx < 0 && (w = -w), sx = w, sy = w * dy / dx), { x: x2 + sx, y: y2 + sy };
}
function buildLayerMatrix(g) {
  let layering = range(maxRank(g) + 1).map(() => []);
  return g.nodes().forEach((v) => {
    let node2 = g.node(v), rank2 = node2.rank;
    rank2 !== void 0 && (layering[rank2][node2.order] = v);
  }), layering;
}
function normalizeRanks$1(g) {
  let nodeRanks = g.nodes().map((v) => {
    let rank2 = g.node(v).rank;
    return rank2 === void 0 ? Number.MAX_VALUE : rank2;
  }), min2 = applyWithChunking$1(Math.min, nodeRanks);
  g.nodes().forEach((v) => {
    let node2 = g.node(v);
    Object.hasOwn(node2, "rank") && (node2.rank -= min2);
  });
}
function removeEmptyRanks$1(g) {
  let nodeRanks = g.nodes().map((v) => g.node(v).rank), offset = applyWithChunking$1(Math.min, nodeRanks), layers = [];
  g.nodes().forEach((v) => {
    let rank2 = g.node(v).rank - offset;
    layers[rank2] || (layers[rank2] = []), layers[rank2].push(v);
  });
  let delta = 0, nodeRankFactor = g.graph().nodeRankFactor;
  Array.from(layers).forEach((vs, i2) => {
    vs === void 0 && i2 % nodeRankFactor !== 0 ? --delta : vs !== void 0 && delta && vs.forEach((v) => g.node(v).rank += delta);
  });
}
function addBorderNode$1(g, prefix, rank2, order2) {
  let node2 = {
    width: 0,
    height: 0
  };
  return arguments.length >= 4 && (node2.rank = rank2, node2.order = order2), addDummyNode(g, "border", node2, prefix);
}
function splitToChunks(array2, chunkSize = CHUNKING_THRESHOLD) {
  const chunks = [];
  for (let i2 = 0; i2 < array2.length; i2 += chunkSize) {
    const chunk = array2.slice(i2, i2 + chunkSize);
    chunks.push(chunk);
  }
  return chunks;
}
const CHUNKING_THRESHOLD = 65535;
function applyWithChunking$1(fn, argsArray) {
  if (argsArray.length > CHUNKING_THRESHOLD) {
    const chunks = splitToChunks(argsArray);
    return fn.apply(null, chunks.map((chunk) => fn.apply(null, chunk)));
  } else
    return fn.apply(null, argsArray);
}
function maxRank(g) {
  const nodeRanks = g.nodes().map((v) => {
    let rank2 = g.node(v).rank;
    return rank2 === void 0 ? Number.MIN_VALUE : rank2;
  });
  return applyWithChunking$1(Math.max, nodeRanks);
}
function partition(collection, fn) {
  let result = { lhs: [], rhs: [] };
  return collection.forEach((value) => {
    fn(value) ? result.lhs.push(value) : result.rhs.push(value);
  }), result;
}
function time(name, fn) {
  let start = Date.now();
  try {
    return fn();
  } finally {
    console.log(name + " time: " + (Date.now() - start) + "ms");
  }
}
function notime(name, fn) {
  return fn();
}
let idCounter = 0;
function uniqueId$1(prefix) {
  var id2 = ++idCounter;
  return toString(prefix) + id2;
}
function range(start, limit, step = 1) {
  limit == null && (limit = start, start = 0);
  let endCon = (i2) => i2 < limit;
  step < 0 && (endCon = (i2) => limit < i2);
  const range2 = [];
  for (let i2 = start; endCon(i2); i2 += step)
    range2.push(i2);
  return range2;
}
function pick(source, keys2) {
  const dest = {};
  for (const key of keys2)
    source[key] !== void 0 && (dest[key] = source[key]);
  return dest;
}
function mapValues(obj, funcOrProp) {
  let func = funcOrProp;
  return typeof funcOrProp == "string" && (func = (val) => val[funcOrProp]), Object.entries(obj).reduce((acc, [k, v]) => (acc[k] = func(v, k), acc), {});
}
function zipObject$1(props2, values) {
  return props2.reduce((acc, key, i2) => (acc[key] = values[i2], acc), {});
}
let greedyFAS = greedyFas, uniqueId = util$d.uniqueId;
var acyclic$1 = {
  run: run$2,
  undo: undo$2
};
function run$2(g) {
  (g.graph().acyclicer === "greedy" ? greedyFAS(g, weightFn(g)) : dfsFAS(g)).forEach((e2) => {
    let label2 = g.edge(e2);
    g.removeEdge(e2), label2.forwardName = e2.name, label2.reversed = !0, g.setEdge(e2.w, e2.v, label2, uniqueId("rev"));
  });
  function weightFn(g2) {
    return (e2) => g2.edge(e2).weight;
  }
}
function dfsFAS(g) {
  let fas = [], stack = {}, visited = {};
  function dfs2(v) {
    Object.hasOwn(visited, v) || (visited[v] = !0, stack[v] = !0, g.outEdges(v).forEach((e2) => {
      Object.hasOwn(stack, e2.w) ? fas.push(e2) : dfs2(e2.w);
    }), delete stack[v]);
  }
  return g.nodes().forEach(dfs2), fas;
}
function undo$2(g) {
  g.edges().forEach((e2) => {
    let label2 = g.edge(e2);
    if (label2.reversed) {
      g.removeEdge(e2);
      let forwardName = label2.forwardName;
      delete label2.reversed, delete label2.forwardName, g.setEdge(e2.w, e2.v, label2, forwardName);
    }
  });
}
let util$c = util$d;
var normalize$1 = {
  run: run$1,
  undo: undo$1
};
function run$1(g) {
  g.graph().dummyChains = [], g.edges().forEach((edge) => normalizeEdge(g, edge));
}
function normalizeEdge(g, e2) {
  let v = e2.v, vRank = g.node(v).rank, w = e2.w, wRank = g.node(w).rank, name = e2.name, edgeLabel2 = g.edge(e2), labelRank = edgeLabel2.labelRank;
  if (wRank === vRank + 1) return;
  g.removeEdge(e2);
  let dummy, attrs, i2;
  for (i2 = 0, ++vRank; vRank < wRank; ++i2, ++vRank)
    edgeLabel2.points = [], attrs = {
      width: 0,
      height: 0,
      edgeLabel: edgeLabel2,
      edgeObj: e2,
      rank: vRank
    }, dummy = util$c.addDummyNode(g, "edge", attrs, "_d"), vRank === labelRank && (attrs.width = edgeLabel2.width, attrs.height = edgeLabel2.height, attrs.dummy = "edge-label", attrs.labelpos = edgeLabel2.labelpos), g.setEdge(v, dummy, { weight: edgeLabel2.weight }, name), i2 === 0 && g.graph().dummyChains.push(dummy), v = dummy;
  g.setEdge(v, w, { weight: edgeLabel2.weight }, name);
}
function undo$1(g) {
  g.graph().dummyChains.forEach((v) => {
    let node2 = g.node(v), origLabel = node2.edgeLabel, w;
    for (g.setEdge(node2.edgeObj, origLabel); node2.dummy; )
      w = g.successors(v)[0], g.removeNode(v), origLabel.points.push({ x: node2.x, y: node2.y }), node2.dummy === "edge-label" && (origLabel.x = node2.x, origLabel.y = node2.y, origLabel.width = node2.width, origLabel.height = node2.height), v = w, node2 = g.node(v);
  });
}
const { applyWithChunking } = util$d;
var util$b = {
  longestPath: longestPath$1,
  slack: slack$2
};
function longestPath$1(g) {
  var visited = {};
  function dfs2(v) {
    var label2 = g.node(v);
    if (Object.hasOwn(visited, v))
      return label2.rank;
    visited[v] = !0;
    let outEdgesMinLens = g.outEdges(v).map((e2) => e2 == null ? Number.POSITIVE_INFINITY : dfs2(e2.w) - g.edge(e2).minlen);
    var rank2 = applyWithChunking(Math.min, outEdgesMinLens);
    return rank2 === Number.POSITIVE_INFINITY && (rank2 = 0), label2.rank = rank2;
  }
  g.sources().forEach(dfs2);
}
function slack$2(g, e2) {
  return g.node(e2.w).rank - g.node(e2.v).rank - g.edge(e2).minlen;
}
var Graph$5 = graphlib.Graph, slack$1 = util$b.slack, feasibleTree_1 = feasibleTree$2;
function feasibleTree$2(g) {
  var t2 = new Graph$5({ directed: !1 }), start = g.nodes()[0], size = g.nodeCount();
  t2.setNode(start, {});
  for (var edge, delta; tightTree(t2, g) < size; )
    edge = findMinSlackEdge(t2, g), delta = t2.hasNode(edge.v) ? slack$1(g, edge) : -slack$1(g, edge), shiftRanks(t2, g, delta);
  return t2;
}
function tightTree(t2, g) {
  function dfs2(v) {
    g.nodeEdges(v).forEach((e2) => {
      var edgeV = e2.v, w = v === edgeV ? e2.w : edgeV;
      !t2.hasNode(w) && !slack$1(g, e2) && (t2.setNode(w, {}), t2.setEdge(v, w, {}), dfs2(w));
    });
  }
  return t2.nodes().forEach(dfs2), t2.nodeCount();
}
function findMinSlackEdge(t2, g) {
  return g.edges().reduce((acc, edge) => {
    let edgeSlack = Number.POSITIVE_INFINITY;
    return t2.hasNode(edge.v) !== t2.hasNode(edge.w) && (edgeSlack = slack$1(g, edge)), edgeSlack < acc[0] ? [edgeSlack, edge] : acc;
  }, [Number.POSITIVE_INFINITY, null])[1];
}
function shiftRanks(t2, g, delta) {
  t2.nodes().forEach((v) => g.node(v).rank += delta);
}
var feasibleTree$1 = feasibleTree_1, slack = util$b.slack, initRank = util$b.longestPath, preorder = graphlib.alg.preorder, postorder$1 = graphlib.alg.postorder, simplify = util$d.simplify, networkSimplex_1 = networkSimplex$1;
networkSimplex$1.initLowLimValues = initLowLimValues;
networkSimplex$1.initCutValues = initCutValues;
networkSimplex$1.calcCutValue = calcCutValue;
networkSimplex$1.leaveEdge = leaveEdge;
networkSimplex$1.enterEdge = enterEdge;
networkSimplex$1.exchangeEdges = exchangeEdges;
function networkSimplex$1(g) {
  g = simplify(g), initRank(g);
  var t2 = feasibleTree$1(g);
  initLowLimValues(t2), initCutValues(t2, g);
  for (var e2, f2; e2 = leaveEdge(t2); )
    f2 = enterEdge(t2, g, e2), exchangeEdges(t2, g, e2, f2);
}
function initCutValues(t2, g) {
  var vs = postorder$1(t2, t2.nodes());
  vs = vs.slice(0, vs.length - 1), vs.forEach((v) => assignCutValue(t2, g, v));
}
function assignCutValue(t2, g, child) {
  var childLab = t2.node(child), parent = childLab.parent;
  t2.edge(child, parent).cutvalue = calcCutValue(t2, g, child);
}
function calcCutValue(t2, g, child) {
  var childLab = t2.node(child), parent = childLab.parent, childIsTail = !0, graphEdge = g.edge(child, parent), cutValue = 0;
  return graphEdge || (childIsTail = !1, graphEdge = g.edge(parent, child)), cutValue = graphEdge.weight, g.nodeEdges(child).forEach((e2) => {
    var isOutEdge = e2.v === child, other = isOutEdge ? e2.w : e2.v;
    if (other !== parent) {
      var pointsToHead = isOutEdge === childIsTail, otherWeight = g.edge(e2).weight;
      if (cutValue += pointsToHead ? otherWeight : -otherWeight, isTreeEdge(t2, child, other)) {
        var otherCutValue = t2.edge(child, other).cutvalue;
        cutValue += pointsToHead ? -otherCutValue : otherCutValue;
      }
    }
  }), cutValue;
}
function initLowLimValues(tree, root2) {
  arguments.length < 2 && (root2 = tree.nodes()[0]), dfsAssignLowLim(tree, {}, 1, root2);
}
function dfsAssignLowLim(tree, visited, nextLim, v, parent) {
  var low = nextLim, label2 = tree.node(v);
  return visited[v] = !0, tree.neighbors(v).forEach((w) => {
    Object.hasOwn(visited, w) || (nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v));
  }), label2.low = low, label2.lim = nextLim++, parent ? label2.parent = parent : delete label2.parent, nextLim;
}
function leaveEdge(tree) {
  return tree.edges().find((e2) => tree.edge(e2).cutvalue < 0);
}
function enterEdge(t2, g, edge) {
  var v = edge.v, w = edge.w;
  g.hasEdge(v, w) || (v = edge.w, w = edge.v);
  var vLabel = t2.node(v), wLabel = t2.node(w), tailLabel = vLabel, flip = !1;
  vLabel.lim > wLabel.lim && (tailLabel = wLabel, flip = !0);
  var candidates = g.edges().filter((edge2) => flip === isDescendant(t2, t2.node(edge2.v), tailLabel) && flip !== isDescendant(t2, t2.node(edge2.w), tailLabel));
  return candidates.reduce((acc, edge2) => slack(g, edge2) < slack(g, acc) ? edge2 : acc);
}
function exchangeEdges(t2, g, e2, f2) {
  var v = e2.v, w = e2.w;
  t2.removeEdge(v, w), t2.setEdge(f2.v, f2.w, {}), initLowLimValues(t2), initCutValues(t2, g), updateRanks(t2, g);
}
function updateRanks(t2, g) {
  var root2 = t2.nodes().find((v) => !g.node(v).parent), vs = preorder(t2, root2);
  vs = vs.slice(1), vs.forEach((v) => {
    var parent = t2.node(v).parent, edge = g.edge(v, parent), flipped = !1;
    edge || (edge = g.edge(parent, v), flipped = !0), g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
  });
}
function isTreeEdge(tree, u2, v) {
  return tree.hasEdge(u2, v);
}
function isDescendant(tree, vLabel, rootLabel) {
  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
}
var rankUtil = util$b, longestPath = rankUtil.longestPath, feasibleTree = feasibleTree_1, networkSimplex = networkSimplex_1, rank_1 = rank$1;
function rank$1(g) {
  switch (g.graph().ranker) {
    case "network-simplex":
      networkSimplexRanker(g);
      break;
    case "tight-tree":
      tightTreeRanker(g);
      break;
    case "longest-path":
      longestPathRanker(g);
      break;
    default:
      networkSimplexRanker(g);
  }
}
var longestPathRanker = longestPath;
function tightTreeRanker(g) {
  longestPath(g), feasibleTree(g);
}
function networkSimplexRanker(g) {
  networkSimplex(g);
}
var parentDummyChains_1 = parentDummyChains$1;
function parentDummyChains$1(g) {
  let postorderNums = postorder(g);
  g.graph().dummyChains.forEach((v) => {
    let node2 = g.node(v), edgeObj = node2.edgeObj, pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w), path = pathData.path, lca = pathData.lca, pathIdx = 0, pathV = path[pathIdx], ascending = !0;
    for (; v !== edgeObj.w; ) {
      if (node2 = g.node(v), ascending) {
        for (; (pathV = path[pathIdx]) !== lca && g.node(pathV).maxRank < node2.rank; )
          pathIdx++;
        pathV === lca && (ascending = !1);
      }
      if (!ascending) {
        for (; pathIdx < path.length - 1 && g.node(pathV = path[pathIdx + 1]).minRank <= node2.rank; )
          pathIdx++;
        pathV = path[pathIdx];
      }
      g.setParent(v, pathV), v = g.successors(v)[0];
    }
  });
}
function findPath(g, postorderNums, v, w) {
  let vPath = [], wPath = [], low = Math.min(postorderNums[v].low, postorderNums[w].low), lim = Math.max(postorderNums[v].lim, postorderNums[w].lim), parent, lca;
  parent = v;
  do
    parent = g.parent(parent), vPath.push(parent);
  while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
  for (lca = parent, parent = w; (parent = g.parent(parent)) !== lca; )
    wPath.push(parent);
  return { path: vPath.concat(wPath.reverse()), lca };
}
function postorder(g) {
  let result = {}, lim = 0;
  function dfs2(v) {
    let low = lim;
    g.children(v).forEach(dfs2), result[v] = { low, lim: lim++ };
  }
  return g.children().forEach(dfs2), result;
}
let util$a = util$d;
var nestingGraph$1 = {
  run,
  cleanup
};
function run(g) {
  let root2 = util$a.addDummyNode(g, "root", {}, "_root"), depths = treeDepths(g), depthsArr = Object.values(depths), height = util$a.applyWithChunking(Math.max, depthsArr) - 1, nodeSep = 2 * height + 1;
  g.graph().nestingRoot = root2, g.edges().forEach((e2) => g.edge(e2).minlen *= nodeSep);
  let weight = sumWeights(g) + 1;
  g.children().forEach((child) => dfs(g, root2, nodeSep, weight, height, depths, child)), g.graph().nodeRankFactor = nodeSep;
}
function dfs(g, root2, nodeSep, weight, height, depths, v) {
  let children = g.children(v);
  if (!children.length) {
    v !== root2 && g.setEdge(root2, v, { weight: 0, minlen: nodeSep });
    return;
  }
  let top = util$a.addBorderNode(g, "_bt"), bottom = util$a.addBorderNode(g, "_bb"), label2 = g.node(v);
  g.setParent(top, v), label2.borderTop = top, g.setParent(bottom, v), label2.borderBottom = bottom, children.forEach((child) => {
    dfs(g, root2, nodeSep, weight, height, depths, child);
    let childNode = g.node(child), childTop = childNode.borderTop ? childNode.borderTop : child, childBottom = childNode.borderBottom ? childNode.borderBottom : child, thisWeight = childNode.borderTop ? weight : 2 * weight, minlen = childTop !== childBottom ? 1 : height - depths[v] + 1;
    g.setEdge(top, childTop, {
      weight: thisWeight,
      minlen,
      nestingEdge: !0
    }), g.setEdge(childBottom, bottom, {
      weight: thisWeight,
      minlen,
      nestingEdge: !0
    });
  }), g.parent(v) || g.setEdge(root2, top, { weight: 0, minlen: height + depths[v] });
}
function treeDepths(g) {
  var depths = {};
  function dfs2(v, depth) {
    var children = g.children(v);
    children && children.length && children.forEach((child) => dfs2(child, depth + 1)), depths[v] = depth;
  }
  return g.children().forEach((v) => dfs2(v, 1)), depths;
}
function sumWeights(g) {
  return g.edges().reduce((acc, e2) => acc + g.edge(e2).weight, 0);
}
function cleanup(g) {
  var graphLabel = g.graph();
  g.removeNode(graphLabel.nestingRoot), delete graphLabel.nestingRoot, g.edges().forEach((e2) => {
    var edge = g.edge(e2);
    edge.nestingEdge && g.removeEdge(e2);
  });
}
let util$9 = util$d;
var addBorderSegments_1 = addBorderSegments$1;
function addBorderSegments$1(g) {
  function dfs2(v) {
    let children = g.children(v), node2 = g.node(v);
    if (children.length && children.forEach(dfs2), Object.hasOwn(node2, "minRank")) {
      node2.borderLeft = [], node2.borderRight = [];
      for (let rank2 = node2.minRank, maxRank2 = node2.maxRank + 1; rank2 < maxRank2; ++rank2)
        addBorderNode(g, "borderLeft", "_bl", v, node2, rank2), addBorderNode(g, "borderRight", "_br", v, node2, rank2);
    }
  }
  g.children().forEach(dfs2);
}
function addBorderNode(g, prop, prefix, sg, sgNode, rank2) {
  let label2 = { width: 0, height: 0, rank: rank2, borderType: prop }, prev = sgNode[prop][rank2 - 1], curr = util$9.addDummyNode(g, "border", label2, prefix);
  sgNode[prop][rank2] = curr, g.setParent(curr, sg), prev && g.setEdge(prev, curr, { weight: 1 });
}
var coordinateSystem$1 = {
  adjust,
  undo
};
function adjust(g) {
  let rankDir = g.graph().rankdir.toLowerCase();
  (rankDir === "lr" || rankDir === "rl") && swapWidthHeight(g);
}
function undo(g) {
  let rankDir = g.graph().rankdir.toLowerCase();
  (rankDir === "bt" || rankDir === "rl") && reverseY(g), (rankDir === "lr" || rankDir === "rl") && (swapXY(g), swapWidthHeight(g));
}
function swapWidthHeight(g) {
  g.nodes().forEach((v) => swapWidthHeightOne(g.node(v))), g.edges().forEach((e2) => swapWidthHeightOne(g.edge(e2)));
}
function swapWidthHeightOne(attrs) {
  let w = attrs.width;
  attrs.width = attrs.height, attrs.height = w;
}
function reverseY(g) {
  g.nodes().forEach((v) => reverseYOne(g.node(v))), g.edges().forEach((e2) => {
    let edge = g.edge(e2);
    edge.points.forEach(reverseYOne), Object.hasOwn(edge, "y") && reverseYOne(edge);
  });
}
function reverseYOne(attrs) {
  attrs.y = -attrs.y;
}
function swapXY(g) {
  g.nodes().forEach((v) => swapXYOne(g.node(v))), g.edges().forEach((e2) => {
    let edge = g.edge(e2);
    edge.points.forEach(swapXYOne), Object.hasOwn(edge, "x") && swapXYOne(edge);
  });
}
function swapXYOne(attrs) {
  let x2 = attrs.x;
  attrs.x = attrs.y, attrs.y = x2;
}
let util$8 = util$d;
var initOrder_1 = initOrder$1;
function initOrder$1(g) {
  let visited = {}, simpleNodes = g.nodes().filter((v) => !g.children(v).length), simpleNodesRanks = simpleNodes.map((v) => g.node(v).rank), maxRank2 = util$8.applyWithChunking(Math.max, simpleNodesRanks), layers = util$8.range(maxRank2 + 1).map(() => []);
  function dfs2(v) {
    if (visited[v]) return;
    visited[v] = !0;
    let node2 = g.node(v);
    layers[node2.rank].push(v), g.successors(v).forEach(dfs2);
  }
  return simpleNodes.sort((a2, b2) => g.node(a2).rank - g.node(b2).rank).forEach(dfs2), layers;
}
let zipObject = util$d.zipObject;
var crossCount_1 = crossCount$1;
function crossCount$1(g, layering) {
  let cc = 0;
  for (let i2 = 1; i2 < layering.length; ++i2)
    cc += twoLayerCrossCount(g, layering[i2 - 1], layering[i2]);
  return cc;
}
function twoLayerCrossCount(g, northLayer, southLayer) {
  let southPos = zipObject(southLayer, southLayer.map((v, i2) => i2)), southEntries = northLayer.flatMap((v) => g.outEdges(v).map((e2) => ({ pos: southPos[e2.w], weight: g.edge(e2).weight })).sort((a2, b2) => a2.pos - b2.pos)), firstIndex = 1;
  for (; firstIndex < southLayer.length; ) firstIndex <<= 1;
  let treeSize = 2 * firstIndex - 1;
  firstIndex -= 1;
  let tree = new Array(treeSize).fill(0), cc = 0;
  return southEntries.forEach((entry) => {
    let index2 = entry.pos + firstIndex;
    tree[index2] += entry.weight;
    let weightSum = 0;
    for (; index2 > 0; )
      index2 % 2 && (weightSum += tree[index2 + 1]), index2 = index2 - 1 >> 1, tree[index2] += entry.weight;
    cc += entry.weight * weightSum;
  }), cc;
}
var barycenter_1 = barycenter$1;
function barycenter$1(g, movable = []) {
  return movable.map((v) => {
    let inV = g.inEdges(v);
    if (inV.length) {
      let result = inV.reduce((acc, e2) => {
        let edge = g.edge(e2), nodeU = g.node(e2.v);
        return {
          sum: acc.sum + edge.weight * nodeU.order,
          weight: acc.weight + edge.weight
        };
      }, { sum: 0, weight: 0 });
      return {
        v,
        barycenter: result.sum / result.weight,
        weight: result.weight
      };
    } else
      return { v };
  });
}
let util$7 = util$d;
var resolveConflicts_1 = resolveConflicts$1;
function resolveConflicts$1(entries, cg) {
  let mappedEntries = {};
  entries.forEach((entry, i2) => {
    let tmp = mappedEntries[entry.v] = {
      indegree: 0,
      in: [],
      out: [],
      vs: [entry.v],
      i: i2
    };
    entry.barycenter !== void 0 && (tmp.barycenter = entry.barycenter, tmp.weight = entry.weight);
  }), cg.edges().forEach((e2) => {
    let entryV = mappedEntries[e2.v], entryW = mappedEntries[e2.w];
    entryV !== void 0 && entryW !== void 0 && (entryW.indegree++, entryV.out.push(mappedEntries[e2.w]));
  });
  let sourceSet = Object.values(mappedEntries).filter((entry) => !entry.indegree);
  return doResolveConflicts(sourceSet);
}
function doResolveConflicts(sourceSet) {
  let entries = [];
  function handleIn(vEntry) {
    return (uEntry) => {
      uEntry.merged || (uEntry.barycenter === void 0 || vEntry.barycenter === void 0 || uEntry.barycenter >= vEntry.barycenter) && mergeEntries(vEntry, uEntry);
    };
  }
  function handleOut(vEntry) {
    return (wEntry) => {
      wEntry.in.push(vEntry), --wEntry.indegree === 0 && sourceSet.push(wEntry);
    };
  }
  for (; sourceSet.length; ) {
    let entry = sourceSet.pop();
    entries.push(entry), entry.in.reverse().forEach(handleIn(entry)), entry.out.forEach(handleOut(entry));
  }
  return entries.filter((entry) => !entry.merged).map((entry) => util$7.pick(entry, ["vs", "i", "barycenter", "weight"]));
}
function mergeEntries(target, source) {
  let sum = 0, weight = 0;
  target.weight && (sum += target.barycenter * target.weight, weight += target.weight), source.weight && (sum += source.barycenter * source.weight, weight += source.weight), target.vs = source.vs.concat(target.vs), target.barycenter = sum / weight, target.weight = weight, target.i = Math.min(source.i, target.i), source.merged = !0;
}
let util$6 = util$d;
var sort_1 = sort$1;
function sort$1(entries, biasRight) {
  let parts = util$6.partition(entries, (entry) => Object.hasOwn(entry, "barycenter")), sortable = parts.lhs, unsortable = parts.rhs.sort((a2, b2) => b2.i - a2.i), vs = [], sum = 0, weight = 0, vsIndex = 0;
  sortable.sort(compareWithBias(!!biasRight)), vsIndex = consumeUnsortable(vs, unsortable, vsIndex), sortable.forEach((entry) => {
    vsIndex += entry.vs.length, vs.push(entry.vs), sum += entry.barycenter * entry.weight, weight += entry.weight, vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
  });
  let result = { vs: vs.flat(!0) };
  return weight && (result.barycenter = sum / weight, result.weight = weight), result;
}
function consumeUnsortable(vs, unsortable, index2) {
  let last;
  for (; unsortable.length && (last = unsortable[unsortable.length - 1]).i <= index2; )
    unsortable.pop(), vs.push(last.vs), index2++;
  return index2;
}
function compareWithBias(bias) {
  return (entryV, entryW) => entryV.barycenter < entryW.barycenter ? -1 : entryV.barycenter > entryW.barycenter ? 1 : bias ? entryW.i - entryV.i : entryV.i - entryW.i;
}
let barycenter = barycenter_1, resolveConflicts = resolveConflicts_1, sort = sort_1;
var sortSubgraph_1 = sortSubgraph$1;
function sortSubgraph$1(g, v, cg, biasRight) {
  let movable = g.children(v), node2 = g.node(v), bl = node2 ? node2.borderLeft : void 0, br = node2 ? node2.borderRight : void 0, subgraphs = {};
  bl && (movable = movable.filter((w) => w !== bl && w !== br));
  let barycenters = barycenter(g, movable);
  barycenters.forEach((entry) => {
    if (g.children(entry.v).length) {
      let subgraphResult = sortSubgraph$1(g, entry.v, cg, biasRight);
      subgraphs[entry.v] = subgraphResult, Object.hasOwn(subgraphResult, "barycenter") && mergeBarycenters(entry, subgraphResult);
    }
  });
  let entries = resolveConflicts(barycenters, cg);
  expandSubgraphs(entries, subgraphs);
  let result = sort(entries, biasRight);
  if (bl && (result.vs = [bl, result.vs, br].flat(!0), g.predecessors(bl).length)) {
    let blPred = g.node(g.predecessors(bl)[0]), brPred = g.node(g.predecessors(br)[0]);
    Object.hasOwn(result, "barycenter") || (result.barycenter = 0, result.weight = 0), result.barycenter = (result.barycenter * result.weight + blPred.order + brPred.order) / (result.weight + 2), result.weight += 2;
  }
  return result;
}
function expandSubgraphs(entries, subgraphs) {
  entries.forEach((entry) => {
    entry.vs = entry.vs.flatMap((v) => subgraphs[v] ? subgraphs[v].vs : v);
  });
}
function mergeBarycenters(target, other) {
  target.barycenter !== void 0 ? (target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight), target.weight += other.weight) : (target.barycenter = other.barycenter, target.weight = other.weight);
}
let Graph$4 = graphlib.Graph, util$5 = util$d;
var buildLayerGraph_1 = buildLayerGraph$1;
function buildLayerGraph$1(g, rank2, relationship) {
  let root2 = createRootNode(g), result = new Graph$4({ compound: !0 }).setGraph({ root: root2 }).setDefaultNodeLabel((v) => g.node(v));
  return g.nodes().forEach((v) => {
    let node2 = g.node(v), parent = g.parent(v);
    (node2.rank === rank2 || node2.minRank <= rank2 && rank2 <= node2.maxRank) && (result.setNode(v), result.setParent(v, parent || root2), g[relationship](v).forEach((e2) => {
      let u2 = e2.v === v ? e2.w : e2.v, edge = result.edge(u2, v), weight = edge !== void 0 ? edge.weight : 0;
      result.setEdge(u2, v, { weight: g.edge(e2).weight + weight });
    }), Object.hasOwn(node2, "minRank") && result.setNode(v, {
      borderLeft: node2.borderLeft[rank2],
      borderRight: node2.borderRight[rank2]
    }));
  }), result;
}
function createRootNode(g) {
  for (var v; g.hasNode(v = util$5.uniqueId("_root")); ) ;
  return v;
}
var addSubgraphConstraints_1 = addSubgraphConstraints$1;
function addSubgraphConstraints$1(g, cg, vs) {
  let prev = {}, rootPrev;
  vs.forEach((v) => {
    let child = g.parent(v), parent, prevChild;
    for (; child; ) {
      if (parent = g.parent(child), parent ? (prevChild = prev[parent], prev[parent] = child) : (prevChild = rootPrev, rootPrev = child), prevChild && prevChild !== child) {
        cg.setEdge(prevChild, child);
        return;
      }
      child = parent;
    }
  });
}
let initOrder = initOrder_1, crossCount = crossCount_1, sortSubgraph = sortSubgraph_1, buildLayerGraph = buildLayerGraph_1, addSubgraphConstraints = addSubgraphConstraints_1, Graph$3 = graphlib.Graph, util$4 = util$d;
var order_1 = order$1;
function order$1(g, opts) {
  if (opts && typeof opts.customOrder == "function") {
    opts.customOrder(g, order$1);
    return;
  }
  let maxRank2 = util$4.maxRank(g), downLayerGraphs = buildLayerGraphs(g, util$4.range(1, maxRank2 + 1), "inEdges"), upLayerGraphs = buildLayerGraphs(g, util$4.range(maxRank2 - 1, -1, -1), "outEdges"), layering = initOrder(g);
  if (assignOrder(g, layering), opts && opts.disableOptimalOrderHeuristic)
    return;
  let bestCC = Number.POSITIVE_INFINITY, best;
  for (let i2 = 0, lastBest = 0; lastBest < 4; ++i2, ++lastBest) {
    sweepLayerGraphs(i2 % 2 ? downLayerGraphs : upLayerGraphs, i2 % 4 >= 2), layering = util$4.buildLayerMatrix(g);
    let cc = crossCount(g, layering);
    cc < bestCC && (lastBest = 0, best = Object.assign({}, layering), bestCC = cc);
  }
  assignOrder(g, best);
}
function buildLayerGraphs(g, ranks, relationship) {
  return ranks.map(function(rank2) {
    return buildLayerGraph(g, rank2, relationship);
  });
}
function sweepLayerGraphs(layerGraphs, biasRight) {
  let cg = new Graph$3();
  layerGraphs.forEach(function(lg) {
    let root2 = lg.graph().root, sorted = sortSubgraph(lg, root2, cg, biasRight);
    sorted.vs.forEach((v, i2) => lg.node(v).order = i2), addSubgraphConstraints(lg, cg, sorted.vs);
  });
}
function assignOrder(g, layering) {
  Object.values(layering).forEach((layer) => layer.forEach((v, i2) => g.node(v).order = i2));
}
let Graph$2 = graphlib.Graph, util$3 = util$d;
var bk = {
  positionX: positionX$1,
  findType1Conflicts,
  findType2Conflicts,
  addConflict,
  hasConflict,
  verticalAlignment,
  horizontalCompaction,
  alignCoordinates,
  findSmallestWidthAlignment,
  balance
};
function findType1Conflicts(g, layering) {
  let conflicts = {};
  function visitLayer(prevLayer, layer) {
    let k0 = 0, scanPos = 0, prevLayerLength = prevLayer.length, lastNode = layer[layer.length - 1];
    return layer.forEach((v, i2) => {
      let w = findOtherInnerSegmentNode(g, v), k1 = w ? g.node(w).order : prevLayerLength;
      (w || v === lastNode) && (layer.slice(scanPos, i2 + 1).forEach((scanNode) => {
        g.predecessors(scanNode).forEach((u2) => {
          let uLabel = g.node(u2), uPos = uLabel.order;
          (uPos < k0 || k1 < uPos) && !(uLabel.dummy && g.node(scanNode).dummy) && addConflict(conflicts, u2, scanNode);
        });
      }), scanPos = i2 + 1, k0 = k1);
    }), layer;
  }
  return layering.length && layering.reduce(visitLayer), conflicts;
}
function findType2Conflicts(g, layering) {
  let conflicts = {};
  function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
    let v;
    util$3.range(southPos, southEnd).forEach((i2) => {
      v = south[i2], g.node(v).dummy && g.predecessors(v).forEach((u2) => {
        let uNode = g.node(u2);
        uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder) && addConflict(conflicts, u2, v);
      });
    });
  }
  function visitLayer(north, south) {
    let prevNorthPos = -1, nextNorthPos, southPos = 0;
    return south.forEach((v, southLookahead) => {
      if (g.node(v).dummy === "border") {
        let predecessors = g.predecessors(v);
        predecessors.length && (nextNorthPos = g.node(predecessors[0]).order, scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos), southPos = southLookahead, prevNorthPos = nextNorthPos);
      }
      scan(south, southPos, south.length, nextNorthPos, north.length);
    }), south;
  }
  return layering.length && layering.reduce(visitLayer), conflicts;
}
function findOtherInnerSegmentNode(g, v) {
  if (g.node(v).dummy)
    return g.predecessors(v).find((u2) => g.node(u2).dummy);
}
function addConflict(conflicts, v, w) {
  if (v > w) {
    let tmp = v;
    v = w, w = tmp;
  }
  let conflictsV = conflicts[v];
  conflictsV || (conflicts[v] = conflictsV = {}), conflictsV[w] = !0;
}
function hasConflict(conflicts, v, w) {
  if (v > w) {
    let tmp = v;
    v = w, w = tmp;
  }
  return !!conflicts[v] && Object.hasOwn(conflicts[v], w);
}
function verticalAlignment(g, layering, conflicts, neighborFn) {
  let root2 = {}, align2 = {}, pos = {};
  return layering.forEach((layer) => {
    layer.forEach((v, order2) => {
      root2[v] = v, align2[v] = v, pos[v] = order2;
    });
  }), layering.forEach((layer) => {
    let prevIdx = -1;
    layer.forEach((v) => {
      let ws = neighborFn(v);
      if (ws.length) {
        ws = ws.sort((a2, b2) => pos[a2] - pos[b2]);
        let mp = (ws.length - 1) / 2;
        for (let i2 = Math.floor(mp), il = Math.ceil(mp); i2 <= il; ++i2) {
          let w = ws[i2];
          align2[v] === v && prevIdx < pos[w] && !hasConflict(conflicts, v, w) && (align2[w] = v, align2[v] = root2[v] = root2[w], prevIdx = pos[w]);
        }
      }
    });
  }), { root: root2, align: align2 };
}
function horizontalCompaction(g, layering, root2, align2, reverseSep) {
  let xs = {}, blockG = buildBlockGraph(g, layering, root2, reverseSep), borderType = reverseSep ? "borderLeft" : "borderRight";
  function iterate(setXsFunc, nextNodesFunc) {
    let stack = blockG.nodes(), elem = stack.pop(), visited = {};
    for (; elem; )
      visited[elem] ? setXsFunc(elem) : (visited[elem] = !0, stack.push(elem), stack = stack.concat(nextNodesFunc(elem))), elem = stack.pop();
  }
  function pass1(elem) {
    xs[elem] = blockG.inEdges(elem).reduce((acc, e2) => Math.max(acc, xs[e2.v] + blockG.edge(e2)), 0);
  }
  function pass2(elem) {
    let min2 = blockG.outEdges(elem).reduce((acc, e2) => Math.min(acc, xs[e2.w] - blockG.edge(e2)), Number.POSITIVE_INFINITY), node2 = g.node(elem);
    min2 !== Number.POSITIVE_INFINITY && node2.borderType !== borderType && (xs[elem] = Math.max(xs[elem], min2));
  }
  return iterate(pass1, blockG.predecessors.bind(blockG)), iterate(pass2, blockG.successors.bind(blockG)), Object.keys(align2).forEach((v) => xs[v] = xs[root2[v]]), xs;
}
function buildBlockGraph(g, layering, root2, reverseSep) {
  let blockGraph = new Graph$2(), graphLabel = g.graph(), sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);
  return layering.forEach((layer) => {
    let u2;
    layer.forEach((v) => {
      let vRoot = root2[v];
      if (blockGraph.setNode(vRoot), u2) {
        var uRoot = root2[u2], prevMax = blockGraph.edge(uRoot, vRoot);
        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u2), prevMax || 0));
      }
      u2 = v;
    });
  }), blockGraph;
}
function findSmallestWidthAlignment(g, xss) {
  return Object.values(xss).reduce((currentMinAndXs, xs) => {
    let max2 = Number.NEGATIVE_INFINITY, min2 = Number.POSITIVE_INFINITY;
    Object.entries(xs).forEach(([v, x2]) => {
      let halfWidth = width(g, v) / 2;
      max2 = Math.max(x2 + halfWidth, max2), min2 = Math.min(x2 - halfWidth, min2);
    });
    const newMin = max2 - min2;
    return newMin < currentMinAndXs[0] && (currentMinAndXs = [newMin, xs]), currentMinAndXs;
  }, [Number.POSITIVE_INFINITY, null])[1];
}
function alignCoordinates(xss, alignTo) {
  let alignToVals = Object.values(alignTo), alignToMin = util$3.applyWithChunking(Math.min, alignToVals), alignToMax = util$3.applyWithChunking(Math.max, alignToVals);
  ["u", "d"].forEach((vert) => {
    ["l", "r"].forEach((horiz) => {
      let alignment = vert + horiz, xs = xss[alignment];
      if (xs === alignTo) return;
      let xsVals = Object.values(xs), delta = alignToMin - util$3.applyWithChunking(Math.min, xsVals);
      horiz !== "l" && (delta = alignToMax - util$3.applyWithChunking(Math.max, xsVals)), delta && (xss[alignment] = util$3.mapValues(xs, (x2) => x2 + delta));
    });
  });
}
function balance(xss, align2) {
  return util$3.mapValues(xss.ul, (num, v) => {
    if (align2)
      return xss[align2.toLowerCase()][v];
    {
      let xs = Object.values(xss).map((xs2) => xs2[v]).sort((a2, b2) => a2 - b2);
      return (xs[1] + xs[2]) / 2;
    }
  });
}
function positionX$1(g) {
  let layering = util$3.buildLayerMatrix(g), conflicts = Object.assign(
    findType1Conflicts(g, layering),
    findType2Conflicts(g, layering)
  ), xss = {}, adjustedLayering;
  ["u", "d"].forEach((vert) => {
    adjustedLayering = vert === "u" ? layering : Object.values(layering).reverse(), ["l", "r"].forEach((horiz) => {
      horiz === "r" && (adjustedLayering = adjustedLayering.map((inner2) => Object.values(inner2).reverse()));
      let neighborFn = (vert === "u" ? g.predecessors : g.successors).bind(g), align2 = verticalAlignment(g, adjustedLayering, conflicts, neighborFn), xs = horizontalCompaction(
        g,
        adjustedLayering,
        align2.root,
        align2.align,
        horiz === "r"
      );
      horiz === "r" && (xs = util$3.mapValues(xs, (x2) => -x2)), xss[vert + horiz] = xs;
    });
  });
  let smallestWidth = findSmallestWidthAlignment(g, xss);
  return alignCoordinates(xss, smallestWidth), balance(xss, g.graph().align);
}
function sep(nodeSep, edgeSep, reverseSep) {
  return (g, v, w) => {
    let vLabel = g.node(v), wLabel = g.node(w), sum = 0, delta;
    if (sum += vLabel.width / 2, Object.hasOwn(vLabel, "labelpos"))
      switch (vLabel.labelpos.toLowerCase()) {
        case "l":
          delta = -vLabel.width / 2;
          break;
        case "r":
          delta = vLabel.width / 2;
          break;
      }
    if (delta && (sum += reverseSep ? delta : -delta), delta = 0, sum += (vLabel.dummy ? edgeSep : nodeSep) / 2, sum += (wLabel.dummy ? edgeSep : nodeSep) / 2, sum += wLabel.width / 2, Object.hasOwn(wLabel, "labelpos"))
      switch (wLabel.labelpos.toLowerCase()) {
        case "l":
          delta = wLabel.width / 2;
          break;
        case "r":
          delta = -wLabel.width / 2;
          break;
      }
    return delta && (sum += reverseSep ? delta : -delta), delta = 0, sum;
  };
}
function width(g, v) {
  return g.node(v).width;
}
let util$2 = util$d, positionX = bk.positionX;
var position_1 = position$1;
function position$1(g) {
  g = util$2.asNonCompoundGraph(g), positionY(g), Object.entries(positionX(g)).forEach(([v, x2]) => g.node(v).x = x2);
}
function positionY(g) {
  let layering = util$2.buildLayerMatrix(g), rankSep = g.graph().ranksep, prevY = 0;
  layering.forEach((layer) => {
    const maxHeight = layer.reduce((acc, v) => {
      const height = g.node(v).height;
      return acc > height ? acc : height;
    }, 0);
    layer.forEach((v) => g.node(v).y = prevY + maxHeight / 2), prevY += maxHeight + rankSep;
  });
}
let acyclic = acyclic$1, normalize = normalize$1, rank = rank_1, normalizeRanks = util$d.normalizeRanks, parentDummyChains = parentDummyChains_1, removeEmptyRanks = util$d.removeEmptyRanks, nestingGraph = nestingGraph$1, addBorderSegments = addBorderSegments_1, coordinateSystem = coordinateSystem$1, order = order_1, position = position_1, util$1 = util$d, Graph$1 = graphlib.Graph;
var layout_1 = layout$2;
function layout$2(g, opts) {
  let time2 = opts && opts.debugTiming ? util$1.time : util$1.notime;
  time2("layout", () => {
    let layoutGraph = time2("  buildLayoutGraph", () => buildLayoutGraph(g));
    time2("  runLayout", () => runLayout(layoutGraph, time2, opts)), time2("  updateInputGraph", () => updateInputGraph(g, layoutGraph));
  });
}
function runLayout(g, time2, opts) {
  time2("    makeSpaceForEdgeLabels", () => makeSpaceForEdgeLabels(g)), time2("    removeSelfEdges", () => removeSelfEdges(g)), time2("    acyclic", () => acyclic.run(g)), time2("    nestingGraph.run", () => nestingGraph.run(g)), time2("    rank", () => rank(util$1.asNonCompoundGraph(g))), time2("    injectEdgeLabelProxies", () => injectEdgeLabelProxies(g)), time2("    removeEmptyRanks", () => removeEmptyRanks(g)), time2("    nestingGraph.cleanup", () => nestingGraph.cleanup(g)), time2("    normalizeRanks", () => normalizeRanks(g)), time2("    assignRankMinMax", () => assignRankMinMax(g)), time2("    removeEdgeLabelProxies", () => removeEdgeLabelProxies(g)), time2("    normalize.run", () => normalize.run(g)), time2("    parentDummyChains", () => parentDummyChains(g)), time2("    addBorderSegments", () => addBorderSegments(g)), time2("    order", () => order(g, opts)), time2("    insertSelfEdges", () => insertSelfEdges(g)), time2("    adjustCoordinateSystem", () => coordinateSystem.adjust(g)), time2("    position", () => position(g)), time2("    positionSelfEdges", () => positionSelfEdges(g)), time2("    removeBorderNodes", () => removeBorderNodes(g)), time2("    normalize.undo", () => normalize.undo(g)), time2("    fixupEdgeLabelCoords", () => fixupEdgeLabelCoords(g)), time2("    undoCoordinateSystem", () => coordinateSystem.undo(g)), time2("    translateGraph", () => translateGraph(g)), time2("    assignNodeIntersects", () => assignNodeIntersects(g)), time2("    reversePoints", () => reversePointsForReversedEdges(g)), time2("    acyclic.undo", () => acyclic.undo(g));
}
function updateInputGraph(inputGraph, layoutGraph) {
  inputGraph.nodes().forEach((v) => {
    let inputLabel = inputGraph.node(v), layoutLabel = layoutGraph.node(v);
    inputLabel && (inputLabel.x = layoutLabel.x, inputLabel.y = layoutLabel.y, inputLabel.rank = layoutLabel.rank, layoutGraph.children(v).length && (inputLabel.width = layoutLabel.width, inputLabel.height = layoutLabel.height));
  }), inputGraph.edges().forEach((e2) => {
    let inputLabel = inputGraph.edge(e2), layoutLabel = layoutGraph.edge(e2);
    inputLabel.points = layoutLabel.points, Object.hasOwn(layoutLabel, "x") && (inputLabel.x = layoutLabel.x, inputLabel.y = layoutLabel.y);
  }), inputGraph.graph().width = layoutGraph.graph().width, inputGraph.graph().height = layoutGraph.graph().height;
}
let graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"], graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" }, graphAttrs = ["acyclicer", "ranker", "rankdir", "align"], nodeNumAttrs = ["width", "height"], nodeDefaults = { width: 0, height: 0 }, edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"], edgeDefaults = {
  minlen: 1,
  weight: 1,
  width: 0,
  height: 0,
  labeloffset: 10,
  labelpos: "r"
}, edgeAttrs = ["labelpos"];
function buildLayoutGraph(inputGraph) {
  let g = new Graph$1({ multigraph: !0, compound: !0 }), graph2 = canonicalize(inputGraph.graph());
  return g.setGraph(Object.assign(
    {},
    graphDefaults,
    selectNumberAttrs(graph2, graphNumAttrs),
    util$1.pick(graph2, graphAttrs)
  )), inputGraph.nodes().forEach((v) => {
    let node2 = canonicalize(inputGraph.node(v));
    const newNode = selectNumberAttrs(node2, nodeNumAttrs);
    Object.keys(nodeDefaults).forEach((k) => {
      newNode[k] === void 0 && (newNode[k] = nodeDefaults[k]);
    }), g.setNode(v, newNode), g.setParent(v, inputGraph.parent(v));
  }), inputGraph.edges().forEach((e2) => {
    let edge = canonicalize(inputGraph.edge(e2));
    g.setEdge(e2, Object.assign(
      {},
      edgeDefaults,
      selectNumberAttrs(edge, edgeNumAttrs),
      util$1.pick(edge, edgeAttrs)
    ));
  }), g;
}
function makeSpaceForEdgeLabels(g) {
  let graph2 = g.graph();
  graph2.ranksep /= 2, g.edges().forEach((e2) => {
    let edge = g.edge(e2);
    edge.minlen *= 2, edge.labelpos.toLowerCase() !== "c" && (graph2.rankdir === "TB" || graph2.rankdir === "BT" ? edge.width += edge.labeloffset : edge.height += edge.labeloffset);
  });
}
function injectEdgeLabelProxies(g) {
  g.edges().forEach((e2) => {
    let edge = g.edge(e2);
    if (edge.width && edge.height) {
      let v = g.node(e2.v), label2 = { rank: (g.node(e2.w).rank - v.rank) / 2 + v.rank, e: e2 };
      util$1.addDummyNode(g, "edge-proxy", label2, "_ep");
    }
  });
}
function assignRankMinMax(g) {
  let maxRank2 = 0;
  g.nodes().forEach((v) => {
    let node2 = g.node(v);
    node2.borderTop && (node2.minRank = g.node(node2.borderTop).rank, node2.maxRank = g.node(node2.borderBottom).rank, maxRank2 = Math.max(maxRank2, node2.maxRank));
  }), g.graph().maxRank = maxRank2;
}
function removeEdgeLabelProxies(g) {
  g.nodes().forEach((v) => {
    let node2 = g.node(v);
    node2.dummy === "edge-proxy" && (g.edge(node2.e).labelRank = node2.rank, g.removeNode(v));
  });
}
function translateGraph(g) {
  let minX = Number.POSITIVE_INFINITY, maxX = 0, minY = Number.POSITIVE_INFINITY, maxY = 0, graphLabel = g.graph(), marginX = graphLabel.marginx || 0, marginY = graphLabel.marginy || 0;
  function getExtremes(attrs) {
    let x2 = attrs.x, y2 = attrs.y, w = attrs.width, h = attrs.height;
    minX = Math.min(minX, x2 - w / 2), maxX = Math.max(maxX, x2 + w / 2), minY = Math.min(minY, y2 - h / 2), maxY = Math.max(maxY, y2 + h / 2);
  }
  g.nodes().forEach((v) => getExtremes(g.node(v))), g.edges().forEach((e2) => {
    let edge = g.edge(e2);
    Object.hasOwn(edge, "x") && getExtremes(edge);
  }), minX -= marginX, minY -= marginY, g.nodes().forEach((v) => {
    let node2 = g.node(v);
    node2.x -= minX, node2.y -= minY;
  }), g.edges().forEach((e2) => {
    let edge = g.edge(e2);
    edge.points.forEach((p2) => {
      p2.x -= minX, p2.y -= minY;
    }), Object.hasOwn(edge, "x") && (edge.x -= minX), Object.hasOwn(edge, "y") && (edge.y -= minY);
  }), graphLabel.width = maxX - minX + marginX, graphLabel.height = maxY - minY + marginY;
}
function assignNodeIntersects(g) {
  g.edges().forEach((e2) => {
    let edge = g.edge(e2), nodeV = g.node(e2.v), nodeW = g.node(e2.w), p1, p2;
    edge.points ? (p1 = edge.points[0], p2 = edge.points[edge.points.length - 1]) : (edge.points = [], p1 = nodeW, p2 = nodeV), edge.points.unshift(util$1.intersectRect(nodeV, p1)), edge.points.push(util$1.intersectRect(nodeW, p2));
  });
}
function fixupEdgeLabelCoords(g) {
  g.edges().forEach((e2) => {
    let edge = g.edge(e2);
    if (Object.hasOwn(edge, "x"))
      switch ((edge.labelpos === "l" || edge.labelpos === "r") && (edge.width -= edge.labeloffset), edge.labelpos) {
        case "l":
          edge.x -= edge.width / 2 + edge.labeloffset;
          break;
        case "r":
          edge.x += edge.width / 2 + edge.labeloffset;
          break;
      }
  });
}
function reversePointsForReversedEdges(g) {
  g.edges().forEach((e2) => {
    let edge = g.edge(e2);
    edge.reversed && edge.points.reverse();
  });
}
function removeBorderNodes(g) {
  g.nodes().forEach((v) => {
    if (g.children(v).length) {
      let node2 = g.node(v), t2 = g.node(node2.borderTop), b2 = g.node(node2.borderBottom), l2 = g.node(node2.borderLeft[node2.borderLeft.length - 1]), r2 = g.node(node2.borderRight[node2.borderRight.length - 1]);
      node2.width = Math.abs(r2.x - l2.x), node2.height = Math.abs(b2.y - t2.y), node2.x = l2.x + node2.width / 2, node2.y = t2.y + node2.height / 2;
    }
  }), g.nodes().forEach((v) => {
    g.node(v).dummy === "border" && g.removeNode(v);
  });
}
function removeSelfEdges(g) {
  g.edges().forEach((e2) => {
    if (e2.v === e2.w) {
      var node2 = g.node(e2.v);
      node2.selfEdges || (node2.selfEdges = []), node2.selfEdges.push({ e: e2, label: g.edge(e2) }), g.removeEdge(e2);
    }
  });
}
function insertSelfEdges(g) {
  var layers = util$1.buildLayerMatrix(g);
  layers.forEach((layer) => {
    var orderShift = 0;
    layer.forEach((v, i2) => {
      var node2 = g.node(v);
      node2.order = i2 + orderShift, (node2.selfEdges || []).forEach((selfEdge) => {
        util$1.addDummyNode(g, "selfedge", {
          width: selfEdge.label.width,
          height: selfEdge.label.height,
          rank: node2.rank,
          order: i2 + ++orderShift,
          e: selfEdge.e,
          label: selfEdge.label
        }, "_se");
      }), delete node2.selfEdges;
    });
  });
}
function positionSelfEdges(g) {
  g.nodes().forEach((v) => {
    var node2 = g.node(v);
    if (node2.dummy === "selfedge") {
      var selfNode = g.node(node2.e.v), x2 = selfNode.x + selfNode.width / 2, y2 = selfNode.y, dx = node2.x - x2, dy = selfNode.height / 2;
      g.setEdge(node2.e, node2.label), g.removeNode(v), node2.label.points = [
        { x: x2 + 2 * dx / 3, y: y2 - dy },
        { x: x2 + 5 * dx / 6, y: y2 - dy },
        { x: x2 + dx, y: y2 },
        { x: x2 + 5 * dx / 6, y: y2 + dy },
        { x: x2 + 2 * dx / 3, y: y2 + dy }
      ], node2.label.x = node2.x, node2.label.y = node2.y;
    }
  });
}
function selectNumberAttrs(obj, attrs) {
  return util$1.mapValues(util$1.pick(obj, attrs), Number);
}
function canonicalize(attrs) {
  var newAttrs = {};
  return attrs && Object.entries(attrs).forEach(([k, v]) => {
    typeof k == "string" && (k = k.toLowerCase()), newAttrs[k] = v;
  }), newAttrs;
}
let util = util$d, Graph2 = graphlib.Graph;
var debug = {
  debugOrdering
};
function debugOrdering(g) {
  let layerMatrix = util.buildLayerMatrix(g), h = new Graph2({ compound: !0, multigraph: !0 }).setGraph({});
  return g.nodes().forEach((v) => {
    h.setNode(v, { label: v }), h.setParent(v, "layer" + g.node(v).rank);
  }), g.edges().forEach((e2) => h.setEdge(e2.v, e2.w, {}, e2.name)), layerMatrix.forEach((layer, i2) => {
    let layerV = "layer" + i2;
    h.setNode(layerV, { rank: "same" }), layer.reduce((u2, v) => (h.setEdge(u2, v, { style: "invis" }), v));
  }), h;
}
var version = "1.1.4", dagre = {
  graphlib,
  layout: layout_1,
  debug,
  util: {
    time: util$d.time,
    notime: util$d.notime
  },
  version
};
const dagre$1 = /* @__PURE__ */ getDefaultExportFromCjs(dagre), Sizes$1 = {
  dagre: {
    ranksep: 40,
    nodesep: 25,
    edgesep: 15
  },
  edgeLabel: {
    width: 120
  },
  nodeWidth: 270,
  hodeHeight: 160,
  // Spacer between elements in a compound node
  // 0 means no spacer
  spacerHeight: 0,
  compoundLabelHeight: 5
}, ZIndexes$1 = {
  compound: 2,
  edge: 3,
  element: 4,
  max: 5
};
function createGraph$1() {
  const g = new dagre$1.graphlib.Graph({
    directed: !0,
    compound: !0
  });
  return g.setGraph({
    ...Sizes$1.dagre,
    rankdir: "LR"
  }), g.setDefaultEdgeLabel(() => ({ ...Sizes$1.edgeLabel })), g.setDefaultNodeLabel(() => ({})), g;
}
const sized$1 = (height = Sizes$1.hodeHeight) => ({
  width: Sizes$1.nodeWidth,
  height
}), graphId$1 = (node2) => ({
  id: node2.id,
  port: node2.type === "compound" ? `${node2.id}::port` : node2.id,
  body: `${node2.id}`,
  spacer: `${node2.id}:spacer`
});
function nodeData$1(element, ctx) {
  let diagramNode = ctx.diagramNodes.get(element.id);
  const ancestor = diagramNode ?? x$1(
    element.ancestors(),
    m$1((ancestor2) => ctx.diagramNodes.get(ancestor2.id)),
    T(n$4),
    d()
  );
  return {
    fqn: element.id,
    element: {
      kind: element.kind,
      title: diagramNode?.title ?? element.title,
      description: diagramNode?.description ?? element.element.description,
      color: diagramNode?.color ?? ancestor?.color ?? element.color,
      shape: diagramNode?.shape ?? element.shape
    },
    navigateTo: diagramNode?.navigateTo ?? d(element.viewsOf())?.id ?? null,
    ports: {
      in: [],
      out: []
    }
  };
}
function createNode$1(nodeType, element, ctx) {
  let node2 = ctx.xynodes.get(element.id);
  if (node2)
    return node2;
  const g = ctx.g, parent = x$1(
    element.ancestors(),
    u$7((ancestor) => !isAncestor(ancestor.id, ctx.edge.source) && !isAncestor(ancestor.id, ctx.edge.target)),
    d(),
    (found) => found ? createNode$1("compound", found, ctx) : null
  ), xynode = {
    type: nodeType,
    id: element.id,
    position: { x: 0, y: 0 },
    data: {
      ...nodeData$1(element, ctx)
    },
    zIndex: ZIndexes$1[nodeType],
    ...!!parent && { parentId: parent.id }
  };
  ctx.xynodes.set(element.id, xynode);
  const k = graphId$1(xynode);
  if (g.setNode(k.id, sized$1()), xynode.type === "compound" && (g.setNode(k.port, {
    width: Sizes$1.nodeWidth - Sizes$1.dagre.ranksep,
    height: Sizes$1.compoundLabelHeight
  }), g.setParent(k.port, k.id)), parent) {
    const parentGraphId = graphId$1(parent).body;
    g.setParent(k.id, parentGraphId);
  }
  return xynode;
}
function applyDagreLayout$1(g) {
  return dagre$1.layout(g), function nodeBounds(nodeId, relativeTo) {
    const { x: x2, y: y2, width: width2, height } = g.node(nodeId), pos = {
      position: {
        x: x2 - Math.round(width2 / 2),
        y: y2 - Math.round(height / 2)
      },
      width: width2,
      height
    };
    if (!relativeTo)
      return pos;
    const offset = nodeBounds(relativeTo).position;
    return {
      position: {
        x: pos.position.x - offset.x,
        y: pos.position.y - offset.y
      },
      width: pos.width,
      height: pos.height
    };
  };
}
function layout$1(edgeId, view, likec4model) {
  const edge = view.edges.find((e2) => e2.id === edgeId);
  invariant$1(edge, "edge not found");
  const all = /* @__PURE__ */ new Set([edge.source, edge.target]), relations = edge.relations.map((r2) => {
    const relation = likec4model.relationship(r2).relationship;
    return all.add(relation.source), all.add(relation.target), relation;
  }).sort(compareRelations).reverse(), diagramNodes = new Map(view.nodes.map((n2) => [n2.id, n2])), g = createGraph$1(), ctx = {
    g,
    xynodes: /* @__PURE__ */ new Map(),
    edge,
    diagramNodes,
    edges: []
  };
  x$1(
    [...all],
    m$2(compareFqnHierarchically),
    t$7(),
    u$4((id2) => {
      const element = likec4model.element(id2);
      createNode$1("element", element, ctx);
    })
  ), relations.length === 1 && all.size < 4 && g.setDefaultEdgeLabel(() => ({ width: 250 }));
  for (const relation of relations) {
    const source = ctx.xynodes.get(relation.source);
    invariant$1(source, "source node not found");
    const target = ctx.xynodes.get(relation.target);
    invariant$1(target, "target node not found"), source.data.ports.out.push(target.id), target.data.ports.in.push(source.id), g.setEdge(graphId$1(source).port, graphId$1(target).port);
    const edge2 = {
      id: relation.id,
      type: "relation",
      source: source.id,
      target: target.id,
      sourceHandle: target.id,
      targetHandle: source.id,
      data: {
        relation
      },
      label: relation.title,
      zIndex: ZIndexes$1.edge,
      markerEnd: {
        type: MarkerType.ArrowClosed,
        width: 10
      },
      style: {
        strokeWidth: 2.2,
        strokeDasharray: "5, 5"
      }
    };
    ctx.edges.push(edge2);
  }
  const nodebounds = applyDagreLayout$1(ctx.g), sortedPorts = (ports) => ports.length < 2 ? ports : x$1(
    ports,
    m$1((port) => ({
      port,
      topY: nodebounds(port).position.y
    })),
    a$3(p$3("topY")),
    m$1(p$3("port"))
  ), xynodes = [...ctx.xynodes.values()].map((node2) => (node2.data.ports.in.length > 1 && (node2.data.ports.in = sortedPorts(node2.data.ports.in)), node2.data.ports.out.length > 1 && (node2.data.ports.out = sortedPorts(node2.data.ports.out)), {
    ...node2,
    ...nodebounds(node2.id, node2.parentId)
  }));
  return {
    view,
    edge,
    edges: ctx.edges,
    nodes: xynodes,
    bounds: {
      x: 0,
      y: 0,
      width: g.graph().width ?? 0,
      height: g.graph().height ?? 0
    }
  };
}
function useLayoutedEdgeDetails(edgeId) {
  const view = useDiagramState((s2) => s2.view), likec4model = useLikeC4Model(!0);
  return useMemo$1(() => layout$1(
    edgeId,
    view,
    likec4model
  ), [
    edgeId,
    view,
    likec4model,
    layout$1
  ]);
}
var elementNode$1 = "xsefl30", elementNodeContent$1 = "xsefl31", elementNodeTitle$1 = "xsefl32", elementNodeDescription$1 = "xsefl33", compoundNodeBody$1 = "xsefl34", compoundNodeTitle$1 = "xsefl35", cssShapeSvg$1 = "xsefl36", edgeContainer$1 = "xsefl37", edgeLabel$2 = "xsefl38 xsefl37", edgeLabelText$2 = "xsefl39", edgeLabelTechnology$1 = "xsefl3a", navigateBtnBox$2 = "xsefl3b", navigateBtn$3 = "xsefl3c";
const Text$5 = Text$6.withProps({
  component: "div"
});
function CompoundNode$1({
  data: {
    element,
    ports,
    ...data
  },
  width: width2 = 200,
  selectable = !0
}) {
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(
      m.div,
      {
        className: clsx([
          compoundNodeBody$1,
          "likec4-compound-node"
        ]),
        "data-compound-depth": 3,
        "data-likec4-color": element.color,
        animate: {
          opacity: data.dimmed ? 0.15 : 1,
          transition: {
            delay: data.dimmed === !0 ? 0.4 : 0
          }
        },
        ...selectable && {
          whileHover: {
            scale: 1.04,
            transition: {
              delay: 0.15
            }
          },
          whileTap: {
            scale: 1
          }
        },
        children: /* @__PURE__ */ jsx(Text$5, { className: compoundNodeTitle$1, maw: width2 - 20, children: element.title })
      }
    ),
    ports.out.map((id2, i2) => /* @__PURE__ */ jsx(
      Handle,
      {
        id: id2,
        type: "source",
        position: Position.Right,
        style: {
          visibility: "hidden",
          top: `${16 + 20 * i2}px`
        }
      },
      id2
    )),
    ports.in.map((id2, i2) => /* @__PURE__ */ jsx(
      Handle,
      {
        id: id2,
        type: "target",
        position: Position.Left,
        style: {
          visibility: "hidden",
          top: `${16 + 20 * i2}px`
        }
      },
      id2
    ))
  ] });
}
var container$6 = "_14ylloj1", handleCenter = "_14ylloj2", containerAnimated = "_14ylloj3", dimmed$2 = "_14ylloj4", indicator$1 = "_14ylloj7", fillElementFill = "_14ylloj8", fillMixStroke = "_14ylloja", hasIcon = "_14yllojb", title$4 = "_14ylloje", description$1 = "_14yllojf", technology = "_14yllojg", elementDataContainer = "_14yllojh", elementTextData = "_14ylloji", elementIcon$2 = "_14yllojj", shapeSvg$1 = "_14yllojm", navigateBtnBox$1 = "_14yllojo", navigateBtn$2 = "_14yllojp _14yllojn", detailsBtn$1 = "_14yllojq _14yllojn";
function cylinderSVGPath(diameter, height, tilt = 0.065) {
  const radius = Math.round(diameter / 2), rx = radius, ry = toDomPrecision(tilt * radius), tiltAdjustedHeight = height - 2 * ry;
  return {
    path: `  M ${diameter},${ry}
        a ${rx},${ry} 0,0,0 ${-diameter} 0
        l 0,${tiltAdjustedHeight}
        a ${rx},${ry} 0,0,0 ${diameter} 0
        l 0,${-tiltAdjustedHeight}
        z
        `.replace(/\s+/g, " ").trim(),
    ry,
    rx
  };
}
function queueSVGPath(width2, height, tilt = 0.185) {
  const diameter = height, ry = Math.round(diameter / 2), rx = toDomPrecision(diameter / 2 * tilt), tiltAdjustedWidth = width2 - 2 * rx;
  return {
    path: `
    M ${rx},0
    a ${rx},${ry} 0,0,0 0 ${diameter}
    l ${tiltAdjustedWidth},0
    a ${rx},${ry} 0,0,0 0 ${-diameter}
    z`.replace(/\s+/g, " ").trim(),
    ry,
    rx
  };
}
const PersonIcon = {
  width: 115,
  height: 120,
  path: "M57.9197 0C10.9124 0 33.5766 54.75 33.5766 54.75C38.6131 62.25 45.3285 60.75 45.3285 66C45.3285 70.5 39.4526 72 33.5766 72.75C24.3431 72.75 15.9489 71.25 7.55474 84.75C2.51825 93 0 120 0 120H115C115 120 112.482 93 108.285 84.75C99.8905 70.5 91.4963 72.75 82.2628 72C76.3869 71.25 70.5109 69.75 70.5109 65.25C70.5109 60.75 77.2263 62.25 82.2628 54C82.2628 54.75 104.927 0 57.9197 0V0Z"
};
function ElementShapeSvg({ shape, w, h }) {
  switch (shape) {
    case "mobile":
      return /* @__PURE__ */ jsxs(Fragment$1, { children: [
        /* @__PURE__ */ jsx(
          "rect",
          {
            width: w,
            height: h,
            rx: 6,
            className: fillMixStroke,
            strokeWidth: 0
          }
        ),
        /* @__PURE__ */ jsxs("g", { className: fillElementFill, strokeWidth: 0, children: [
          /* @__PURE__ */ jsx("circle", { cx: 17, cy: h / 2, r: 12 }),
          /* @__PURE__ */ jsx("rect", { x: 33, y: 12, width: w - 44, height: h - 24, rx: 5 })
        ] })
      ] });
    case "browser":
      return /* @__PURE__ */ jsxs(Fragment$1, { children: [
        /* @__PURE__ */ jsx(
          "rect",
          {
            width: w,
            height: h,
            rx: 6,
            className: fillMixStroke,
            strokeWidth: 0
          }
        ),
        /* @__PURE__ */ jsxs("g", { className: fillElementFill, strokeWidth: 0, children: [
          /* @__PURE__ */ jsx("circle", { cx: 16, cy: 17, r: 7 }),
          /* @__PURE__ */ jsx("circle", { cx: 36, cy: 17, r: 7 }),
          /* @__PURE__ */ jsx("circle", { cx: 56, cy: 17, r: 7 }),
          /* @__PURE__ */ jsx("rect", { x: 70, y: 8, width: w - 80, height: 17, rx: 4 }),
          /* @__PURE__ */ jsx("rect", { x: 10, y: 32, width: w - 20, height: h - 42, rx: 4 })
        ] })
      ] });
    case "person":
      return /* @__PURE__ */ jsxs(Fragment$1, { children: [
        /* @__PURE__ */ jsx(
          "rect",
          {
            width: w,
            height: h,
            rx: 6,
            strokeWidth: 0
          }
        ),
        /* @__PURE__ */ jsx(
          "svg",
          {
            x: w - PersonIcon.width - 6,
            y: h - PersonIcon.height,
            width: PersonIcon.width,
            height: PersonIcon.height,
            viewBox: `0 0 ${PersonIcon.width} ${PersonIcon.height}`,
            className: fillMixStroke,
            children: /* @__PURE__ */ jsx(
              "path",
              {
                strokeWidth: 0,
                d: PersonIcon.path
              }
            )
          }
        )
      ] });
    case "queue": {
      const { path, rx, ry } = queueSVGPath(w, h);
      return /* @__PURE__ */ jsxs(Fragment$1, { children: [
        /* @__PURE__ */ jsx("path", { d: path, strokeWidth: 2 }),
        /* @__PURE__ */ jsx("ellipse", { cx: rx, cy: ry, ry: ry - 0.75, rx, className: fillMixStroke, strokeWidth: 2 })
      ] });
    }
    case "storage":
    case "cylinder": {
      const { path, rx, ry } = cylinderSVGPath(w, h);
      return /* @__PURE__ */ jsxs(Fragment$1, { children: [
        /* @__PURE__ */ jsx("path", { d: path, strokeWidth: 2 }),
        /* @__PURE__ */ jsx("ellipse", { cx: rx, cy: ry, ry, rx: rx - 0.75, className: fillMixStroke, strokeWidth: 2 })
      ] });
    }
    case "rectangle":
      return /* @__PURE__ */ jsx(
        "rect",
        {
          width: w,
          height: h,
          rx: 6,
          strokeWidth: 0
        }
      );
    default:
      return nonexhaustive(shape);
  }
}
function SelectedIndicator({ shape, w, h }) {
  switch (shape) {
    case "queue":
      return /* @__PURE__ */ jsx("path", { d: queueSVGPath(w, h).path });
    case "storage":
    case "cylinder":
      return /* @__PURE__ */ jsx("path", { d: cylinderSVGPath(w, h).path });
    default:
      return /* @__PURE__ */ jsx(
        "rect",
        {
          x: -1,
          y: -1,
          width: w + 2,
          height: h + 2,
          rx: 6
        }
      );
  }
}
const Action$2 = ActionIcon$1.withProps({
  className: "nodrag nopan " + navigateBtn$3,
  radius: "md",
  role: "button",
  onDoubleClick: stopPropagation$1,
  onPointerDownCapture: stopPropagation$1
}), Text$4 = Text$6.withProps({
  component: "div"
});
function selector$6(s2) {
  return {
    currentViewId: s2.view.id,
    enableRelationshipBrowser: s2.enableRelationshipBrowser,
    onNavigateTo: s2.onNavigateTo,
    onOpenSource: s2.onOpenSourceElement
  };
}
function ElementNode$1({
  data: {
    element,
    ports,
    navigateTo,
    ...data
  },
  selectable = !0,
  width: w = 100,
  height: h = 100
}) {
  const overlay = useOverlayDialog(), {
    currentViewId,
    onNavigateTo,
    onOpenSource,
    enableRelationshipBrowser
  } = useDiagramState(selector$6);
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsxs(
      m.div,
      {
        className: clsx([
          elementNode$1,
          "likec4-element-node"
        ]),
        "data-likec4-color": element.color,
        "data-likec4-shape": element.shape,
        animate: {
          opacity: data.dimmed ? 0.15 : 1,
          transition: {
            delay: data.dimmed === !0 ? 0.4 : 0
          }
        },
        ...selectable && {
          whileHover: {
            scale: 1.045,
            transition: {
              delay: 0.15
            }
          },
          whileTap: {
            scale: 0.97
          }
        },
        children: [
          /* @__PURE__ */ jsx(
            "svg",
            {
              className: clsx(
                cssShapeSvg$1
              ),
              viewBox: `0 0 ${w} ${h}`,
              width: w,
              height: h,
              children: /* @__PURE__ */ jsx(ElementShapeSvg, { shape: element.shape, w, h })
            }
          ),
          /* @__PURE__ */ jsxs(Box, { className: elementNodeContent$1, children: [
            /* @__PURE__ */ jsx(Text$4, { className: elementNodeTitle$1, lineClamp: 2, children: element.title }),
            element.description && /* @__PURE__ */ jsx(Text$4, { className: elementNodeDescription$1, lineClamp: 4, children: element.description })
          ] }),
          /* @__PURE__ */ jsxs(Group, { className: navigateBtnBox$2, children: [
            navigateTo && onNavigateTo && navigateTo !== currentViewId && /* @__PURE__ */ jsx(
              Action$2,
              {
                onClick: (event) => {
                  event.stopPropagation(), overlay.close(() => onNavigateTo(navigateTo));
                },
                children: /* @__PURE__ */ jsx(IconZoomScan, { stroke: 1.8, style: { width: "75%" } })
              }
            ),
            enableRelationshipBrowser && /* @__PURE__ */ jsx(
              Action$2,
              {
                onClick: (event) => {
                  event.stopPropagation(), overlay.openOverlay({
                    relationshipsOf: data.fqn
                  });
                },
                children: /* @__PURE__ */ jsx(IconTransform, { stroke: 1.8, style: { width: "72%" } })
              }
            ),
            onOpenSource && /* @__PURE__ */ jsx(
              Action$2,
              {
                onClick: (event) => {
                  event.stopPropagation(), onOpenSource(data.fqn);
                },
                children: /* @__PURE__ */ jsx(IconFileSymlink, { stroke: 1.8, style: { width: "72%" } })
              }
            )
          ] })
        ]
      }
    ),
    ports.out.map((id2, i2) => /* @__PURE__ */ jsx(
      Handle,
      {
        id: id2,
        type: "source",
        position: Position.Right,
        style: {
          visibility: "hidden",
          top: `${15 + (i2 + 1) * ((h - 30) / (ports.out.length + 1))}px`
        }
      },
      id2
    )),
    ports.in.map((id2, i2) => /* @__PURE__ */ jsx(
      Handle,
      {
        id: id2,
        type: "target",
        position: Position.Left,
        style: {
          visibility: "hidden",
          top: `${15 + (i2 + 1) * ((h - 30) / (ports.in.length + 1))}px`
        }
      },
      id2
    ))
  ] });
}
function RelationshipEdge$2({
  data,
  label: label2,
  ...props2
}) {
  const overlay = useOverlayDialog(), onNavigateTo = useDiagramState((s2) => s2.onNavigateTo), [edgePath, labelX, labelY] = getBezierPath(props2), navigateTo = data.relation.navigateTo;
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(
      "g",
      {
        className: edgeContainer$1,
        "data-edge-dimmed": data.dimmed,
        "data-edge-hovered": data.hovered,
        children: /* @__PURE__ */ jsx(
          BaseEdge,
          {
            path: edgePath,
            ...props2
          }
        )
      }
    ),
    /* @__PURE__ */ jsx(EdgeLabelRenderer, { children: /* @__PURE__ */ jsxs(
      Stack$1,
      {
        gap: 2,
        style: {
          position: "absolute",
          transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,
          maxWidth: Math.abs(props2.targetX - props2.sourceX - 40),
          zIndex: ZIndexes$1.max
        },
        className: clsx([
          edgeLabel$2,
          "nodrag nopan"
        ]),
        "data-edge-dimmed": data.dimmed,
        "data-edge-hovered": data.hovered,
        children: [
          label2 && /* @__PURE__ */ jsx(Text$6, { component: "div", className: edgeLabelText$2, lineClamp: 3, children: label2 }),
          data.relation.technology && /* @__PURE__ */ jsxs(Text$6, { component: "div", className: edgeLabelTechnology$1, children: [
            "[ ",
            data.relation.technology,
            " ]"
          ] }),
          navigateTo && onNavigateTo && /* @__PURE__ */ jsx(Box, { ta: "center", mt: 4, children: /* @__PURE__ */ jsx(
            ActionIcon$1,
            {
              variant: "default",
              size: "sm",
              radius: "sm",
              onPointerDownCapture: stopPropagation$1,
              onClick: (event) => {
                event.stopPropagation(), overlay.close(() => {
                  onNavigateTo(navigateTo);
                });
              },
              role: "button",
              onDoubleClick: stopPropagation$1,
              children: /* @__PURE__ */ jsx(IconZoomScan, {})
            }
          ) })
        ]
      }
    ) })
  ] });
}
const nodeTypes$2 = {
  element: ElementNode$1,
  compound: CompoundNode$1
}, edgeTypes$2 = {
  relation: RelationshipEdge$2
}, resetDimmedAndHovered$1 = (xyflow2) => {
  xyflow2.setEdges(
    (edges) => edges.map((edge) => ({
      ...edge,
      data: {
        ...edge.data,
        dimmed: !1,
        hovered: !1
      },
      animated: !1
    }))
  ), xyflow2.setNodes(
    (nodes) => nodes.map(
      (n2) => ({
        ...n2,
        data: {
          ...n2.data,
          dimmed: !1,
          hovered: !1
        }
      })
    )
  );
}, EdgeDetailsXYFlow = memo$1(function({ edgeId }) {
  const diagramStore = useDiagramStoreApi(), {
    view,
    edge,
    edges,
    nodes,
    bounds
  } = useLayoutedEdgeDetails(edgeId), boundsRef = useSyncedRef(bounds), xyflow2 = useReactFlow(), xystore = useStoreApi(), fitview = useDebouncedCallback(
    () => {
      const {
        width: width2,
        height
      } = xystore.getState(), viewport = getViewportForBounds(
        {
          ...boundsRef.current,
          height: Math.max(boundsRef.current.height + 100, height - 200)
          // Add some padding to the bottom
        },
        width2,
        height,
        0.2,
        1,
        0.2
      );
      xyflow2.setViewport(viewport, { duration: 350 });
    },
    [xyflow2],
    150
  );
  useEffect$1(() => {
    xyflow2.setNodes(nodes), xyflow2.setEdges(edges);
  }, [nodes, edges]);
  const zoomable = !0;
  return useUpdateEffect$1(() => fitview(), [edge.id]), /* @__PURE__ */ jsxs(
    index,
    {
      defaultEdges: [],
      defaultNodes: [],
      nodeTypes: nodeTypes$2,
      edgeTypes: edgeTypes$2,
      defaultMarkerColor: "var(--xy-edge-stroke)",
      zoomOnPinch: zoomable,
      zoomOnScroll: !1,
      zoomOnDoubleClick: !1,
      maxZoom: 1.5,
      minZoom: 0.1,
      fitView: !0,
      fitViewOptions: {
        padding: 0.2,
        maxZoom: 1,
        minZoom: 0.1,
        includeHiddenNodes: !0
      },
      preventScrolling: !0,
      noDragClassName: "nodrag",
      noPanClassName: "nopan",
      panOnScroll: !0,
      panOnDrag: !0,
      elementsSelectable: !0,
      nodesFocusable: !1,
      edgesFocusable: !1,
      nodesDraggable: !1,
      onEdgeMouseEnter: (_, edge2) => {
        xyflow2.setEdges(
          (edges2) => edges2.map((e2) => ({
            ...e2,
            data: {
              ...e2.data,
              dimmed: e2.id !== edge2.id,
              hovered: e2.id === edge2.id
            },
            zIndex: e2.id === edge2.id ? ZIndexes$1.max : ZIndexes$1.edge,
            animated: e2.id === edge2.id
          }))
        ), xyflow2.setNodes(
          (nodes2) => nodes2.map((n2) => ({
            ...n2,
            data: {
              ...n2.data,
              dimmed: n2.id !== edge2.source && n2.id !== edge2.target
            }
          }))
        );
      },
      onEdgeMouseLeave: () => {
        resetDimmedAndHovered$1(xyflow2);
      },
      onEdgeClick: (e2, edge2) => {
        e2.stopPropagation(), diagramStore.getState().onOpenSourceRelation?.(edge2.data.relation.id);
      },
      children: [
        /* @__PURE__ */ jsx(Panel$1, { position: "top-center", children: /* @__PURE__ */ jsx(Group, { gap: "xs", wrap: "nowrap", children: /* @__PURE__ */ jsx(
          SelectEdge,
          {
            view,
            edge
          }
        ) }) }),
        /* @__PURE__ */ jsx(EdgeData, { edge, top: bounds.height, width: bounds.width })
      ]
    }
  );
}), EdgeData = ({ edge, top, width: width2 }) => /* @__PURE__ */ jsx(ViewportPortal, { children: /* @__PURE__ */ jsx(
  Box,
  {
    maw: width2,
    style: {
      transform: `translate(100px, ${top + 32}px)`
    },
    children: /* @__PURE__ */ jsxs(Box, { className: edgeDataGrid, children: [
      /* @__PURE__ */ jsx(Text$6, { size: "xs", fw: 500, c: "dimmed", children: "technology" }),
      /* @__PURE__ */ jsx(Text$6, { children: edge.technology || "unknown" }),
      /* @__PURE__ */ jsx(Text$6, { size: "xs", fw: 500, c: "dimmed", children: "description" }),
      /* @__PURE__ */ jsx(Text$6, { children: edge.description || "no description" })
    ] })
  }
) });
var dialog = "_129pgl12", card$2 = "_129pgl13", cardHeader = "_129pgl14", title$3 = "_129pgl15", elementIcon$1 = "_129pgl16", viewButton = "_129pgl19", viewButtonTitle = "_129pgl1a", tabsRoot = "_129pgl1b", tabsList = "_129pgl1c", tabsTab = "_129pgl1d", tabsPanel = "_129pgl1e", propertiesGrid = "_129pgl1f", propertyLabel = "_129pgl1g", elementLink = "_129pgl1h", resizeHandle = "_129pgl1i", container$5 = "y6dq321", cssReactflowMarker = "y6dq322", node = "_1nudxvt0", label = "_1nudxvt1";
const classes = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get label() {
    return label;
  },
  get node() {
    return node;
  }
}, Symbol.toStringTag, { value: "Module" })), SelectElement = ({
  subject,
  viewId,
  scope,
  onSelect
}) => {
  const viewport = useRef$1(null), data = useLikeC4ElementsTree(scope === "view" ? viewId : void 0), tree = useTree({
    multiple: !1
  });
  useEffect$1(() => {
    ancestorsFqn(subject.id).reverse().forEach((id2) => {
      tree.expand(id2);
    }), tree.select(subject.id);
  }, [subject.id]);
  const theme2 = useComputedColorScheme();
  return /* @__PURE__ */ jsxs(
    Popover,
    {
      position: "bottom",
      shadow: "md",
      keepMounted: !0,
      withinPortal: !1,
      closeOnClickOutside: !0,
      clickOutsideEvents: ["pointerdown", "mousedown", "click"],
      onOpen: () => {
        setTimeout(() => {
          const item = viewport.current?.querySelector(`[data-value="${subject.id}"]`);
          console.log("item", item), item?.scrollIntoView({ behavior: "instant", block: "nearest" });
        }, 100);
      },
      children: [
        /* @__PURE__ */ jsx(PopoverTarget, { children: /* @__PURE__ */ jsx(
          Button,
          {
            size: "xs",
            variant: "light",
            color: theme2 === "light" ? "dark" : "gray",
            fw: "500",
            maw: 250,
            style: { padding: "0.25rem 0.75rem" },
            rightSection: /* @__PURE__ */ jsx(IconSelector, { size: 16 }),
            children: subject.title
          }
        ) }),
        /* @__PURE__ */ jsx(PopoverDropdown, { p: 0, miw: 250, maw: 400, children: /* @__PURE__ */ jsx(ScrollAreaAutosize, { mah: "70vh", scrollbars: "y", type: "never", viewportRef: viewport, children: /* @__PURE__ */ jsx(
          Tree,
          {
            allowRangeSelection: !1,
            selectOnClick: !1,
            tree,
            data,
            classNames: classes,
            levelOffset: 8,
            styles: {
              label: {
                paddingTop: 5,
                paddingBottom: 6
              }
            },
            renderNode: ({ node: node2, selected, expanded, elementProps, hasChildren }) => /* @__PURE__ */ jsxs(Group, { gap: 2, wrap: "nowrap", ...elementProps, py: "3", children: [
              /* @__PURE__ */ jsx(
                ActionIcon$1,
                {
                  variant: "subtle",
                  size: 18,
                  c: "dimmed",
                  style: {
                    visibility: hasChildren ? "visible" : "hidden"
                  },
                  children: /* @__PURE__ */ jsx(
                    IconChevronRight,
                    {
                      stroke: 3.5,
                      style: {
                        transition: "transform 150ms ease",
                        transform: `rotate(${expanded ? "90deg" : "0"})`,
                        width: "80%"
                      }
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsx(
                Box,
                {
                  flex: "1 1 100%",
                  w: "100%",
                  onClick: (e2) => {
                    e2.stopPropagation(), onSelect(node2.value), tree.select(node2.value), tree.expand(node2.value);
                  },
                  children: /* @__PURE__ */ jsx(
                    Text$6,
                    {
                      fz: "sm",
                      fw: selected ? "600" : "400",
                      truncate: "end",
                      children: node2.label
                    }
                  )
                }
              )
            ] })
          }
        ) }) })
      ]
    }
  );
}, columns = ["incomers", "subjects", "outgoers"], Sizes = {
  dagre: {
    ranksep: 60,
    nodesep: 35,
    edgesep: 25
  },
  edgeLabel: {
    width: 120,
    height: 10,
    minlen: 1,
    weight: 1
  },
  emptyNodeOffset: 120,
  nodeWidth: 320,
  hodeHeight: 180,
  // Spacer between elements in a compound node
  // 0 means no spacer
  spacerHeight: 0,
  compound: {
    labelHeight: 1,
    paddingTop: 50,
    paddingBottom: 32
  }
}, ZIndexes = {
  empty: 2,
  compound: 2,
  edge: 3,
  element: 4,
  max: 5
};
function createGraph() {
  const g = new dagre$1.graphlib.Graph({
    directed: !0,
    compound: !0
  });
  return g.setGraph({
    ...Sizes.dagre,
    rankdir: "LR"
  }), g.setDefaultEdgeLabel(() => ({ ...Sizes.edgeLabel })), g.setDefaultNodeLabel(() => ({})), g;
}
const sized = (height = Sizes.hodeHeight) => ({
  width: Sizes.nodeWidth,
  height
}), graphId = (node2) => ({
  id: node2.id,
  port: node2.type === "compound" ? `${node2.id}::port` : node2.id,
  body: `${node2.id}`,
  spacer: `${node2.id}:spacer`
});
function nodeData(element, ctx) {
  let diagramNode = ctx.diagramNodes.get(element.id);
  const ancestor = diagramNode ?? (ctx.scope === "view" ? x$1(
    element.ancestors(),
    m$1((ancestor2) => ctx.diagramNodes.get(ancestor2.id)),
    T(n$4),
    d()
  ) : void 0);
  return {
    fqn: element.id,
    existsInCurrentView: ctx.diagramNodes.has(element.id),
    element: {
      kind: element.kind,
      title: diagramNode?.title ?? element.title,
      description: diagramNode?.description ?? element.element.description,
      color: diagramNode?.color ?? ancestor?.color ?? element.color,
      shape: diagramNode?.shape ?? element.shape
    },
    navigateTo: diagramNode?.navigateTo ?? d(element.viewsOf())?.id ?? null,
    ports: {
      left: [],
      right: []
    }
  };
}
function createEmptyNode(column, ctx) {
  const id2 = `${column}__empty`, xynodes = ctx.columns[column];
  let node2 = xynodes.get(id2);
  if (node2)
    return invariant$1(node2.type === "empty", "Node is not empty"), node2;
  const xynode = {
    type: "empty",
    id: id2,
    position: { x: 0, y: 0 },
    data: {
      column
    },
    zIndex: ZIndexes.empty
  };
  xynodes.set(id2, xynode);
  const k = graphId(xynode), emptyContainer = id2 + "__container";
  return ctx.g.setNode(emptyContainer, {}), ctx.g.setNode(k.id, {
    width: Sizes.nodeWidth - 20,
    height: Sizes.hodeHeight
  }), ctx.g.setParent(k.id, emptyContainer), xynode;
}
function createNode(column, nodeType, element, ctx, depth = 0) {
  const xynodes = ctx.columns[column];
  let node2 = xynodes.get(element.id);
  if (node2) {
    if (invariant$1(node2.type !== "empty", `Unexpected empty Node type ${element.id}: ${node2.type}, expect ${nodeType}`), node2.type === "element" && nodeType === "compound")
      throw new Error(`Unexpected Node type ${element.id}: ${node2.type}, expect ${nodeType}`);
    return node2;
  }
  const g = ctx.g, parent = x$1(
    element.ancestors(),
    u$7((ancestor) => !isAncestor(ancestor.id, ctx.subjectId)),
    f(
      (ancestor) => ctx.diagramNodes.has(ancestor.id) || ctx.connected[column].has(ancestor.id) || ctx.scope === "global" && ctx.subjectElement.ascendingSiblings().some((s2) => s2.id === ancestor.id)
    ),
    (found) => found ? createNode(column, "compound", found, ctx, depth + 2) : null
  ), xynode = {
    type: nodeType,
    id: `${column}::${element.id}`,
    position: { x: 0, y: 0 },
    data: {
      ...nodeData(element, ctx),
      column
    },
    zIndex: ZIndexes[nodeType],
    ...!!parent && { parentId: parent.id }
  };
  xynodes.set(element.id, xynode);
  const k = graphId(xynode);
  return g.setNode(k.id, sized()), xynode.type === "compound" && (g.setNode(k.port, {
    width: Sizes.nodeWidth - Sizes.dagre.ranksep,
    height: Sizes.compound.labelHeight
  }), g.setParent(k.port, k.id)), parent && (parent.data.depth = Math.min(Math.max(parent.data.depth ?? 0, depth + 1), 6), g.setParent(k.id, graphId(parent).body)), xynode;
}
function applyDagreLayout(g) {
  return dagre$1.layout(g), function(nodeId) {
    const { x: x2, y: y2, width: width2, height } = g.node(nodeId);
    return {
      position: {
        x: x2 - Math.round(width2 / 2),
        y: y2 - Math.round(height / 2)
      },
      width: width2,
      height
    };
  };
}
function addEdge(ctx, props2) {
  const { source, target, relations, includedInCurrentView } = props2, ids = relations.map((r2) => r2.id).join("_"), label2 = t$5(relations)?.title ?? "untitled", isMultiple = relations.length > 1, edge = {
    id: `rel${ctx.edges.length + 1}_${ids}`,
    type: "relation",
    source,
    target,
    sourceHandle: target,
    targetHandle: source,
    data: {
      includedInCurrentView,
      relations
    },
    label: isMultiple ? `${relations.length} relationships` : label2,
    zIndex: ZIndexes.edge,
    markerEnd: {
      type: MarkerType.ArrowClosed,
      width: isMultiple ? 7 : 9
    },
    style: {
      strokeWidth: isMultiple ? 5 : 2.8,
      strokeDasharray: isMultiple ? void 0 : "5, 5"
    }
  };
  ctx.edges.push(edge);
}
function findNodeOrFirstAncestor(fqn2, nodes) {
  let node2 = nodes.get(fqn2), parent = fqn2;
  for (; !node2 && (parent = parentFqn(parent)); )
    node2 = nodes.get(parent);
  return node2;
}
function layout(subjectId, view, likec4model, scope) {
  const diagramNodes = new Map(view.nodes.map((n2) => [n2.id, n2])), subjectElement = likec4model.element(subjectId), viewIncludesSubject = diagramNodes.has(subjectId), viewRelationships = new Set(
    view.edges.flatMap((e2) => e2.relations)
  ), notIncludedRelations = /* @__PURE__ */ new Set();
  viewIncludesSubject ? u$4([
    ...subjectElement.incoming().map((r2) => r2.id),
    ...subjectElement.outgoing().map((r2) => r2.id)
  ], (relationId) => {
    viewRelationships.has(relationId) || notIncludedRelations.add(relationId);
  }) : scope = "global";
  let relationships;
  if (scope === "global")
    relationships = {
      incoming: subjectElement.incoming().map((r2) => r2.relationship),
      outgoing: subjectElement.outgoing().map((r2) => r2.relationship)
    };
  else {
    const subjectViewModel = likec4model.view(view.id).element(subjectId);
    relationships = {
      incoming: subjectViewModel.incoming().flatMap((c) => c.relationships().map((r2) => r2.relationship)),
      outgoing: subjectViewModel.outgoing().flatMap((c) => c.relationships().map((r2) => r2.relationship))
    };
  }
  const g = createGraph(), ctx = {
    scope,
    g,
    diagramNodes,
    subjectElement,
    subjectId,
    connected: {
      incomers: /* @__PURE__ */ new Set(),
      outgoers: /* @__PURE__ */ new Set(),
      subjects: /* @__PURE__ */ new Set([subjectId])
    },
    columns: {
      incomers: /* @__PURE__ */ new Map(),
      subjects: /* @__PURE__ */ new Map(),
      outgoers: /* @__PURE__ */ new Map()
    },
    edges: []
  };
  if (relationships.incoming.forEach((incoming) => {
    ctx.connected.incomers.add(incoming.source), ctx.connected.subjects.add(incoming.target);
  }), relationships.outgoing.forEach((outgoing) => {
    ctx.connected.subjects.add(outgoing.source), ctx.connected.outgoers.add(outgoing.target);
  }), viewIncludesSubject) {
    const subjectViewModel = likec4model.view(view.id).element(subjectId);
    subjectViewModel.incomers().forEach((incomer) => {
      ctx.connected.incomers.add(incomer.id);
    }), subjectViewModel.outgoers().forEach((outgoer) => {
      ctx.connected.outgoers.add(outgoer.id);
    });
  }
  columns.forEach((column) => {
    x$1(
      [...ctx.connected[column].values()],
      m$1((id2) => likec4model.element(id2)),
      m$2((a2, b2) => -1 * compareNatural(a2.title, b2.title)),
      m$2(compareByFqnHierarchically),
      t$7(),
      u$4((element) => {
        createNode(column, "element", element, ctx);
      })
    );
  }), x$1(
    [
      // Process incoming
      {
        sources: ctx.columns.incomers,
        targets: ctx.columns.subjects,
        relationships: relationships.incoming.sort(compareRelations).reverse()
      },
      // Process outgoing
      {
        sources: ctx.columns.subjects,
        targets: ctx.columns.outgoers,
        relationships: relationships.outgoing.sort(compareRelations).reverse()
      }
    ],
    /**
     * We select relationships, sources and targets
     * If sourece or target of the relationship is not found - take first ancestor
     */
    u$5(({ sources, targets, relationships: relationships2 }) => relationships2.map((relation) => {
      const source = findNodeOrFirstAncestor(relation.source, sources);
      if (!source || source.type === "empty")
        return null;
      const target = findNodeOrFirstAncestor(relation.target, targets);
      return !target || target.type === "empty" ? null : {
        relation,
        source,
        target,
        includedInCurrentView: viewRelationships.has(relation.id),
        id: `${source.id}:${target.id}`
      };
    })),
    T(l$2),
    // Group relations with saame source and target - make them one edge
    i$2(p$3("id")),
    i$3((grouped) => {
      const { source, target } = grouped[0], relations = m$1(grouped, (g2) => g2.relation);
      source.data.ports.right.push({
        id: target.id,
        type: "out"
      }), target.data.ports.left.push({
        id: source.id,
        type: "in"
      }), source.type === "compound" || target.type, g.setEdge(graphId(source).port, graphId(target).port, {
        ...Sizes.edgeLabel
        // weight: isAnyCompound ? 1 : 2
      }), addEdge(ctx, {
        // if view does not include subject - do not highlight
        includedInCurrentView: !viewIncludesSubject || grouped.every((g2) => g2.includedInCurrentView),
        source: source.id,
        target: target.id,
        relations
      });
    })
  );
  const subjectPort = graphId(ctx.columns.subjects.get(subjectId)).port;
  if (ctx.columns.incomers.size == 0) {
    const source = createEmptyNode("incomers", ctx);
    g.setEdge(graphId(source).port, subjectPort);
  }
  if (ctx.columns.outgoers.size == 0) {
    const target = createEmptyNode("outgoers", ctx);
    g.setEdge(subjectPort, graphId(target).port);
  }
  for (const subject of ctx.columns.subjects.values()) {
    if (subject.type !== "element")
      continue;
    const subjectPortsCount = Math.max(subject.data.ports.left.length, subject.data.ports.right.length);
    subjectPortsCount > 2 && (g.node(subject.id).height = Sizes.hodeHeight + (subjectPortsCount - 3) * 14);
  }
  const dagreBounds = applyDagreLayout(ctx.g), xynodes = [
    ...ctx.columns.incomers.values(),
    ...ctx.columns.subjects.values(),
    ...ctx.columns.outgoers.values()
  ], _calculatedNodeBounds = x$1(
    xynodes,
    T((n2) => n2.type !== "compound"),
    l$3((n2) => [n2.id, dagreBounds(n2.id)])
  );
  function nodeBounds(nodeId) {
    return _calculatedNodeBounds[nodeId] ??= x$1(
      xynodes,
      T((n2) => n2.parentId === nodeId),
      m$1((n2) => nodeBounds(n2.id)),
      r$4((bounds) => {
        invariant$1(bounds.length > 0, `Node ${nodeId} has no nested nodes`);
      }),
      l$4((acc, bounds) => ({
        minY: Math.min(acc.minY, bounds.position.y),
        maxY: Math.max(acc.maxY, bounds.position.y + bounds.height)
      }), { minY: 1 / 0, maxY: -1 / 0 }),
      ({ minY, maxY }) => {
        const {
          position: { x: x2 },
          width: width2
        } = dagreBounds(nodeId);
        return minY = minY - Sizes.compound.paddingTop, maxY = maxY + Sizes.compound.paddingBottom, {
          position: {
            x: x2,
            y: minY
          },
          width: width2,
          height: maxY - minY
        };
      }
    );
  }
  for (const node2 of xynodes) {
    const { position: position2, width: width2, height } = nodeBounds(node2.id);
    if (node2.width = width2, node2.height = height, node2.position = position2, node2.parentId) {
      const parentPos = nodeBounds(node2.parentId).position;
      node2.position = {
        x: position2.x - parentPos.x,
        y: position2.y - parentPos.y
      };
    }
  }
  const sortedPorts = (ports) => x$1(
    ports,
    m$1((port) => ({
      port,
      topY: nodeBounds(port.id).position.y
    })),
    a$3(p$3("topY")),
    m$1(p$3("port"))
  );
  for (const node2 of xynodes) {
    if (node2.type === "empty") {
      const subjectBounds = nodeBounds(nonNullable(ctx.columns.subjects.get(subjectId), "Subject node is missing").id);
      if (node2.height = Math.min(subjectBounds.height, 300), node2.position.y = subjectBounds.position.y + subjectBounds.height / 2 - node2.height / 2, node2.data.column === "incomers")
        node2.width = subjectBounds.position.x - Sizes.emptyNodeOffset - node2.position.x;
      else {
        const rightX = node2.position.x + node2.width;
        node2.position.x = subjectBounds.position.x + subjectBounds.width + Sizes.emptyNodeOffset, node2.width = rightX - node2.position.x;
      }
      continue;
    }
    node2.data.ports.left.length > 1 && (node2.data.ports.left = sortedPorts(node2.data.ports.left)), node2.data.ports.right.length > 1 && (node2.data.ports.right = sortedPorts(node2.data.ports.right));
  }
  return {
    viewIncludesSubject,
    notIncludedRelations: notIncludedRelations.size,
    subject: subjectElement,
    edges: ctx.edges,
    nodes: xynodes,
    bounds: {
      x: 0,
      y: 0,
      width: g.graph().width ?? 100,
      height: g.graph().height ?? 100
    }
  };
}
function useLayoutedRelationships(subjectId, view, scope) {
  const likec4model = useLikeC4Model(!0);
  return useMemo$1(() => layout(
    subjectId,
    view,
    likec4model,
    scope
  ), [
    subjectId,
    view,
    likec4model,
    layout,
    scope
  ]);
}
var elementNode = "_1ittjvh0", elementNodeContent = "_1ittjvh1", elementNodeTitle = "_1ittjvh2", elementNodeDescription = "_1ittjvh3", compoundNodeBody = "_1ittjvh4", compoundNodeTitle = "_1ittjvh5", cssShapeSvg = "_1ittjvh6", edgeContainer = "_1ittjvh7", edgeLabel$1 = "_1ittjvh8 _1ittjvh7", edgeLabelText$1 = "_1ittjvh9", edgeLabelTechnology = "_1ittjvha", emptyNode = "_1ittjvhb", navigateBtnBox = "_1ittjvhc", navigateBtn$1 = "_1ittjvhd";
const Text$3 = Text$6.withProps({
  component: "div"
}), CompoundNode = memo$1(({
  id: id2,
  data: {
    element,
    ports,
    layoutId = id2,
    leaving = !1,
    initialAnimation = !0,
    ...data
  },
  width: width2 = 200,
  height = 100,
  ...props2
}) => {
  const scale2 = (diff) => ({
    scaleX: (width2 + diff) / width2,
    scaleY: (height + diff) / height
  });
  let opacity = 1;
  data.dimmed && (opacity = data.dimmed === "immediate" ? 0.05 : 0.15), leaving && (opacity = 0);
  const {
    elementsSelectable
  } = useStore$1(
    useCallback$1((s2) => ({
      elementsSelectable: s2.elementsSelectable
    }), []),
    shallowEqual
  ), selectable = props2.selectable ?? elementsSelectable;
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(
      m.div,
      {
        className: clsx([
          compoundNodeBody,
          "likec4-compound-node"
        ]),
        layoutId,
        "data-compound-depth": data.depth ?? 1,
        "data-likec4-color": element.color,
        initial: layoutId === id2 && initialAnimation ? {
          ...scale2(-20),
          opacity: 0,
          width: width2,
          height
        } : !1,
        animate: {
          ...scale2(0),
          opacity,
          width: width2,
          height,
          transition: {
            opacity: {
              delay: !leaving && data.dimmed === !0 ? 0.4 : 0,
              ...(leaving || data.dimmed === "immediate") && {
                duration: 0.09
              }
            }
          }
        },
        ...selectable && {
          whileHover: {
            ...scale2(12),
            scaleX: (width2 + 12) / width2,
            scaleY: (height + 12) / height,
            transition: {
              delay: 0.1
            }
          },
          whileTap: {
            ...scale2(-12)
          }
        },
        children: /* @__PURE__ */ jsx(Text$3, { className: compoundNodeTitle, maw: width2 - 20, children: element.title })
      }
    ),
    ports.left.map(({ id: id22, type }, i2) => /* @__PURE__ */ jsx(
      Handle,
      {
        id: id22,
        type: type === "in" ? "target" : "source",
        position: Position.Left,
        style: {
          visibility: "hidden",
          top: `${20 * (i2 + 1)}px`
        }
      },
      id22
    )),
    ports.right.map(({ id: id22, type }, i2) => /* @__PURE__ */ jsx(
      Handle,
      {
        id: id22,
        type: type === "in" ? "target" : "source",
        position: Position.Right,
        style: {
          visibility: "hidden",
          top: `${20 * (i2 + 1)}px`
        }
      },
      id22
    ))
  ] });
}, (prev, next) => deepEqual(prev.data, next.data)), Action$1 = ActionIcon$1.withProps({
  className: "nodrag nopan " + navigateBtn$1,
  radius: "md",
  role: "button",
  onDoubleClick: stopPropagation$1,
  onPointerDownCapture: stopPropagation$1
}), Text$2 = Text$6.withProps({
  component: "div"
});
function selector$5(s2) {
  return {
    currentViewId: s2.view.id,
    onNavigateTo: s2.onNavigateTo,
    onOpenSource: s2.onOpenSourceElement
  };
}
const ElementNode = memo$1(({
  id: id2,
  data: {
    element,
    ports,
    navigateTo,
    layoutId = id2,
    leaving = !1,
    initialAnimation = !0,
    ...data
  },
  selectable = !0,
  width: w = 100,
  height: h = 100
}) => {
  const overlay = useOverlayDialog(), {
    currentViewId,
    onNavigateTo,
    onOpenSource
  } = useDiagramState(selector$5), scale2 = (diff) => ({
    scaleX: (w + diff) / w,
    scaleY: (h + diff) / h
  });
  let opacity = 1;
  return data.dimmed && (opacity = data.dimmed === "immediate" ? 0.05 : 0.15), leaving && (opacity = 0), /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsxs(
      m.div,
      {
        className: clsx([
          elementNode,
          "likec4-element-node"
        ]),
        layoutId,
        "data-likec4-color": element.color,
        initial: layoutId === id2 && initialAnimation ? {
          ...scale2(-20),
          opacity: 0,
          width: w,
          height: h
        } : !1,
        animate: {
          ...scale2(0),
          opacity,
          width: w,
          height: h,
          transition: {
            opacity: {
              delay: !leaving && data.dimmed === !0 ? 0.4 : 0,
              ...(leaving || data.dimmed === "immediate") && {
                duration: 0.09
              }
            }
          }
        },
        ...selectable && {
          whileHover: {
            ...scale2(16)
            // transition: {
            //   delay: 0.1
            // }
          },
          whileTap: {
            ...scale2(-8)
          }
        },
        children: [
          /* @__PURE__ */ jsx(
            "svg",
            {
              className: clsx(
                cssShapeSvg
              ),
              viewBox: `0 0 ${w} ${h}`,
              width: w,
              height: h,
              children: /* @__PURE__ */ jsx(ElementShapeSvg, { shape: element.shape, w, h })
            }
          ),
          /* @__PURE__ */ jsxs(Box, { className: elementNodeContent, children: [
            /* @__PURE__ */ jsx(Text$2, { className: elementNodeTitle, lineClamp: 2, children: element.title }),
            element.description && /* @__PURE__ */ jsx(Text$2, { className: elementNodeDescription, lineClamp: 4, children: element.description })
          ] }),
          /* @__PURE__ */ jsxs(Group, { className: navigateBtnBox, children: [
            navigateTo && onNavigateTo && navigateTo !== currentViewId && /* @__PURE__ */ jsx(
              Action$1,
              {
                onClick: (event) => {
                  event.stopPropagation(), overlay.close(() => onNavigateTo(navigateTo));
                },
                children: /* @__PURE__ */ jsx(IconZoomScan, { stroke: 1.8, style: { width: "75%" } })
              }
            ),
            data.column !== "subjects" && /* @__PURE__ */ jsx(
              Action$1,
              {
                onClick: (event) => {
                  event.stopPropagation(), overlay.openOverlay({
                    relationshipsOf: data.fqn
                  });
                },
                children: /* @__PURE__ */ jsx(IconTransform, { stroke: 1.8, style: { width: "72%" } })
              }
            ),
            onOpenSource && /* @__PURE__ */ jsx(
              Action$1,
              {
                onClick: (event) => {
                  event.stopPropagation(), onOpenSource(data.fqn);
                },
                children: /* @__PURE__ */ jsx(IconFileSymlink, { stroke: 1.8, style: { width: "72%" } })
              }
            )
          ] })
        ]
      }
    ),
    ports.left.map(({ id: id22, type }, i2) => /* @__PURE__ */ jsx(
      Handle,
      {
        id: id22,
        type: type === "in" ? "target" : "source",
        position: Position.Left,
        style: {
          visibility: "hidden",
          top: `${15 + (i2 + 1) * ((h - 30) / (ports.left.length + 1))}px`
        }
      },
      id22
    )),
    ports.right.map(({ id: id22, type }, i2) => /* @__PURE__ */ jsx(
      Handle,
      {
        id: id22,
        type: type === "in" ? "target" : "source",
        position: Position.Right,
        style: {
          visibility: "hidden",
          top: `${15 + (i2 + 1) * ((h - 30) / (ports.right.length + 1))}px`
        }
      },
      id22
    ))
  ] });
}, (prev, next) => deepEqual(prev.data, next.data)), Text$1 = Text$6.withProps({
  component: "div"
});
function EmptyNode({
  data: {
    column
  }
}) {
  return /* @__PURE__ */ jsx(Box, { className: emptyNode, children: /* @__PURE__ */ jsxs(Text$1, { c: "dimmed", fz: "lg", fw: 500, children: [
    "No ",
    column === "incomers" ? "incoming" : "outgoing"
  ] }) });
}
const Tooltip$4 = Tooltip$5.withProps({
  color: "dark",
  fz: "sm",
  openDelay: 400,
  closeDelay: 150,
  withinPortal: !1,
  label: "",
  children: null,
  offset: 4
});
function RelationshipEdge$1({
  data,
  label: label2,
  ...props2
}) {
  const {
    viewId,
    onNavigateTo
  } = useDiagramState((s2) => ({
    viewId: s2.view.id,
    onNavigateTo: s2.onNavigateTo
  })), overlay = useOverlayDialog(), [edgePath, labelX, labelY] = getBezierPath(props2), navigateTo = onNavigateTo ? t$5(data.relations)?.navigateTo : void 0, isMultiRelation = data.relations.length > 1, technology2 = t$5(data.relations)?.technology;
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(
      "g",
      {
        className: edgeContainer,
        "data-edge-dimmed": data.dimmed,
        "data-edge-hovered": data.hovered,
        "data-likec4-color": data.includedInCurrentView ? "gray" : "amber",
        children: /* @__PURE__ */ jsx(
          BaseEdge,
          {
            path: edgePath,
            ...props2
          }
        )
      }
    ),
    /* @__PURE__ */ jsx(EdgeLabelRenderer, { children: /* @__PURE__ */ jsxs(
      Stack$1,
      {
        gap: 2,
        style: {
          position: "absolute",
          transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,
          maxWidth: Math.abs(props2.targetX - props2.sourceX - 70),
          zIndex: ZIndexes.max
        },
        className: clsx([
          edgeLabel$1,
          "nodrag nopan"
        ]),
        "data-edge-dimmed": data.dimmed,
        "data-edge-hovered": data.hovered,
        "data-likec4-color": data.includedInCurrentView ? "gray" : "amber",
        children: [
          label2 && /* @__PURE__ */ jsx(Tooltip$4, { label: "Not included in current view", disabled: data.includedInCurrentView, color: "orange", children: /* @__PURE__ */ jsxs(Group, { gap: 6, wrap: "nowrap", children: [
            isMultiRelation && /* @__PURE__ */ jsx(ThemeIcon, { size: "sm", variant: "transparent", color: "orange", children: /* @__PURE__ */ jsx(IconBoxMultipleFilled, { style: { width: "80%" } }) }),
            /* @__PURE__ */ jsx(
              Text$6,
              {
                fw: isMultiRelation ? "500" : "400",
                style: {
                  whiteSpace: isMultiRelation ? "nowrap" : void 0
                },
                component: "div",
                className: edgeLabelText$1,
                lineClamp: 3,
                children: label2
              }
            )
          ] }) }),
          technology2 && /* @__PURE__ */ jsxs(Text$6, { component: "div", className: edgeLabelTechnology, children: [
            "[ ",
            technology2,
            " ]"
          ] }),
          navigateTo && viewId !== navigateTo && /* @__PURE__ */ jsx(Box, { ta: "center", mt: 4, children: /* @__PURE__ */ jsx(
            ActionIcon$1,
            {
              variant: "default",
              size: "sm",
              radius: "sm",
              onPointerDownCapture: stopPropagation$1,
              onClick: (event) => {
                event.stopPropagation(), overlay.close(() => {
                  onNavigateTo?.(navigateTo, event);
                });
              },
              role: "button",
              onDoubleClick: stopPropagation$1,
              children: /* @__PURE__ */ jsx(IconZoomScan, {})
            }
          ) })
        ]
      }
    ) })
  ] });
}
const nodeTypes$1 = {
  element: ElementNode,
  compound: CompoundNode,
  empty: EmptyNode
}, edgeTypes$1 = {
  relation: RelationshipEdge$1
}, findRootSubject = (nodes) => nodes.find((n2) => n2.data.column === "subjects" && n$2(n2.parentId)), resetDimmedAndHovered = (xyflow2) => {
  xyflow2.setEdges(
    (edges) => edges.map((edge) => ({
      ...edge,
      data: {
        ...edge.data,
        dimmed: !1,
        hovered: !1
      },
      animated: !1
    }))
  ), xyflow2.setNodes(
    (nodes) => nodes.map(
      (n2) => ({
        ...n2,
        data: {
          ...n2.data,
          dimmed: !1,
          hovered: !1
        }
      })
    )
  );
}, animateEdge = (node2, animated = !0) => (edges) => edges.map((edge) => {
  const isConnected = edge.source === node2.id || edge.target === node2.id || isAncestor(node2.id, edge.source) || isAncestor(node2.id, edge.target);
  return {
    ...edge,
    animated: animated && isConnected
  };
}), selectContainerViewport = (s2) => `${s2.width}x${s2.height}`;
function RelationshipsXYFlowWrapped({
  subjectId,
  view,
  nodes,
  edges,
  bounds,
  children,
  maxZoom = 2,
  minZoom = 0.05,
  viewportPadding = 0.1,
  ...rest
}) {
  const id2 = useId$2(), lastClickedNodeRef = useRef$1(null), xyflow2 = useReactFlow(), xystore = useStoreApi(), [zoomOnDoubleClick, setZoomOnDoubleClick] = useState$1(!0), containerviewport = useStore$1(selectContainerViewport);
  useOnViewportChange({
    onEnd: ({ x: x2, y: y2, zoom }) => {
      const roundedX = Math.round(x2), roundedY = Math.round(y2);
      (x2 !== roundedX || y2 !== roundedY) && xystore.setState({ transform: [roundedX, roundedY, zoom] }), setZoomOnDoubleClick(zoom < 0.7);
    }
  });
  const initialFitviewFlagRef = useRef$1(!1), viewBoundsRef = useSyncedRef(bounds), fitview = useDebouncedCallback(
    () => {
      const { width: width2, height } = xystore.getState();
      xyflow2.setViewport(
        getViewportForBounds(viewBoundsRef.current, width2, height, minZoom, maxZoom, viewportPadding),
        initialFitviewFlagRef.current ? { duration: 500 } : void 0
      ), initialFitviewFlagRef.current = !0;
    },
    [xyflow2, minZoom, maxZoom, viewportPadding],
    100
  );
  return useUpdateEffect(() => {
    fitview();
  }, [containerviewport]), useDeepCompareEffect(() => {
    const {
      nodes: _nodes,
      edges: _edges,
      setNodes,
      setEdges,
      width: width2,
      height
    } = xystore.getState(), nextSubjectNode = findRootSubject(nodes), currentSubjectNode = findRootSubject(_nodes);
    if (currentSubjectNode && nextSubjectNode?.data.fqn === currentSubjectNode.data.fqn) {
      setNodes(m$1(nodes, s$1(["data", "initialAnimation"], !1))), setEdges(edges), fitview();
      return;
    }
    nextSubjectNode ? nextSubjectNode.data.fqn !== subjectId && console.error(`Subject node mismatch, expected: ${subjectId} got: ${nextSubjectNode.data.fqn}`) : console.error("Subject node not found");
    const nextzoom = getViewportForBounds(bounds, width2, height, minZoom, maxZoom, viewportPadding).zoom, nextSubjectCenter = nextSubjectNode && {
      x: nextSubjectNode.position.x + (nextSubjectNode.width ?? 0) / 2,
      y: nextSubjectNode.position.y + (nextSubjectNode.height ?? 0) / 2
    }, existingNode = lastClickedNodeRef.current ?? xyflow2.getNodes().find((n2) => n2.type !== "empty" && n2.data.column !== "subjects" && n2.data.fqn === subjectId);
    if (lastClickedNodeRef.current = null, nextSubjectCenter && existingNode && currentSubjectNode) {
      const currentSubjectInternalNode = xyflow2.getInternalNode(currentSubjectNode.id), currentSubjectCenter = centerXYInternalNode(currentSubjectInternalNode), existingInternalNode = xyflow2.getInternalNode(existingNode.id), existingDimensions = getNodeDimensions(existingInternalNode);
      nextSubjectNode.data.layoutId = existingNode.id, setNodes(_nodes.map((n2) => n2.id !== existingNode.id ? {
        ...n2,
        data: {
          ...n2.data,
          leaving: n2.data.column === "subjects",
          dimmed: n2.data.column === "subjects" ? "immediate" : !1
        }
        // hidden: n.data.column === 'subjects'
      } : {
        ...y$4(n2, ["parentId"]),
        position: {
          x: currentSubjectCenter.x - existingDimensions.width / 2,
          y: currentSubjectCenter.y - existingDimensions.height / 2
        },
        zIndex: ZIndexes.max,
        data: {
          ...n2.data,
          leaving: !1,
          dimmed: !1
        }
      })), setEdges(_edges.map((e2) => ({
        ...e2,
        data: {
          ...e2.data,
          dimmed: "immediate"
        },
        hidden: e2.source === existingNode.id || e2.target === existingNode.id || isAncestor(existingNode.id, e2.source) || isAncestor(existingNode.id, e2.target)
      })));
      const zoom = Math.min(
        xyflow2.getViewport().zoom,
        nextzoom
      );
      let isCancelled = !1;
      return requestAnimationFrame(async () => {
        await delay$1(150), !isCancelled && (await xyflow2.setCenter(currentSubjectCenter.x, currentSubjectCenter.y, { zoom, duration: 250 }), requestAnimationFrame(() => {
          isCancelled || (xyflow2.setCenter(nextSubjectCenter.x, nextSubjectCenter.y, { zoom }), setNodes(nodes), setEdges(edges), fitview());
        }));
      }), () => {
        isCancelled = !0;
      };
    }
    setNodes(m$1(nodes, s$1(["data", "initialAnimation"], !1))), setEdges(edges), fitview();
  }, [nodes, edges, subjectId]), /* @__PURE__ */ jsx(
    index,
    {
      id: id2,
      defaultEdges: [],
      defaultNodes: [],
      nodeTypes: nodeTypes$1,
      edgeTypes: edgeTypes$1,
      defaultMarkerColor: "var(--likec4-relation-lineColor)",
      className: cssReactflowMarker,
      zoomOnPinch: !0,
      zoomOnScroll: !1,
      zoomOnDoubleClick,
      maxZoom,
      minZoom,
      fitView: !0,
      fitViewOptions: {
        padding: viewportPadding,
        maxZoom,
        minZoom,
        includeHiddenNodes: !0
      },
      preventScrolling: !0,
      noDragClassName: "nodrag",
      noPanClassName: "nopan",
      panOnScroll: !0,
      panOnDrag: !0,
      nodesFocusable: !1,
      edgesFocusable: !1,
      nodesDraggable: !1,
      onNodeMouseEnter: (_, node2) => {
        node2.type !== "empty" && xyflow2.setEdges(animateEdge(node2, !0));
      },
      onNodeMouseLeave: () => {
        resetDimmedAndHovered(xyflow2);
      },
      onEdgeMouseEnter: (_, edge) => {
        xyflow2.setEdges(
          (edges2) => edges2.map((e2) => ({
            ...e2,
            data: {
              ...e2.data,
              dimmed: e2.id !== edge.id,
              hovered: e2.id === edge.id
            },
            zIndex: e2.id === edge.id ? ZIndexes.max : ZIndexes.edge,
            animated: e2.id === edge.id
          }))
        ), xyflow2.setNodes(
          (nodes2) => nodes2.map((n2) => ({
            ...n2,
            data: {
              ...n2.data,
              dimmed: n2.id !== edge.source && n2.id !== edge.target
            }
          }))
        );
      },
      onEdgeMouseLeave: () => {
        resetDimmedAndHovered(xyflow2);
      },
      onNodeDoubleClick: (e2) => {
        e2.stopPropagation();
      },
      ...!zoomOnDoubleClick && {
        onDoubleClick: (e2) => {
          e2.stopPropagation(), fitview();
        }
      },
      ...rest,
      children
    }
  );
}
function RelationshipsXYFlow(props2) {
  return /* @__PURE__ */ jsx(
    ReactFlowProvider,
    {
      defaultNodes: [],
      defaultEdges: [],
      children: /* @__PURE__ */ jsx(RelationshipsXYFlowWrapped, { ...props2 })
    }
  );
}
var fqn = "bt3ejo0", relationshipStat = "bt3ejo1", xyflow = "bt3ejo2", panelScope = "bt3ejo3";
function TabPanelRelationships({
  currentView,
  element
}) {
  const layoutId = useId$2(), enableRelationshipBrowser = useDiagramState((s2) => s2.enableRelationshipBrowser), overlay = useOverlayDialog(), [scope, setScope] = useState$1("view"), node2 = nonNullable(currentView.nodes.find((n2) => n2.id === element.id)), incoming = element.incoming().map((r2) => r2.id), outgoing = element.outgoing().map((r2) => r2.id), findRelationIds = (edgeId) => currentView.edges.find((edge) => edge.id === edgeId)?.relations ?? [], incomingInView = i$9(node2.inEdges.flatMap(findRelationIds)), outgoingInView = i$9(node2.outEdges.flatMap(findRelationIds)), notIncludedRelations = [
    ...incoming,
    ...outgoing
  ].filter((r2) => !incomingInView.includes(r2) && !outgoingInView.includes(r2)).length, {
    edges,
    nodes,
    bounds
  } = useLayoutedRelationships(element.id, currentView, scope);
  return /* @__PURE__ */ jsxs(Stack$1, { gap: "xs", pos: "relative", w: "100%", h: "100%", children: [
    incoming.length + outgoing.length > 0 && /* @__PURE__ */ jsxs(Group, { gap: "xs", wrap: "nowrap", align: "center", children: [
      /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsxs(Group, { gap: 8, mb: 4, wrap: "nowrap", children: [
        /* @__PURE__ */ jsx(
          RelationshipsStat,
          {
            title: "incoming",
            total: incoming.length,
            included: incomingInView.length
          }
        ),
        /* @__PURE__ */ jsx(ThemeIcon, { size: "sm", variant: "transparent", c: "dimmed", children: /* @__PURE__ */ jsx(IconArrowRight, { style: { width: 16 } }) }),
        /* @__PURE__ */ jsx(Text$6, { className: fqn, children: nameFromFqn(element.id) }),
        /* @__PURE__ */ jsx(ThemeIcon, { size: "sm", variant: "transparent", c: "dimmed", children: /* @__PURE__ */ jsx(IconArrowRight, { style: { width: 16 } }) }),
        /* @__PURE__ */ jsx(
          RelationshipsStat,
          {
            title: "outgoing",
            total: outgoing.length,
            included: outgoingInView.length
          }
        )
      ] }) }),
      notIncludedRelations > 0 && /* @__PURE__ */ jsxs(
        Group,
        {
          mt: "xs",
          gap: 6,
          c: "orange",
          style: { cursor: "pointer" },
          children: [
            /* @__PURE__ */ jsx(IconInfoCircle, { style: { width: 14 } }),
            /* @__PURE__ */ jsxs(Text$6, { fz: "sm", children: [
              notIncludedRelations,
              " relationship",
              notIncludedRelations > 1 ? "s are" : " is",
              " hidden"
            ] })
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsx(Box, { className: xyflow, children: /* @__PURE__ */ jsx(LayoutGroup, { id: layoutId, children: /* @__PURE__ */ jsxs(
      RelationshipsXYFlow,
      {
        subjectId: element.id,
        bounds,
        nodes,
        edges,
        view: currentView,
        elementsSelectable: !1,
        children: [
          /* @__PURE__ */ jsx(Panel$1, { position: "top-left", className: panelScope, children: /* @__PURE__ */ jsx(
            SegmentedControl,
            {
              size: "xs",
              withItemsBorders: !1,
              value: scope,
              onChange: setScope,
              data: [
                { label: "Global", value: "global" },
                { label: "View", value: "view" }
              ]
            }
          ) }),
          enableRelationshipBrowser && /* @__PURE__ */ jsx(Panel$1, { position: "top-right", children: /* @__PURE__ */ jsx(
            Button,
            {
              size: "compact-sm",
              variant: "default",
              fz: "xs",
              fw: 500,
              rightSection: /* @__PURE__ */ jsx(IconExternalLink, { stroke: 1.6, style: { width: 16 } }),
              onClick: (e2) => {
                e2.stopPropagation(), overlay.close(() => {
                  overlay.openOverlay({
                    relationshipsOf: element.id
                  });
                });
              },
              children: "Open"
            }
          ) })
        ]
      }
    ) }) })
  ] });
}
function RelationshipsStat({
  title: title2,
  total,
  included
}) {
  return /* @__PURE__ */ jsx(
    Paper,
    {
      withBorder: !0,
      shadow: "none",
      className: relationshipStat,
      px: "md",
      py: "xs",
      radius: "md",
      mod: {
        zero: total === 0,
        missing: total !== included
      },
      children: /* @__PURE__ */ jsxs(Stack$1, { gap: 4, align: "flex-end", children: [
        /* @__PURE__ */ jsx(Text$6, { component: "div", c: total !== included ? "orange" : "dimmed", tt: "uppercase", fw: 600, fz: 10, lh: 1, children: title2 }),
        /* @__PURE__ */ jsx(Text$6, { fw: 600, fz: "xl", component: "div", lh: 1, children: total !== included ? /* @__PURE__ */ jsxs(Fragment$1, { children: [
          included,
          " / ",
          total
        ] }) : /* @__PURE__ */ jsx(Fragment$1, { children: total }) })
      ] })
    }
  );
}
var treeNodeLabel = "_956g9l0", elementLabel = "_956g9l1";
const ElementLabel = ({
  element
}) => /* @__PURE__ */ jsx(Box, { className: elementLabel, children: /* @__PURE__ */ jsx(Text$6, { component: "div", fz: "sm", fw: "500", children: element.title }) });
function TabElementStructure({
  element
}) {
  const tree = useTree({
    multiple: !1
  }), data = useMemo$1(() => {
    let seq = 1;
    const messageNode = (label2) => ({
      label: label2,
      value: `msg${seq++}`,
      type: "message",
      children: []
    }), current = {
      label: /* @__PURE__ */ jsx(ElementLabel, { type: "current", element }),
      value: element.id,
      element,
      type: "current",
      children: element.children().map((child) => ({
        label: /* @__PURE__ */ jsx(ElementLabel, { type: "descedant", element: child }),
        value: child.id,
        element: child,
        type: "descedant",
        children: []
      }))
    };
    return current.children.length === 0 && current.children.push(
      messageNode(/* @__PURE__ */ jsx(Pill, { radius: "sm", children: "no nested" }))
    ), [
      element.ancestors().reduce((acc, parent) => ({
        label: /* @__PURE__ */ jsx(ElementLabel, { type: "ancestor", element: parent }),
        value: parent.id,
        element: parent,
        type: "ancestor",
        children: [acc]
      }), current)
    ];
  }, [element]);
  return useEffect$1(() => {
    tree.expandAllNodes();
  }, [data]), /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsxs(Alert, { variant: "light", color: "orange", title: "In development", icon: /* @__PURE__ */ jsx(IconInfoCircle, {}), children: [
      "We need your feedback. Share your thoughts and ideas -",
      " ",
      /* @__PURE__ */ jsx(
        Anchor,
        {
          fz: "sm",
          fw: 500,
          underline: "hover",
          c: "orange",
          href: "https://github.com/likec4/likec4/discussions/",
          target: "_blank",
          children: "GitHub discussions"
        }
      )
    ] }),
    /* @__PURE__ */ jsx(
      Tree,
      {
        levelOffset: "xl",
        allowRangeSelection: !1,
        expandOnClick: !1,
        expandOnSpace: !1,
        classNames: {
          label: treeNodeLabel
        },
        data,
        tree
      }
    )
  ] });
}
const Divider = Divider$1.withProps({
  mb: 8,
  labelPosition: "left",
  variant: "dashed"
}), Tooltip$3 = Tooltip$5.withProps({
  color: "dark",
  fz: "xs",
  openDelay: 400,
  closeDelay: 150,
  label: "",
  children: null,
  offset: 4
}), SmallLabel = Text$6.withProps({
  component: "div",
  fz: 11,
  fw: 500,
  c: "dimmed",
  lh: 1
}), PropertyLabel = Text$6.withProps({
  component: "div",
  fz: "xs",
  c: "dimmed",
  className: propertyLabel
}), MIN_PADDING = 24;
function ElementDetailsCard({ fqn: fqn2 }) {
  const windowSize = useViewportSize(), windowWidth = windowSize.width || window.innerWidth || 1200, windowHeight = windowSize.height || window.innerHeight || 800, xyflow2 = useXYFlow(), xynode = useInternalNode(fqn2);
  invariant$1(xynode, `XYNode with id ${fqn2} not found`);
  const overlay = useOverlayDialog(), [activeTab, setActiveTab] = useState$1("Properties"), diagramApi = useDiagramStoreApi(), {
    view: currentView,
    renderIcon,
    onNavigateTo,
    onOpenSourceElement: onOpenSource
  } = useDiagramState(i$6(["view", "renderIcon", "onNavigateTo", "onOpenSourceElement"])), element = currentView.nodes.find((n2) => n2.id === fqn2);
  invariant$1(element, `DiagramNode with fqn ${fqn2} not found`);
  const likec4Model = useLikeC4Model(!0), elementModel = likec4Model.element(fqn2), viewId = currentView.id, elementIcon2 = ElementIcon$1({
    element,
    viewId,
    renderIcon
  }), incoming = elementModel.incoming().map((r2) => r2.id), outgoing = elementModel.outgoing().map((r2) => r2.id), findRelationIds = (edgeId) => currentView.edges.find((edge) => edge.id === edgeId)?.relations ?? [], incomingInView = i$9(element.inEdges.flatMap(findRelationIds)), outgoingInView = i$9(element.outEdges.flatMap(findRelationIds));
  [
    ...incoming,
    ...outgoing
  ].filter((r2) => !incomingInView.includes(r2) && !outgoingInView.includes(r2)).length;
  const [viewsOf, otherViews] = x$1(
    elementModel.views(),
    m$1((v) => v.view),
    d$2((v) => v.__ !== "dynamic" && v.viewOf === fqn2)
  ), defaultView = element.navigateTo ? likec4Model.view(element.navigateTo).view : f(viewsOf, (v) => v.id !== currentView.id) ?? null, defaultLink = element.links && t$5(element.links), onNavigateToCb = useCallback$1((toView, e2) => {
    e2?.stopPropagation();
    const { onNavigateTo: onNavigateTo2 } = diagramApi.getState();
    onNavigateTo2 && overlay.close(() => {
      diagramApi.setState({
        lastOnNavigate: {
          fromView: currentView.id,
          toView,
          fromNode: fqn2
        }
      }), onNavigateTo2(toView);
    });
  }, [fqn2, currentView.id]), controls = useDragControls(), isCompound = element.children.length > 0, fromPositon = xyflow2.flowToScreenPosition({
    x: xynode.internals.positionAbsolute.x + element.width / 2,
    y: xynode.internals.positionAbsolute.y + (isCompound ? 0 : element.height / 2)
  }), _width = Math.min(700, windowWidth - MIN_PADDING * 2), _height = Math.min(650, windowHeight - MIN_PADDING * 2), left = Math.round(
    u(fromPositon.x - _width / 2, {
      min: MIN_PADDING,
      max: windowWidth - _width - MIN_PADDING
    })
  ), top = Math.round(
    u(fromPositon.y - (isCompound ? 0 : 60), {
      min: MIN_PADDING,
      max: windowHeight - _height - MIN_PADDING
    })
  ), width2 = useMotionValue(_width), height = useMotionValue(_height), handleDrag = useCallback$1((_, info) => {
    width2.set(Math.max(width2.get() + info.delta.x, 320)), height.set(Math.max(height.get() + info.delta.y, 300));
  }, []), ref = useRef$1(null);
  return useEffect$1(() => {
    ref.current?.showModal();
  }, []), /* @__PURE__ */ jsx(
    m.dialog,
    {
      ref,
      className: dialog,
      initial: {
        "--backdrop-blur": "0px",
        "--backdrop-opacity": "0%"
      },
      animate: {
        "--backdrop-blur": "1px",
        "--backdrop-opacity": "50%"
      },
      exit: {
        "--backdrop-blur": "0px",
        "--backdrop-opacity": "0%"
      },
      onClick: (e2) => {
        e2.target?.nodeName?.toUpperCase() === "DIALOG" && (e2.stopPropagation(), overlay.close());
      },
      onClose: (e2) => {
        e2.stopPropagation(), overlay.close();
      },
      children: /* @__PURE__ */ jsx(RemoveScroll, { forwardProps: !0, children: /* @__PURE__ */ jsx(
        Card,
        {
          drag: !0,
          dragElastic: 0,
          dragMomentum: !1,
          dragListener: !1,
          dragControls: controls,
          withBorder: !0,
          shadow: "md",
          component: m.div,
          className: card$2,
          layoutId: `${viewId}:element:${fqn2}`,
          initial: {
            top,
            left,
            width: _width,
            height: _height,
            opacity: 0
          },
          animate: {
            opacity: 1
          },
          exit: {
            opacity: 0
          },
          style: {
            // `style` prop in Mantine doesn't accept motion values
            width: width2,
            height
          },
          onKeyDown: (e2) => {
            e2.key === "Escape" && (e2.preventDefault(), e2.stopPropagation(), overlay.close());
          },
          "data-likec4-color": element.color,
          children: /* @__PURE__ */ jsxs(FocusTrap, { children: [
            /* @__PURE__ */ jsx(FocusTrapInitialFocus, {}),
            /* @__PURE__ */ jsxs(
              Box,
              {
                className: cardHeader,
                onPointerDown: (e2) => controls.start(e2),
                children: [
                  /* @__PURE__ */ jsxs(Group, { align: "start", justify: "space-between", gap: "sm", mb: "sm", wrap: "nowrap", children: [
                    /* @__PURE__ */ jsxs(Group, { align: "start", gap: "sm", style: { cursor: "default" }, wrap: "nowrap", children: [
                      elementIcon2,
                      /* @__PURE__ */ jsxs(Box, { children: [
                        /* @__PURE__ */ jsx(
                          Text$6,
                          {
                            component: m.div,
                            layout: "position",
                            layoutId: `${viewId}:element:title:${fqn2}`,
                            className: title$3,
                            children: elementModel.title
                          }
                        ),
                        element.notation && /* @__PURE__ */ jsx(Text$6, { component: "div", c: "dimmed", fz: "sm", fw: 500, lh: 1.3, lineClamp: 1, children: element.notation })
                      ] })
                    ] }),
                    /* @__PURE__ */ jsx(
                      CloseButton,
                      {
                        size: "lg",
                        onClick: (e2) => {
                          e2.stopPropagation(), overlay.close();
                        }
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxs(Group, { align: "baseline", gap: "sm", wrap: "nowrap", children: [
                    /* @__PURE__ */ jsxs(Box, { children: [
                      /* @__PURE__ */ jsx(SmallLabel, { children: "kind" }),
                      /* @__PURE__ */ jsx(Badge, { radius: "sm", size: "sm", fw: 600, color: "gray", children: element.kind })
                    ] }),
                    /* @__PURE__ */ jsxs(Box, { flex: 1, children: [
                      /* @__PURE__ */ jsx(SmallLabel, { children: "tags" }),
                      /* @__PURE__ */ jsxs(Flex, { gap: 4, flex: 1, mt: 6, children: [
                        element.tags?.map((tag) => /* @__PURE__ */ jsxs(Badge, { radius: "sm", size: "sm", fw: 600, variant: "gradient", children: [
                          "#",
                          tag
                        ] }, tag)),
                        !element.tags && /* @__PURE__ */ jsx(Badge, { radius: "sm", size: "sm", fw: 600, color: "gray", children: "" })
                      ] })
                    ] }),
                    /* @__PURE__ */ jsxs(
                      ActionIconGroup,
                      {
                        style: {
                          alignSelf: "flex-end"
                        },
                        children: [
                          defaultLink && /* @__PURE__ */ jsx(
                            ActionIcon$1,
                            {
                              component: "a",
                              href: defaultLink.url,
                              target: "_blank",
                              size: "lg",
                              variant: "default",
                              radius: "sm",
                              children: /* @__PURE__ */ jsx(IconExternalLink, { stroke: 1.6, style: { width: "65%" } })
                            }
                          ),
                          onOpenSource && /* @__PURE__ */ jsx(Tooltip$3, { label: "Open source", children: /* @__PURE__ */ jsx(
                            ActionIcon$1,
                            {
                              size: "lg",
                              variant: "default",
                              radius: "sm",
                              onClick: (e2) => {
                                e2.stopPropagation(), diagramApi.getState().onOpenSourceElement?.(fqn2);
                              },
                              children: /* @__PURE__ */ jsx(IconFileSymlink, { stroke: 1.8, style: { width: "62%" } })
                            }
                          ) }),
                          defaultView && /* @__PURE__ */ jsx(Tooltip$3, { label: "Open default view", children: /* @__PURE__ */ jsx(
                            ActionIcon$1,
                            {
                              size: "lg",
                              variant: "default",
                              radius: "sm",
                              onClick: (e2) => {
                                onNavigateToCb(defaultView.id, e2);
                              },
                              children: /* @__PURE__ */ jsx(IconZoomScan, { style: { width: "70%" } })
                            }
                          ) })
                        ]
                      }
                    )
                  ] })
                ]
              }
            ),
            /* @__PURE__ */ jsxs(
              Tabs,
              {
                value: activeTab,
                onChange: (v) => setActiveTab(v),
                variant: "none",
                classNames: {
                  root: tabsRoot,
                  list: tabsList,
                  tab: tabsTab,
                  panel: tabsPanel
                },
                children: [
                  /* @__PURE__ */ jsxs(TabsList, { children: [
                    /* @__PURE__ */ jsx(TabsTab, { value: "Properties", children: "Properties" }),
                    /* @__PURE__ */ jsx(TabsTab, { value: "Relationships", children: "Relationships" }),
                    /* @__PURE__ */ jsx(TabsTab, { value: "Views", children: "Views" }),
                    /* @__PURE__ */ jsx(TabsTab, { value: "Structure", children: "Structure" })
                  ] }),
                  /* @__PURE__ */ jsx(TabsPanel, { value: "Properties", children: /* @__PURE__ */ jsx(ScrollArea, { scrollbars: "y", type: "auto", children: /* @__PURE__ */ jsxs(Box, { className: propertiesGrid, pt: "xs", children: [
                    /* @__PURE__ */ jsx(ElementProperty, { title: "description", emptyValue: "no description", children: element.description }),
                    element.technology && /* @__PURE__ */ jsx(ElementProperty, { title: "technology", children: element.technology }),
                    element.links && /* @__PURE__ */ jsxs(Fragment$1, { children: [
                      /* @__PURE__ */ jsx(PropertyLabel, { children: "links" }),
                      /* @__PURE__ */ jsx(Stack$1, { gap: "xs", align: "flex-start", children: element.links.map((link, i2) => /* @__PURE__ */ jsx(ElementLink, { value: link }, i2)) })
                    ] }),
                    elementModel.element.metadata && /* @__PURE__ */ jsx(ElementMetata, { value: elementModel.element.metadata })
                  ] }) }) }),
                  /* @__PURE__ */ jsx(TabsPanel, { value: "Relationships", children: activeTab === "Relationships" && /* @__PURE__ */ jsx(
                    TabPanelRelationships,
                    {
                      element: elementModel,
                      currentView
                    }
                  ) }),
                  /* @__PURE__ */ jsx(TabsPanel, { value: "Views", children: /* @__PURE__ */ jsx(ScrollArea, { scrollbars: "y", type: "auto", children: /* @__PURE__ */ jsxs(Stack$1, { gap: "lg", children: [
                    viewsOf.length > 0 && /* @__PURE__ */ jsxs(Box, { children: [
                      /* @__PURE__ */ jsx(Divider, { label: "views of the element (scoped)" }),
                      /* @__PURE__ */ jsx(Stack$1, { gap: "sm", children: viewsOf.map((view) => /* @__PURE__ */ jsx(
                        ViewButton,
                        {
                          view,
                          onNavigateTo: onNavigateToCb
                        },
                        view.id
                      )) })
                    ] }),
                    otherViews.length > 0 && /* @__PURE__ */ jsxs(Box, { children: [
                      /* @__PURE__ */ jsx(Divider, { label: "views including this element" }),
                      /* @__PURE__ */ jsx(Stack$1, { gap: "sm", children: otherViews.map((view) => /* @__PURE__ */ jsx(
                        ViewButton,
                        {
                          view,
                          onNavigateTo: onNavigateToCb
                        },
                        view.id
                      )) })
                    ] })
                  ] }) }) }),
                  /* @__PURE__ */ jsx(TabsPanel, { value: "Structure", children: /* @__PURE__ */ jsx(ScrollArea, { scrollbars: "y", type: "auto", children: /* @__PURE__ */ jsx(TabElementStructure, { element: elementModel }) }) })
                ]
              }
            ),
            /* @__PURE__ */ jsx(
              m.div,
              {
                className: resizeHandle,
                drag: !0,
                dragElastic: 0,
                dragMomentum: !1,
                onDrag: handleDrag,
                dragConstraints: { top: 0, left: 0, right: 0, bottom: 0 }
              }
            )
          ] })
        }
      ) })
    }
  );
}
const ElementIcon$1 = ({ element, viewId, renderIcon: RenderIcon2 }) => {
  if (!element.icon)
    return null;
  let icon = null;
  return element.icon.startsWith("http://") || element.icon.startsWith("https://") ? icon = /* @__PURE__ */ jsx("img", { src: element.icon, alt: element.title }) : RenderIcon2 && (icon = /* @__PURE__ */ jsx(RenderIcon2, { node: element })), icon ? /* @__PURE__ */ jsx(
    m.div,
    {
      layoutId: `${viewId}:element:icon:${element.id}`,
      className: clsx(
        elementIcon$1,
        "likec4-element-icon"
      ),
      "data-likec4-icon": element.icon,
      children: icon
    }
  ) : null;
}, ViewButton = ({
  view,
  onNavigateTo
}) => /* @__PURE__ */ jsx(UnstyledButton, { className: viewButton, onClick: (e2) => onNavigateTo(view.id, e2), children: /* @__PURE__ */ jsxs(Group, { gap: 6, align: "start", wrap: "nowrap", children: [
  /* @__PURE__ */ jsx(ThemeIcon, { size: "sm", variant: "transparent", children: /* @__PURE__ */ jsx(IconZoomScan, { stroke: 1.8 }) }),
  /* @__PURE__ */ jsxs(Box, { children: [
    /* @__PURE__ */ jsx(Text$6, { component: "div", className: viewButtonTitle, lineClamp: 1, children: view.title || "untitled" }),
    view.description && /* @__PURE__ */ jsx(Text$6, { component: "div", mt: 2, fz: "xs", c: "dimmed", lh: 1.4, lineClamp: 1, children: view.description })
  ] })
] }) });
function ElementProperty({
  title: title2,
  emptyValue = "undefined",
  children,
  style,
  ...props2
}) {
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(PropertyLabel, { children: title2 }),
    /* @__PURE__ */ jsx(
      Text$6,
      {
        component: "div",
        ...n$2(children) && { c: "dimmed" },
        fz: "md",
        style: {
          whiteSpace: "preserve-breaks",
          ...style
        },
        ...props2,
        children: children || emptyValue
      }
    )
  ] });
}
function ElementLink({
  value
}) {
  const url = new URL(value.url, window.location.href).toString();
  return /* @__PURE__ */ jsx(CopyButton$1, { value: url, children: ({ copied, copy }) => /* @__PURE__ */ jsx(Anchor, { href: url, target: "_blank", underline: "never", className: elementLink, children: /* @__PURE__ */ jsxs(Group, { gap: 4, align: "center", wrap: "nowrap", children: [
    /* @__PURE__ */ jsx(
      ActionIcon$1,
      {
        tabIndex: -1,
        size: 24,
        variant: copied ? "light" : "subtle",
        color: copied ? "teal" : "gray",
        onClick: (e2) => {
          e2.stopPropagation(), e2.preventDefault(), copy();
        },
        children: copied ? /* @__PURE__ */ jsx(IconCheck, {}) : /* @__PURE__ */ jsx(IconCopy, { style: { width: "65%", opacity: 0.8 } })
      }
    ),
    /* @__PURE__ */ jsxs(Box, { flex: 1, children: [
      /* @__PURE__ */ jsx(Text$6, { fz: "sm", truncate: !0, lh: 1.3, fw: value.title ? 500 : 400, children: value.title || url }),
      value.title && /* @__PURE__ */ jsx(Text$6, { component: "div", fz: 10, c: "dimmed", lh: 1.2, truncate: !0, children: url })
    ] })
  ] }) }) });
}
function ElementMetata({
  value
}) {
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(PropertyLabel, { children: "metadata" }),
    /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(Code, { block: !0, children: JSON.stringify(value, null, 2) }) })
  ] });
}
const RelationshipsOverlay = memo$1(function({ subjectId }) {
  const view = useDiagramState((s2) => s2.view), [_scope, setScope] = useLocalStorage({
    key: "likec4:scope-relationships-of",
    getInitialValueInEffect: !1,
    defaultValue: "view"
  }), {
    notIncludedRelations,
    viewIncludesSubject,
    edges,
    nodes,
    subject,
    bounds
  } = useLayoutedRelationships(subjectId, view, _scope), scope = viewIncludesSubject ? _scope : "global", showSubjectWarning = !viewIncludesSubject && _scope === "view", [historySubjectId, historyOps, { history, current }] = useStateHistory(subjectId), overlay = useOverlayDialog();
  return useEffect$1(() => {
    historySubjectId !== subjectId && historyOps.set(subjectId);
  }, [subjectId]), useEffect$1(() => {
    historySubjectId !== subjectId && overlay.openOverlay({
      relationshipsOf: historySubjectId
    });
  }, [historySubjectId]), /* @__PURE__ */ jsx(
    RelationshipsXYFlow,
    {
      nodes,
      edges,
      bounds,
      view,
      subjectId,
      viewportPadding: 0.2,
      onNodeClick: (e2, node2) => {
        e2.stopPropagation(), node2.type !== "empty" && overlay.openOverlay({
          relationshipsOf: node2.data.fqn
        });
      },
      children: /* @__PURE__ */ jsx(Panel$1, { position: "top-center", children: /* @__PURE__ */ jsxs(Group, { gap: "xs", wrap: "nowrap", children: [
        /* @__PURE__ */ jsx(
          Button,
          {
            leftSection: /* @__PURE__ */ jsx(IconArrowLeft, { stroke: 3, size: 14 }),
            color: "dimmed",
            variant: "subtle",
            style: {
              visibility: current > 0 ? "visible" : "hidden",
              padding: "0.25rem 0.75rem"
            },
            styles: {
              label: {
                fontWeight: 400
              },
              section: {
                marginInlineEnd: 6
              }
            },
            size: "sm",
            onClick: (e2) => {
              e2.stopPropagation(), historyOps.back();
            },
            children: "Back"
          }
        ),
        /* @__PURE__ */ jsx(Space, { w: 2 }),
        /* @__PURE__ */ jsxs(Group, { gap: "xs", pos: "relative", wrap: "nowrap", flex: "1 0 auto", children: [
          /* @__PURE__ */ jsx(Box, { fz: "sm", fw: "400", style: { whiteSpace: "nowrap", userSelect: "none" }, children: "Relationships of" }),
          /* @__PURE__ */ jsx(Box, { flex: "1 0 auto", children: /* @__PURE__ */ jsx(
            SelectElement,
            {
              scope,
              subject: subject.element,
              onSelect: (fqn2) => overlay.openOverlay({
                relationshipsOf: fqn2
              }),
              viewId: view.id
            }
          ) }),
          /* @__PURE__ */ jsx(
            SegmentedControl,
            {
              flex: "1 0 auto",
              size: "xs",
              withItemsBorders: !1,
              value: scope,
              onChange: setScope,
              data: [
                { label: "Global", value: "global" },
                { label: "Current view", value: "view", disabled: !viewIncludesSubject }
              ]
            }
          ),
          showSubjectWarning && /* @__PURE__ */ jsx(
            Box,
            {
              pos: "absolute",
              top: "calc(100% + .5rem)",
              left: "50%",
              w: "max-content",
              style: {
                transform: "translateX(-50%)",
                textAlign: "center",
                cursor: "pointer"
              },
              onClick: (e2) => {
                e2.stopPropagation(), setScope("global");
              },
              children: /* @__PURE__ */ jsx(Text$6, { fw: 500, size: "xs", c: "orange", component: "div", children: "Current view doesn't include this element, switched to Global" })
            }
          ),
          viewIncludesSubject && scope === "view" && notIncludedRelations > 0 && /* @__PURE__ */ jsx(
            Box,
            {
              pos: "absolute",
              top: "calc(100% + .5rem)",
              left: "50%",
              w: "max-content",
              style: {
                transform: "translateX(-50%)",
                textAlign: "center",
                cursor: "pointer"
              },
              onClick: (e2) => {
                e2.stopPropagation(), setScope("global");
              },
              children: /* @__PURE__ */ jsxs(Text$6, { fw: 500, size: "xs", c: "orange", component: "div", children: [
                "View does not include ",
                notIncludedRelations,
                " ",
                "relationship",
                notIncludedRelations > 1 ? "s" : "",
                ". Switch to Global to compare"
              ] })
            }
          )
        ] }),
        /* @__PURE__ */ jsx(
          Button,
          {
            rightSection: /* @__PURE__ */ jsx(IconArrowRight, { stroke: 3, size: 14 }),
            color: "dimmed",
            variant: "subtle",
            style: {
              visibility: current + 1 < history.length ? "visible" : "hidden",
              padding: "0.25rem 0.75rem"
            },
            styles: {
              label: {
                fontWeight: 400
              },
              section: {
                marginInlineStart: 4
              }
            },
            size: "sm",
            onClick: (e2) => {
              e2.stopPropagation(), historyOps.forward();
            },
            children: "Forward"
          }
        )
      ] }) })
    }
  );
}), Overlays = memo$1(() => {
  const diagramStore = useDiagramStoreApi(), {
    activeOverlay,
    viewId
  } = useDiagramState((s2) => ({
    activeOverlay: s2.activeOverlay,
    viewId: s2.view.id
  })), onCloseCbRef = useRef$1(), ctxValue = useMemo$1(() => ({
    openOverlay: (overlay) => {
      diagramStore.getState().openOverlay(overlay);
    },
    close: (cb) => {
      onCloseCbRef.current = cb, diagramStore.getState().closeOverlay();
    }
  }), [diagramStore]), onExitComplete = () => {
    onCloseCbRef.current?.(), onCloseCbRef.current = void 0;
  };
  return useHotkeys(
    !!activeOverlay ? [
      ["Escape", (e2) => {
        e2.stopPropagation(), ctxValue.close();
      }, { preventDefault: !0 }]
    ] : []
  ), /* @__PURE__ */ jsxs(OverlayContext.Provider, { value: ctxValue, children: [
    /* @__PURE__ */ jsx(AnimatePresence, { initial: !1, onExitComplete, children: activeOverlay?.elementDetails && /* @__PURE__ */ jsx(ElementDetailsCard, { fqn: activeOverlay.elementDetails }, "details card") }, viewId),
    /* @__PURE__ */ jsx(AnimatePresence, { initial: !1, onExitComplete, children: activeOverlay && n$2(activeOverlay.elementDetails) && /* @__PURE__ */ jsx(RemoveScroll, { forwardProps: !0, children: /* @__PURE__ */ jsx(
      Box,
      {
        component: m.div,
        className: container$5,
        "data-likec4-color": "gray",
        initial: {
          "--backdrop-blur": "0px",
          "--backdrop-opacity": "0%",
          opacity: 0,
          translateY: -15
        },
        animate: {
          "--backdrop-blur": "10px",
          "--backdrop-opacity": "70%",
          opacity: 1,
          translateY: 0
        },
        exit: {
          "--backdrop-blur": "1px",
          "--backdrop-opacity": "0%",
          translateY: -5,
          opacity: 0,
          transition: {
            duration: 0.2
          }
        },
        children: /* @__PURE__ */ jsxs(FocusTrap, { children: [
          activeOverlay.relationshipsOf && /* @__PURE__ */ jsx(RelationshipsOverlay, { subjectId: activeOverlay.relationshipsOf }),
          activeOverlay.edgeDetails && /* @__PURE__ */ jsx(
            ReactFlowProvider,
            {
              defaultNodes: [],
              defaultEdges: [],
              children: /* @__PURE__ */ jsx(EdgeDetailsXYFlow, { edgeId: activeOverlay.edgeDetails })
            }
          ),
          /* @__PURE__ */ jsx(Box, { pos: "absolute", top: "1rem", right: "1rem", children: /* @__PURE__ */ jsx(
            ActionIcon$1,
            {
              variant: "default",
              size: "lg",
              onClick: (e2) => {
                e2.stopPropagation(), ctxValue.close();
              },
              children: /* @__PURE__ */ jsx(IconX, {})
            }
          ) })
        ] })
      }
    ) }) })
  ] });
});
function EnsureMantine({ children }) {
  if (!useContext$1(MantineContext))
    throw new Error("LikeC4Diagram must be a child of MantineProvider");
  return /* @__PURE__ */ jsx(Fragment$1, { children });
}
EnsureMantine.displayName = "EnsureMantine";
const FramerMotionConfig = ({ children }) => {
  const layoutId = useId$2(), nonce = useMantineStyleNonce()?.();
  return /* @__PURE__ */ jsx(LazyMotion, { features: domMax, strict: !0, children: /* @__PURE__ */ jsx(MotionConfig, { reducedMotion: "user", ...nonce && { nonce }, children: /* @__PURE__ */ jsx(LayoutGroup, { id: layoutId, children }) }) });
};
function selectXYFlowSize(state) {
  return `${Math.round(state.width)}:${Math.round(state.height)}`;
}
function selectDiagramsize({ view, fitViewPadding }) {
  return [
    view.bounds.x,
    view.bounds.y,
    view.bounds.width,
    view.bounds.height,
    fitViewPadding
  ].map(Math.round).join(":");
}
function FitViewOnViewportResize({ diagramApi }) {
  const xyflowsize = useXYStore(selectXYFlowSize), viewsize = useDiagramState(selectDiagramsize), dimensions = xyflowsize + viewsize, prevDimensionsRef = useRef$1(dimensions);
  return useDebouncedEffect(
    () => {
      const { focusedNodeId, fitDiagram } = diagramApi.getState();
      focusedNodeId || prevDimensionsRef.current === dimensions || (prevDimensionsRef.current = dimensions, fitDiagram(250));
    },
    [dimensions, diagramApi],
    250
  ), null;
}
function selector$4({ view, activeWalkthrough, viewportChanged, fitViewPadding }) {
  return {
    layoutId: view.id + "_" + view.autoLayout + "_" + fitViewPadding,
    isActiveWalkthrough: !!activeWalkthrough,
    viewportNotMoved: !viewportChanged
  };
}
function FitViewOnDiagramChange() {
  const {
    layoutId,
    isActiveWalkthrough,
    viewportNotMoved
  } = useDiagramState(selector$4, shallowEqual), diagramApi = useDiagramStoreApi(), [currentLayoutId, setCurrent] = useState$1(layoutId), requiresFit = layoutId !== currentLayoutId;
  return useDebouncedEffect(
    () => {
      layoutId !== currentLayoutId && (setCurrent(layoutId), diagramApi.getState().fitDiagram(450));
    },
    [requiresFit, diagramApi],
    50
  ), viewportNotMoved && !isActiveWalkthrough && !requiresFit ? /* @__PURE__ */ jsx(FitViewOnViewportResize, { diagramApi }) : null;
}
function SelectEdgesOnNodeFocus() {
  const diagramStore = useDiagramStoreApi(), focusedNodeId = useDiagramState((s2) => s2.focusedNodeId);
  return useUpdateEffect(() => {
    if (!focusedNodeId) {
      diagramStore.getState().xystore.getState().resetSelectedElements();
      return;
    }
    const container2 = diagramStore.getState().getContainer();
    if (!container2)
      return;
    const edgeChanges = [], nodeChanges = [], {
      edgeLookup,
      nodeLookup,
      panZoom,
      transform,
      triggerNodeChanges,
      triggerEdgeChanges
    } = diagramStore.getState().xystore.getState();
    let focusBounds = nodeToRect(nonNullable(nodeLookup.get(focusedNodeId)));
    for (const [, edge] of edgeLookup) {
      if (edge.source === focusedNodeId || edge.target === focusedNodeId) {
        const anotherNodeId = edge.source === focusedNodeId ? edge.target : edge.source, nd = nonNullable(nodeLookup.get(anotherNodeId));
        focusBounds = getBoundsOfRects(focusBounds, nodeToRect(nd));
      }
      edge.selected && edgeChanges.push({
        id: edge.id,
        type: "select",
        selected: !1
      });
    }
    for (const [, node2] of nodeLookup)
      node2.selected && node2.id !== focusedNodeId && nodeChanges.push({
        id: node2.id,
        type: "select",
        selected: !1
      });
    nodeChanges.push({
      id: focusedNodeId,
      type: "select",
      selected: !0
    }), edgeChanges.length > 0 && triggerEdgeChanges(edgeChanges), triggerNodeChanges(nodeChanges);
    const { width: width2, height } = container2.getBoundingClientRect(), maxZoom = Math.max(1, transform[2]), viewport = getViewportForBounds(
      {
        x: focusBounds.x - 16,
        y: focusBounds.y - 16,
        width: focusBounds.width + 32,
        height: focusBounds.height + 32
      },
      width2,
      height,
      MinZoom,
      maxZoom,
      0
    );
    panZoom?.setViewport(viewport, {
      duration: 350
    });
  }, [focusedNodeId]), useHotkeys(
    focusedNodeId !== null ? [
      ["Escape", (e2) => {
        e2.stopPropagation();
        const { resetFocusAndLastClicked, fitDiagram } = diagramStore.getState();
        resetFocusAndLastClicked(), fitDiagram();
      }, { preventDefault: !0 }]
    ] : []
  ), null;
}
function assignInlineVars(varsOrContract, tokens) {
  var styles = {};
  {
    var _vars = varsOrContract;
    for (var varName in _vars) {
      var value = _vars[varName];
      value != null && (styles[getVarName(varName)] = value);
    }
  }
  return Object.defineProperty(styles, "toString", {
    value: function() {
      return Object.keys(this).map((key) => "".concat(key, ":").concat(this[key])).join(";");
    },
    writable: !1
  }), styles;
}
function constant(x2) {
  return function() {
    return x2;
  };
}
const epsilon$1 = 1e-12, pi = Math.PI, tau = 2 * pi, epsilon = 1e-6, tauEpsilon = tau - epsilon;
function append(strings) {
  this._ += strings[0];
  for (let i2 = 1, n2 = strings.length; i2 < n2; ++i2)
    this._ += arguments[i2] + strings[i2];
}
function appendRound(digits) {
  let d2 = Math.floor(digits);
  if (!(d2 >= 0)) throw new Error(`invalid digits: ${digits}`);
  if (d2 > 15) return append;
  const k = 10 ** d2;
  return function(strings) {
    this._ += strings[0];
    for (let i2 = 1, n2 = strings.length; i2 < n2; ++i2)
      this._ += Math.round(arguments[i2] * k) / k + strings[i2];
  };
}
class Path {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x2, y2) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(x2, y2) {
    this._append`L${this._x1 = +x2},${this._y1 = +y2}`;
  }
  quadraticCurveTo(x1, y1, x2, y2) {
    this._append`Q${+x1},${+y1},${this._x1 = +x2},${this._y1 = +y2}`;
  }
  bezierCurveTo(x1, y1, x2, y2, x3, y3) {
    this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x3},${this._y1 = +y3}`;
  }
  arcTo(x1, y1, x2, y2, r2) {
    if (x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r2 = +r2, r2 < 0) throw new Error(`negative radius: ${r2}`);
    let x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null)
      this._append`M${this._x1 = x1},${this._y1 = y1}`;
    else if (l01_2 > epsilon) if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r2)
      this._append`L${this._x1 = x1},${this._y1 = y1}`;
    else {
      let x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l2 = r2 * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l2 / l01, t21 = l2 / l21;
      Math.abs(t01 - 1) > epsilon && this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`, this._append`A${r2},${r2},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
    }
  }
  arc(x2, y2, r2, a0, a1, ccw) {
    if (x2 = +x2, y2 = +y2, r2 = +r2, ccw = !!ccw, r2 < 0) throw new Error(`negative radius: ${r2}`);
    let dx = r2 * Math.cos(a0), dy = r2 * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    this._x1 === null ? this._append`M${x0},${y0}` : (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) && this._append`L${x0},${y0}`, r2 && (da < 0 && (da = da % tau + tau), da > tauEpsilon ? this._append`A${r2},${r2},0,1,${cw},${x2 - dx},${y2 - dy}A${r2},${r2},0,1,${cw},${this._x1 = x0},${this._y1 = y0}` : da > epsilon && this._append`A${r2},${r2},0,${+(da >= pi)},${cw},${this._x1 = x2 + r2 * Math.cos(a1)},${this._y1 = y2 + r2 * Math.sin(a1)}`);
  }
  rect(x2, y2, w, h) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}h${w = +w}v${+h}h${-w}Z`;
  }
  toString() {
    return this._;
  }
}
function withPath(shape) {
  let digits = 3;
  return shape.digits = function(_) {
    if (!arguments.length) return digits;
    if (_ == null)
      digits = null;
    else {
      const d2 = Math.floor(_);
      if (!(d2 >= 0)) throw new RangeError(`invalid digits: ${_}`);
      digits = d2;
    }
    return shape;
  }, () => new Path(digits);
}
function array(x2) {
  return typeof x2 == "object" && "length" in x2 ? x2 : Array.from(x2);
}
function Linear(context) {
  this._context = context;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    switch (x2 = +x2, y2 = +y2, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(x2, y2);
        break;
    }
  }
};
function curveLinear(context) {
  return new Linear(context);
}
function x(p2) {
  return p2[0];
}
function y(p2) {
  return p2[1];
}
function d3line(x$12, y$12) {
  var defined = constant(!0), context = null, curve2 = curveLinear, output = null, path = withPath(line);
  x$12 = typeof x$12 == "function" ? x$12 : x$12 === void 0 ? x : constant(x$12), y$12 = typeof y$12 == "function" ? y$12 : y$12 === void 0 ? y : constant(y$12);
  function line(data) {
    var i2, n2 = (data = array(data)).length, d2, defined0 = !1, buffer;
    for (context == null && (output = curve2(buffer = path())), i2 = 0; i2 <= n2; ++i2)
      !(i2 < n2 && defined(d2 = data[i2], i2, data)) === defined0 && ((defined0 = !defined0) ? output.lineStart() : output.lineEnd()), defined0 && output.point(+x$12(d2, i2, data), +y$12(d2, i2, data));
    if (buffer) return output = null, buffer + "" || null;
  }
  return line.x = function(_) {
    return arguments.length ? (x$12 = typeof _ == "function" ? _ : constant(+_), line) : x$12;
  }, line.y = function(_) {
    return arguments.length ? (y$12 = typeof _ == "function" ? _ : constant(+_), line) : y$12;
  }, line.defined = function(_) {
    return arguments.length ? (defined = typeof _ == "function" ? _ : constant(!!_), line) : defined;
  }, line.curve = function(_) {
    return arguments.length ? (curve2 = _, context != null && (output = curve2(context)), line) : curve2;
  }, line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve2(context = _), line) : context;
  }, line;
}
function point$1(that, x2, y2) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x2),
    that._y2 + that._k * (that._y1 - y2),
    that._x2,
    that._y2
  );
}
function Cardinal(context, tension) {
  this._context = context, this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point$1(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    switch (x2 = +x2, y2 = +y2, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2, this._x1 = x2, this._y1 = y2;
        break;
      case 2:
        this._point = 3;
      default:
        point$1(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
(function custom(tension) {
  function cardinal(context) {
    return new Cardinal(context, tension);
  }
  return cardinal.tension = function(tension2) {
    return custom(+tension2);
  }, cardinal;
})(0);
function CardinalOpen(context, tension) {
  this._context = context, this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    switch (x2 = +x2, y2 = +y2, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point$1(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
(function custom2(tension) {
  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }
  return cardinal.tension = function(tension2) {
    return custom2(+tension2);
  }, cardinal;
})(0);
function point(that, x2, y2) {
  var x1 = that._x1, y1 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon$1) {
    var a2 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n2 = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a2 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n2, y1 = (y1 * a2 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n2;
  }
  if (that._l23_a > epsilon$1) {
    var b2 = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m2 = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b2 + that._x1 * that._l23_2a - x2 * that._l12_2a) / m2, y22 = (y22 * b2 + that._y1 * that._l23_2a - y2 * that._l12_2a) / m2;
  }
  that._context.bezierCurveTo(x1, y1, x22, y22, that._x2, that._y2);
}
function CatmullRom(context, alpha2) {
  this._context = context, this._alpha = alpha2;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    if (x2 = +x2, y2 = +y2, this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        point(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
(function custom3(alpha2) {
  function catmullRom(context) {
    return alpha2 ? new CatmullRom(context, alpha2) : new Cardinal(context, 0);
  }
  return catmullRom.alpha = function(alpha3) {
    return custom3(+alpha3);
  }, catmullRom;
})(0.5);
function CatmullRomOpen(context, alpha2) {
  this._context = context, this._alpha = alpha2;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    if (x2 = +x2, y2 = +y2, this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
const curveCatmullRomOpen = function custom4(alpha2) {
  function catmullRom(context) {
    return alpha2 ? new CatmullRomOpen(context, alpha2) : new CardinalOpen(context, 0);
  }
  return catmullRom.alpha = function(alpha3) {
    return custom4(+alpha3);
  }, catmullRom;
}(0.5), Open = (props2) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "-4 -4 14 16",
    refX: 5,
    refY: 4,
    markerWidth: "7",
    markerHeight: "8",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...props2,
    children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M0,0 L7,4 L0,8 L4,4 Z",
        stroke: "context-stroke",
        fill: "context-stroke",
        strokeDasharray: 0,
        strokeWidth: 1,
        strokeLinecap: "round"
      }
    )
  }
), Arrow = (props2) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "-1 -1 12 10",
    refX: 4,
    refY: 3,
    markerWidth: "8",
    markerHeight: "6",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...props2,
    children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M 0 0 L 8 3 L 0 6 L 1 3 z",
        fill: "context-stroke",
        strokeWidth: 0
      }
    )
  }
), Crow = (props2) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "-1 -1 12 12",
    refX: 8,
    refY: 4,
    markerWidth: "8",
    markerHeight: "8",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...props2,
    children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M 8 0 L 0 4 L 8 8 M 8 4 L 0 4",
        fill: "none",
        strokeWidth: 1
      }
    )
  }
), OArrow = (props2) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "-1 -1 12 10",
    refX: 4,
    refY: 3,
    markerWidth: "8",
    markerHeight: "6",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...props2,
    children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M 0 0 L 8 3 L 0 6 L 1 3 z",
        stroke: "context-stroke",
        fill: "var(--likec4-background-color)",
        strokeWidth: 1.25,
        strokeLinejoin: "miter",
        strokeLinecap: "square"
      }
    )
  }
), Diamond = (props2) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "-4 -4 16 14",
    refX: 5,
    refY: 4,
    markerWidth: "10",
    markerHeight: "8",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...props2,
    children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M5,0 L10,4 L5,8 L0,4 Z",
        fill: "context-stroke",
        strokeWidth: 0,
        strokeLinecap: "round"
      }
    )
  }
), ODiamond = (props2) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "-4 -4 16 14",
    refX: 6,
    refY: 4,
    markerWidth: "10",
    markerHeight: "8",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...props2,
    children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M5,0 L10,4 L5,8 L0,4 Z",
        stroke: "context-stroke",
        fill: "var(--likec4-background-color)",
        strokeWidth: 1.25,
        strokeLinecap: "round"
      }
    )
  }
), Dot = (props2) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "0 0 10 10",
    refX: 4,
    refY: 4,
    markerWidth: "6",
    markerHeight: "6",
    ...props2,
    children: /* @__PURE__ */ jsx(
      "circle",
      {
        strokeWidth: 0,
        fill: "context-stroke",
        cx: 4,
        cy: 4,
        r: 3
      }
    )
  }
), ODot = (props2) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "0 0 10 10",
    refX: 4,
    refY: 4,
    markerWidth: "6",
    markerHeight: "6",
    ...props2,
    children: /* @__PURE__ */ jsx(
      "circle",
      {
        strokeWidth: 1.25,
        stroke: "context-stroke",
        fill: "var(--likec4-background-color)",
        cx: 4,
        cy: 4,
        r: 3
      }
    )
  }
), EdgeMarkers = {
  Arrow,
  Crow,
  OArrow,
  Open,
  Diamond,
  ODiamond,
  Dot,
  ODot
};
var container$4 = "yi2p6v1", dimmed$1 = "yi2p6v2", edgePathBg = "yi2p6v3", markerContext = "yi2p6v4", controlPoint = "yi2p6v5", controlDragging = "yi2p6v6", cssEdgePath = "yi2p6v8", stepEdgeNumber = "yi2p6v9", varLabelX = "var(--yi2p6va)", varLabelY = "var(--yi2p6vb)", edgeLabel = "yi2p6vd", edgeLabelText = "yi2p6ve", edgeNoteCloseButton = "yi2p6vf", edgeNoteText = "yi2p6vg", cssNavigateBtn = "yi2p6vh", cssNavigateBtnIcon = "yi2p6vi", menuDropdown = "_1gqkcc30", menuItemRelationship = "_1gqkcc31", endpoint = "_1gqkcc32", title$2 = "_1gqkcc33";
const stopPropagation = (e2) => e2.stopPropagation(), Tooltip$2 = Tooltip$5.withProps({
  color: "gray",
  fz: "xs",
  openDelay: 300,
  closeDelay: 150,
  label: "",
  children: null,
  offset: 8,
  withinPortal: !1
});
function RelationshipsDropdownMenu({
  edge,
  disabled = !1,
  likec4model,
  children
}) {
  const {
    openOverlay,
    enableRelationshipBrowser
  } = useDiagramState(i$6(["openOverlay", "enableRelationshipBrowser"])), portalProps = useMantinePortalProps(), [sourceXYNode, targetXYNode] = useXYNodesData([edge.source, edge.target]);
  invariant$1(sourceXYNode, `Source XYNode ${edge.source} not found for edge ${edge.id}`), invariant$1(targetXYNode, `Target XYNode ${edge.target} not found for edge ${edge.id}`);
  const [direct, nested] = x$1(
    edge.relations,
    m$1((id2) => {
      try {
        return likec4model.relationship(id2);
      } catch (e2) {
        return console.error(
          `View is cached and likec4model missing relationship ${id2} from ${edge.source} -> ${edge.target}`,
          e2
        ), null;
      }
    }),
    T(n$4),
    d$2((r2) => r2.relationship.source === edge.source && r2.relationship.target === edge.target)
  ), onClickOpenOverlay = useCallback$1((e2) => {
    e2.stopPropagation(), enableRelationshipBrowser && openOverlay({
      edgeDetails: edge.id
    });
  }, [edge.id, openOverlay, enableRelationshipBrowser]), renderRelationship = (relationship, index2) => /* @__PURE__ */ jsxs(Fragment, { children: [
    index2 > 0 && /* @__PURE__ */ jsx(MenuDivider, { opacity: 0.65 }),
    /* @__PURE__ */ jsx(
      MenuItem,
      {
        onClick: onClickOpenOverlay,
        component: Relationship,
        relationship,
        sourceNode: sourceXYNode.data.element,
        targetNode: targetXYNode.data.element,
        edge
      }
    )
  ] }, relationship.id);
  return direct.length + nested.length === 0 ? /* @__PURE__ */ jsx(Fragment$1, { children }) : /* @__PURE__ */ jsxs(
    Menu,
    {
      trigger: "click-hover",
      openDelay: 300,
      closeDelay: 450,
      floatingStrategy: "fixed",
      closeOnClickOutside: !0,
      clickOutsideEvents: ["pointerdown", "mousedown", "click"],
      closeOnEscape: !0,
      closeOnItemClick: !1,
      disabled,
      ...portalProps,
      children: [
        /* @__PURE__ */ jsx(MenuTarget, { children }),
        /* @__PURE__ */ jsxs(
          MenuDropdown,
          {
            className: menuDropdown,
            onPointerDownCapture: stopPropagation,
            onPointerDown: stopPropagation,
            onClick: stopPropagation,
            children: [
              direct.length > 0 && /* @__PURE__ */ jsxs(Fragment$1, { children: [
                /* @__PURE__ */ jsx(MenuLabel, { children: "direct relationships" }),
                direct.map(renderRelationship)
              ] }),
              nested.length > 0 && /* @__PURE__ */ jsxs(Fragment$1, { children: [
                direct.length > 0 && /* @__PURE__ */ jsx(MenuDivider, {}),
                /* @__PURE__ */ jsx(MenuLabel, { children: "resolved from nested" }),
                nested.map(renderRelationship)
              ] }),
              enableRelationshipBrowser && /* @__PURE__ */ jsx(Box, { pos: "absolute", top: 5, right: 6, children: /* @__PURE__ */ jsx(
                ActionIcon$1,
                {
                  size: 24,
                  variant: "subtle",
                  onClick: onClickOpenOverlay,
                  children: /* @__PURE__ */ jsx(IconInfoCircle, { style: { width: "70%" } })
                }
              ) })
            ]
          }
        )
      ]
    }
  );
}
const Relationship = forwardRef$1(({
  className,
  relationship: r2,
  edge,
  sourceNode,
  targetNode,
  ...props2
}, ref) => {
  const diagramApi = useDiagramStoreApi(), {
    viewId,
    hasOnOpenSourceRelation,
    hasOnNavigateTo
  } = useDiagramState((s2) => ({
    viewId: s2.view.id,
    hasOnOpenSourceRelation: !!s2.onOpenSourceRelation,
    hasOnNavigateTo: !!s2.onNavigateTo
  })), sourceId = nameFromFqn(edge.source) + r2.source.id.slice(edge.source.length), targetId = nameFromFqn(edge.target) + r2.target.id.slice(edge.target.length), navigateTo = hasOnNavigateTo && r2.relationship.navigateTo !== viewId ? r2.relationship.navigateTo : void 0;
  return /* @__PURE__ */ jsxs(Stack$1, { ref, className: clsx(menuItemRelationship, className), ...props2, children: [
    /* @__PURE__ */ jsxs(Group, { gap: 4, children: [
      /* @__PURE__ */ jsx(Text$6, { component: "div", className: endpoint, "data-likec4-color": sourceNode.color, children: sourceId }),
      /* @__PURE__ */ jsx(IconArrowRight, { stroke: 2.5, size: 11 }),
      /* @__PURE__ */ jsx(Text$6, { component: "div", className: endpoint, "data-likec4-color": targetNode.color, children: targetId }),
      (navigateTo || hasOnOpenSourceRelation) && /* @__PURE__ */ jsxs(TooltipGroup, { openDelay: 100, children: [
        /* @__PURE__ */ jsx(Space, { w: "xs" }),
        navigateTo && /* @__PURE__ */ jsx(Tooltip$2, { label: "Open dynamic view", children: /* @__PURE__ */ jsx(
          ActionIcon$1,
          {
            className: clsx("nodrag nopan"),
            size: "sm",
            radius: "sm",
            variant: "default",
            onPointerDownCapture: stopPropagation,
            onClick: (event) => {
              event.stopPropagation(), diagramApi.getState().onNavigateTo?.(navigateTo, event);
            },
            role: "button",
            children: /* @__PURE__ */ jsx(IconZoomScan, { size: "80%", stroke: 2 })
          }
        ) }),
        hasOnOpenSourceRelation && /* @__PURE__ */ jsx(Tooltip$2, { label: "Open source", children: /* @__PURE__ */ jsx(
          ActionIcon$1,
          {
            className: clsx("nodrag nopan"),
            size: "sm",
            radius: "sm",
            variant: "default",
            onPointerDownCapture: stopPropagation,
            onClick: (event) => {
              event.stopPropagation(), diagramApi.getState().onOpenSourceRelation?.(r2.id);
            },
            role: "button",
            children: /* @__PURE__ */ jsx(IconFileSymlink, { size: "80%", stroke: 2 })
          }
        ) })
      ] })
    ] }),
    /* @__PURE__ */ jsx(Box, { className: title$2, children: r2.title || "untitled" })
  ] });
}), EdgeLabel = ({
  isDimmed,
  edgeData: {
    label: label2,
    edge
  },
  ...props2
}) => {
  const likec4model = useLikeC4Model(), {
    enableRelationshipDetails,
    isActiveWalkthroughStep,
    hasOnNavigateTo
  } = useDiagramState((s2) => ({
    enableRelationshipDetails: s2.enableRelationshipDetails,
    isActiveWalkthroughStep: s2.activeWalkthrough?.stepId === edge.id,
    hasOnNavigateTo: !!s2.onNavigateTo
  })), notes = isActiveWalkthroughStep ? edge.notes ?? null : null, stepNum = isStepEdgeId(edge.id) ? extractStep(edge.id) : null, navigateTo = hasOnNavigateTo ? edge.navigateTo ?? null : null;
  return /* @__PURE__ */ jsx(EdgeLabelRenderer, { children: ((node2) => n$4(notes) ? /* @__PURE__ */ jsx(NotePopover, { notes, children: node2 }) : enableRelationshipDetails && likec4model && edge.relations.length > 0 ? /* @__PURE__ */ jsx(
    RelationshipsDropdownMenu,
    {
      disabled: isDimmed,
      likec4model,
      edge,
      children: node2
    }
  ) : node2)(
    /* @__PURE__ */ jsxs(Box, { ...props2, children: [
      stepNum !== null && /* @__PURE__ */ jsx(Box, { className: stepEdgeNumber, children: stepNum }),
      n$4(label2?.text) && /* @__PURE__ */ jsx(Box, { className: edgeLabelText, children: label2.text }),
      navigateTo && /* @__PURE__ */ jsx(NavigateToBtn, { viewId: navigateTo })
    ] })
  ) });
}, NotePopover = ({ notes, children }) => {
  const {
    nextDynamicStep,
    hasNext,
    hasPrevious
  } = useDiagramState((s2) => ({
    nextDynamicStep: s2.nextDynamicStep,
    hasNext: s2.activeWalkthrough?.hasNext ?? !1,
    hasPrevious: s2.activeWalkthrough?.hasPrevious ?? !1
  })), [isOpened, setIsOpened] = useState$1(!1), portalProps = useMantinePortalProps();
  return useDebouncedEffect(
    () => {
      setIsOpened(!0);
    },
    [],
    300
  ), /* @__PURE__ */ jsxs(
    Popover,
    {
      shadow: "xs",
      offset: 16,
      opened: isOpened,
      closeOnClickOutside: !1,
      ...portalProps,
      children: [
        /* @__PURE__ */ jsx(PopoverTarget, { children }),
        /* @__PURE__ */ jsxs(
          PopoverDropdown,
          {
            component: Stack$1,
            p: "xs",
            onPointerDownCapture: stopPropagation$1,
            onClick: stopPropagation$1,
            onDoubleClick: stopPropagation$1,
            children: [
              /* @__PURE__ */ jsx(ScrollAreaAutosize, { maw: 450, mah: 350, type: "scroll", mx: "auto", mt: 2, children: /* @__PURE__ */ jsx(Text$6, { component: "div", className: edgeNoteText, p: 4, children: notes }) }),
              /* @__PURE__ */ jsx(
                CloseButton,
                {
                  size: "xs",
                  className: edgeNoteCloseButton,
                  onClick: () => setIsOpened(!1)
                }
              ),
              (hasPrevious || hasNext) && /* @__PURE__ */ jsxs(Group, { gap: 0, justify: hasPrevious ? "flex-start" : "flex-end", children: [
                hasPrevious && /* @__PURE__ */ jsx(
                  Button,
                  {
                    variant: "subtle",
                    radius: "xs",
                    size: "compact-xs",
                    onClick: () => nextDynamicStep(-1),
                    children: "back"
                  }
                ),
                hasNext && /* @__PURE__ */ jsx(Button, { variant: "subtle", radius: "xs", size: "compact-xs", onClick: () => nextDynamicStep(), children: "next" })
              ] })
            ]
          }
        )
      ]
    }
  );
};
function NavigateToBtn({ viewId }) {
  const diagramApi = useDiagramStoreApi();
  return /* @__PURE__ */ jsx(
    ActionIcon$1,
    {
      className: clsx("nodrag nopan", cssNavigateBtn),
      size: "sm",
      radius: "sm",
      onPointerDownCapture: stopPropagation$1,
      onClick: (event) => {
        event.stopPropagation(), diagramApi.getState().onNavigateTo?.(viewId, event);
      },
      role: "button",
      onDoubleClick: stopPropagation$1,
      children: /* @__PURE__ */ jsx(IconZoomScan, { className: cssNavigateBtnIcon })
    }
  );
}
function getNodeIntersectionFromCenterToPoint(intersectionNode, { x: x1, y: y1 }) {
  const {
    width: intersectionNodeWidth,
    height: intersectionNodeHeight
  } = getNodeDimensions(intersectionNode), intersectionNodePosition = intersectionNode.internals.positionAbsolute, w = intersectionNodeWidth / 2, h = intersectionNodeHeight / 2, x2 = intersectionNodePosition.x + w, y2 = intersectionNodePosition.y + h, xx1 = (x1 - x2) / (2 * w) - (y1 - y2) / (2 * h), yy1 = (x1 - x2) / (2 * w) + (y1 - y2) / (2 * h), a2 = 1 / (Math.abs(xx1) + Math.abs(yy1)), xx3 = a2 * xx1, yy3 = a2 * yy1, x3 = w * (xx3 + yy3) + x2, y3 = h * (-xx3 + yy3) + y2;
  return { x: x3, y: y3 };
}
const toMarker = (arrowType) => {
  if (!(!arrowType || arrowType === "none"))
    switch (arrowType) {
      case "normal":
        return "Arrow";
      case "crow":
        return "Crow";
      case "onormal":
        return "OArrow";
      case "diamond":
        return "Diamond";
      case "odiamond":
        return "ODiamond";
      case "open":
      case "vee":
        return "Open";
      case "dot":
        return "Dot";
      case "odot":
        return "ODot";
      default:
        nonexhaustive(arrowType);
    }
};
function bezierPath(bezierSpline) {
  let [start, ...points] = bezierSpline;
  invariant$1(start, "start should be defined");
  let path = `M ${start[0]},${start[1]}`;
  for (; i$8(points, 3); ) {
    const [cp1, cp2, end, ...rest] = points;
    path = path + ` C ${cp1[0]},${cp1[1]} ${cp2[0]},${cp2[1]} ${end[0]},${end[1]}`, points = rest;
  }
  return invariant$1(points.length === 0, "all points should be consumed"), path;
}
const isSame = (a2, b2) => Math.abs(a2 - b2) < 2.5, isSamePoint = (a2, b2) => isSame(o$3(a2) ? a2[0] : a2.x, o$3(b2) ? b2[0] : b2.x) && isSame(o$3(a2) ? a2[1] : a2.y, o$3(b2) ? b2[1] : b2.y), sameControlPoints = (a2, b2) => a2 === b2 ? !0 : !a2 || !b2 || a2.length !== b2.length ? !1 : a2.every((ap, i2) => isSamePoint(ap, b2[i2])), isEqualProps$2 = (prev, next) => prev.id === next.id && deepEqual(prev.source, next.source) && deepEqual(prev.target, next.target) && deepEqual(prev.selected ?? !1, next.selected ?? !1) && isSame(prev.sourceX, next.sourceX) && isSame(prev.sourceY, next.sourceY) && isSame(prev.targetX, next.targetX) && isSame(prev.targetY, next.targetY) && deepEqual(prev.data.label, next.data.label) && sameControlPoints(prev.data.controlPoints, next.data.controlPoints) && deepEqual(prev.data.edge, next.data.edge), curve = d3line().curve(curveCatmullRomOpen).x((d2) => d2.x).y((d2) => d2.y), RelationshipEdge = memo$1(function({
  id: id2,
  data,
  sourceX,
  sourceY,
  targetX,
  targetY,
  style,
  source,
  target,
  interactionWidth
}) {
  const [isControlPointDragging, setIsControlPointDragging] = useState$1(!1), diagramStore = useDiagramStoreApi(), xyflowStore = useXYStoreApi(), {
    connectedToFocusedNode,
    isActiveWalkthroughStep,
    isEdgePathEditable,
    isHovered,
    isDimmed,
    isActiveAsParallel
  } = useDiagramState((s2) => ({
    isEdgePathEditable: s2.readonly !== !0 && s2.experimentalEdgeEditing === !0 && s2.focusedNodeId === null && s2.activeWalkthrough === null,
    connectedToFocusedNode: s2.focusedNodeId === source || s2.focusedNodeId === target,
    isActiveWalkthroughStep: s2.activeWalkthrough?.stepId === data.edge.id,
    // If activeWalkthrough and this edge is part of the parallel group
    isActiveAsParallel: !!s2.activeWalkthrough?.parallelPrefix && id2.startsWith(s2.activeWalkthrough.parallelPrefix),
    isHovered: s2.hoveredEdgeId === id2,
    isDimmed: s2.dimmed.has(id2)
  })), isActive = connectedToFocusedNode || isActiveWalkthroughStep, { nodeLookup, edgeLookup } = xyflowStore.getState(), sourceNode = nonNullable(nodeLookup.get(source), `source node ${source} not found`), targetNode = nonNullable(nodeLookup.get(target), `target node ${target} not found`), isModified = n$4(data.controlPoints) || !isSamePoint(sourceNode.internals.positionAbsolute, sourceNode.data.element.position) || !isSamePoint(targetNode.internals.positionAbsolute, targetNode.data.element.position), {
    label: label2,
    edge: {
      points: diagramEdgePoints,
      line = "dashed",
      color: color2 = "gray",
      labelBBox,
      ...diagramEdge
    }
  } = data;
  let controlPoints = data.controlPoints ?? bezierControlPoints(data.edge);
  const isStepEdge = isStepEdgeId(data.edge.id), isDotted = line === "dotted", isDashed = isDotted || line === "dashed";
  let strokeDasharray;
  isDotted ? strokeDasharray = "1,8" : isDashed && (strokeDasharray = "8,10");
  let labelX = labelBBox?.x ?? 0, labelY = labelBBox?.y ?? 0;
  const [labelPos, setLabelPos] = useState$1({
    x: label2?.bbox.x ?? labelX,
    y: label2?.bbox.y ?? labelY
  });
  let edgePath;
  if (isModified) {
    const sourceCenterPos = { x: sourceX, y: sourceY }, targetCenterPos = { x: targetX, y: targetY }, points = diagramEdge.dir === "back" ? [
      targetCenterPos,
      getNodeIntersectionFromCenterToPoint(targetNode, d(controlPoints) ?? sourceCenterPos),
      ...controlPoints,
      getNodeIntersectionFromCenterToPoint(sourceNode, a$2(controlPoints) ?? targetCenterPos),
      sourceCenterPos
    ] : [
      sourceCenterPos,
      getNodeIntersectionFromCenterToPoint(sourceNode, d(controlPoints) ?? targetCenterPos),
      ...controlPoints,
      getNodeIntersectionFromCenterToPoint(targetNode, a$2(controlPoints) ?? sourceCenterPos),
      targetCenterPos
    ];
    edgePath = nonNullable(curve(points));
  } else
    edgePath = bezierPath(diagramEdgePoints);
  const svgPathRef = useRef$1(null);
  useEffect$1(() => {
    const path = svgPathRef.current;
    if (!path) return;
    const dompoint = path.getPointAtLength(path.getTotalLength() * 0.5), point2 = {
      x: Math.round(dompoint.x),
      y: Math.round(dompoint.y)
    };
    setLabelPos((current) => isSamePoint(current, point2) ? current : point2);
  }, [edgePath]), useDebouncedEffect(
    () => {
      !label2 || label2.bbox.x === labelPos.x && label2.bbox.y === labelPos.y || diagramStore.getState().xyflow.updateEdgeData(id2, {
        label: {
          ...label2,
          bbox: {
            ...label2.bbox,
            ...labelPos
          }
        }
      });
    },
    [labelPos],
    50,
    300
  ), (isModified || isControlPointDragging) && (labelX = labelPos.x, labelY = labelPos.y);
  const onLmbControlPointerDown = (index2, e2, domNode) => {
    const { addSelectedEdges } = xyflowStore.getState(), { xyflow: xyflow2 } = diagramStore.getState();
    addSelectedEdges([id2]);
    const wasCanceled = diagramStore.getState().cancelSaveManualLayout();
    e2.stopPropagation();
    let hasMoved = !1, pointer = { x: e2.clientX, y: e2.clientY };
    const onPointerMove = (e22) => {
      const clientPoint = {
        x: e22.clientX,
        y: e22.clientY
      };
      if (!isSamePoint(pointer, clientPoint)) {
        setIsControlPointDragging(!0), hasMoved = !0, pointer = clientPoint;
        const { x: x2, y: y2 } = xyflow2.screenToFlowPosition(pointer, { snapToGrid: !1 });
        xyflow2.updateEdgeData(id2, (xyedge) => {
          const cp = (xyedge.data.controlPoints ?? controlPoints).slice();
          return cp[index2] = {
            x: Math.round(x2),
            y: Math.round(y2)
          }, {
            controlPoints: cp
          };
        });
      }
      e22.stopPropagation();
    }, onPointerUp = (e22) => {
      domNode.removeEventListener("pointermove", onPointerMove, {
        capture: !0
      }), hasMoved && e22.stopPropagation(), (hasMoved || wasCanceled) && diagramStore.getState().scheduleSaveManualLayout(), setIsControlPointDragging(!1);
    };
    domNode.addEventListener("pointermove", onPointerMove, {
      capture: !0
    }), domNode.addEventListener("pointerup", onPointerUp, {
      once: !0,
      capture: !0
    });
  }, onRmbControlPointerDown = (index2, e2, domNode) => {
    const { xyflow: xyflow2 } = diagramStore.getState();
    if (controlPoints.length <= 1)
      return;
    const onPointerUp = (e22) => {
      const newControlPoints = controlPoints.slice();
      newControlPoints.splice(index2, 1), e22.stopPropagation(), setTimeout(() => {
        xyflow2.updateEdgeData(id2, { controlPoints: newControlPoints }), diagramStore.getState().scheduleSaveManualLayout();
      }, 10), domNode.removeEventListener("pointerup", onPointerUp, {
        capture: !0
      }), e22.stopPropagation();
    };
    domNode.addEventListener("pointerup", onPointerUp, {
      once: !0,
      capture: !0
    }), e2.stopPropagation();
  }, onControlPointerDown = (index2, e2) => {
    const { domNode } = xyflowStore.getState();
    if (!(!domNode || e2.pointerType !== "mouse"))
      switch (e2.button) {
        case 0:
          onLmbControlPointerDown(index2, e2, domNode);
          break;
        case 2:
          onRmbControlPointerDown(index2, e2, domNode);
          break;
      }
  }, onEdgePointerDown = (e2) => {
    const { domNode } = xyflowStore.getState(), { xyflow: xyflow2, scheduleSaveManualLayout } = diagramStore.getState();
    !domNode || e2.pointerType !== "mouse" || e2.button === 2 && (xyflow2.updateEdgeData(id2, (edge) => {
      const points = [
        new VectorImpl(sourceX, sourceY),
        ...controlPoints.map(vector) || [],
        new VectorImpl(targetX, targetY)
      ];
      let pointer = { x: e2.clientX, y: e2.clientY };
      const newPoint = vector(xyflow2.screenToFlowPosition(pointer, { snapToGrid: !1 }));
      let insertionIndex = 0, minDistance = 1 / 0;
      for (let i2 = 0; i2 < points.length - 1; i2++) {
        const a2 = points[i2], b2 = points[i2 + 1], fromCurrentToNext = b2.sub(a2), fromCurrentToNew = newPoint.sub(a2), fromNextToNew = newPoint.sub(b2);
        if (fromCurrentToNext.dot(fromCurrentToNew) * fromCurrentToNext.dot(fromNextToNew) < 0) {
          const distanceToEdge = Math.abs(fromCurrentToNext.cross(fromCurrentToNew).abs() / fromCurrentToNext.abs());
          distanceToEdge < minDistance && (minDistance = distanceToEdge, insertionIndex = i2);
        }
      }
      const newControlPoints = edge.data.controlPoints?.slice() || [];
      return newControlPoints.splice(insertionIndex, 0, newPoint), { controlPoints: newControlPoints };
    }), scheduleSaveManualLayout(), e2.stopPropagation());
  };
  let markerStartName = toMarker(diagramEdge.tail), markerEndName = toMarker(diagramEdge.head ?? "normal");
  diagramEdge.dir === "back" && ([markerStartName, markerEndName] = [markerEndName, markerStartName]);
  const MarkerStart = markerStartName ? EdgeMarkers[markerStartName] : null, MarkerEnd = markerEndName ? EdgeMarkers[markerEndName] : null, edgeZIndex = edgeLookup.get(id2).zIndex ?? ZIndexes$2.Edge;
  let labelZIndex;
  return isEdgePathEditable ? labelZIndex = edgeZIndex - 1 : isHovered ? labelZIndex = ZIndexes$2.Element + 1 : labelZIndex = edgeZIndex + 1, /* @__PURE__ */ jsxs(
    "g",
    {
      className: clsx(
        container$4,
        isDimmed && dimmed$1,
        isControlPointDragging && controlDragging
      ),
      "data-likec4-color": color2,
      "data-edge-dir": diagramEdge.dir,
      "data-edge-active": isActive,
      "data-edge-animated": isActive || isActiveAsParallel,
      "data-edge-hovered": isHovered,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            className: clsx("react-flow__edge-interaction"),
            d: edgePath,
            fill: "none",
            stroke: "transparent",
            strokeWidth: interactionWidth ?? 10
          }
        ),
        /* @__PURE__ */ jsxs("g", { className: markerContext, onPointerDown: (e2) => onEdgePointerDown(e2), children: [
          /* @__PURE__ */ jsxs("defs", { children: [
            MarkerStart && /* @__PURE__ */ jsx(MarkerStart, { id: "start" + id2 }),
            MarkerEnd && /* @__PURE__ */ jsx(MarkerEnd, { id: "end" + id2 })
          ] }),
          /* @__PURE__ */ jsx(
            "path",
            {
              className: clsx("react-flow__edge-path", edgePathBg),
              d: edgePath,
              style,
              strokeLinecap: "round"
            }
          ),
          /* @__PURE__ */ jsx(
            "path",
            {
              ref: svgPathRef,
              className: clsx("react-flow__edge-path", cssEdgePath),
              d: edgePath,
              style,
              strokeLinecap: "round",
              strokeDasharray,
              markerStart: MarkerStart ? `url(#start${id2})` : void 0,
              markerEnd: MarkerEnd ? `url(#end${id2})` : void 0
            }
          )
        ] }),
        isEdgePathEditable && /* @__PURE__ */ jsx(
          "g",
          {
            onContextMenu: (e2) => {
              e2.preventDefault(), e2.stopPropagation();
            },
            children: controlPoints.map((p2, i2) => /* @__PURE__ */ jsx(
              "circle",
              {
                onPointerDown: (e2) => onControlPointerDown(i2, e2),
                className: controlPoint,
                cx: p2.x,
                cy: p2.y,
                r: 3
              },
              i2
            ))
          }
        ),
        (data.label || isStepEdge) && /* @__PURE__ */ jsx(
          EdgeLabel,
          {
            isDimmed,
            edgeData: data,
            className: clsx(
              "nodrag nopan",
              container$4,
              edgeLabel,
              isDimmed && dimmed$1
            ),
            style: {
              ...assignInlineVars({
                [varLabelX]: isModified ? `calc(${labelX}px - 10%)` : `${labelX}px`,
                [varLabelY]: isModified ? `${labelY - 5}px` : `${labelY}px`
              }),
              // ...(isEdgePathEditable && selected && {
              //   pointerEvents: 'none'
              // }),
              ...label2 && {
                maxWidth: label2.bbox.width + 18
              },
              zIndex: labelZIndex
            },
            mod: {
              "data-likec4-color": color2,
              "data-edge-hovered": isHovered && !isActiveWalkthroughStep,
              "data-edge-active": isActive
            }
          }
        )
      ]
    }
  );
}, isEqualProps$2), ElementIcon = ({
  element,
  viewId,
  className,
  renderIcon: RenderIcon2
}) => {
  if (!element.icon)
    return null;
  let icon = null;
  return element.icon.startsWith("http://") || element.icon.startsWith("https://") ? icon = /* @__PURE__ */ jsx("img", { src: element.icon, alt: element.title }) : RenderIcon2 && (icon = /* @__PURE__ */ jsx(RenderIcon2, { node: element })), icon ? /* @__PURE__ */ jsx(
    m.div,
    {
      layoutId: `${viewId}:element:icon:${element.id}`,
      className: clsx(
        className,
        "likec4-element-icon"
      ),
      "data-likec4-icon": element.icon,
      children: icon
    },
    `${viewId}:element:icon:${element.id}`
  ) : null;
}, {
  primary,
  secondary,
  muted,
  ...otherColors
} = defaultTheme.elements, themedColors = [
  { key: "primary", value: primary.fill },
  { key: "secondary", value: secondary.fill },
  { key: "muted", value: muted.fill }
], colors = keys$1(otherColors).map((key) => ({
  key,
  value: defaultTheme.elements[key].fill
})), Tooltip$1 = Tooltip$5.withProps({
  color: "dark",
  fz: "xs",
  openDelay: 400,
  closeDelay: 150,
  label: "",
  children: null,
  offset: 4
});
function CompoundToolbar({
  element,
  onColorPreview,
  ...props2
}) {
  const targets = [element.id], diagramApi = useDiagramStoreApi(), {
    hasGoToSource,
    enableRelationshipBrowser
  } = useDiagramState((s2) => ({
    hasGoToSource: !!s2.onOpenSourceElement,
    enableRelationshipBrowser: s2.enableRelationshipBrowser
  })), onChange = (style) => {
    diagramApi.getState().triggerChangeElementStyle({
      op: "change-element-style",
      style,
      targets
    });
  };
  return /* @__PURE__ */ jsxs(Toolbar, { element, ...props2, children: [
    /* @__PURE__ */ jsx(
      ColorButton,
      {
        element,
        isOpacityEditable: !0,
        onColorPreview,
        onChange,
        position: "left-start"
      }
    ),
    /* @__PURE__ */ jsx(
      BorderStyleOption,
      {
        elementBorderStyle: element.style?.border,
        onChange
      }
    ),
    hasGoToSource && /* @__PURE__ */ jsx(GoToSourceButton, { elementId: element.id }),
    enableRelationshipBrowser && /* @__PURE__ */ jsx(BrowseRelationshipsButton, { elementId: element.id })
  ] });
}
function Toolbar({ element, children, ...props2 }) {
  return /* @__PURE__ */ jsx(NodeToolbar, { ...props2, children: /* @__PURE__ */ jsx(
    Paper,
    {
      className: clsx("nodrag", "nopan"),
      px: 5,
      pb: 8,
      pt: 4,
      radius: "sm",
      shadow: "xl",
      onDoubleClickCapture: stopPropagation$1,
      onPointerDown: stopPropagation$1,
      onClick: stopPropagation$1,
      onDoubleClick: stopPropagation$1,
      withBorder: !0,
      children: /* @__PURE__ */ jsxs(Stack$1, { gap: 4, children: [
        /* @__PURE__ */ jsx(Box, { pl: 2, children: /* @__PURE__ */ jsx(Text$6, { c: "dimmed", fz: 10, fw: 500, children: element.id }) }),
        /* @__PURE__ */ jsx(Group, { gap: 3, children })
      ] })
    }
  ) });
}
function ElementToolbar({
  element,
  onColorPreview,
  ...props2
}) {
  const targets = [element.id], diagramApi = useDiagramStoreApi(), {
    hasGoToSource,
    enableRelationshipBrowser
  } = useDiagramState((s2) => ({
    hasGoToSource: !!s2.onOpenSourceElement,
    enableRelationshipBrowser: s2.enableRelationshipBrowser
  })), portalProps = useMantinePortalProps(), onChange = (style) => {
    diagramApi.getState().triggerChangeElementStyle({
      op: "change-element-style",
      style,
      targets
    });
  };
  return /* @__PURE__ */ jsxs(Toolbar, { element, ...props2, children: [
    /* @__PURE__ */ jsxs(
      Menu,
      {
        openDelay: 300,
        closeDelay: 450,
        floatingStrategy: "fixed",
        closeOnClickOutside: !0,
        clickOutsideEvents: ["pointerdown", "mousedown", "click"],
        closeOnEscape: !0,
        closeOnItemClick: !1,
        position: "bottom-start",
        offset: 2,
        styles: {
          item: {
            padding: "calc(var(--mantine-spacing-xs) / 1.5) var(--mantine-spacing-xs)"
          }
        },
        ...portalProps,
        children: [
          /* @__PURE__ */ jsx(MenuTarget, { children: /* @__PURE__ */ jsx(
            Button,
            {
              variant: "light",
              color: "gray",
              size: "compact-xs",
              rightSection: /* @__PURE__ */ jsx(IconSelector, { size: 12 }),
              children: element.shape
            }
          ) }),
          /* @__PURE__ */ jsx(
            MenuDropdown,
            {
              onDoubleClick: stopPropagation$1,
              onClick: stopPropagation$1,
              children: ElementShapes.map((shape) => /* @__PURE__ */ jsx(
                MenuItem,
                {
                  fz: 12,
                  fw: 500,
                  value: shape,
                  rightSection: element.shape === shape ? /* @__PURE__ */ jsx(IconCheck, { size: 12 }) : void 0,
                  onClick: (e2) => {
                    e2.stopPropagation(), onChange({ shape });
                  },
                  children: shape
                },
                shape
              ))
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ jsx(
      ColorButton,
      {
        element,
        onColorPreview,
        onChange,
        position: "right-end"
      }
    ),
    hasGoToSource && /* @__PURE__ */ jsx(GoToSourceButton, { elementId: element.id }),
    enableRelationshipBrowser && /* @__PURE__ */ jsx(BrowseRelationshipsButton, { elementId: element.id })
  ] });
}
function GoToSourceButton({ elementId }) {
  const diagramApi = useDiagramStoreApi(), portalProps = useMantinePortalProps();
  return /* @__PURE__ */ jsx(Tooltip$1, { label: "Open source", ...portalProps, children: /* @__PURE__ */ jsx(
    ActionIcon$1,
    {
      size: "sm",
      variant: "subtle",
      color: "gray",
      onClick: (e2) => {
        e2.stopPropagation(), diagramApi.getState().onOpenSourceElement?.(elementId);
      },
      children: /* @__PURE__ */ jsx(IconFileSymlink, { stroke: 1.8, style: { width: "70%" } })
    }
  ) });
}
function ColorButton({
  element,
  onColorPreview,
  isOpacityEditable = !1,
  onChange,
  ...props2
}) {
  const elementColor = element.color ?? "primary";
  return /* @__PURE__ */ jsxs(
    Popover,
    {
      clickOutsideEvents: ["pointerdown", "mousedown", "click"],
      position: "right-end",
      offset: 2,
      ...props2,
      children: [
        /* @__PURE__ */ jsx(PopoverTarget, { children: /* @__PURE__ */ jsx(Button, { variant: "subtle", color: "gray", size: "compact-xs", px: 3, children: /* @__PURE__ */ jsx(
          ColorSwatch,
          {
            color: defaultTheme.elements[elementColor]?.fill,
            size: 14,
            withShadow: !0,
            style: { color: "#fff", cursor: "pointer" }
          }
        ) }) }),
        /* @__PURE__ */ jsxs(PopoverDropdown, { p: "xs", children: [
          /* @__PURE__ */ jsx(
            ColorSwatches,
            {
              elementColor,
              onColorPreview,
              onChange: (color2) => onChange({ color: color2 })
            }
          ),
          isOpacityEditable && /* @__PURE__ */ jsxs(Fragment$1, { children: [
            /* @__PURE__ */ jsx(Space, { h: "xs" }),
            /* @__PURE__ */ jsx(Divider$1, { label: "opacity", labelPosition: "left" }),
            /* @__PURE__ */ jsx(Space, { h: "xs" }),
            /* @__PURE__ */ jsx(
              OpacityOption,
              {
                elementOpacity: element.style?.opacity,
                onOpacityChange: (opacity) => {
                  onChange({ opacity });
                }
              }
            )
          ] })
        ] })
      ]
    }
  );
}
function ColorSwatches({
  elementColor,
  onColorPreview,
  onChange
}) {
  const changeColor = (color2) => (e2) => {
    e2.stopPropagation(), onColorPreview(null), elementColor !== color2 && onChange(color2);
  };
  return /* @__PURE__ */ jsx(Stack$1, { gap: 2, onMouseLeave: () => onColorPreview(null), children: /* @__PURE__ */ jsxs(TooltipGroup, { openDelay: 1e3, closeDelay: 300, children: [
    /* @__PURE__ */ jsx(Flex, { maw: 120, gap: "6", justify: "flex-start", align: "flex-start", direction: "row", wrap: "wrap", children: themedColors.map(({ key, value }) => /* @__PURE__ */ jsx(
      Tooltip$5,
      {
        label: key,
        fz: "xs",
        color: "dark",
        offset: 2,
        transitionProps: { duration: 140, transition: "slide-up" },
        children: /* @__PURE__ */ jsx(
          ColorSwatch,
          {
            color: value,
            size: 18,
            withShadow: !0,
            onMouseEnter: () => onColorPreview(key),
            onClick: changeColor(key),
            style: { color: "#fff", cursor: "pointer" },
            children: elementColor === key && /* @__PURE__ */ jsx(CheckIcon, { style: { width: rem(10), height: rem(10) } })
          }
        )
      },
      key
    )) }),
    /* @__PURE__ */ jsx(
      Flex,
      {
        mt: "sm",
        maw: 110,
        gap: "6",
        justify: "flex-start",
        align: "flex-start",
        direction: "row",
        wrap: "wrap",
        children: colors.map(({ key, value }) => /* @__PURE__ */ jsx(
          Tooltip$5,
          {
            label: key,
            fz: "xs",
            color: "dark",
            offset: 2,
            transitionProps: { duration: 140, transition: "slide-up" },
            children: /* @__PURE__ */ jsx(
              ColorSwatch,
              {
                color: value,
                size: 18,
                onMouseEnter: () => onColorPreview(key),
                onClick: changeColor(key),
                style: { color: "#fff", cursor: "pointer" },
                children: elementColor === key && /* @__PURE__ */ jsx(CheckIcon, { style: { width: rem(10), height: rem(10) } })
              }
            )
          },
          key
        ))
      }
    )
  ] }) });
}
function BorderStyleOption({
  elementBorderStyle = "dashed",
  onChange
}) {
  const [value, setValue] = useState$1(elementBorderStyle);
  return useEffect$1(() => {
    setValue(elementBorderStyle);
  }, [elementBorderStyle]), /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(
    SegmentedControl,
    {
      size: "xs",
      fullWidth: !0,
      withItemsBorders: !1,
      value,
      onChange: (v) => {
        const border = v;
        setValue(border), onChange({ border });
      },
      styles: {
        label: {
          paddingTop: 2,
          paddingBottom: 2
        }
      },
      data: [
        { label: "Solid", value: "solid" },
        { label: "Dashed", value: "dashed" },
        { label: "Dotted", value: "dotted" },
        { label: "None", value: "none" }
      ]
    }
  ) });
}
function OpacityOption({
  elementOpacity = 100,
  onOpacityChange
}) {
  const [value, setValue] = useState$1(elementOpacity);
  return useUpdateEffect(() => {
    setValue(elementOpacity);
  }, [elementOpacity]), /* @__PURE__ */ jsx(
    Slider,
    {
      size: "sm",
      color: "dark",
      value,
      onChange: setValue,
      onChangeEnd: onOpacityChange
    }
  );
}
function BrowseRelationshipsButton({ elementId }) {
  const diagramApi = useDiagramStoreApi(), portalProps = useMantinePortalProps();
  return /* @__PURE__ */ jsx(Tooltip$1, { label: "Browse relationships", ...portalProps, children: /* @__PURE__ */ jsx(
    ActionIcon$1,
    {
      size: "sm",
      variant: "subtle",
      color: "gray",
      onClick: (e2) => {
        e2.stopPropagation(), diagramApi.getState().openOverlay({
          relationshipsOf: elementId
        });
      },
      children: /* @__PURE__ */ jsx(
        IconTransform,
        {
          stroke: 2,
          style: {
            width: "72%",
            height: "72%"
          }
        }
      )
    }
  ) });
}
function useFramerAnimateVariants() {
  const [variants, setVariants] = useState$1(null), handlers = useMemo$1(() => {
    const getTarget = (e2) => {
      try {
        return e2?.target?.closest("[data-animate-target]")?.getAttribute("data-animate-target") ?? null;
      } catch (_e) {
        return console.warn("Failed to get animate target", _e), null;
      }
    }, onHoverStart = (e2) => {
      e2?.stopPropagation();
      const hoverTarget = getTarget(e2);
      if (!t$3(hoverTarget) || n(hoverTarget)) {
        setVariants(null);
        return;
      }
      setVariants(["hovered", `hovered:${hoverTarget}`]);
    }, resetVariants = (e2) => {
      e2?.stopPropagation(), setVariants(null);
    };
    return {
      onTapStart: (e2) => {
        e2?.stopPropagation();
        const tapTarget = getTarget(e2);
        if (!t$3(tapTarget)) {
          setVariants(null);
          return;
        }
        n(tapTarget) ? setVariants([
          "hovered",
          "tap"
        ]) : setVariants([
          "hovered",
          `hovered:${tapTarget}`,
          `tap:${tapTarget}`
        ]);
      },
      onHoverStart,
      onHoverEnd: resetVariants,
      onTapCancel: resetVariants,
      onTap: onHoverStart
    };
  }, [setVariants]);
  return [variants, handlers];
}
var containerForFramer = "c3cfh00", container$3 = "c3cfh02", nodeHandlerInCenter = "c3cfh03", dimmed = "c3cfh04", varOpacity = "var(--c3cfh05)", varBorderTransparency = "var(--c3cfh06)", compoundBody = "c3cfh07", compoundTitle = "c3cfh08", withNavigation = "c3cfh09", transparent = "c3cfh0b", title$1 = "c3cfh0c", indicator = "c3cfh0g", navigateBtn = "c3cfh0j c3cfh0i", detailsBtn = "c3cfh0k c3cfh0i", elementIcon = "c3cfh0l";
const isEqualProps$1 = (prev, next) => prev.id === next.id && deepEqual(prev.selected ?? !1, next.selected ?? !1) && deepEqual(prev.dragging ?? !1, next.dragging ?? !1) && deepEqual(prev.data, next.data), VariantsRoot$1 = {
  idle: {
    transition: {
      delayChildren: 0.1
      // stagger
    }
  },
  selected: {},
  hovered: {},
  tap: {}
}, VariantsNavigate$1 = {
  idle: {
    "--ai-bg": "var(--ai-bg-idle)",
    scale: 1,
    opacity: 0.8,
    originX: 1,
    originY: 0.25,
    translateX: 0,
    translateY: 0
  },
  selected: {},
  hovered: {
    "--ai-bg": "var(--ai-bg-hover)",
    scale: 1.25,
    opacity: 1,
    translateX: -1
  },
  "hovered:navigate": {
    scale: 1.42
  },
  "hovered:relations": {},
  "tap:navigate": {
    scale: 1.15
  }
};
VariantsNavigate$1.selected = VariantsNavigate$1.hovered;
const VariantsDetailsBtn$1 = {
  idle: {
    "--ai-bg": "var(--ai-bg-idle)",
    scale: 1,
    opacity: 0.3
  },
  selected: {},
  hovered: {
    scale: 1.2,
    opacity: 0.6
  },
  "hovered:details": {
    scale: 1.42,
    opacity: 1
  },
  "tap:details": {
    scale: 1.15
  }
};
VariantsDetailsBtn$1.selected = VariantsDetailsBtn$1.hovered;
const CompoundNodeMemo = /* @__PURE__ */ memo$1(({
  id: id2,
  selected = !1,
  dragging = !1,
  data: {
    isViewGroup,
    element
  }
}) => {
  const { depth, style, color: color2 } = element, isNotViewGroup = !isViewGroup, opacity = u((style.opacity ?? 100) / 100, {
    min: 0,
    max: 1
  }), borderTransparency = u(50 - opacity * 50, {
    min: 0,
    max: 50
  }), {
    viewId,
    triggerOnNavigateTo,
    openOverlay,
    isEditable,
    isHovered,
    isDimmed,
    isInteractive,
    isNavigable,
    renderIcon,
    enableElementDetails
  } = useDiagramState((s2) => ({
    viewId: s2.view.id,
    triggerOnNavigateTo: s2.triggerOnNavigateTo,
    openOverlay: s2.openOverlay,
    isEditable: s2.readonly !== !0,
    isHovered: s2.hoveredNodeId === id2,
    isDimmed: s2.dimmed.has(id2),
    isInteractive: s2.nodesDraggable || s2.nodesSelectable || s2.enableElementDetails || !!s2.onNavigateTo && !!element.navigateTo,
    // If this is a view group, we don't want to show the navigate button
    isNavigable: isNotViewGroup && !!s2.onNavigateTo && !!element.navigateTo,
    renderIcon: s2.renderIcon,
    enableElementDetails: isNotViewGroup && s2.enableElementDetails
  })), _isToolbarVisible = isNotViewGroup && isEditable && (isHovered || !1), [isToolbarVisible] = useDebouncedValue(_isToolbarVisible, _isToolbarVisible ? 500 : 300), [animateVariants, animateHandlers] = useFramerAnimateVariants();
  let animate;
  switch (!0) {
    case (dragging && selected):
      animate = "selected";
      break;
    case dragging:
      animate = "idle";
      break;
    case (isInteractive && isHovered):
      animate = "hovered";
      break;
    case selected:
      animate = "selected";
      break;
    default:
      animate = "idle";
  }
  const [previewColor, setPreviewColor] = useState$1(null), onNavigateTo = useCallback$1((e2) => {
    e2.stopPropagation(), triggerOnNavigateTo(id2, e2);
  }, [triggerOnNavigateTo, id2]), onOpenDetails = useCallback$1((e2) => {
    e2.stopPropagation(), openOverlay({ elementDetails: element.id });
  }, [openOverlay, element.id]), elementIcon$12 = ElementIcon({
    element,
    viewId,
    className: elementIcon,
    renderIcon
  });
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    isToolbarVisible && /* @__PURE__ */ jsx(
      CompoundToolbar,
      {
        isVisible: !0,
        element,
        align: "start",
        onColorPreview: setPreviewColor
      }
    ),
    /* @__PURE__ */ jsx(
      Box,
      {
        component: m.div,
        layoutId: `${viewId}:element:${id2}`,
        className: containerForFramer,
        children: /* @__PURE__ */ jsxs(
          Box,
          {
            component: m.div,
            variants: VariantsRoot$1,
            initial: !1,
            animate: isHovered && !dragging ? animateVariants ?? animate : animate,
            className: clsx(
              container$3,
              "likec4-compound-node",
              opacity < 1 && "likec4-compound-transparent",
              isDimmed && dimmed
            ),
            mod: {
              "animate-target": "",
              "compound-depth": depth,
              "likec4-color": previewColor ?? color2,
              hovered: isHovered
            },
            tabIndex: -1,
            ...isInteractive && {
              onTapStart: animateHandlers.onTapStart,
              onTap: animateHandlers.onTap,
              onTapCancel: animateHandlers.onTapCancel
            },
            children: [
              /* @__PURE__ */ jsx("svg", { className: indicator, children: /* @__PURE__ */ jsx(
                "rect",
                {
                  x: 0,
                  y: 0,
                  width: "100%",
                  height: "100%",
                  rx: 6
                }
              ) }),
              /* @__PURE__ */ jsx(
                Box,
                {
                  className: clsx(
                    compoundBody,
                    opacity < 1 && transparent,
                    "likec4-compound"
                  ),
                  style: {
                    ...opacity < 1 && {
                      ...assignInlineVars({
                        [varBorderTransparency]: `${borderTransparency}%`,
                        [varOpacity]: opacity.toFixed(2)
                      }),
                      borderStyle: style.border ?? "dashed"
                    }
                  },
                  children: /* @__PURE__ */ jsxs(
                    Box,
                    {
                      className: clsx(
                        compoundTitle,
                        isNavigable && withNavigation,
                        "likec4-compound-title"
                      ),
                      children: [
                        elementIcon$12,
                        /* @__PURE__ */ jsx(
                          Text$6,
                          {
                            component: m.div,
                            layoutId: `${viewId}:element:title:${id2}`,
                            className: title$1,
                            children: element.title
                          },
                          `${viewId}:element:title:${id2}`
                        ),
                        enableElementDetails && /* @__PURE__ */ jsx(
                          Tooltip$5,
                          {
                            fz: "xs",
                            color: "dark",
                            label: "Open details",
                            withinPortal: !1,
                            offset: 2,
                            openDelay: 600,
                            children: /* @__PURE__ */ jsx(
                              ActionIcon$1,
                              {
                                component: m.div,
                                variants: VariantsDetailsBtn$1,
                                "data-animate-target": "details",
                                className: clsx("nodrag nopan", detailsBtn),
                                radius: "md",
                                style: { zIndex: 100 },
                                role: "button",
                                onClick: onOpenDetails,
                                onDoubleClick: stopPropagation$1,
                                ...isInteractive && animateHandlers,
                                children: /* @__PURE__ */ jsx(IconId, { stroke: 1.8, style: { width: "75%" } })
                              }
                            )
                          }
                        )
                      ]
                    }
                  )
                }
              ),
              isNavigable && /* @__PURE__ */ jsx(
                ActionIcon$1,
                {
                  component: m.div,
                  variants: VariantsNavigate$1,
                  "data-animate-target": "navigate",
                  className: clsx("nodrag nopan", navigateBtn),
                  radius: "md",
                  style: { zIndex: 100 },
                  onClick: onNavigateTo,
                  role: "button",
                  onDoubleClick: stopPropagation$1,
                  ...isInteractive && animateHandlers,
                  children: /* @__PURE__ */ jsx(IconZoomScan, { style: { width: "75%" } })
                },
                "navigate"
              )
            ]
          }
        )
      },
      `${viewId}:element:${id2}`
    ),
    /* @__PURE__ */ jsx(Handle, { type: "target", position: Position.Top, className: nodeHandlerInCenter }),
    /* @__PURE__ */ jsx(Handle, { type: "source", position: Position.Top, className: nodeHandlerInCenter })
  ] });
}, isEqualProps$1), Text = Text$6.withProps({
  component: "div"
}), selectedScale = 1.015, VariantsRoot = {
  idle: (_, { scale: scale2 }) => ({
    scale: 1,
    transition: e$2(scale2) && scale2 > selectedScale ? {
      delay: 0.1,
      delayChildren: 0.06
      // staggerChildren: 0.07,
      // staggerDirection: -1
    } : {}
  }),
  selected: {
    scale: selectedScale
  },
  hovered: (_, { scale: scale2 }) => ({
    scale: 1.06,
    transition: !e$2(scale2) || scale2 >= 1 && scale2 < 1.06 ? {
      // delay: 0.09,
      delayChildren: 0.08
    } : {}
  }),
  tap: {
    scale: 0.975
  }
}, VariantsNavigateBtn = {
  idle: {
    "--ai-bg": "var(--ai-bg-idle)",
    scale: 1,
    opacity: 0.5,
    originY: 0.5
  },
  selected: {},
  hovered: {
    "--ai-bg": "var(--ai-bg-hover)",
    scale: 1.35,
    opacity: 1
  }
};
VariantsNavigateBtn.selected = VariantsNavigateBtn.hovered;
const VariantsNavigate = {
  ...VariantsNavigateBtn,
  "hovered:navigate": {
    scale: 1.42
  },
  "tap:navigate": {
    scale: 1.15
  }
}, VariantRealationships = {
  ...VariantsNavigateBtn,
  "hovered:relationships": {
    scale: 1.42
  },
  "tap:relationships": {
    scale: 1.15
  }
}, VariantsDetailsBtn = {
  idle: {
    "--ai-bg": "var(--ai-bg-idle)",
    scale: 1,
    opacity: 0.5
  },
  selected: {},
  hovered: {
    scale: 1.2,
    opacity: 0.7
  },
  "hovered:details": {
    scale: 1.42,
    opacity: 1
  },
  "tap:details": {
    scale: 1.15
  }
};
VariantsDetailsBtn.selected = VariantsDetailsBtn.hovered;
const isEqualProps = (prev, next) => prev.id === next.id && deepEqual(prev.selected ?? !1, next.selected ?? !1) && deepEqual(prev.dragging ?? !1, next.dragging ?? !1) && deepEqual(prev.width ?? 0, next.width ?? 0) && deepEqual(prev.height ?? 0, next.height ?? 0) && deepEqual(prev.data, next.data), ElementNodeMemo = memo$1(function({
  id: id2,
  data: {
    element
  },
  dragging,
  selected = !1,
  width: width2,
  height
}) {
  const {
    viewId,
    isEditable,
    isHovered,
    isDimmed,
    isNavigable,
    isInteractive,
    enableElementDetails,
    enableRelationshipBrowser,
    triggerOnNavigateTo,
    openOverlay,
    isInActiveOverlay,
    renderIcon
  } = useDiagramState((s2) => ({
    viewId: s2.view.id,
    isEditable: s2.readonly !== !0,
    isHovered: s2.hoveredNodeId === id2,
    isDimmed: s2.dimmed.has(id2),
    isInteractive: s2.nodesDraggable || s2.nodesSelectable || s2.enableElementDetails || s2.enableRelationshipBrowser || !!s2.onNavigateTo && !!element.navigateTo,
    isNavigable: !!s2.onNavigateTo && !!element.navigateTo,
    enableElementDetails: s2.enableElementDetails,
    enableRelationshipBrowser: s2.enableRelationshipBrowser,
    triggerOnNavigateTo: s2.triggerOnNavigateTo,
    openOverlay: s2.openOverlay,
    isInActiveOverlay: (s2.activeOverlay?.elementDetails ?? s2.activeOverlay?.relationshipsOf) === id2,
    renderIcon: s2.renderIcon
  })), _isToolbarVisible = isEditable && (isHovered || !1), [isToolbarVisible] = useDebouncedValue(_isToolbarVisible, _isToolbarVisible ? 500 : 300), w = toDomPrecision(width2 ?? element.width), h = toDomPrecision(height ?? element.height), [animateVariants, animateHandlers] = useFramerAnimateVariants();
  let animate;
  switch (!0) {
    case isInActiveOverlay:
      animate = "idle";
      break;
    case (dragging && selected):
      animate = "selected";
      break;
    case dragging:
      animate = "idle";
      break;
    case (isInteractive && isHovered):
      animate = "hovered";
      break;
    case selected:
      animate = "selected";
      break;
    default:
      animate = "idle";
  }
  const elementIcon2 = ElementIcon({
    element,
    viewId,
    className: elementIcon$2,
    renderIcon
  }), [previewColor, setPreviewColor] = useState$1(null), onNavigateTo = useCallback$1((e2) => {
    e2.stopPropagation(), triggerOnNavigateTo(id2, e2);
  }, [triggerOnNavigateTo, id2]), onOpenDetails = useCallback$1((e2) => {
    e2.stopPropagation(), openOverlay({ elementDetails: element.id });
  }, [openOverlay, element.id]), onOpenRelationships = useCallback$1((e2) => {
    e2.stopPropagation(), openOverlay({ relationshipsOf: element.id });
  }, [openOverlay, element.id]);
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    isToolbarVisible && /* @__PURE__ */ jsx(
      ElementToolbar,
      {
        element,
        isVisible: isToolbarVisible,
        onColorPreview: setPreviewColor
      }
    ),
    /* @__PURE__ */ jsxs(
      Box,
      {
        component: m.div,
        className: clsx([
          container$6,
          isDimmed && dimmed$2,
          animate !== "idle" && containerAnimated,
          "likec4-element-node"
        ]),
        layoutId: `${viewId}:element:${id2}`,
        "data-hovered": !dragging && isHovered,
        "data-likec4-color": previewColor ?? element.color,
        "data-likec4-shape": element.shape,
        "data-animate-target": "",
        initial: !1,
        variants: VariantsRoot,
        animate: isHovered && !dragging && !isInActiveOverlay ? animateVariants ?? animate : animate,
        tabIndex: -1,
        ...isInteractive && {
          onTapStart: animateHandlers.onTapStart,
          onTap: animateHandlers.onTap,
          onTapCancel: animateHandlers.onTapCancel
        },
        children: [
          /* @__PURE__ */ jsxs(
            "svg",
            {
              className: clsx(shapeSvg$1),
              viewBox: `0 0 ${w} ${h}`,
              children: [
                /* @__PURE__ */ jsx("g", { className: indicator$1, children: /* @__PURE__ */ jsx(SelectedIndicator, { shape: element.shape, w, h }) }),
                /* @__PURE__ */ jsx(ElementShapeSvg, { shape: element.shape, w, h })
              ]
            }
          ),
          /* @__PURE__ */ jsxs(
            Box,
            {
              className: clsx(
                elementDataContainer,
                n$4(elementIcon2) && hasIcon,
                "likec4-element"
              ),
              children: [
                elementIcon2,
                /* @__PURE__ */ jsxs(Box, { className: clsx(elementTextData, "likec4-element-main-props"), children: [
                  /* @__PURE__ */ jsx(
                    Text,
                    {
                      component: m.div,
                      layoutId: `${viewId}:element:title:${id2}`,
                      className: clsx(title$4, "likec4-element-title"),
                      children: element.title
                    },
                    `${viewId}:element:title:${id2}`
                  ),
                  element.technology && /* @__PURE__ */ jsx(Text, { className: clsx(technology, "likec4-element-technology"), children: element.technology }),
                  element.description && /* @__PURE__ */ jsx(Text, { className: clsx(description$1, "likec4-element-description"), lineClamp: 5, children: element.description })
                ] })
              ]
            }
          ),
          (enableRelationshipBrowser || isNavigable) && /* @__PURE__ */ jsxs(Group, { className: navigateBtnBox$1, align: "center", children: [
            enableRelationshipBrowser && /* @__PURE__ */ jsx(
              ActionIcon$1,
              {
                component: m.div,
                variants: VariantRealationships,
                "data-animate-target": "relationships",
                className: clsx("nodrag nopan", navigateBtn$2),
                radius: "md",
                role: "button",
                onClick: onOpenRelationships,
                onDoubleClick: stopPropagation$1,
                ...isInteractive && animateHandlers,
                children: /* @__PURE__ */ jsx(IconTransform, { style: { width: "75%" } })
              }
            ),
            isNavigable && /* @__PURE__ */ jsx(
              ActionIcon$1,
              {
                component: m.div,
                variants: VariantsNavigate,
                "data-animate-target": "navigate",
                className: clsx("nodrag nopan", navigateBtn$2),
                radius: "md",
                role: "button",
                onClick: onNavigateTo,
                onDoubleClick: stopPropagation$1,
                ...isInteractive && animateHandlers,
                children: /* @__PURE__ */ jsx(IconZoomScan, { style: { width: "75%" } })
              }
            )
          ] }),
          enableElementDetails && /* @__PURE__ */ jsx(
            Tooltip$5,
            {
              fz: "xs",
              color: "dark",
              label: "Open details",
              withinPortal: !1,
              offset: 2,
              openDelay: 600,
              children: /* @__PURE__ */ jsx(
                ActionIcon$1,
                {
                  component: m.div,
                  variants: VariantsDetailsBtn,
                  "data-animate-target": "details",
                  className: clsx("nodrag nopan", detailsBtn$1),
                  radius: "md",
                  style: { zIndex: 100 },
                  role: "button",
                  onClick: onOpenDetails,
                  onDoubleClick: stopPropagation$1,
                  ...isInteractive && animateHandlers,
                  children: /* @__PURE__ */ jsx(IconId, { stroke: 1.8, style: { width: "75%" } })
                }
              )
            }
          )
        ]
      },
      `${viewId}:element:${id2}`
    ),
    /* @__PURE__ */ jsx(Handle, { type: "target", position: Position.Top, className: handleCenter }),
    /* @__PURE__ */ jsx(Handle, { type: "source", position: Position.Top, className: handleCenter })
  ] });
}, isEqualProps);
function useXYFlowEvents() {
  const diagramApi = useDiagramStoreApi(), lastClickTimestamp = useRef$1(), dblclickTimeout = useRef$1(), hoveredNodeFromOnEdgeEnterRef = useRef$1("");
  return useMemo$1(() => {
    const dbclickLock = () => dblclickTimeout.current !== void 0 ? !0 : (dblclickTimeout.current = window.setTimeout(() => {
      dblclickTimeout.current = void 0;
    }, 300), !1), lastClickWasRecent = (ms = 2e3) => {
      const prevTimestamp = lastClickTimestamp.current ?? 0, now2 = lastClickTimestamp.current = Date.now();
      return prevTimestamp + ms > now2;
    };
    return {
      onDoubleClick: (event) => {
        const {
          onCanvasDblClick,
          zoomable,
          viewportChanged,
          fitDiagram,
          resetFocusAndLastClicked
        } = diagramApi.getState();
        resetFocusAndLastClicked(), zoomable && viewportChanged && fitDiagram(), onCanvasDblClick || event.stopPropagation(), onCanvasDblClick?.(event);
      },
      onPaneClick: (event) => {
        if (dbclickLock())
          return;
        const {
          focusedNodeId,
          activeWalkthrough,
          fitDiagram,
          onCanvasClick,
          resetFocusAndLastClicked
        } = diagramApi.getState();
        (focusedNodeId ?? activeWalkthrough) !== null && (fitDiagram(), onCanvasClick || event.stopPropagation()), resetFocusAndLastClicked(), onCanvasClick?.(event);
      },
      onNodeContextMenu: (event, xynode) => {
        diagramApi.getState().setLastClickedNode(xynode.id), diagramApi.getState().onNodeContextMenu?.(
          xynode.data.element,
          event
        );
      },
      onPaneContextMenu: (event) => {
        diagramApi.getState().resetFocusAndLastClicked(), diagramApi.getState().onCanvasContextMenu?.(event);
      },
      onEdgeContextMenu: (event, xyedge) => {
        diagramApi.getState().setLastClickedEdge(xyedge.id), diagramApi.getState().onEdgeContextMenu?.(
          xyedge.data.edge,
          event
        );
      },
      onNodeClick: (event, xynode) => {
        const {
          focusedNodeId,
          fitDiagram,
          focusOnNode,
          onNodeClick,
          xystore,
          enableFocusMode,
          lastClickedNodeId,
          nodesSelectable,
          enableElementDetails,
          setLastClickedNode,
          onOpenSourceElement,
          openOverlay
        } = diagramApi.getState();
        setLastClickedNode(xynode.id);
        const shallChangeFocus = !!focusedNodeId && focusedNodeId !== xynode.id, clickedRecently = lastClickWasRecent() && lastClickedNodeId === xynode.id;
        let stopPropagation2 = !1;
        if (clickedRecently && onOpenSourceElement && (onOpenSourceElement(xynode.data.element.id), stopPropagation2 = !0), enableFocusMode)
          switch (!0) {
            case (shallChangeFocus || clickedRecently && !focusedNodeId): {
              focusOnNode(xynode.id), stopPropagation2 = !0;
              break;
            }
            case (clickedRecently && focusedNodeId === xynode.id): {
              focusOnNode(!1), fitDiagram(), stopPropagation2 = !0;
              break;
            }
            case (!clickedRecently && focusedNodeId === xynode.id && enableElementDetails): {
              openOverlay({
                elementDetails: xynode.data.element.id
              }), stopPropagation2 = !0;
              break;
            }
          }
        else enableElementDetails && (clickedRecently || focusedNodeId === xynode.id) && !onNodeClick ? (openOverlay({
          elementDetails: xynode.data.element.id
        }), stopPropagation2 = !0) : nodesSelectable && (xystore.getState().addSelectedNodes([xynode.id]), stopPropagation2 = !0);
        if (!onNodeClick && stopPropagation2) {
          event.stopPropagation();
          return;
        }
        onNodeClick?.(
          xynode.data.element,
          event
        );
      },
      onNodeDoubleClick: (event, xynode) => {
        const {
          setLastClickedNode
        } = diagramApi.getState();
        setLastClickedNode(xynode.id), lastClickWasRecent(), event.stopPropagation();
      },
      onEdgeClick: (event, xyedge) => {
        const {
          lastClickedEdgeId,
          isDynamicView,
          enableDynamicViewWalkthrough,
          activateWalkthrough,
          activeWalkthrough,
          focusedNodeId,
          xystore,
          nodesSelectable,
          focusOnNode,
          onEdgeClick,
          setLastClickedEdge
        } = diagramApi.getState();
        lastClickedEdgeId !== xyedge.id && setLastClickedEdge(xyedge.id);
        const isNotAFirstClick = lastClickedEdgeId === xyedge.id, connectedToFocusedNode = n$4(focusedNodeId) && (focusedNodeId === xyedge.source || focusedNodeId === xyedge.target);
        if (isDynamicView && enableDynamicViewWalkthrough && (connectedToFocusedNode || isNotAFirstClick || l$2(activeWalkthrough))) {
          const nextStep = xyedge.data.edge.id;
          if (activeWalkthrough?.stepId !== nextStep) {
            activateWalkthrough(nextStep), event.stopPropagation();
            return;
          }
        }
        if (n$4(focusedNodeId)) {
          if (focusOnNode(connectedToFocusedNode && focusedNodeId === xyedge.source ? xyedge.target : xyedge.source), !onEdgeClick) {
            event.stopPropagation();
            return;
          }
        } else if (nodesSelectable && (xystore.getState().addSelectedEdges([xyedge.id]), !onEdgeClick)) {
          event.stopPropagation();
          return;
        }
        onEdgeClick?.(
          xyedge.data.edge,
          event
        );
      },
      onEdgeDoubleClick: (event, xyedge) => {
        diagramApi.getState().setLastClickedEdge(xyedge.id);
        const {
          enableFocusMode,
          isDynamicView,
          enableDynamicViewWalkthrough,
          focusOnNode,
          activeWalkthrough,
          activateWalkthrough,
          openOverlay,
          enableRelationshipDetails
        } = diagramApi.getState();
        if (isDynamicView && enableDynamicViewWalkthrough) {
          const nextStep = xyedge.data.edge.id;
          activeWalkthrough?.stepId !== nextStep && (activateWalkthrough(nextStep), event.stopPropagation());
          return;
        }
        if (enableRelationshipDetails) {
          openOverlay({
            edgeDetails: xyedge.data.edge.id
          }), event.stopPropagation();
          return;
        }
        if (enableFocusMode) {
          focusOnNode(xyedge.source), event.stopPropagation();
          return;
        }
      },
      onMoveEnd: (event, _viewport) => {
        const viewportChanged = !!event;
        viewportChanged !== diagramApi.getState().viewportChanged && diagramApi.setState({ viewportChanged }, !1, `viewport-changed: ${viewportChanged}`);
      },
      onNodeMouseEnter: (_event, xynode) => {
        hoveredNodeFromOnEdgeEnterRef.current = "", diagramApi.getState().setHoveredNode(xynode.id);
      },
      onNodeMouseLeave: (_event, xynode) => {
        const { hoveredNodeId, setHoveredNode } = diagramApi.getState();
        hoveredNodeId === xynode.id && setHoveredNode(null);
      },
      onEdgeMouseEnter: (_event, { id: id2, source, target }) => {
        const { hoveredNodeId, focusedNodeId, setHoveredEdge, setHoveredNode } = diagramApi.getState();
        if (setHoveredEdge(id2), (focusedNodeId === source || focusedNodeId === target) && focusedNodeId !== hoveredNodeId) {
          const next = hoveredNodeFromOnEdgeEnterRef.current = source === focusedNodeId ? target : source;
          setHoveredNode(next);
        }
      },
      onEdgeMouseLeave: (_event, xyedge) => {
        const { hoveredEdgeId, setHoveredEdge, hoveredNodeId, setHoveredNode } = diagramApi.getState();
        hoveredEdgeId === xyedge.id && setHoveredEdge(null), hoveredNodeId === hoveredNodeFromOnEdgeEnterRef.current && setHoveredNode(null), hoveredNodeFromOnEdgeEnterRef.current = "";
      }
    };
  }, [diagramApi]);
}
const nodeTypes = {
  element: ElementNodeMemo,
  compound: CompoundNodeMemo
}, edgeTypes = {
  relationship: RelationshipEdge
}, selector$3 = (s2) => ({
  nodes: s2.xynodes,
  edges: s2.xyedges,
  onInit: s2.onInit,
  onNodesChange: s2.onNodesChange,
  onEdgesChange: s2.onEdgesChange,
  nodesSelectable: s2.nodesSelectable || s2.focusedNodeId !== null,
  nodesDraggable: s2.nodesDraggable,
  fitView: s2.fitViewEnabled,
  fitViewPadding: s2.fitViewPadding,
  // hasOnNavigateTo: !!s.onNavigateTo,
  // hasOnNodeClick: !!s.onNodeClick,
  hasOnNodeContextMenu: !!s2.onNodeContextMenu,
  hasOnCanvasContextMenu: !!s2.onCanvasContextMenu,
  hasOnEdgeContextMenu: !!s2.onEdgeContextMenu,
  hasOnEdgeClick: !!s2.onEdgeClick,
  zoomable: s2.zoomable,
  pannable: s2.pannable,
  // If fitView is not enabled
  // And diagram starts with a negative x or y - we need to translate viewprot
  translateX: s2.fitViewEnabled ? 0 : -Math.min(s2.view.bounds.x, 0),
  translateY: s2.fitViewEnabled ? 0 : -Math.min(s2.view.bounds.y, 0)
});
function XYFlow({
  colorMode = "system",
  className,
  children,
  style
}) {
  const xyflowApi = useXYStoreApi(), {
    nodes,
    edges,
    onInit,
    onNodesChange,
    onEdgesChange,
    nodesSelectable,
    nodesDraggable,
    fitView,
    fitViewPadding,
    pannable,
    zoomable,
    hasOnNodeContextMenu,
    hasOnCanvasContextMenu,
    hasOnEdgeContextMenu,
    translateX,
    translateY
  } = useDiagramState(selector$3, shallowEqual), layoutConstraints = useLayoutConstraints(), {
    onNodeContextMenu,
    onPaneContextMenu,
    onEdgeContextMenu,
    ...handlers
  } = useXYFlowEvents();
  return useOnViewportChange({
    onEnd: ({ x: x2, y: y2, zoom }) => {
      const roundedX = Math.round(x2), roundedY = Math.round(y2);
      (x2 !== roundedX || y2 !== roundedY) && xyflowApi.setState({ transform: [roundedX, roundedY, zoom] });
    }
  }), /* @__PURE__ */ jsx(
    index,
    {
      className,
      style,
      ...colorMode && { colorMode },
      nodes,
      edges,
      onNodesChange,
      onEdgesChange,
      onInit,
      nodeTypes,
      edgeTypes,
      zoomOnPinch: zoomable,
      zoomOnScroll: !pannable && zoomable,
      ...!zoomable && {
        zoomActivationKeyCode: null
      },
      zoomOnDoubleClick: !1,
      maxZoom: zoomable ? MaxZoom : 1,
      minZoom: zoomable ? MinZoom : 1,
      fitView: !1,
      fitViewOptions: {
        minZoom: MinZoom,
        maxZoom: 1,
        padding: fitViewPadding,
        includeHiddenNodes: !0
      },
      ...!fitView && {
        viewport: {
          x: translateX,
          y: translateY,
          zoom: 1
        }
      },
      preventScrolling: zoomable || pannable,
      defaultMarkerColor: "var(--xy-edge-stroke)",
      noDragClassName: "nodrag",
      noPanClassName: "nopan",
      panOnScroll: pannable,
      panOnDrag: pannable,
      ...!pannable && {
        selectionKeyCode: null
      },
      elementsSelectable: nodesSelectable,
      nodesFocusable: nodesDraggable || nodesSelectable,
      edgesFocusable: !1,
      nodesDraggable,
      ...nodesDraggable && layoutConstraints,
      nodeDragThreshold: 4,
      elevateNodesOnSelect: !1,
      selectNodesOnDrag: !1,
      ...hasOnNodeContextMenu && { onNodeContextMenu },
      ...hasOnCanvasContextMenu && { onPaneContextMenu },
      ...hasOnEdgeContextMenu && { onEdgeContextMenu },
      ...handlers,
      children
    }
  );
}
var container$2 = "_19ci0hj0", card$1 = "_19ci0hj1", title = "_19ci0hj2", description = "_19ci0hj3";
const selector$2 = (s2) => ({
  id: s2.view.id,
  title: s2.view.title ?? "untitled",
  description: s2.view.description,
  links: s2.view.links
});
function DiagramTitlePanel() {
  const { id: id2, title: title$12, description: description$12, links } = useDiagramState(selector$2), [isCollapsed, setCollapsed] = useLocalStorage({
    key: "diagram-title-webview-collapsed",
    defaultValue: !1
  }), toggle = () => setCollapsed((v) => !v);
  return /* @__PURE__ */ jsx(AnimatePresence, { mode: "wait", children: /* @__PURE__ */ jsx(
    m.div,
    {
      initial: { opacity: 0.05, scale: 0.7 },
      animate: { opacity: 1, scale: 1 },
      exit: {
        opacity: 0.05,
        scale: 0.6
      },
      className: clsx("react-flow__panel", container$2),
      style: {
        transformOrigin: "left center"
      },
      children: /* @__PURE__ */ jsxs(
        Card,
        {
          radius: "sm",
          className: card$1,
          withBorder: !isCollapsed,
          p: isCollapsed ? "sm" : "md",
          onDoubleClick: (e2) => e2.stopPropagation(),
          children: [
            isCollapsed && /* @__PURE__ */ jsx(CardSection, { children: /* @__PURE__ */ jsx(
              Button,
              {
                fullWidth: !0,
                justify: "stretch",
                size: "md",
                radius: "0",
                variant: "subtle",
                color: "gray",
                onClick: toggle,
                fw: 500,
                fz: "sm",
                tabIndex: -1,
                children: title$12
              }
            ) }),
            !isCollapsed && /* @__PURE__ */ jsxs(Fragment$1, { children: [
              /* @__PURE__ */ jsx(CardSection, { mb: "xs", children: /* @__PURE__ */ jsx(
                Button,
                {
                  fullWidth: !0,
                  size: "xs",
                  h: "sm",
                  py: 2,
                  radius: "0",
                  variant: "subtle",
                  color: "gray",
                  onClick: toggle,
                  tabIndex: -1,
                  children: /* @__PURE__ */ jsx(IconMenu, { size: 11, opacity: 0.7 })
                }
              ) }),
              /* @__PURE__ */ jsxs(Group, { justify: "stretch", wrap: "nowrap", mb: "sm", children: [
                /* @__PURE__ */ jsx(
                  Text$6,
                  {
                    component: "div",
                    flex: "1",
                    size: "md",
                    fw: 500,
                    lh: 1.1,
                    className: title,
                    children: title$12
                  }
                ),
                /* @__PURE__ */ jsxs(
                  Text$6,
                  {
                    hidden: isCollapsed,
                    component: "div",
                    flex: "0 0 auto",
                    inline: !0,
                    size: "xs",
                    fz: 9,
                    fw: 500,
                    c: "dimmed",
                    style: {
                      userSelect: "all"
                    },
                    children: [
                      /* @__PURE__ */ jsxs("span", { style: { userSelect: "none" }, children: [
                        "id:",
                        " "
                      ] }),
                      id2
                    ]
                  }
                )
              ] }),
              description$12 && /* @__PURE__ */ jsx(
                Spoiler,
                {
                  maxHeight: 42,
                  showLabel: /* @__PURE__ */ jsx(Button, { color: "gray", variant: "light", fz: "10", size: "compact-xs", tabIndex: -1, children: "show more" }),
                  hideLabel: /* @__PURE__ */ jsx(Button, { color: "gray", variant: "light", fz: "10", size: "compact-xs", tabIndex: -1, children: "hide" }),
                  children: /* @__PURE__ */ jsx(
                    Text$6,
                    {
                      component: "div",
                      size: "sm",
                      className: description,
                      children: description$12 || "no description"
                    }
                  )
                }
              ),
              !description$12 && /* @__PURE__ */ jsx(
                Text$6,
                {
                  component: "div",
                  size: "xs",
                  c: "dimmed",
                  children: "no description"
                }
              ),
              links && /* @__PURE__ */ jsx(
                Stack$1,
                {
                  gap: 3,
                  justify: "stretch",
                  align: "stretch",
                  children: links.map((link) => /* @__PURE__ */ jsxs(Group, { wrap: "nowrap", align: "center", gap: "sm", children: [
                    /* @__PURE__ */ jsx(Box, { flex: "1", style: { overflow: "hidden" }, children: /* @__PURE__ */ jsx(
                      Anchor,
                      {
                        href: link.url,
                        target: "_blank",
                        fz: "xs",
                        truncate: "end",
                        display: "inline-block",
                        w: "100%",
                        children: link.title || link.url
                      }
                    ) }),
                    /* @__PURE__ */ jsx(CopyButton$1, { value: link.url, children: ({ copied, copy }) => /* @__PURE__ */ jsx(
                      Button,
                      {
                        size: "compact-xs",
                        fz: "10",
                        variant: "light",
                        onClick: copy,
                        color: copied ? "teal" : "gray",
                        children: copied ? "copied" : "copy"
                      }
                    ) })
                  ] }, link.url))
                }
              )
            ] })
          ]
        }
      )
    },
    id2
  ) });
}
var container$1 = "h3ljtj0", buttons = "h3ljtj1", btn = "h3ljtj3", parallelStateFrame = "h3ljtj4";
function DynamicViewWalkthrough() {
  const isMobile = useXYStore((s2) => s2.width <= 750), {
    nextDynamicStep,
    stopDynamicView,
    isActive,
    isParallel,
    hasNext,
    hasPrevious
  } = useDiagramState((s2) => ({
    nextDynamicStep: s2.nextDynamicStep,
    stopDynamicView: s2.stopWalkthrough,
    isActive: n$3(s2.activeWalkthrough),
    isParallel: n$4(s2.activeWalkthrough?.parallelPrefix),
    hasNext: s2.activeWalkthrough?.hasNext ?? !1,
    hasPrevious: s2.activeWalkthrough?.hasPrevious ?? !1
  })), diagramApi = useDiagramStoreApi();
  useHotkeys(
    isActive ? [
      ["ArrowLeft", () => nextDynamicStep(-1)],
      ["ArrowRight", () => nextDynamicStep()],
      ["Escape", (e2) => {
        e2.stopImmediatePropagation(), stopDynamicView();
      }, { preventDefault: !0 }]
    ] : [
      ["ArrowLeft", () => nextDynamicStep()],
      ["ArrowRight", () => nextDynamicStep()]
    ]
  );
  const buttonProps = {
    className: btn,
    size: isMobile ? "compact-md" : "lg",
    radius: isMobile ? "lg" : "xl"
  }, startWalkthrough = (e2) => {
    e2.stopPropagation();
    const {
      xyedges,
      activateWalkthrough
    } = diagramApi.getState(), firstEdge = nonNullable(d(xyedges), "expected at least one edge");
    activateWalkthrough(firstEdge.data.edge.id);
  }, nextStep = (increment = 1) => (e2) => {
    e2.stopPropagation(), nextDynamicStep(increment);
  };
  return /* @__PURE__ */ jsxs(AnimatePresence, { children: [
    isParallel && /* @__PURE__ */ jsx(
      Box,
      {
        layout: !0,
        component: m.div,
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        className: clsx("react-flow__panel", parallelStateFrame)
      },
      "parallel-frame"
    ),
    /* @__PURE__ */ jsxs(
      Box,
      {
        className: clsx("react-flow__panel", container$1),
        onClick: (e2) => e2.stopPropagation(),
        onDoubleClick: (e2) => e2.stopPropagation(),
        children: [
          !isActive && /* @__PURE__ */ jsx(
            Button,
            {
              ...buttonProps,
              className: clsx(buttons, btn),
              rightSection: /* @__PURE__ */ jsx(IconPlayerPlayFilled, {}),
              onClick: startWalkthrough,
              px: "xl",
              children: "Start"
            }
          ),
          isParallel && /* @__PURE__ */ jsx(
            Badge,
            {
              component: m.div,
              initial: { opacity: 0.05, transform: "translateY(20px)" },
              animate: { opacity: 1, transform: "translateY(0)" },
              exit: {
                opacity: 0,
                transform: "translateY(20px)"
              },
              variant: "gradient",
              size: isMobile ? "xs" : "md",
              gradient: { from: "red", to: "orange", deg: 90 },
              radius: "sm",
              children: "parallel"
            },
            "parallel-badge"
          ),
          isActive && /* @__PURE__ */ jsxs(ButtonGroup, { className: buttons, children: [
            /* @__PURE__ */ jsx(
              Button,
              {
                ...buttonProps,
                pl: "lg",
                disabled: !hasPrevious,
                onClick: nextStep(-1),
                children: /* @__PURE__ */ jsx(IconPlayerSkipBackFilled, {})
              }
            ),
            /* @__PURE__ */ jsxs(
              Button,
              {
                ...buttonProps,
                px: hasNext ? "md" : "xl",
                onClick: (e2) => {
                  e2.stopPropagation(), stopDynamicView();
                },
                children: [
                  hasNext && /* @__PURE__ */ jsx(IconPlayerStopFilled, {}),
                  !hasNext && "End"
                ]
              }
            ),
            hasNext && /* @__PURE__ */ jsx(
              Button,
              {
                ...buttonProps,
                pr: "lg",
                onClick: nextStep(),
                children: /* @__PURE__ */ jsx(IconPlayerSkipForwardFilled, {})
              }
            )
          ] })
        ]
      }
    )
  ] });
}
var container = "eaj0yq0", card = "eaj0yq1", tabPanel = "eaj0yq2", elementNotation = "eaj0yq3", shapeSvg = "eaj0yq4", shapeBadge = "eaj0yq5";
const ElementNotation = ({ value }) => {
  const {
    title: title2,
    color: color2 = "primary",
    shape = "rectangle"
  } = value, [onlyKind, setOnlyKind] = useState$1(null), diagramStore = useDiagramStoreApi(), w = 300, h = 200;
  return /* @__PURE__ */ jsx(
    Card,
    {
      shadow: "none",
      px: "xs",
      py: "sm",
      className: elementNotation,
      mod: {
        "data-likec4-color": color2
      },
      onMouseEnter: () => {
        setOnlyKind(null), diagramStore.getState().highlightByElementNotation(value);
      },
      onMouseLeave: () => {
        setOnlyKind(null), diagramStore.setState({ dimmed: /* @__PURE__ */ new Set() });
      },
      children: /* @__PURE__ */ jsxs(
        Group,
        {
          gap: "sm",
          align: "stretch",
          wrap: "nowrap",
          children: [
            /* @__PURE__ */ jsx(
              Box,
              {
                flex: "0 0 70px",
                style: {
                  width: 70,
                  height: u$1(70 * (h / w), 0)
                },
                children: /* @__PURE__ */ jsx(
                  "svg",
                  {
                    className: clsx(
                      shapeSvg
                    ),
                    viewBox: `0 0 ${w} ${h}`,
                    children: /* @__PURE__ */ jsx(
                      ElementShapeSvg,
                      {
                        shape,
                        w,
                        h
                      }
                    )
                  }
                )
              }
            ),
            /* @__PURE__ */ jsxs(Stack$1, { gap: 4, flex: 1, children: [
              /* @__PURE__ */ jsx(Group, { gap: 4, flex: "0 0 auto", children: value.kinds.map((kind) => /* @__PURE__ */ jsx(
                Badge,
                {
                  className: shapeBadge,
                  onMouseEnter: () => {
                    setOnlyKind(kind), diagramStore.getState().highlightByElementNotation(value, kind);
                  },
                  onMouseLeave: () => {
                    setOnlyKind(null), diagramStore.getState().highlightByElementNotation(value);
                  },
                  opacity: l$2(onlyKind) && onlyKind !== kind ? 0.25 : 1,
                  color: l$2(onlyKind) && onlyKind !== kind ? "gray" : vars.element.fill,
                  children: kind
                },
                kind
              )) }),
              /* @__PURE__ */ jsx(
                Text$6,
                {
                  component: "div",
                  fz: "sm",
                  fw: 500,
                  lh: "1.25",
                  style: {
                    textWrap: "pretty"
                  },
                  children: title2
                }
              )
            ] })
          ]
        }
      )
    }
  );
}, selector$1 = (s2) => ({
  id: s2.view.id,
  notations: s2.view.notation?.elements ?? [],
  isVisible: n$2(s2.focusedNodeId ?? s2.activeWalkthrough)
});
function NotationPanel() {
  const height = useXYStore((s2) => s2.height), {
    id: id2,
    notations,
    isVisible
  } = useDiagramState(selector$1), [isCollapsed, setCollapsed] = useLocalStorage({
    key: "notation-webview-collapsed",
    defaultValue: !0
  }), hasNotations = notations.length > 0, portalProps = useMantinePortalProps();
  return /* @__PURE__ */ jsxs(AnimatePresence, { children: [
    !hasNotations && isVisible && /* @__PURE__ */ jsx(
      m.div,
      {
        initial: { opacity: 0.75, translateX: "50%" },
        animate: { opacity: 1, translateX: 0 },
        exit: {
          translateX: "100%",
          opacity: 0.6
        },
        className: clsx("react-flow__panel", container),
        children: /* @__PURE__ */ jsx(Tooltip$5, { label: "View has no notations", color: "orange", ...portalProps, children: /* @__PURE__ */ jsx(
          ThemeIcon,
          {
            size: "lg",
            variant: "light",
            color: "orange",
            radius: "md",
            children: /* @__PURE__ */ jsx(IconAlertTriangle, {})
          }
        ) })
      },
      "empty"
    ),
    hasNotations && isVisible && isCollapsed && /* @__PURE__ */ jsx(
      m.div,
      {
        initial: { opacity: 0.75, translateX: "50%" },
        animate: { opacity: 1, translateX: 0 },
        exit: {
          translateX: "100%",
          opacity: 0.6
        },
        className: clsx("react-flow__panel", container),
        children: /* @__PURE__ */ jsx(Tooltip$5, { label: "Show notation", color: "dark", fz: "xs", ...portalProps, children: /* @__PURE__ */ jsx(
          ActionIcon$1,
          {
            size: "lg",
            variant: "default",
            color: "gray",
            radius: "md",
            onClick: () => setCollapsed(!1),
            children: /* @__PURE__ */ jsx(IconHelpCircle, { stroke: 1.5 })
          }
        ) })
      },
      "collapsed"
    ),
    hasNotations && isVisible && !isCollapsed && /* @__PURE__ */ jsx(
      m.div,
      {
        initial: {
          opacity: 0.75,
          // translateX: '50%',
          scale: 0.2
        },
        animate: { opacity: 1, scale: 1 },
        exit: {
          opacity: 0,
          scale: 0.25
        },
        className: clsx("react-flow__panel", container),
        style: {
          transformOrigin: "bottom right"
        },
        children: /* @__PURE__ */ jsx(
          Paper,
          {
            radius: "sm",
            withBorder: !0,
            shadow: "lg",
            className: card,
            children: /* @__PURE__ */ jsxs(Tabs, { defaultValue: "first", radius: "xs", children: [
              /* @__PURE__ */ jsxs(TabsList, { children: [
                /* @__PURE__ */ jsx(
                  ActionIcon$1,
                  {
                    size: "md",
                    variant: "subtle",
                    color: "gray",
                    ml: 2,
                    style: {
                      alignSelf: "center"
                    },
                    onClick: () => setCollapsed(!0),
                    children: /* @__PURE__ */ jsx(IconArrowDownRight, { stroke: 2 })
                  }
                ),
                /* @__PURE__ */ jsx(TabsTab, { value: "first", fz: "xs", children: "Elements" }),
                /* @__PURE__ */ jsx(TabsTab, { value: "second", fz: "xs", disabled: !0, children: "Relationships" })
              ] }),
              /* @__PURE__ */ jsx(TabsPanel, { value: "first", className: tabPanel, hidden: isCollapsed, children: /* @__PURE__ */ jsx(
                ScrollAreaAutosize,
                {
                  viewportProps: {
                    style: {
                      maxHeight: `min(40vh, ${Math.max(height - 60, 50)}px)`
                    }
                  },
                  children: /* @__PURE__ */ jsx(Stack$1, { gap: 0, children: notations.map((n2, i2) => /* @__PURE__ */ jsx(ElementNotation, { value: n2 }, i2)) })
                }
              ) })
            ] })
          }
        )
      },
      id2
    )
  ] });
}
const Tooltip = Tooltip$5.withProps({
  color: "dark",
  fz: "xs",
  position: "right",
  openDelay: 600,
  closeDelay: 120,
  label: "",
  children: null,
  offset: 8
}), ActionIcon = ActionIcon$1.withProps({
  classNames: {
    root: "action-icon"
  },
  variant: "default",
  color: "gray"
});
var backwardForwardButtons = "syg3oy0", panel = "syg3oy1", actionIconGroup = "syg3oy2", autolayoutButton = "syg3oy4", autolayoutIndicator = "syg3oy5", spacingSliderBody = "syg3oy6", spacingSliderThumb = "syg3oy7";
const selector = (state) => ({
  viewId: state.view.id,
  autoLayout: state.view.autoLayout
}), ChangeAutoLayoutButton = (props2) => {
  const store = useDiagramStoreApi(), [rootRef, setRootRef] = useState$1(null), [controlsRefs, setControlsRefs] = useState$1({}), {
    autoLayout,
    viewId
  } = useDiagramState(selector), { ref, hovered: isSpacingHovered } = useHover(), setControlRef = (name) => (node2) => {
    controlsRefs[name] = node2, setControlsRefs(controlsRefs);
  }, setAutoLayout = (direction) => (event) => {
    event.stopPropagation(), store.getState().onChange?.({
      change: {
        op: "change-autolayout",
        layout: {
          ...autoLayout,
          direction
        }
      }
    });
  }, setSpacing = (nodeSep, rankSep) => {
    store.setState({
      viewportChanged: !1
    }), store.getState().onChange?.({
      change: {
        op: "change-autolayout",
        layout: {
          ...autoLayout,
          nodeSep,
          rankSep
        }
      }
    });
  };
  return /* @__PURE__ */ jsxs(
    Popover,
    {
      position: "right-start",
      clickOutsideEvents: [
        "pointerdown"
      ],
      radius: "xs",
      shadow: "lg",
      offset: {
        mainAxis: 10
      },
      ...props2,
      children: [
        /* @__PURE__ */ jsx(PopoverTarget, { children: /* @__PURE__ */ jsx(Tooltip, { label: "Change Auto Layout", children: /* @__PURE__ */ jsx(ActionIcon, { children: /* @__PURE__ */ jsx(IconLayoutDashboard, {}) }) }) }),
        /* @__PURE__ */ jsx(PopoverDropdown, { className: "likec4-top-left-panel", p: 8, pt: 6, opacity: isSpacingHovered ? 0.6 : 1, children: /* @__PURE__ */ jsxs(Box, { pos: "relative", ref: setRootRef, children: [
          /* @__PURE__ */ jsx(
            FloatingIndicator,
            {
              target: controlsRefs[autoLayout.direction],
              parent: rootRef,
              className: autolayoutIndicator
            }
          ),
          /* @__PURE__ */ jsx(Box, { mb: 10, children: /* @__PURE__ */ jsx(Text$6, { inline: !0, fz: "xs", c: "dimmed", fw: 500, children: "Auto layout:" }) }),
          /* @__PURE__ */ jsxs(Flex, { gap: 2, wrap: "wrap", justify: "stretch", maw: 160, children: [
            /* @__PURE__ */ jsx(UnstyledButton, { className: autolayoutButton, ref: setControlRef("TB"), onClick: setAutoLayout("TB"), children: "Top-Bottom" }),
            /* @__PURE__ */ jsx(UnstyledButton, { className: autolayoutButton, ref: setControlRef("BT"), onClick: setAutoLayout("BT"), children: "Bottom-Top" }),
            /* @__PURE__ */ jsx(UnstyledButton, { className: autolayoutButton, ref: setControlRef("LR"), onClick: setAutoLayout("LR"), children: "Left-Right" }),
            /* @__PURE__ */ jsx(UnstyledButton, { className: autolayoutButton, ref: setControlRef("RL"), onClick: setAutoLayout("RL"), children: "Right-Left" })
          ] }),
          /* @__PURE__ */ jsx(Box, { my: 10, children: /* @__PURE__ */ jsx(Text$6, { inline: !0, fz: "xs", c: "dimmed", fw: 500, children: "Spacing:" }) }),
          /* @__PURE__ */ jsx(
            SpacingSliders,
            {
              ref,
              isVertical: autoLayout.direction === "TB" || autoLayout.direction === "BT",
              nodeSep: autoLayout.nodeSep,
              rankSep: autoLayout.rankSep,
              onChange: setSpacing
            },
            viewId
          )
        ] }) })
      ]
    }
  );
}, MAX_SPACING = 400, SpacingSliders = forwardRef$1(({
  isVertical,
  nodeSep,
  rankSep,
  onChange
}, _ref) => {
  isVertical || ([nodeSep, rankSep] = [rankSep, nodeSep]);
  const propagateChange = useDebouncedCallback(
    ({ x: x2, y: y2 }) => {
      isVertical || ([x2, y2] = [y2, x2]), onChange(Math.round(x2 * MAX_SPACING), Math.round(y2 * MAX_SPACING));
    },
    [onChange, isVertical],
    150,
    2e3
  ), [value, setValue] = useUncontrolled({
    defaultValue: clampUseMovePosition({
      x: (nodeSep ?? 100) / MAX_SPACING,
      y: (rankSep ?? 120) / MAX_SPACING
    }),
    onChange: propagateChange
  }), { ref } = useMove(setValue);
  let nodeSepValue = Math.round(value.x * MAX_SPACING), rankSepValue = Math.round(value.y * MAX_SPACING);
  isVertical || ([nodeSepValue, rankSepValue] = [rankSepValue, nodeSepValue]);
  const mergedRef = useMergedRef(ref, _ref);
  return /* @__PURE__ */ jsxs(Box, { ref: mergedRef, className: spacingSliderBody, pt: "100%", children: [
    /* @__PURE__ */ jsx(
      Box,
      {
        className: spacingSliderThumb,
        style: {
          left: `${value.x * 100}%`,
          top: `${value.y * 100}%`
        }
      }
    ),
    /* @__PURE__ */ jsx(Box, { pos: "absolute", left: 2, bottom: 2, children: /* @__PURE__ */ jsxs(Text$6, { component: "div", fz: 8, c: "dimmed", fw: 500, children: [
      rankSepValue,
      ", ",
      nodeSepValue
    ] }) })
  ] });
}), Action = ({
  label: label2,
  icon,
  onClick
}) => /* @__PURE__ */ jsx(Tooltip, { label: label2, withinPortal: !1, position: "top", children: /* @__PURE__ */ jsx(ActionIcon, { onClick, children: icon }) }), ManualLayoutToolsButton = (props2) => {
  const store = useDiagramStoreApi();
  return /* @__PURE__ */ jsxs(
    Popover,
    {
      position: "right-start",
      clickOutsideEvents: [
        "pointerdown"
      ],
      radius: "xs",
      shadow: "lg",
      offset: {
        mainAxis: 10
      },
      ...props2,
      children: [
        /* @__PURE__ */ jsx(PopoverTarget, { children: /* @__PURE__ */ jsx(Tooltip, { label: "Manual layouting tools", withinPortal: !1, position: "top-end", children: /* @__PURE__ */ jsx(ActionIcon, { children: /* @__PURE__ */ jsx(IconLayoutCollage, {}) }) }) }),
        /* @__PURE__ */ jsx(PopoverDropdown, { p: 0, children: /* @__PURE__ */ jsxs(Group, { gap: "xs", children: [
          /* @__PURE__ */ jsxs(ActionIconGroup, { pos: "relative", children: [
            /* @__PURE__ */ jsx(
              Action,
              {
                label: "Align in columns",
                icon: /* @__PURE__ */ jsx(IconLayoutBoardSplit, {}),
                onClick: (e2) => {
                  e2.stopPropagation(), store.getState().align("Column");
                }
              }
            ),
            /* @__PURE__ */ jsx(
              Action,
              {
                label: "Align left",
                icon: /* @__PURE__ */ jsx(IconLayoutAlignLeft, {}),
                onClick: (e2) => {
                  e2.stopPropagation(), store.getState().align("Left");
                }
              }
            ),
            /* @__PURE__ */ jsx(
              Action,
              {
                label: "Align center",
                icon: /* @__PURE__ */ jsx(IconLayoutAlignCenter, {}),
                onClick: (e2) => {
                  e2.stopPropagation(), store.getState().align("Center");
                }
              }
            ),
            /* @__PURE__ */ jsx(
              Action,
              {
                label: "Align right",
                icon: /* @__PURE__ */ jsx(IconLayoutAlignRight, {}),
                onClick: (e2) => {
                  e2.stopPropagation(), store.getState().align("Right");
                }
              }
            ),
            /* @__PURE__ */ jsx(
              Action,
              {
                label: "Align in rows",
                icon: /* @__PURE__ */ jsx(IconLayoutBoardSplit, { style: { transform: "rotate(90deg)" } }),
                onClick: (e2) => {
                  e2.stopPropagation(), store.getState().align("Row");
                }
              }
            ),
            /* @__PURE__ */ jsx(
              Action,
              {
                label: "Align top",
                icon: /* @__PURE__ */ jsx(IconLayoutAlignTop, {}),
                onClick: (e2) => {
                  e2.stopPropagation(), store.getState().align("Top");
                }
              }
            ),
            /* @__PURE__ */ jsx(
              Action,
              {
                label: "Align middle",
                icon: /* @__PURE__ */ jsx(IconLayoutAlignMiddle, {}),
                onClick: (e2) => {
                  e2.stopPropagation(), store.getState().align("Middle");
                }
              }
            ),
            /* @__PURE__ */ jsx(
              Action,
              {
                label: "Align bottom",
                icon: /* @__PURE__ */ jsx(IconLayoutAlignBottom, {}),
                onClick: (e2) => {
                  e2.stopPropagation(), store.getState().align("Bottom");
                }
              }
            )
          ] }),
          /* @__PURE__ */ jsx(
            Action,
            {
              label: "Reset all control points",
              icon: /* @__PURE__ */ jsx(IconRouteOff, {}),
              onClick: (e2) => {
                e2.stopPropagation(), store.getState().resetEdgeControlPoints();
              }
            }
          )
        ] }) })
      ]
    }
  );
}, historySelector = (s2) => ({
  showBurgerMenu: !!s2.onBurgerMenuClick,
  hasStepBack: s2.showNavigationButtons && !!s2.onNavigateTo && s2.navigationHistoryIndex > 0,
  hasStepForward: s2.showNavigationButtons && !!s2.onNavigateTo && s2.navigationHistoryIndex < s2.navigationHistory.length - 1
}), BackwardForwardButtons = () => {
  const store = useDiagramStoreApi(), {
    showBurgerMenu,
    hasStepBack,
    hasStepForward
  } = useDiagramState(historySelector);
  return /* @__PURE__ */ jsx(LayoutGroup, { children: /* @__PURE__ */ jsxs(
    Group,
    {
      className: clsx(backwardForwardButtons, "likec4-navigation-webview"),
      align: "flex-start",
      gap: "xs",
      children: [
        showBurgerMenu && /* @__PURE__ */ jsx(
          ActionIcon,
          {
            onClick: (e2) => {
              e2.stopPropagation(), store.getState().onBurgerMenuClick?.();
            },
            children: /* @__PURE__ */ jsx(IconMenu2, {})
          }
        ),
        /* @__PURE__ */ jsxs(AnimatePresence, { children: [
          hasStepBack && /* @__PURE__ */ jsx(
            m.div,
            {
              layout: !0,
              initial: { opacity: 0.05, transform: "translateX(-10px)" },
              animate: { opacity: 1, transform: "translateX(0)" },
              exit: {
                opacity: 0.05,
                transform: "translateX(-10px)"
              },
              children: /* @__PURE__ */ jsx(
                ActionIcon,
                {
                  onClick: (e2) => {
                    e2.stopPropagation(), store.getState().goBack();
                  },
                  children: /* @__PURE__ */ jsx(IconChevronLeft, {})
                }
              )
            },
            "back"
          ),
          hasStepForward && /* @__PURE__ */ jsx(
            m.div,
            {
              layout: !0,
              initial: { opacity: 0.05, transform: "translateX(10px)" },
              animate: { opacity: 1, transform: "translateX(0)" },
              exit: {
                opacity: 0,
                transform: "translateX(10px)"
              },
              children: /* @__PURE__ */ jsx(
                ActionIcon,
                {
                  onClick: (e2) => {
                    e2.stopPropagation(), store.getState().goForward();
                  },
                  children: /* @__PURE__ */ jsx(IconChevronRight, {})
                }
              )
            },
            "forward"
          )
        ] })
      ]
    }
  ) });
}, LayoutDriftNotification = (props2) => /* @__PURE__ */ jsxs(
  HoverCard,
  {
    position: "right-start",
    openDelay: 200,
    closeDelay: 100,
    ...props2,
    children: [
      /* @__PURE__ */ jsx(HoverCardTarget, { children: /* @__PURE__ */ jsxs(ActionIcon, { c: "orange", children: [
        /* @__PURE__ */ jsx(Overlay, { color: mantine.colors.orange.lightHover, backgroundOpacity: 1 }),
        /* @__PURE__ */ jsx(IconAlertTriangle, {})
      ] }) }),
      /* @__PURE__ */ jsx(HoverCardDropdown, { p: "0", children: /* @__PURE__ */ jsxs(
        Notification,
        {
          color: "orange",
          withBorder: !1,
          withCloseButton: !1,
          title: "Manual layout issues",
          children: [
            /* @__PURE__ */ jsxs(Text$6, { mt: 2, size: "sm", lh: "xs", children: [
              "View contains new elements or their sizes have changed,",
              /* @__PURE__ */ jsx("br", {}),
              "last manual layout can not be applied."
            ] }),
            /* @__PURE__ */ jsxs(Text$6, { mt: "xs", size: "sm", lh: "xs", children: [
              "Update view predicates or remove ",
              /* @__PURE__ */ jsx(Code, { children: "@likec4-generated" })
            ] })
          ]
        }
      ) })
    ]
  }
), TopLeftPanel = () => {
  const store = useDiagramStoreApi(), {
    enableSearch,
    showNavigationButtons,
    showFitDiagram,
    showLayoutDriftWarning,
    showChangeAutoLayout,
    showGoToSource,
    viewportChanged,
    showManualLayoutTools
  } = useDiagramState((s2) => {
    const isNotWalkthrough = n$2(s2.activeWalkthrough), isNotFocused = n$2(s2.focusedNodeId), isNotActive = isNotWalkthrough && isNotFocused;
    return {
      enableSearch: s2.enableSearch,
      showNavigationButtons: !!s2.onBurgerMenuClick || s2.showNavigationButtons && !!s2.onNavigateTo,
      showFitDiagram: s2.controls && s2.fitViewEnabled && s2.zoomable && isNotWalkthrough,
      showLayoutDriftWarning: s2.controls && !s2.readonly && s2.view.hasLayoutDrift === !0 && isNotActive,
      showChangeAutoLayout: s2.controls && s2.isEditable() && isNotActive,
      showGoToSource: s2.controls && !!s2.onOpenSourceView && isNotWalkthrough,
      viewportChanged: s2.viewportChanged,
      showManualLayoutTools: s2.controls && s2.readonly !== !0 && s2.experimentalEdgeEditing === !0
    };
  }), portalProps = useMantinePortalProps();
  return /* @__PURE__ */ jsx(TooltipGroup, { openDelay: 600, closeDelay: 150, children: /* @__PURE__ */ jsxs(
    Stack$1,
    {
      className: clsx(
        "react-flow__panel",
        panel,
        "likec4-top-left-panel"
      ),
      align: "flex-start",
      onClick: (e2) => e2.stopPropagation(),
      gap: "xs",
      children: [
        showNavigationButtons && /* @__PURE__ */ jsx(BackwardForwardButtons, {}),
        /* @__PURE__ */ jsxs(ActionIconGroup, { className: actionIconGroup, orientation: "vertical", children: [
          enableSearch && /* @__PURE__ */ jsx(Tooltip, { label: "Search", children: /* @__PURE__ */ jsx(
            ActionIcon,
            {
              onClick: () => openSpotlight(),
              children: /* @__PURE__ */ jsx(IconSearch, {})
            }
          ) }),
          showGoToSource && /* @__PURE__ */ jsx(Tooltip, { label: "Open source", ...portalProps, children: /* @__PURE__ */ jsx(
            ActionIcon,
            {
              onClick: (e2) => {
                e2.stopPropagation(), store.getState().onOpenSourceView?.();
              },
              children: /* @__PURE__ */ jsx(IconFileSymlink, { stroke: 1.5 })
            }
          ) }),
          showChangeAutoLayout && /* @__PURE__ */ jsx(ChangeAutoLayoutButton, { ...portalProps }),
          showLayoutDriftWarning && /* @__PURE__ */ jsx(LayoutDriftNotification, { ...portalProps }),
          showManualLayoutTools && /* @__PURE__ */ jsx(ManualLayoutToolsButton, { ...portalProps }),
          showFitDiagram && /* @__PURE__ */ jsx(Tooltip, { label: viewportChanged ? "Center camera" : "Camera is centered", ...portalProps, children: /* @__PURE__ */ jsx(
            ActionIcon,
            {
              onClick: (e2) => {
                e2.stopPropagation(), store.getState().fitDiagram();
              },
              children: /* @__PURE__ */ jsx(IconFocusCentered, {})
            }
          ) })
        ] })
      ]
    }
  ) });
};
TopLeftPanel.displayName = "TopLeftPanel";
function literalToEnum(value) {
  switch (value) {
    case "dots":
      return BackgroundVariant.Dots;
    case "lines":
      return BackgroundVariant.Lines;
    case "cross":
      return BackgroundVariant.Cross;
    default:
      nonexhaustive(value);
  }
}
function XYFlowBackground({ background }) {
  if (typeof background == "string")
    return /* @__PURE__ */ jsx(Background, { variant: literalToEnum(background), size: 2, gap: 20 });
  const { variant, ...rest } = background;
  return /* @__PURE__ */ jsx(Background, { variant: literalToEnum(variant), ...rest });
}
const XYFlowInner = /* @__PURE__ */ memo$1(function({
  background,
  showDiagramTitle
}) {
  const {
    showNotations,
    isDynamicView,
    showTopLeft,
    isDynamicViewActive,
    enableDynamicViewWalkthrough
  } = useDiagramState((s2) => ({
    showNotations: s2.showNotations,
    isDynamicView: s2.isDynamicView,
    showTopLeft: s2.controls || s2.showNavigationButtons && !!s2.onNavigateTo || !!s2.onBurgerMenuClick,
    enableDynamicViewWalkthrough: s2.enableDynamicViewWalkthrough,
    isDynamicViewActive: l$2(s2.activeWalkthrough)
  }));
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    background !== "transparent" && background !== "solid" && /* @__PURE__ */ jsx(XYFlowBackground, { background }),
    showTopLeft && /* @__PURE__ */ jsx(TopLeftPanel, {}),
    showDiagramTitle && !isDynamicViewActive && /* @__PURE__ */ jsx(DiagramTitlePanel, {}),
    isDynamicView && enableDynamicViewWalkthrough && /* @__PURE__ */ jsx(DynamicViewWalkthrough, {}),
    showNotations && /* @__PURE__ */ jsx(NotationPanel, {})
  ] });
}, deepEqual);
XYFlowInner.displayName = "XYFlowInner";
function LikeC4Diagram({
  view,
  className,
  fitView = !0,
  fitViewPadding = 0,
  readonly = !0,
  pannable = !0,
  zoomable = !0,
  nodesSelectable = !readonly,
  nodesDraggable = !readonly,
  background = "dots",
  controls = !readonly,
  showDiagramTitle = !0,
  showNotations = !0,
  enableDynamicViewWalkthrough = !1,
  enableFocusMode = !1,
  enableElementDetails = !1,
  enableRelationshipDetails = enableElementDetails,
  enableRelationshipBrowser = enableRelationshipDetails,
  enableSearch = !0,
  initialWidth,
  initialHeight,
  keepAspectRatio = !1,
  experimentalEdgeEditing = !1,
  onCanvasClick,
  onCanvasContextMenu,
  onCanvasDblClick,
  onEdgeClick,
  onChange,
  onEdgeContextMenu,
  onNavigateTo,
  onNodeClick,
  onNodeContextMenu,
  onOpenSourceElement,
  onOpenSourceView,
  onOpenSourceRelation,
  onBurgerMenuClick,
  renderIcon,
  where,
  showNavigationButtons = !!onNavigateTo
}) {
  const hasLikec4model = !!useLikeC4Model(), initialRef = useRef$1({
    defaultNodes: [],
    defaultEdges: [],
    initialWidth: initialWidth ?? view.bounds.width,
    initialHeight: initialHeight ?? view.bounds.height
  });
  return useEffect$1(() => {
    readonly !== !0 && where != null && console.warn(`Ignore filter, supported in readonly mode only
`, { where }), !hasLikec4model && (enableRelationshipDetails && console.warn("Invalid showRelationshipDetails=true, requires LikeC4ModelProvider"), enableElementDetails && console.warn("Invalid enableElementDetails=true, requires LikeC4ModelProvider"), enableRelationshipBrowser && console.warn("Invalid enableRelationshipBrowser=true, requires LikeC4ModelProvider"));
  }), /* @__PURE__ */ jsx(EnsureMantine, { children: /* @__PURE__ */ jsx(FramerMotionConfig, { children: /* @__PURE__ */ jsxs(
    ReactFlowProvider,
    {
      fitView,
      ...initialRef.current,
      children: [
        !n(view.customColorDefinitions) && /* @__PURE__ */ jsx(LikeC4CustomColors, { customColors: view.customColorDefinitions }),
        /* @__PURE__ */ jsx(
          DiagramContextProvider,
          {
            view,
            keepAspectRatio,
            className: clsx(rootClassName, className),
            readonly,
            experimentalEdgeEditing: !readonly && experimentalEdgeEditing,
            pannable,
            zoomable,
            nodesDraggable,
            nodesSelectable: nodesSelectable || enableFocusMode,
            hasLikeC4Model: hasLikec4model,
            fitViewEnabled: fitView,
            fitViewPadding,
            controls,
            showNavigationButtons: showNavigationButtons && !!onNavigateTo,
            showNotations,
            enableFocusMode,
            enableRelationshipDetails: enableRelationshipDetails && hasLikec4model,
            enableSearch: hasLikec4model && enableSearch,
            enableElementDetails: enableElementDetails && hasLikec4model,
            enableDynamicViewWalkthrough,
            enableRelationshipBrowser: enableRelationshipBrowser && hasLikec4model,
            whereFilter: readonly ? where ?? null : null,
            renderIcon: renderIcon ?? null,
            onCanvasClick: onCanvasClick ?? null,
            onCanvasContextMenu: onCanvasContextMenu ?? null,
            onEdgeClick: onEdgeClick ?? null,
            onEdgeContextMenu: onEdgeContextMenu ?? null,
            onNodeClick: onNodeClick ?? null,
            onNodeContextMenu: onNodeContextMenu ?? null,
            onChange: onChange ?? null,
            onNavigateTo: onNavigateTo ?? null,
            onCanvasDblClick: onCanvasDblClick ?? null,
            onOpenSourceView: onOpenSourceView ?? null,
            onOpenSourceElement: onOpenSourceElement ?? null,
            onOpenSourceRelation: onOpenSourceRelation ?? null,
            onBurgerMenuClick: onBurgerMenuClick ?? null,
            children: /* @__PURE__ */ jsx(
              LikeC4DiagramInnerMemo,
              {
                background,
                showDiagramTitle,
                enableSearch: hasLikec4model && enableSearch
              }
            )
          }
        )
      ]
    }
  ) }) });
}
LikeC4Diagram.displayName = "LikeC4Diagram";
const LikeC4DiagramInnerMemo = /* @__PURE__ */ memo$1(function({
  background,
  showDiagramTitle,
  enableSearch
}) {
  const {
    isInitialized,
    pannable,
    fitView,
    enableFocusMode,
    enableOverlays
  } = useDiagramState((s2) => ({
    isInitialized: s2.initialized,
    pannable: s2.pannable,
    fitView: s2.fitViewEnabled,
    enableFocusMode: s2.enableFocusMode,
    enableOverlays: s2.hasLikeC4Model && (s2.enableRelationshipBrowser || s2.enableElementDetails)
  }));
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(
      XYFlow,
      {
        className: clsx(
          "likec4-diagram",
          cssReactFlow,
          cssNoControls,
          pannable !== !0 && cssDisablePan,
          background === "transparent" && cssTransparentBg,
          isInitialized ? "initialized" : notInitialized
        ),
        children: /* @__PURE__ */ jsx(
          XYFlowInner,
          {
            showDiagramTitle,
            background
          }
        )
      }
    ),
    enableOverlays && /* @__PURE__ */ jsx(Overlays, {}),
    enableSearch && /* @__PURE__ */ jsx(LikeC4Search, {}),
    isInitialized && /* @__PURE__ */ jsxs(Fragment$1, { children: [
      fitView && /* @__PURE__ */ jsx(FitViewOnDiagramChange, {}),
      enableFocusMode && /* @__PURE__ */ jsx(SelectEdgesOnNodeFocus, {})
    ] })
  ] });
}, deepEqual);
LikeC4DiagramInnerMemo.displayName = "LikeC4DiagramInnerMemo";
function LikeC4ModelProvider({
  children,
  likec4model
}) {
  return /* @__PURE__ */ jsx(LikeC4ModelContext.Provider, { value: likec4model, children });
}
function StaticLikeC4Diagram({
  view,
  fitView = !0,
  fitViewPadding = 0,
  enableElementDetails = !1,
  enableRelationshipDetails = !1,
  enableRelationshipBrowser = enableRelationshipDetails,
  background = "transparent",
  ...rest
}) {
  return /* @__PURE__ */ jsx(
    LikeC4Diagram,
    {
      view,
      readonly: !0,
      fitView,
      fitViewPadding,
      pannable: !1,
      zoomable: !1,
      controls: !1,
      background,
      showDiagramTitle: !1,
      showNotations: !1,
      enableElementDetails,
      enableRelationshipDetails,
      enableRelationshipBrowser,
      enableDynamicViewWalkthrough: !1,
      experimentalEdgeEditing: !1,
      enableFocusMode: !1,
      nodesSelectable: !1,
      nodesDraggable: !1,
      enableSearch: !1,
      ...rest
    }
  );
}
function LikeC4Model({ children }) {
  const model = useLikeC4ModelAtom();
  return /* @__PURE__ */ jsx(LikeC4ModelProvider, { likec4model: model, children });
}
const theme = createTheme({
  autoContrast: !0,
  primaryColor: "indigo",
  cursorType: "pointer",
  fontFamily: "var(--likec4-app-font)",
  headings: {
    fontWeight: "500",
    sizes: {
      h1: {
        // fontSize: '2rem',
        fontWeight: "600"
      },
      h2: {
        // fontSize: '1.85rem',
      }
    }
  }
}), asTheme = (v) => {
  if (typeof v != "string")
    return;
  const vlower = v.toLowerCase();
  if (vlower === "light" || vlower === "dark")
    return vlower;
}, asPadding = (v) => {
  switch (!0) {
    case typeof v == "number":
      return Math.round(v);
    case typeof v == "string":
      return Math.round(parseFloat(v));
  }
}, Route$a = createRootRouteWithContext()({
  component: RootComponent,
  validateSearch: (search) => ({
    padding: asPadding(search.padding),
    theme: asTheme(search.theme)
  })
});
function RootComponent() {
  const { theme: theme$1 } = Route$a.useSearch();
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(ScrollRestoration, {}),
    /* @__PURE__ */ jsx(
      MantineProvider,
      {
        ...theme$1 && { forceColorScheme: theme$1 },
        defaultColorScheme: theme$1 ?? "auto",
        theme,
        children: /* @__PURE__ */ jsx(LikeC4Model, { children: /* @__PURE__ */ jsx(Outlet, {}) })
      }
    )
  ] });
}
var previewBg = "_15b5f732", cardLink = "_15b5f733";
function IndexPage() {
  const views = t$4(useLikeC4Views());
  return /* @__PURE__ */ jsx(
    SimpleGrid,
    {
      p: { base: "md", sm: "xl" },
      cols: { base: 1, sm: 2, md: 3, lg: 5 },
      spacing: { base: 10, sm: "xl" },
      verticalSpacing: { base: "md", sm: "xl" },
      children: views.map((v) => /* @__PURE__ */ jsx(ViewCard, { viewId: v }, v))
    }
  );
}
const ViewCard = memo$1(({ viewId }) => {
  const diagram = useLikeC4DiagramView(viewId);
  if (!diagram)
    return null;
  const { id: id2, title: title2, description: description2 } = diagram;
  return /* @__PURE__ */ jsxs(
    Card,
    {
      shadow: "xs",
      padding: "lg",
      radius: "sm",
      withBorder: !0,
      children: [
        /* @__PURE__ */ jsx(Card.Section, { children: /* @__PURE__ */ jsx(DiagramPreview$1, { diagram }) }),
        /* @__PURE__ */ jsx(Group, { justify: "space-between", mt: "md", mb: "xs", children: /* @__PURE__ */ jsx(Text$6, { fw: 500, children: title2 }) }),
        /* @__PURE__ */ jsx(Text$6, { size: "sm", c: "dimmed", children: description2 }),
        /* @__PURE__ */ jsx(Link, { to: "/view/$viewId", params: { viewId: id2 }, search: !0, className: cardLink })
      ]
    }
  );
});
function DiagramPreview$1({ diagram }) {
  const { ref, inViewport } = useInViewport(), [visible, setVisible] = useState$1(inViewport);
  return useLayoutEffect$1(() => {
    inViewport && !visible && setVisible(!0);
  }, [inViewport]), /* @__PURE__ */ jsx(Box, { ref, className: previewBg, style: { height: 175 }, children: visible && /* @__PURE__ */ jsx(
    StaticLikeC4Diagram,
    {
      background: "transparent",
      view: diagram,
      keepAspectRatio: !1,
      renderIcon: RenderIcon,
      fitView: !0,
      fitViewPadding: 0.1
    }
  ) });
}
const OverviewGraph = /* @__PURE__ */ lazy(() => import("./-index-overview-DrCqsLHx.js"));
function WithOverviewGraph() {
  return /* @__PURE__ */ jsx(Suspense, { children: /* @__PURE__ */ jsx(OverviewGraph, {}) });
}
const Route$9 = createFileRoute("/")({
  component: withOverviewGraph ? WithOverviewGraph : IndexPage
});
var svgContainer = "_1dn84dq1", cssViewOutlet = "_1dn84dq3", cssExportView = "_1dn84dq4", cssWebcomponentView = "_1dn84dq5", cssWebcomponentIframeContainer = "_1dn84dq6";
const Route$8 = createFileRoute("/webcomponent/$")({
  component: WebcomponentPage
});
function WebcomponentPage() {
  const router = useRouter(), viewId = Route$8.useParams()._splat || "index", { colorScheme } = useMantineColorScheme();
  let base = router.basepath.endsWith("/") ? router.basepath : `${router.basepath}/`;
  const jsurl = new URL(
    `${base}likec4-views.js`,
    window.location.href
  ), iframeHtml = `
    <!DOCTYPE html>
    <html lang="en-US" style="color-scheme: ${colorScheme};">
    <head>
      <meta charset="utf-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no" />
      <style>
        * {
          border-width: 0px;
          border-style: solid;
          box-sizing: border-box;
          overflow-wrap: break-word;
        }
        html, body {
          margin: 0;
          background-color: transparent !important;
          width: 100%;
          height: 100%;
          font-size: 16px;
        }
        body {
          position: relative;
          min-height: 100%;
          padding: clamp(0.5rem, 5vh, 4rem) clamp(0.5rem, 5vw, 5rem);
        }
      </style>
    </head>
    <body>
      <script type="module" src="${jsurl.href}"><\/script>
      <${ComponentName.View} view-id="${encodeURIComponent(viewId)}"></${ComponentName.View}>
    </body>
    </html>
  `;
  return /* @__PURE__ */ jsx(Flex, { direction: "column", className: cssWebcomponentView, children: /* @__PURE__ */ jsx(Box, { className: cssWebcomponentIframeContainer, children: /* @__PURE__ */ jsx(
    "iframe",
    {
      srcDoc: iframeHtml,
      allowtransparency: "true"
    }
  ) }) });
}
const ErrorBoundaryContext = createContext$1(null), initialState = {
  didCatch: !1,
  error: null
};
class ErrorBoundary extends Component {
  constructor(props2) {
    super(props2), this.resetErrorBoundary = this.resetErrorBoundary.bind(this), this.state = initialState;
  }
  static getDerivedStateFromError(error) {
    return {
      didCatch: !0,
      error
    };
  }
  resetErrorBoundary() {
    const {
      error
    } = this.state;
    if (error !== null) {
      for (var _this$props$onReset, _this$props, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
        args[_key] = arguments[_key];
      (_this$props$onReset = (_this$props = this.props).onReset) === null || _this$props$onReset === void 0 || _this$props$onReset.call(_this$props, {
        args,
        reason: "imperative-api"
      }), this.setState(initialState);
    }
  }
  componentDidCatch(error, info) {
    var _this$props$onError, _this$props2;
    (_this$props$onError = (_this$props2 = this.props).onError) === null || _this$props$onError === void 0 || _this$props$onError.call(_this$props2, error, info);
  }
  componentDidUpdate(prevProps, prevState) {
    const {
      didCatch
    } = this.state, {
      resetKeys
    } = this.props;
    if (didCatch && prevState.error !== null && hasArrayChanged(prevProps.resetKeys, resetKeys)) {
      var _this$props$onReset2, _this$props3;
      (_this$props$onReset2 = (_this$props3 = this.props).onReset) === null || _this$props$onReset2 === void 0 || _this$props$onReset2.call(_this$props3, {
        next: resetKeys,
        prev: prevProps.resetKeys,
        reason: "keys"
      }), this.setState(initialState);
    }
  }
  render() {
    const {
      children,
      fallbackRender,
      FallbackComponent,
      fallback
    } = this.props, {
      didCatch,
      error
    } = this.state;
    let childToRender = children;
    if (didCatch) {
      const props2 = {
        error,
        resetErrorBoundary: this.resetErrorBoundary
      };
      if (typeof fallbackRender == "function")
        childToRender = fallbackRender(props2);
      else if (FallbackComponent)
        childToRender = createElement$1(FallbackComponent, props2);
      else if (fallback !== void 0)
        childToRender = fallback;
      else
        throw error;
    }
    return createElement$1(ErrorBoundaryContext.Provider, {
      value: {
        didCatch,
        error,
        resetErrorBoundary: this.resetErrorBoundary
      }
    }, childToRender);
  }
}
function hasArrayChanged() {
  let a2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], b2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return a2.length !== b2.length || a2.some((item, index2) => !Object.is(item, b2[index2]));
}
const isTreeNodeData = (node2) => "type" in node2 && ["file", "folder", "diagram"].includes(node2.type);
function dropFilename(relativePath) {
  return relativePath === "" ? "" : relativePath.split("/").slice(0, -1).join("/");
}
function compareTreeNodes(a2, b2) {
  return a2.children.length === 0 && b2.children.length > 0 ? 1 : a2.children.length > 0 && b2.children.length === 0 ? -1 : compareNatural(a2.label, b2.label);
}
function buildDiagramTreeData(views, groupBy) {
  const root2 = {
    value: "",
    label: "Diagrams",
    type: "folder",
    children: []
  }, findParent = (path) => {
    let parent = root2;
    if (path === "")
      return parent;
    const segments = path.split("/"), traversed = ["@fs"];
    for (; segments.length; ) {
      const label2 = segments.shift();
      traversed.push(label2);
      const value = traversed.join("/");
      let node2 = f(parent.children, (n2) => n2.value === value);
      node2 || (node2 = { label: label2, value, type: "folder", children: [] }, parent.children.push(node2)), parent = node2;
    }
    return parent;
  };
  for (const view of views) {
    let relativePath;
    switch (groupBy) {
      case "by-files":
        relativePath = view.relativePath ?? "";
        break;
      case "by-folders":
        relativePath = dropFilename(view.relativePath ?? "");
        break;
      case "none":
        relativePath = "";
        break;
      default:
        nonexhaustive(groupBy);
    }
    const parent = findParent(relativePath);
    parent.children.push({
      value: view.id,
      label: view.title ?? view.id,
      type: "diagram",
      children: []
    }), parent !== root2 && (parent.children.sort(compareTreeNodes), groupBy === "by-files" && parent.type !== "file" && (parent.type = "file"));
  }
  return root2.children.sort(compareTreeNodes);
}
function useDiagramsTreeData(groupBy = "by-files") {
  const views = useLikeC4ModelAtom().sourcemodel.views;
  return useMemo$1(() => buildDiagramTreeData(r$6(views), groupBy), [views, groupBy]);
}
const isFile = (node2) => isTreeNodeData(node2) && node2.type === "file", FolderIcon = ({ node: node2, expanded }) => isFile(node2) ? /* @__PURE__ */ jsx(ThemeIcon, { size: "sm", variant: "transparent", color: "indigo", children: /* @__PURE__ */ jsx(IconFileCode, { size: 16 }) }) : /* @__PURE__ */ jsx(ThemeIcon, { size: "sm", variant: "transparent", color: "violet", children: expanded ? /* @__PURE__ */ jsx(IconFolderOpen, { size: 16 }) : /* @__PURE__ */ jsx(IconFolderFilled, { size: 16 }) }), DiagramsTree = /* @__PURE__ */ memo$1(({ groupBy }) => {
  const data = useDiagramsTreeData(groupBy), { viewId } = useParams({
    from: "/view/$viewId"
  }), router = useRouter(), diagram = useLikeC4View(viewId), tree = useTree({
    multiple: !1
  }), relativePath = diagram?.relativePath ?? null;
  useUpdateEffect(() => {
    tree.collapseAllNodes();
  }, [groupBy]), useEffect$1(() => {
    if (relativePath) {
      const segments = relativePath.split("/");
      let path = "@fs";
      for (const segment of segments)
        path += `/${segment}`, tree.expand(path);
    }
  }, [relativePath, groupBy]), useEffect$1(() => {
    tree.select(viewId);
  }, [viewId]);
  const theme2 = useComputedColorScheme();
  return /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(
    Tree,
    {
      allowRangeSelection: !1,
      tree,
      data,
      styles: {
        node: {
          marginTop: 2,
          marginBottom: 2
        }
      },
      levelOffset: "md",
      renderNode: ({ node: node2, selected, expanded, elementProps, hasChildren }) => /* @__PURE__ */ jsx(DiagramPreviewHoverCard, { viewId: hasChildren ? null : node2.value, ...elementProps, children: /* @__PURE__ */ jsx(
        Button,
        {
          fullWidth: !0,
          color: theme2 === "light" ? "dark" : "gray",
          variant: selected ? "transparent" : "subtle",
          size: "sm",
          fz: "sm",
          fw: hasChildren ? "600" : "500",
          justify: "flex-start",
          styles: {
            section: {
              opacity: 0.75
            }
          },
          leftSection: /* @__PURE__ */ jsxs(Fragment$1, { children: [
            !hasChildren && node2.value === "index" && /* @__PURE__ */ jsx(IconStarFilled, { size: 14, opacity: 0.7 }),
            !hasChildren && node2.value !== "index" && /* @__PURE__ */ jsx(IconLayoutDashboard, { size: 16, opacity: 0.7 }),
            hasChildren && /* @__PURE__ */ jsx(FolderIcon, { node: node2, expanded })
          ] }),
          ...!hasChildren && {
            onClick: () => {
              router.navigate({
                params: {
                  viewId: node2.value
                }
              });
            }
          },
          children: node2.label
        }
      ) })
    }
  ) });
});
function DiagramPreviewHoverCard({
  viewId,
  children,
  ...props2
}) {
  return viewId ? /* @__PURE__ */ jsx(Box, { ...props2, children: /* @__PURE__ */ jsx(DiagramPreview, { viewId, onClick: props2.onClick, children }) }) : /* @__PURE__ */ jsx(Box, { ...props2, children });
}
function DiagramPreview({
  viewId,
  children,
  onClick
}) {
  const diagram = useLikeC4DiagramView(viewId);
  if (!diagram)
    return children;
  const ratio = Math.max(diagram.bounds.width / 400, diagram.bounds.height / 300), width2 = Math.round(diagram.bounds.width / ratio), height = Math.round(diagram.bounds.height / ratio);
  return /* @__PURE__ */ jsxs(HoverCard, { position: "right-start", openDelay: 400, closeDelay: 100, keepMounted: !1, shadow: "lg", children: [
    /* @__PURE__ */ jsx(HoverCardTarget, { children }),
    /* @__PURE__ */ jsx(HoverCardDropdown, { style: { width: width2, height }, p: "xs", onClick, children: /* @__PURE__ */ jsx(
      StaticLikeC4Diagram,
      {
        view: diagram,
        keepAspectRatio: !1,
        renderIcon: RenderIcon,
        fitView: !0,
        fitViewPadding: 0,
        enableElementDetails: !1,
        initialWidth: width2,
        initialHeight: height
      }
    ) })
  ] });
}
let listenerQueue = [], lqIndex = 0;
const QUEUE_ITEMS_PER_LISTENER = 4;
let atom = (initialValue) => {
  let listeners = [], $atom = {
    get() {
      return $atom.lc || $atom.listen(() => {
      })(), $atom.value;
    },
    lc: 0,
    listen(listener) {
      return $atom.lc = listeners.push(listener), () => {
        for (let i2 = lqIndex + QUEUE_ITEMS_PER_LISTENER; i2 < listenerQueue.length; )
          listenerQueue[i2] === listener ? listenerQueue.splice(i2, QUEUE_ITEMS_PER_LISTENER) : i2 += QUEUE_ITEMS_PER_LISTENER;
        let index2 = listeners.indexOf(listener);
        ~index2 && (listeners.splice(index2, 1), --$atom.lc || $atom.off());
      };
    },
    notify(oldValue, changedKey) {
      let runListenerQueue = !listenerQueue.length;
      for (let listener of listeners)
        listenerQueue.push(
          listener,
          $atom.value,
          oldValue,
          changedKey
        );
      if (runListenerQueue) {
        for (lqIndex = 0; lqIndex < listenerQueue.length; lqIndex += QUEUE_ITEMS_PER_LISTENER)
          listenerQueue[lqIndex](
            listenerQueue[lqIndex + 1],
            listenerQueue[lqIndex + 2],
            listenerQueue[lqIndex + 3]
          );
        listenerQueue.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(newValue) {
      let oldValue = $atom.value;
      oldValue !== newValue && ($atom.value = newValue, $atom.notify(oldValue));
    },
    subscribe(listener) {
      let unbind = $atom.listen(listener);
      return listener($atom.value), unbind;
    },
    value: initialValue
  };
  return $atom;
};
const MOUNT = 5, UNMOUNT = 6, REVERT_MUTATION = 10;
let on = (object2, listener, eventKey, mutateStore) => (object2.events = object2.events || {}, object2.events[eventKey + REVERT_MUTATION] || (object2.events[eventKey + REVERT_MUTATION] = mutateStore((eventProps) => {
  object2.events[eventKey].reduceRight((event, l2) => (l2(event), event), {
    shared: {},
    ...eventProps
  });
})), object2.events[eventKey] = object2.events[eventKey] || [], object2.events[eventKey].push(listener), () => {
  let currentListeners = object2.events[eventKey], index2 = currentListeners.indexOf(listener);
  currentListeners.splice(index2, 1), currentListeners.length || (delete object2.events[eventKey], object2.events[eventKey + REVERT_MUTATION](), delete object2.events[eventKey + REVERT_MUTATION]);
}), STORE_UNMOUNT_DELAY = 1e3, onMount = ($store, initialize) => on($store, (payload) => {
  let destroy = initialize(payload);
  destroy && $store.events[UNMOUNT].push(destroy);
}, MOUNT, (runListeners) => {
  let originListen = $store.listen;
  $store.listen = (...args) => (!$store.lc && !$store.active && ($store.active = !0, runListeners()), originListen(...args));
  let originOff = $store.off;
  return $store.events[UNMOUNT] = [], $store.off = () => {
    originOff(), setTimeout(() => {
      if ($store.active && !$store.lc) {
        $store.active = !1;
        for (let destroy of $store.events[UNMOUNT]) destroy();
        $store.events[UNMOUNT] = [];
      }
    }, STORE_UNMOUNT_DELAY);
  }, () => {
    $store.listen = originListen, $store.off = originOff;
  };
});
function listenKeys($store, keys2, listener) {
  let keysSet = /* @__PURE__ */ new Set([...keys2, void 0]);
  return $store.listen((value, oldValue, changed) => {
    keysSet.has(changed) && listener(value, oldValue, changed);
  });
}
let emit = (snapshotRef, onChange) => (value) => {
  snapshotRef.current = value, onChange();
};
function useStore(store, { keys: keys2, deps = [store, keys2] } = {}) {
  let snapshotRef = useRef$1();
  snapshotRef.current = store.get();
  let subscribe = useCallback$1(
    (onChange) => keys2?.length > 0 ? listenKeys(store, keys2, emit(snapshotRef, onChange)) : store.listen(emit(snapshotRef, onChange)),
    deps
  ), get = () => snapshotRef.current;
  return useSyncExternalStore(subscribe, get, get);
}
const drawerOpenedAtom = atom(!1);
onMount(drawerOpenedAtom, () => {
  drawerOpenedAtom.set(!1);
});
const useDrawerOpened = () => useStore(drawerOpenedAtom), SidebarDrawerOps = {
  open: () => drawerOpenedAtom.set(!0),
  close: () => drawerOpenedAtom.set(!1)
};
function SidebarDrawer() {
  const opened = useDrawerOpened(), [grouping, setGrouping] = useLocalStorage({
    key: "sidebar-drawer-grouping",
    defaultValue: "by-files"
  });
  return /* @__PURE__ */ jsxs(
    Drawer.Root,
    {
      keepMounted: !0,
      opened,
      scrollAreaComponent: ScrollArea.Autosize,
      onClose: SidebarDrawerOps.close,
      children: [
        /* @__PURE__ */ jsx(Drawer.Overlay, { blur: 0.5 }),
        /* @__PURE__ */ jsxs(Drawer.Content, { children: [
          /* @__PURE__ */ jsxs(Drawer.Header, { children: [
            /* @__PURE__ */ jsxs(Group, { gap: "xs", children: [
              /* @__PURE__ */ jsx(
                Button,
                {
                  component: Link,
                  to: "/",
                  leftSection: /* @__PURE__ */ jsx(IconArrowLeft, { size: 14 }),
                  color: "dimmed",
                  variant: "subtle",
                  px: rem(5),
                  styles: {
                    section: {
                      marginInlineEnd: 4
                    }
                  },
                  size: "xs",
                  children: "Overview"
                }
              ),
              /* @__PURE__ */ jsx(
                SegmentedControl,
                {
                  size: "xs",
                  withItemsBorders: !1,
                  value: grouping,
                  onChange: setGrouping,
                  data: [
                    { label: "By files", value: "by-files" },
                    { label: "By folders", value: "by-folders" },
                    { label: "List", value: "none" }
                  ]
                }
              ),
              /* @__PURE__ */ jsx(
                Button,
                {
                  component: Link,
                  to: "/view/$viewId",
                  params: { viewId: "index" },
                  leftSection: /* @__PURE__ */ jsx(IconStarFilled, { size: 12, stroke: 2 }),
                  color: "dimmed",
                  variant: "subtle",
                  px: rem(5),
                  styles: {
                    section: {
                      marginInlineEnd: 4
                    }
                  },
                  size: "xs",
                  children: "Open index"
                }
              )
            ] }),
            /* @__PURE__ */ jsx(Drawer.CloseButton, {})
          ] }),
          /* @__PURE__ */ jsx(Drawer.Body, { children: /* @__PURE__ */ jsx(DiagramsTree, { groupBy: grouping }) })
        ] })
      ]
    }
  );
}
function ColorSchemeToggle() {
  const { setColorScheme } = useMantineColorScheme(), computedColorScheme = useComputedColorScheme("light", { getInitialValueInEffect: !0 });
  return /* @__PURE__ */ jsx(
    ActionIcon$1,
    {
      visibleFrom: "sm",
      size: "md",
      variant: "subtle",
      color: "gray",
      onClick: () => setColorScheme(computedColorScheme === "light" ? "dark" : "light"),
      "aria-label": "Toggle color scheme",
      children: computedColorScheme === "light" ? /* @__PURE__ */ jsx(IconMoonStars, { stroke: 1.5 }) : /* @__PURE__ */ jsx(IconSun, { stroke: 1.5 })
    }
  );
}
var cssHeader = "yr9aef0";
const AlertLocalhost = () => /* @__PURE__ */ jsx(
  Alert,
  {
    color: "yellow",
    icon: /* @__PURE__ */ jsx(IconAlertTriangle, {}),
    title: "Localhost URL",
    styles: { body: { gap: rem(4) } },
    children: /* @__PURE__ */ jsx(Text$6, { c: "yellow", size: "sm", children: "You need to deploy your project to make it available on the internet" })
  }
), CopyButtonChild = ({ copied, copy }) => /* @__PURE__ */ jsx(
  Button,
  {
    size: "xs",
    color: copied ? "teal" : "gray",
    variant: "light",
    leftSection: copied ? /* @__PURE__ */ jsx(IconCheck, { style: { width: rem(16) } }) : /* @__PURE__ */ jsx(IconCopy, { style: { width: rem(16) } }),
    onClick: copy,
    children: copied ? "Copied" : "Copy to clipboard"
  }
), EmbedPanel = ({ diagram }) => {
  const router = useRouter(), { colorScheme } = useMantineColorScheme(), [theme2, setTheme] = useState$1(colorScheme), padding = 20, url = new URL(
    router.buildLocation({
      to: "/embed/$viewId",
      params: { viewId: diagram.id },
      search: {
        padding,
        theme: theme2 !== "auto" ? theme2 : void 0
      }
    }).href,
    window.location.href
  ), width2 = diagram.bounds.width + padding * 2, height = diagram.bounds.height + padding * 2, href = url.href, code = `
<div style="aspect-ratio:${width2}/${height};width:100%;height:auto;max-width:${width2}px;margin:0 auto">
  <iframe src="${href}" width="100%" height="100%" style="border:0;background:transparent;"></iframe>
</div>
`.trim();
  return /* @__PURE__ */ jsxs(Stack$1, { children: [
    code.includes("http://localhost") && /* @__PURE__ */ jsx(AlertLocalhost, {}),
    /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(Text$6, { size: "sm", children: "Embedded view is an iframe with a static diagram" }) }),
    /* @__PURE__ */ jsxs(Stack$1, { gap: "xs", children: [
      /* @__PURE__ */ jsxs(Group, { justify: "space-between", children: [
        /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(Text$6, { fw: "500", size: "sm", children: "HTML" }) }),
        /* @__PURE__ */ jsxs(Group, { gap: "xs", children: [
          /* @__PURE__ */ jsx(ActionIcon$1, { component: "a", href, target: "_blank", variant: "light", color: "gray", children: /* @__PURE__ */ jsx(IconExternalLink, {}) }),
          /* @__PURE__ */ jsx(CopyButton$1, { value: code, timeout: 1500, children: CopyButtonChild })
        ] })
      ] }),
      /* @__PURE__ */ jsx(Code, { block: !0, children: code }),
      /* @__PURE__ */ jsx(
        Box,
        {
          style: {
            alignSelf: "flex-start"
          },
          children: /* @__PURE__ */ jsx(
            Select,
            {
              label: "Color scheme",
              value: theme2,
              allowDeselect: !1,
              onChange: (v) => setTheme(v ?? "auto"),
              data: [
                { value: "auto", label: "Auto" },
                { value: "light", label: "Light" },
                { value: "dark", label: "Dark" }
              ]
            }
          )
        }
      )
    ] })
  ] });
};
function WebcomponentsPanel({ diagram }) {
  const router = useRouter();
  let base = router.basepath.endsWith("/") ? router.basepath : `${router.basepath}/`;
  const jscode = `
  <script module src="${new URL(
    `${base}likec4-views.js`,
    window.location.href
  ).href}"><\/script>
`.trim(), htmlCode = `
  <${ComponentName.View} view-id="${encodeURIComponent(diagram.id)}"></${ComponentName.View}>
`.trim(), webcomponentPreview = router.buildLocation(
    {
      to: "/webcomponent/$",
      params: { _splat: diagram.id },
      search: !0
    }
  );
  return /* @__PURE__ */ jsxs(Stack$1, { children: [
    jscode.includes("http://localhost") && /* @__PURE__ */ jsx(AlertLocalhost, {}),
    /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(Text$6, { size: "sm", children: "Add this script to your page:" }) }),
    /* @__PURE__ */ jsxs(Stack$1, { gap: "xs", children: [
      /* @__PURE__ */ jsxs(Group, { justify: "space-between", children: [
        /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(Text$6, { fw: "500", size: "sm", children: "JavaScript" }) }),
        /* @__PURE__ */ jsxs(Group, { gap: "xs", children: [
          /* @__PURE__ */ jsx(ActionIcon$1, { component: "a", href: webcomponentPreview.href, target: "_blank", variant: "light", color: "gray", children: /* @__PURE__ */ jsx(IconExternalLink, {}) }),
          /* @__PURE__ */ jsx(
            CopyButton$1,
            {
              value: jscode,
              timeout: 1500,
              children: CopyButtonChild
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsx(Code, { block: !0, children: jscode }),
      /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsxs(Text$6, { size: "sm", c: "dimmed", children: [
        "This script defines a custom element (webcomponent) that renders your diagrams.",
        /* @__PURE__ */ jsx("br", {}),
        "Script must be inserted once in the ",
        /* @__PURE__ */ jsx("code", { children: "<head>" }),
        " or at the end of the ",
        /* @__PURE__ */ jsx("code", { children: "<body>" }),
        " ",
        "tag."
      ] }) })
    ] }),
    /* @__PURE__ */ jsxs(Stack$1, { gap: "xs", children: [
      /* @__PURE__ */ jsxs(Group, { justify: "space-between", children: [
        /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(Text$6, { fw: "500", size: "sm", children: "HTML" }) }),
        /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(
          CopyButton$1,
          {
            value: htmlCode,
            timeout: 1500,
            children: CopyButtonChild
          }
        ) })
      ] }),
      /* @__PURE__ */ jsx(Code, { block: !0, children: htmlCode }),
      /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsxs(Text$6, { size: "sm", c: "dimmed", children: [
        "Insert this code to your page. Page may have multiple ",
        /* @__PURE__ */ jsx("code", { children: "<likec4-view>" }),
        "."
      ] }) })
    ] })
  ] });
}
function ShareModal({
  opened,
  onClose,
  diagram
}) {
  const [activeTab, setActiveTab] = useState$1("webcomponent");
  return /* @__PURE__ */ jsxs(
    ModalRoot,
    {
      size: "xl",
      opened,
      keepMounted: !0,
      onClose,
      children: [
        /* @__PURE__ */ jsx(ModalOverlay, { backgroundOpacity: 0.5, blur: 3 }),
        /* @__PURE__ */ jsx(ModalContent, { children: /* @__PURE__ */ jsxs(ModalBody, { children: [
          /* @__PURE__ */ jsxs(Tabs, { value: activeTab, onChange: (tab) => setActiveTab(tab ?? "webcomponent"), children: [
            /* @__PURE__ */ jsxs(TabsList, { children: [
              /* @__PURE__ */ jsx(TabsTab, { value: "webcomponent", children: "Webcomponent" }),
              /* @__PURE__ */ jsx(TabsTab, { value: "embed", children: "Embedded" })
            ] }),
            /* @__PURE__ */ jsx(TabsPanel, { value: "embed", pt: "md", children: /* @__PURE__ */ jsx(EmbedPanel, { diagram }) }),
            /* @__PURE__ */ jsx(TabsPanel, { value: "webcomponent", pt: "md", children: /* @__PURE__ */ jsx(WebcomponentsPanel, { diagram }) })
          ] }),
          /* @__PURE__ */ jsx(Group, { justify: "flex-end", mt: "lg", children: /* @__PURE__ */ jsx(Button, { size: "sm", onClick: onClose, children: "Close" }) })
        ] }) })
      ]
    }
  );
}
function Header({ diagram }) {
  const isReactDiagramRoute = useRouterState().matches.some(
    ({ routeId }) => routeId === "/view/$viewId/" || routeId === "/view/$viewId/editor"
  ), { breakpoints } = useMantineTheme(), isTablet = useMediaQuery(`(min-width: ${breakpoints.md})`) ?? !1, [opened, { open, close }] = useDisclosure(!1);
  return /* @__PURE__ */ jsxs(
    Paper,
    {
      className: cssHeader,
      pos: "fixed",
      top: "0.5rem",
      right: "0.5rem",
      p: 4,
      radius: "sm",
      shadow: "lg",
      children: [
        /* @__PURE__ */ jsxs(Group, { gap: isTablet ? 6 : 4, wrap: "nowrap", children: [
          isReactDiagramRoute ? /* @__PURE__ */ jsxs(Fragment$1, { children: [
            /* @__PURE__ */ jsx(Button, { size: isTablet ? "sm" : "xs", leftSection: /* @__PURE__ */ jsx(IconShare, { size: 14 }), onClick: open, children: "Share" }),
            /* @__PURE__ */ jsx(ExportButton, {})
          ] }) : /* @__PURE__ */ jsx(
            Button,
            {
              component: Link,
              to: "/view/$viewId/",
              size: isTablet ? "sm" : "xs",
              variant: "subtle",
              color: "gray",
              children: "Back to diagram"
            }
          ),
          /* @__PURE__ */ jsx(Divider$1, { orientation: "vertical", visibleFrom: "md" }),
          /* @__PURE__ */ jsx(ColorSchemeToggle, {}),
          /* @__PURE__ */ jsx(Space, {})
        ] }),
        /* @__PURE__ */ jsx(
          ShareModal,
          {
            opened,
            onClose: close,
            diagram
          }
        )
      ]
    }
  );
}
function ExportButton() {
  const params = useParams({
    from: "/view/$viewId"
  }), previewUrl = usePreviewUrl(params.viewId);
  return /* @__PURE__ */ jsxs(Menu, { shadow: "md", width: 200, trigger: "click-hover", openDelay: 200, children: [
    /* @__PURE__ */ jsx(MenuTarget, { children: /* @__PURE__ */ jsx(
      Button,
      {
        variant: "subtle",
        size: "sm",
        color: "gray",
        px: "sm",
        rightSection: /* @__PURE__ */ jsx(IconChevronDown, { opacity: 0.5, size: 14 }),
        visibleFrom: "md",
        children: "Export"
      }
    ) }),
    /* @__PURE__ */ jsxs(MenuDropdown, { children: [
      /* @__PURE__ */ jsx(MenuLabel, { children: "Current view" }),
      previewUrl ? /* @__PURE__ */ jsx(
        MenuItem,
        {
          component: "a",
          href: previewUrl,
          download: `${params.viewId}.png`,
          target: "_blank",
          children: "Export as .png"
        }
      ) : /* @__PURE__ */ jsx(
        MenuItem,
        {
          component: Link,
          to: "/export/$viewId",
          target: "_blank",
          search: {
            download: !0
          },
          params,
          children: "Export as .png"
        }
      ),
      /* @__PURE__ */ jsx(MenuItem, { component: Link, to: "/view/$viewId/dot", search: !0, params, children: "Export as .dot" }),
      /* @__PURE__ */ jsx(MenuItem, { component: Link, to: "/view/$viewId/d2", search: !0, params, children: "Export as .d2" }),
      /* @__PURE__ */ jsx(MenuItem, { component: Link, to: "/view/$viewId/mmd", search: !0, params, children: "Export as .mmd" }),
      /* @__PURE__ */ jsx(MenuItem, { disabled: !0, children: "Export to Draw.io" }),
      /* @__PURE__ */ jsx(MenuItem, { disabled: !0, children: "Export to Miro" }),
      /* @__PURE__ */ jsx(MenuItem, { disabled: !0, children: "Export to Notion" })
    ] })
  ] });
}
const Route$7 = createFileRoute("/view/$viewId")({
  component: ViewLayout
});
function Fallback({ error, resetErrorBoundary }) {
  const router = useRouter(), { viewId } = Route$7.useParams();
  return useUpdateEffect(() => {
    resetErrorBoundary();
  }, [viewId]), isNotFound(error) ? /* @__PURE__ */ jsx(Container, { my: "md", children: /* @__PURE__ */ jsxs(Alert, { variant: "light", color: "orange", children: [
    /* @__PURE__ */ jsxs(Text$6, { c: "orange", fz: "md", children: [
      "The diagram",
      " ",
      /* @__PURE__ */ jsx(Code, { color: "orange", children: viewId }),
      " ",
      "does not exist or contains errors"
    ] }),
    /* @__PURE__ */ jsx(
      Button,
      {
        onClick: () => {
          resetErrorBoundary(), router.navigate({
            to: "/",
            search: !0
          });
        },
        variant: "light",
        color: "orange",
        mt: "lg",
        size: "xs",
        children: "Go to overview"
      }
    )
  ] }) }) : /* @__PURE__ */ jsx(Container, { my: "md", children: /* @__PURE__ */ jsxs(Alert, { variant: "filled", color: "red", title: "Something went wrong", children: [
    /* @__PURE__ */ jsx(Code, { block: !0, color: "red", children: error.stack ?? error.message }),
    /* @__PURE__ */ jsx(Button, { onClick: resetErrorBoundary, color: "red", variant: "white", mt: "lg", size: "xs", children: "Try again" })
  ] }) });
}
function ViewLayout() {
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(Box, { className: cssViewOutlet, children: /* @__PURE__ */ jsx(ErrorBoundary, { FallbackComponent: Fallback, children: /* @__PURE__ */ jsx(Outlet, {}) }) }),
    /* @__PURE__ */ jsx(ViewHeader, {}),
    !withOverviewGraph && /* @__PURE__ */ jsx(SidebarDrawer, {})
  ] });
}
function ViewHeader() {
  const view = useLikeC4DiagramView(Route$7.useParams().viewId);
  return view ? /* @__PURE__ */ jsx(Header, { diagram: view }) : null;
}
function useTransparentBackground(enabled = !0) {
  useIsomorphicLayoutEffect$1(() => {
    const htmlEl = document.body.parentElement;
    if (!htmlEl || enabled !== !0) return;
    const classname = "transparent-bg";
    return htmlEl.classList.add(classname), () => {
      htmlEl.classList.remove(classname);
    };
  }, [enabled]);
}
async function downloadAsPng({
  pngFilename,
  viewport
}) {
  const { toBlob } = await import("./index-CIsxIzOH.js"), {
    width: width2,
    height
  } = viewport.getBoundingClientRect();
  try {
    const blob = await toBlob(viewport, {
      backgroundColor: "transparent",
      width: width2,
      height,
      cacheBust: !0,
      imagePlaceholder: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="
    });
    if (!blob)
      throw new Error("Failed to create PNG blob");
    var url = URL.createObjectURL(blob), link = document.createElement("a");
    link.setAttribute("download", `${pngFilename}.png`), link.href = url, document.body.appendChild(link), link.click(), await new Promise((resolve) => setTimeout(resolve, 1e3)), document.body.removeChild(link), URL.revokeObjectURL(url), window.close();
  } catch (err) {
    console.error(err), window.alert("Failed to export to PNG, check the console for more details.");
  }
}
const asBoolean = (v) => {
  if (typeof v == "boolean")
    return v;
  if (typeof v == "string")
    return v === "true";
}, Route$6 = createFileRoute("/export/$viewId")({
  component: ExportPage,
  validateSearch: (search) => ({
    download: asBoolean(search.download)
  })
});
function ExportPage() {
  const {
    padding = 20,
    download = !1
  } = Route$6.useSearch(), { viewId } = Route$6.useParams(), diagram = useLikeC4DiagramView(viewId), viewportRef = useRef$1(null), loadingOverlayRef = useRef$1(null), downloadedRef = useRef$1(!1);
  if (useTransparentBackground(), useEffect$1(() => {
    document.querySelectorAll(".react-flow__viewport").forEach((el) => {
      el.style.transform = "";
    });
  }), useDebouncedEffect(
    () => {
      const viewport = viewportRef.current;
      if (!download || !viewport || !diagram)
        return;
      const loadingOverlay = loadingOverlayRef.current;
      loadingOverlay && (loadingOverlay.style.display = "none"), !downloadedRef.current && (downloadedRef.current = !0, downloadAsPng({
        pngFilename: viewId,
        viewport
      }));
    },
    [],
    500
  ), !diagram)
    throw notFound();
  const width2 = diagram.bounds.width + padding * 2, height = diagram.bounds.height + padding * 2;
  return /* @__PURE__ */ jsxs(
    Box,
    {
      ref: viewportRef,
      className: cssExportView,
      role: "presentation",
      style: {
        padding,
        minWidth: width2,
        width: width2,
        minHeight: height,
        height
      },
      children: [
        download && /* @__PURE__ */ jsx(LoadingOverlay, { ref: loadingOverlayRef, visible: !0 }),
        /* @__PURE__ */ jsx(
          LikeC4Diagram,
          {
            view: diagram,
            readonly: !0,
            fitView: !1,
            fitViewPadding: 0,
            pannable: !1,
            zoomable: !1,
            controls: !1,
            background: "transparent",
            enableDynamicViewWalkthrough: !1,
            enableElementDetails: !1,
            enableRelationshipBrowser: !1,
            showNavigationButtons: !1,
            enableRelationshipDetails: !1,
            showDiagramTitle: !1,
            showNotations: !1,
            nodesSelectable: !1,
            nodesDraggable: !1,
            enableFocusMode: !1,
            enableSearch: !1,
            renderIcon: RenderIcon,
            initialWidth: diagram.bounds.width,
            initialHeight: diagram.bounds.height
          }
        )
      ]
    }
  );
}
const Route$5 = createFileRoute("/embed/$viewId")({
  component: EmbedPage
});
function EmbedPage() {
  const { padding = 20 } = Route$5.useSearch(), { viewId } = Route$5.useParams(), diagram = useLikeC4DiagramView(viewId);
  if (useTransparentBackground(!!diagram), !diagram)
    throw notFound();
  return /* @__PURE__ */ jsx(
    Box,
    {
      pos: "absolute",
      style: {
        top: 0,
        left: "50%",
        boxSizing: "border-box",
        padding,
        transform: "translateX(-50%)",
        aspectRatio: `${diagram.bounds.width + padding * 2} / ${diagram.bounds.height + padding * 2}`,
        width: "100vw",
        maxWidth: diagram.bounds.width + padding * 2,
        height: "auto",
        maxHeight: "100vh"
      },
      children: /* @__PURE__ */ jsx(
        LikeC4Diagram,
        {
          view: diagram,
          readonly: !0,
          fitView: !0,
          fitViewPadding: 0,
          pannable: !1,
          zoomable: !1,
          controls: !1,
          background: "transparent",
          enableDynamicViewWalkthrough: !1,
          showNavigationButtons: !1,
          enableRelationshipDetails: !1,
          showDiagramTitle: !1,
          showNotations: !1,
          nodesSelectable: !1,
          nodesDraggable: !1,
          enableFocusMode: !1,
          enableElementDetails: !1,
          enableRelationshipBrowser: !1,
          experimentalEdgeEditing: !1,
          keepAspectRatio: !1,
          renderIcon: RenderIcon,
          initialWidth: diagram.bounds.width,
          initialHeight: diagram.bounds.height
        }
      )
    }
  );
}
const Route$4 = createFileRoute("/view/$viewId/")({
  component: ViewReact
});
function ViewReact() {
  const router = useRouter(), { viewId } = Route$4.useParams(), view = useLikeC4DiagramView(viewId), onNavigateTo = useCallbackRef((viewId2) => {
    router.navigate({
      to: "/view/$viewId",
      params: { viewId: viewId2 },
      search: !0
    });
  });
  if (!view)
    throw notFound();
  const hasNotations = (view.notation?.elements ?? []).length > 0;
  return /* @__PURE__ */ jsx(
    LikeC4Diagram,
    {
      view,
      readonly: !0,
      zoomable: !0,
      pannable: !0,
      controls: !0,
      fitViewPadding: 0.1,
      showDiagramTitle: !0,
      showNavigationButtons: !0,
      enableFocusMode: !0,
      enableDynamicViewWalkthrough: !0,
      enableElementDetails: !0,
      enableRelationshipDetails: !0,
      enableRelationshipBrowser: !0,
      experimentalEdgeEditing: !1,
      showNotations: isDevelopment || hasNotations,
      nodesDraggable: !1,
      nodesSelectable: !1,
      renderIcon: RenderIcon,
      onNavigateTo,
      onBurgerMenuClick: withOverviewGraph ? () => {
        router.navigate({
          to: "/",
          search: !0
        });
      } : SidebarDrawerOps.open
    }
  );
}
const {
  createElement,
  createContext,
  createRef,
  forwardRef,
  useCallback,
  useContext,
  useEffect,
  useImperativeHandle,
  useLayoutEffect,
  useMemo,
  useRef,
  useState
} = React, useId = React[`useId${Math.random()}`.slice(0, 5)], useLayoutEffect_do_not_use_directly = useLayoutEffect, PanelGroupContext = createContext(null);
PanelGroupContext.displayName = "PanelGroupContext";
const useIsomorphicLayoutEffect = useLayoutEffect_do_not_use_directly, wrappedUseId = typeof useId == "function" ? useId : () => null;
let counter = 0;
function useUniqueId(idFromParams = null) {
  const idFromUseId = wrappedUseId(), idRef = useRef(idFromParams || idFromUseId || null);
  return idRef.current === null && (idRef.current = "" + counter++), idFromParams ?? idRef.current;
}
function PanelWithForwardedRef({
  children,
  className: classNameFromProps = "",
  collapsedSize,
  collapsible,
  defaultSize,
  forwardedRef,
  id: idFromProps,
  maxSize,
  minSize,
  onCollapse,
  onExpand,
  onResize,
  order: order2,
  style: styleFromProps,
  tagName: Type = "div",
  ...rest
}) {
  const context = useContext(PanelGroupContext);
  if (context === null)
    throw Error("Panel components must be rendered within a PanelGroup container");
  const {
    collapsePanel,
    expandPanel,
    getPanelSize,
    getPanelStyle,
    groupId,
    isPanelCollapsed,
    reevaluatePanelConstraints,
    registerPanel,
    resizePanel: resizePanel2,
    unregisterPanel
  } = context, panelId = useUniqueId(idFromProps), panelDataRef = useRef({
    callbacks: {
      onCollapse,
      onExpand,
      onResize
    },
    constraints: {
      collapsedSize,
      collapsible,
      defaultSize,
      maxSize,
      minSize
    },
    id: panelId,
    idIsFromProps: idFromProps !== void 0,
    order: order2
  });
  useRef({
    didLogMissingDefaultSizeWarning: !1
  }), useIsomorphicLayoutEffect(() => {
    const {
      callbacks,
      constraints
    } = panelDataRef.current, prevConstraints = {
      ...constraints
    };
    panelDataRef.current.id = panelId, panelDataRef.current.idIsFromProps = idFromProps !== void 0, panelDataRef.current.order = order2, callbacks.onCollapse = onCollapse, callbacks.onExpand = onExpand, callbacks.onResize = onResize, constraints.collapsedSize = collapsedSize, constraints.collapsible = collapsible, constraints.defaultSize = defaultSize, constraints.maxSize = maxSize, constraints.minSize = minSize, (prevConstraints.collapsedSize !== constraints.collapsedSize || prevConstraints.collapsible !== constraints.collapsible || prevConstraints.maxSize !== constraints.maxSize || prevConstraints.minSize !== constraints.minSize) && reevaluatePanelConstraints(panelDataRef.current, prevConstraints);
  }), useIsomorphicLayoutEffect(() => {
    const panelData = panelDataRef.current;
    return registerPanel(panelData), () => {
      unregisterPanel(panelData);
    };
  }, [order2, panelId, registerPanel, unregisterPanel]), useImperativeHandle(forwardedRef, () => ({
    collapse: () => {
      collapsePanel(panelDataRef.current);
    },
    expand: (minSize2) => {
      expandPanel(panelDataRef.current, minSize2);
    },
    getId() {
      return panelId;
    },
    getSize() {
      return getPanelSize(panelDataRef.current);
    },
    isCollapsed() {
      return isPanelCollapsed(panelDataRef.current);
    },
    isExpanded() {
      return !isPanelCollapsed(panelDataRef.current);
    },
    resize: (size) => {
      resizePanel2(panelDataRef.current, size);
    }
  }), [collapsePanel, expandPanel, getPanelSize, isPanelCollapsed, panelId, resizePanel2]);
  const style = getPanelStyle(panelDataRef.current, defaultSize);
  return createElement(Type, {
    ...rest,
    children,
    className: classNameFromProps,
    id: idFromProps,
    style: {
      ...style,
      ...styleFromProps
    },
    // CSS selectors
    "data-panel": "",
    "data-panel-collapsible": collapsible || void 0,
    "data-panel-group-id": groupId,
    "data-panel-id": panelId,
    "data-panel-size": parseFloat("" + style.flexGrow).toFixed(1)
  });
}
const Panel = forwardRef((props2, ref) => createElement(PanelWithForwardedRef, {
  ...props2,
  forwardedRef: ref
}));
PanelWithForwardedRef.displayName = "Panel";
Panel.displayName = "forwardRef(Panel)";
let currentCursorStyle = null, styleElement = null;
function getCursorStyle(state, constraintFlags) {
  if (constraintFlags) {
    const horizontalMin = (constraintFlags & EXCEEDED_HORIZONTAL_MIN) !== 0, horizontalMax = (constraintFlags & EXCEEDED_HORIZONTAL_MAX) !== 0, verticalMin = (constraintFlags & EXCEEDED_VERTICAL_MIN) !== 0, verticalMax = (constraintFlags & EXCEEDED_VERTICAL_MAX) !== 0;
    if (horizontalMin)
      return verticalMin ? "se-resize" : verticalMax ? "ne-resize" : "e-resize";
    if (horizontalMax)
      return verticalMin ? "sw-resize" : verticalMax ? "nw-resize" : "w-resize";
    if (verticalMin)
      return "s-resize";
    if (verticalMax)
      return "n-resize";
  }
  switch (state) {
    case "horizontal":
      return "ew-resize";
    case "intersection":
      return "move";
    case "vertical":
      return "ns-resize";
  }
}
function resetGlobalCursorStyle() {
  styleElement !== null && (document.head.removeChild(styleElement), currentCursorStyle = null, styleElement = null);
}
function setGlobalCursorStyle(state, constraintFlags) {
  const style = getCursorStyle(state, constraintFlags);
  currentCursorStyle !== style && (currentCursorStyle = style, styleElement === null && (styleElement = document.createElement("style"), document.head.appendChild(styleElement)), styleElement.innerHTML = `*{cursor: ${style}!important;}`);
}
function isKeyDown(event) {
  return event.type === "keydown";
}
function isPointerEvent(event) {
  return event.type.startsWith("pointer");
}
function isMouseEvent(event) {
  return event.type.startsWith("mouse");
}
function getResizeEventCoordinates(event) {
  if (isPointerEvent(event)) {
    if (event.isPrimary)
      return {
        x: event.clientX,
        y: event.clientY
      };
  } else if (isMouseEvent(event))
    return {
      x: event.clientX,
      y: event.clientY
    };
  return {
    x: 1 / 0,
    y: 1 / 0
  };
}
function getInputType() {
  if (typeof matchMedia == "function")
    return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
}
function intersects(rectOne, rectTwo, strict) {
  return rectOne.x < rectTwo.x + rectTwo.width && rectOne.x + rectOne.width > rectTwo.x && rectOne.y < rectTwo.y + rectTwo.height && rectOne.y + rectOne.height > rectTwo.y;
}
function compare(a2, b2) {
  if (a2 === b2) throw new Error("Cannot compare node with itself");
  const ancestors = {
    a: get_ancestors(a2),
    b: get_ancestors(b2)
  };
  let common_ancestor;
  for (; ancestors.a.at(-1) === ancestors.b.at(-1); )
    a2 = ancestors.a.pop(), b2 = ancestors.b.pop(), common_ancestor = a2;
  assert(common_ancestor, "Stacking order can only be calculated for elements with a common ancestor");
  const z_indexes = {
    a: get_z_index(find_stacking_context(ancestors.a)),
    b: get_z_index(find_stacking_context(ancestors.b))
  };
  if (z_indexes.a === z_indexes.b) {
    const children = common_ancestor.childNodes, furthest_ancestors = {
      a: ancestors.a.at(-1),
      b: ancestors.b.at(-1)
    };
    let i2 = children.length;
    for (; i2--; ) {
      const child = children[i2];
      if (child === furthest_ancestors.a) return 1;
      if (child === furthest_ancestors.b) return -1;
    }
  }
  return Math.sign(z_indexes.a - z_indexes.b);
}
const props = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function is_flex_item(node2) {
  var _get_parent;
  const display = getComputedStyle((_get_parent = get_parent(node2)) !== null && _get_parent !== void 0 ? _get_parent : node2).display;
  return display === "flex" || display === "inline-flex";
}
function creates_stacking_context(node2) {
  const style = getComputedStyle(node2);
  return !!(style.position === "fixed" || style.zIndex !== "auto" && (style.position !== "static" || is_flex_item(node2)) || +style.opacity < 1 || "transform" in style && style.transform !== "none" || "webkitTransform" in style && style.webkitTransform !== "none" || "mixBlendMode" in style && style.mixBlendMode !== "normal" || "filter" in style && style.filter !== "none" || "webkitFilter" in style && style.webkitFilter !== "none" || "isolation" in style && style.isolation === "isolate" || props.test(style.willChange) || style.webkitOverflowScrolling === "touch");
}
function find_stacking_context(nodes) {
  let i2 = nodes.length;
  for (; i2--; ) {
    const node2 = nodes[i2];
    if (assert(node2, "Missing node"), creates_stacking_context(node2)) return node2;
  }
  return null;
}
function get_z_index(node2) {
  return node2 && Number(getComputedStyle(node2).zIndex) || 0;
}
function get_ancestors(node2) {
  const ancestors = [];
  for (; node2; )
    ancestors.push(node2), node2 = get_parent(node2);
  return ancestors;
}
function get_parent(node2) {
  const {
    parentNode
  } = node2;
  return parentNode && parentNode instanceof ShadowRoot ? parentNode.host : parentNode;
}
const EXCEEDED_HORIZONTAL_MIN = 1, EXCEEDED_HORIZONTAL_MAX = 2, EXCEEDED_VERTICAL_MIN = 4, EXCEEDED_VERTICAL_MAX = 8, isCoarsePointer = getInputType() === "coarse";
let intersectingHandles = [], isPointerDown = !1, ownerDocumentCounts = /* @__PURE__ */ new Map(), panelConstraintFlags = /* @__PURE__ */ new Map();
const registeredResizeHandlers = /* @__PURE__ */ new Set();
function registerResizeHandle(resizeHandleId, element, direction, hitAreaMargins, setResizeHandlerState) {
  var _ownerDocumentCounts$;
  const {
    ownerDocument
  } = element, data = {
    direction,
    element,
    hitAreaMargins,
    setResizeHandlerState
  }, count = (_ownerDocumentCounts$ = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$ !== void 0 ? _ownerDocumentCounts$ : 0;
  return ownerDocumentCounts.set(ownerDocument, count + 1), registeredResizeHandlers.add(data), updateListeners(), function() {
    var _ownerDocumentCounts$2;
    panelConstraintFlags.delete(resizeHandleId), registeredResizeHandlers.delete(data);
    const count2 = (_ownerDocumentCounts$2 = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$2 !== void 0 ? _ownerDocumentCounts$2 : 1;
    if (ownerDocumentCounts.set(ownerDocument, count2 - 1), updateListeners(), count2 === 1 && ownerDocumentCounts.delete(ownerDocument), intersectingHandles.includes(data)) {
      const index2 = intersectingHandles.indexOf(data);
      index2 >= 0 && intersectingHandles.splice(index2, 1), updateCursor(), setResizeHandlerState("up", !0, null);
    }
  };
}
function handlePointerDown(event) {
  const {
    target
  } = event, {
    x: x2,
    y: y2
  } = getResizeEventCoordinates(event);
  isPointerDown = !0, recalculateIntersectingHandles({
    target,
    x: x2,
    y: y2
  }), updateListeners(), intersectingHandles.length > 0 && (updateResizeHandlerStates("down", event), event.preventDefault(), event.stopPropagation());
}
function handlePointerMove(event) {
  const {
    x: x2,
    y: y2
  } = getResizeEventCoordinates(event);
  if (isPointerDown && event.buttons === 0 && (isPointerDown = !1, updateResizeHandlerStates("up", event)), !isPointerDown) {
    const {
      target
    } = event;
    recalculateIntersectingHandles({
      target,
      x: x2,
      y: y2
    });
  }
  updateResizeHandlerStates("move", event), updateCursor(), intersectingHandles.length > 0 && event.preventDefault();
}
function handlePointerUp(event) {
  const {
    target
  } = event, {
    x: x2,
    y: y2
  } = getResizeEventCoordinates(event);
  panelConstraintFlags.clear(), isPointerDown = !1, intersectingHandles.length > 0 && event.preventDefault(), updateResizeHandlerStates("up", event), recalculateIntersectingHandles({
    target,
    x: x2,
    y: y2
  }), updateCursor(), updateListeners();
}
function recalculateIntersectingHandles({
  target,
  x: x2,
  y: y2
}) {
  intersectingHandles.splice(0);
  let targetElement = null;
  (target instanceof HTMLElement || target instanceof SVGElement) && (targetElement = target), registeredResizeHandlers.forEach((data) => {
    const {
      element: dragHandleElement,
      hitAreaMargins
    } = data, dragHandleRect = dragHandleElement.getBoundingClientRect(), {
      bottom,
      left,
      right,
      top
    } = dragHandleRect, margin = isCoarsePointer ? hitAreaMargins.coarse : hitAreaMargins.fine;
    if (x2 >= left - margin && x2 <= right + margin && y2 >= top - margin && y2 <= bottom + margin) {
      if (targetElement !== null && document.contains(targetElement) && dragHandleElement !== targetElement && !dragHandleElement.contains(targetElement) && !targetElement.contains(dragHandleElement) && // Calculating stacking order has a cost, so we should avoid it if possible
      // That is why we only check potentially intersecting handles,
      // and why we skip if the event target is within the handle's DOM
      compare(targetElement, dragHandleElement) > 0) {
        let currentElement = targetElement, didIntersect = !1;
        for (; currentElement && !currentElement.contains(dragHandleElement); ) {
          if (intersects(currentElement.getBoundingClientRect(), dragHandleRect)) {
            didIntersect = !0;
            break;
          }
          currentElement = currentElement.parentElement;
        }
        if (didIntersect)
          return;
      }
      intersectingHandles.push(data);
    }
  });
}
function reportConstraintsViolation(resizeHandleId, flag) {
  panelConstraintFlags.set(resizeHandleId, flag);
}
function updateCursor() {
  let intersectsHorizontal = !1, intersectsVertical = !1;
  intersectingHandles.forEach((data) => {
    const {
      direction
    } = data;
    direction === "horizontal" ? intersectsHorizontal = !0 : intersectsVertical = !0;
  });
  let constraintFlags = 0;
  panelConstraintFlags.forEach((flag) => {
    constraintFlags |= flag;
  }), intersectsHorizontal && intersectsVertical ? setGlobalCursorStyle("intersection", constraintFlags) : intersectsHorizontal ? setGlobalCursorStyle("horizontal", constraintFlags) : intersectsVertical ? setGlobalCursorStyle("vertical", constraintFlags) : resetGlobalCursorStyle();
}
function updateListeners() {
  ownerDocumentCounts.forEach((_, ownerDocument) => {
    const {
      body
    } = ownerDocument;
    body.removeEventListener("contextmenu", handlePointerUp), body.removeEventListener("pointerdown", handlePointerDown), body.removeEventListener("pointerleave", handlePointerMove), body.removeEventListener("pointermove", handlePointerMove);
  }), window.removeEventListener("pointerup", handlePointerUp), window.removeEventListener("pointercancel", handlePointerUp), registeredResizeHandlers.size > 0 && (isPointerDown ? (intersectingHandles.length > 0 && ownerDocumentCounts.forEach((count, ownerDocument) => {
    const {
      body
    } = ownerDocument;
    count > 0 && (body.addEventListener("contextmenu", handlePointerUp), body.addEventListener("pointerleave", handlePointerMove), body.addEventListener("pointermove", handlePointerMove));
  }), window.addEventListener("pointerup", handlePointerUp), window.addEventListener("pointercancel", handlePointerUp)) : ownerDocumentCounts.forEach((count, ownerDocument) => {
    const {
      body
    } = ownerDocument;
    count > 0 && (body.addEventListener("pointerdown", handlePointerDown, {
      capture: !0
    }), body.addEventListener("pointermove", handlePointerMove));
  }));
}
function updateResizeHandlerStates(action, event) {
  registeredResizeHandlers.forEach((data) => {
    const {
      setResizeHandlerState
    } = data, isActive = intersectingHandles.includes(data);
    setResizeHandlerState(action, isActive, event);
  });
}
function useForceUpdate() {
  const [_, setCount] = useState(0);
  return useCallback(() => setCount((prevCount) => prevCount + 1), []);
}
function assert(expectedCondition, message) {
  if (!expectedCondition)
    throw console.error(message), Error(message);
}
const PRECISION = 10;
function fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {
  return actual.toFixed(fractionDigits) === expected.toFixed(fractionDigits) ? 0 : actual > expected ? 1 : -1;
}
function fuzzyNumbersEqual$1(actual, expected, fractionDigits = PRECISION) {
  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;
}
function fuzzyNumbersEqual(actual, expected, fractionDigits) {
  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;
}
function fuzzyLayoutsEqual(actual, expected, fractionDigits) {
  if (actual.length !== expected.length)
    return !1;
  for (let index2 = 0; index2 < actual.length; index2++) {
    const actualSize = actual[index2], expectedSize = expected[index2];
    if (!fuzzyNumbersEqual(actualSize, expectedSize, fractionDigits))
      return !1;
  }
  return !0;
}
function resizePanel({
  panelConstraints: panelConstraintsArray,
  panelIndex,
  size
}) {
  const panelConstraints = panelConstraintsArray[panelIndex];
  assert(panelConstraints != null, `Panel constraints not found for index ${panelIndex}`);
  let {
    collapsedSize = 0,
    collapsible,
    maxSize = 100,
    minSize = 0
  } = panelConstraints;
  if (fuzzyCompareNumbers(size, minSize) < 0)
    if (collapsible) {
      const halfwayPoint = (collapsedSize + minSize) / 2;
      fuzzyCompareNumbers(size, halfwayPoint) < 0 ? size = collapsedSize : size = minSize;
    } else
      size = minSize;
  return size = Math.min(maxSize, size), size = parseFloat(size.toFixed(PRECISION)), size;
}
function adjustLayoutByDelta({
  delta,
  initialLayout,
  panelConstraints: panelConstraintsArray,
  pivotIndices,
  prevLayout,
  trigger
}) {
  if (fuzzyNumbersEqual(delta, 0))
    return initialLayout;
  const nextLayout = [...initialLayout], [firstPivotIndex, secondPivotIndex] = pivotIndices;
  assert(firstPivotIndex != null, "Invalid first pivot index"), assert(secondPivotIndex != null, "Invalid second pivot index");
  let deltaApplied = 0;
  if (trigger === "keyboard") {
    {
      const index2 = delta < 0 ? secondPivotIndex : firstPivotIndex, panelConstraints = panelConstraintsArray[index2];
      assert(panelConstraints, `Panel constraints not found for index ${index2}`);
      const {
        collapsedSize = 0,
        collapsible,
        minSize = 0
      } = panelConstraints;
      if (collapsible) {
        const prevSize = initialLayout[index2];
        if (assert(prevSize != null, `Previous layout not found for panel index ${index2}`), fuzzyNumbersEqual(prevSize, collapsedSize)) {
          const localDelta = minSize - prevSize;
          fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0 && (delta = delta < 0 ? 0 - localDelta : localDelta);
        }
      }
    }
    {
      const index2 = delta < 0 ? firstPivotIndex : secondPivotIndex, panelConstraints = panelConstraintsArray[index2];
      assert(panelConstraints, `No panel constraints found for index ${index2}`);
      const {
        collapsedSize = 0,
        collapsible,
        minSize = 0
      } = panelConstraints;
      if (collapsible) {
        const prevSize = initialLayout[index2];
        if (assert(prevSize != null, `Previous layout not found for panel index ${index2}`), fuzzyNumbersEqual(prevSize, minSize)) {
          const localDelta = prevSize - collapsedSize;
          fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0 && (delta = delta < 0 ? 0 - localDelta : localDelta);
        }
      }
    }
  }
  {
    const increment = delta < 0 ? 1 : -1;
    let index2 = delta < 0 ? secondPivotIndex : firstPivotIndex, maxAvailableDelta = 0;
    for (; ; ) {
      const prevSize = initialLayout[index2];
      assert(prevSize != null, `Previous layout not found for panel index ${index2}`);
      const delta2 = resizePanel({
        panelConstraints: panelConstraintsArray,
        panelIndex: index2,
        size: 100
      }) - prevSize;
      if (maxAvailableDelta += delta2, index2 += increment, index2 < 0 || index2 >= panelConstraintsArray.length)
        break;
    }
    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));
    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;
  }
  {
    let index2 = delta < 0 ? firstPivotIndex : secondPivotIndex;
    for (; index2 >= 0 && index2 < panelConstraintsArray.length; ) {
      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied), prevSize = initialLayout[index2];
      assert(prevSize != null, `Previous layout not found for panel index ${index2}`);
      const unsafeSize = prevSize - deltaRemaining, safeSize = resizePanel({
        panelConstraints: panelConstraintsArray,
        panelIndex: index2,
        size: unsafeSize
      });
      if (!fuzzyNumbersEqual(prevSize, safeSize) && (deltaApplied += prevSize - safeSize, nextLayout[index2] = safeSize, deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), void 0, {
        numeric: !0
      }) >= 0))
        break;
      delta < 0 ? index2-- : index2++;
    }
  }
  if (fuzzyLayoutsEqual(prevLayout, nextLayout))
    return prevLayout;
  {
    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex, prevSize = initialLayout[pivotIndex];
    assert(prevSize != null, `Previous layout not found for panel index ${pivotIndex}`);
    const unsafeSize = prevSize + deltaApplied, safeSize = resizePanel({
      panelConstraints: panelConstraintsArray,
      panelIndex: pivotIndex,
      size: unsafeSize
    });
    if (nextLayout[pivotIndex] = safeSize, !fuzzyNumbersEqual(safeSize, unsafeSize)) {
      let deltaRemaining = unsafeSize - safeSize, index2 = delta < 0 ? secondPivotIndex : firstPivotIndex;
      for (; index2 >= 0 && index2 < panelConstraintsArray.length; ) {
        const prevSize2 = nextLayout[index2];
        assert(prevSize2 != null, `Previous layout not found for panel index ${index2}`);
        const unsafeSize2 = prevSize2 + deltaRemaining, safeSize2 = resizePanel({
          panelConstraints: panelConstraintsArray,
          panelIndex: index2,
          size: unsafeSize2
        });
        if (fuzzyNumbersEqual(prevSize2, safeSize2) || (deltaRemaining -= safeSize2 - prevSize2, nextLayout[index2] = safeSize2), fuzzyNumbersEqual(deltaRemaining, 0))
          break;
        delta > 0 ? index2-- : index2++;
      }
    }
  }
  const totalSize = nextLayout.reduce((total, size) => size + total, 0);
  return fuzzyNumbersEqual(totalSize, 100) ? nextLayout : prevLayout;
}
function calculateAriaValues({
  layout: layout2,
  panelsArray,
  pivotIndices
}) {
  let currentMinSize = 0, currentMaxSize = 100, totalMinSize = 0, totalMaxSize = 0;
  const firstIndex = pivotIndices[0];
  assert(firstIndex != null, "No pivot index found"), panelsArray.forEach((panelData, index2) => {
    const {
      constraints
    } = panelData, {
      maxSize = 100,
      minSize = 0
    } = constraints;
    index2 === firstIndex ? (currentMinSize = minSize, currentMaxSize = maxSize) : (totalMinSize += minSize, totalMaxSize += maxSize);
  });
  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize), valueMin = Math.max(currentMinSize, 100 - totalMaxSize), valueNow = layout2[firstIndex];
  return {
    valueMax,
    valueMin,
    valueNow
  };
}
function getResizeHandleElementsForGroup(groupId, scope = document) {
  return Array.from(scope.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id="${groupId}"]`));
}
function getResizeHandleElementIndex(groupId, id2, scope = document) {
  const index2 = getResizeHandleElementsForGroup(groupId, scope).findIndex((handle) => handle.getAttribute("data-panel-resize-handle-id") === id2);
  return index2 ?? null;
}
function determinePivotIndices(groupId, dragHandleId, panelGroupElement) {
  const index2 = getResizeHandleElementIndex(groupId, dragHandleId, panelGroupElement);
  return index2 != null ? [index2, index2 + 1] : [-1, -1];
}
function getPanelGroupElement(id2, rootElement = document) {
  var _dataset;
  if (rootElement instanceof HTMLElement && (rootElement == null || (_dataset = rootElement.dataset) === null || _dataset === void 0 ? void 0 : _dataset.panelGroupId) == id2)
    return rootElement;
  const element = rootElement.querySelector(`[data-panel-group][data-panel-group-id="${id2}"]`);
  return element || null;
}
function getResizeHandleElement(id2, scope = document) {
  const element = scope.querySelector(`[data-panel-resize-handle-id="${id2}"]`);
  return element || null;
}
function getResizeHandlePanelIds(groupId, handleId, panelsArray, scope = document) {
  var _panelsArray$index$id, _panelsArray$index, _panelsArray$id, _panelsArray;
  const handle = getResizeHandleElement(handleId, scope), handles = getResizeHandleElementsForGroup(groupId, scope), index2 = handle ? handles.indexOf(handle) : -1, idBefore = (_panelsArray$index$id = (_panelsArray$index = panelsArray[index2]) === null || _panelsArray$index === void 0 ? void 0 : _panelsArray$index.id) !== null && _panelsArray$index$id !== void 0 ? _panelsArray$index$id : null, idAfter = (_panelsArray$id = (_panelsArray = panelsArray[index2 + 1]) === null || _panelsArray === void 0 ? void 0 : _panelsArray.id) !== null && _panelsArray$id !== void 0 ? _panelsArray$id : null;
  return [idBefore, idAfter];
}
function useWindowSplitterPanelGroupBehavior({
  committedValuesRef,
  eagerValuesRef,
  groupId,
  layout: layout2,
  panelDataArray,
  panelGroupElement,
  setLayout
}) {
  useRef({
    didWarnAboutMissingResizeHandle: !1
  }), useIsomorphicLayoutEffect(() => {
    if (!panelGroupElement)
      return;
    const resizeHandleElements = getResizeHandleElementsForGroup(groupId, panelGroupElement);
    for (let index2 = 0; index2 < panelDataArray.length - 1; index2++) {
      const {
        valueMax,
        valueMin,
        valueNow
      } = calculateAriaValues({
        layout: layout2,
        panelsArray: panelDataArray,
        pivotIndices: [index2, index2 + 1]
      }), resizeHandleElement = resizeHandleElements[index2];
      if (resizeHandleElement != null) {
        const panelData = panelDataArray[index2];
        assert(panelData, `No panel data found for index "${index2}"`), resizeHandleElement.setAttribute("aria-controls", panelData.id), resizeHandleElement.setAttribute("aria-valuemax", "" + Math.round(valueMax)), resizeHandleElement.setAttribute("aria-valuemin", "" + Math.round(valueMin)), resizeHandleElement.setAttribute("aria-valuenow", valueNow != null ? "" + Math.round(valueNow) : "");
      }
    }
    return () => {
      resizeHandleElements.forEach((resizeHandleElement, index2) => {
        resizeHandleElement.removeAttribute("aria-controls"), resizeHandleElement.removeAttribute("aria-valuemax"), resizeHandleElement.removeAttribute("aria-valuemin"), resizeHandleElement.removeAttribute("aria-valuenow");
      });
    };
  }, [groupId, layout2, panelDataArray, panelGroupElement]), useEffect(() => {
    if (!panelGroupElement)
      return;
    const eagerValues = eagerValuesRef.current;
    assert(eagerValues, "Eager values not found");
    const {
      panelDataArray: panelDataArray2
    } = eagerValues, groupElement = getPanelGroupElement(groupId, panelGroupElement);
    assert(groupElement != null, `No group found for id "${groupId}"`);
    const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);
    assert(handles, `No resize handles found for group id "${groupId}"`);
    const cleanupFunctions = handles.map((handle) => {
      const handleId = handle.getAttribute("data-panel-resize-handle-id");
      assert(handleId, "Resize handle element has no handle id attribute");
      const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelDataArray2, panelGroupElement);
      if (idBefore == null || idAfter == null)
        return () => {
        };
      const onKeyDown = (event) => {
        if (!event.defaultPrevented)
          switch (event.key) {
            case "Enter": {
              event.preventDefault();
              const index2 = panelDataArray2.findIndex((panelData) => panelData.id === idBefore);
              if (index2 >= 0) {
                const panelData = panelDataArray2[index2];
                assert(panelData, `No panel data found for index ${index2}`);
                const size = layout2[index2], {
                  collapsedSize = 0,
                  collapsible,
                  minSize = 0
                } = panelData.constraints;
                if (size != null && collapsible) {
                  const nextLayout = adjustLayoutByDelta({
                    delta: fuzzyNumbersEqual(size, collapsedSize) ? minSize - collapsedSize : collapsedSize - size,
                    initialLayout: layout2,
                    panelConstraints: panelDataArray2.map((panelData2) => panelData2.constraints),
                    pivotIndices: determinePivotIndices(groupId, handleId, panelGroupElement),
                    prevLayout: layout2,
                    trigger: "keyboard"
                  });
                  layout2 !== nextLayout && setLayout(nextLayout);
                }
              }
              break;
            }
          }
      };
      return handle.addEventListener("keydown", onKeyDown), () => {
        handle.removeEventListener("keydown", onKeyDown);
      };
    });
    return () => {
      cleanupFunctions.forEach((cleanupFunction) => cleanupFunction());
    };
  }, [panelGroupElement, committedValuesRef, eagerValuesRef, groupId, layout2, panelDataArray, setLayout]);
}
function areEqual(arrayA, arrayB) {
  if (arrayA.length !== arrayB.length)
    return !1;
  for (let index2 = 0; index2 < arrayA.length; index2++)
    if (arrayA[index2] !== arrayB[index2])
      return !1;
  return !0;
}
function getResizeEventCursorPosition(direction, event) {
  const isHorizontal = direction === "horizontal", {
    x: x2,
    y: y2
  } = getResizeEventCoordinates(event);
  return isHorizontal ? x2 : y2;
}
function calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement) {
  const isHorizontal = direction === "horizontal", handleElement = getResizeHandleElement(dragHandleId, panelGroupElement);
  assert(handleElement, `No resize handle element found for id "${dragHandleId}"`);
  const groupId = handleElement.getAttribute("data-panel-group-id");
  assert(groupId, "Resize handle element has no group id attribute");
  let {
    initialCursorPosition
  } = initialDragState;
  const cursorPosition = getResizeEventCursorPosition(direction, event), groupElement = getPanelGroupElement(groupId, panelGroupElement);
  assert(groupElement, `No group element found for id "${groupId}"`);
  const groupRect = groupElement.getBoundingClientRect(), groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;
  return (cursorPosition - initialCursorPosition) / groupSizeInPixels * 100;
}
function calculateDeltaPercentage(event, dragHandleId, direction, initialDragState, keyboardResizeBy, panelGroupElement) {
  if (isKeyDown(event)) {
    const isHorizontal = direction === "horizontal";
    let delta = 0;
    event.shiftKey ? delta = 100 : keyboardResizeBy != null ? delta = keyboardResizeBy : delta = 10;
    let movement = 0;
    switch (event.key) {
      case "ArrowDown":
        movement = isHorizontal ? 0 : delta;
        break;
      case "ArrowLeft":
        movement = isHorizontal ? -delta : 0;
        break;
      case "ArrowRight":
        movement = isHorizontal ? delta : 0;
        break;
      case "ArrowUp":
        movement = isHorizontal ? 0 : -delta;
        break;
      case "End":
        movement = 100;
        break;
      case "Home":
        movement = -100;
        break;
    }
    return movement;
  } else
    return initialDragState == null ? 0 : calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement);
}
function calculateUnsafeDefaultLayout({
  panelDataArray
}) {
  const layout2 = Array(panelDataArray.length), panelConstraintsArray = panelDataArray.map((panelData) => panelData.constraints);
  let numPanelsWithSizes = 0, remainingSize = 100;
  for (let index2 = 0; index2 < panelDataArray.length; index2++) {
    const panelConstraints = panelConstraintsArray[index2];
    assert(panelConstraints, `Panel constraints not found for index ${index2}`);
    const {
      defaultSize
    } = panelConstraints;
    defaultSize != null && (numPanelsWithSizes++, layout2[index2] = defaultSize, remainingSize -= defaultSize);
  }
  for (let index2 = 0; index2 < panelDataArray.length; index2++) {
    const panelConstraints = panelConstraintsArray[index2];
    assert(panelConstraints, `Panel constraints not found for index ${index2}`);
    const {
      defaultSize
    } = panelConstraints;
    if (defaultSize != null)
      continue;
    const numRemainingPanels = panelDataArray.length - numPanelsWithSizes, size = remainingSize / numRemainingPanels;
    numPanelsWithSizes++, layout2[index2] = size, remainingSize -= size;
  }
  return layout2;
}
function callPanelCallbacks(panelsArray, layout2, panelIdToLastNotifiedSizeMap) {
  layout2.forEach((size, index2) => {
    const panelData = panelsArray[index2];
    assert(panelData, `Panel data not found for index ${index2}`);
    const {
      callbacks,
      constraints,
      id: panelId
    } = panelData, {
      collapsedSize = 0,
      collapsible
    } = constraints, lastNotifiedSize = panelIdToLastNotifiedSizeMap[panelId];
    if (lastNotifiedSize == null || size !== lastNotifiedSize) {
      panelIdToLastNotifiedSizeMap[panelId] = size;
      const {
        onCollapse,
        onExpand,
        onResize
      } = callbacks;
      onResize && onResize(size, lastNotifiedSize), collapsible && (onCollapse || onExpand) && (onExpand && (lastNotifiedSize == null || fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && !fuzzyNumbersEqual$1(size, collapsedSize) && onExpand(), onCollapse && (lastNotifiedSize == null || !fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && fuzzyNumbersEqual$1(size, collapsedSize) && onCollapse());
    }
  });
}
function compareLayouts(a2, b2) {
  if (a2.length !== b2.length)
    return !1;
  for (let index2 = 0; index2 < a2.length; index2++)
    if (a2[index2] != b2[index2])
      return !1;
  return !0;
}
function computePanelFlexBoxStyle({
  defaultSize,
  dragState,
  layout: layout2,
  panelData,
  panelIndex,
  precision = 3
}) {
  const size = layout2[panelIndex];
  let flexGrow;
  return size == null ? flexGrow = defaultSize != null ? defaultSize.toPrecision(precision) : "1" : panelData.length === 1 ? flexGrow = "1" : flexGrow = size.toPrecision(precision), {
    flexBasis: 0,
    flexGrow,
    flexShrink: 1,
    // Without this, Panel sizes may be unintentionally overridden by their content
    overflow: "hidden",
    // Disable pointer events inside of a panel during resize
    // This avoid edge cases like nested iframes
    pointerEvents: dragState !== null ? "none" : void 0
  };
}
function debounce(callback, durationMs = 10) {
  let timeoutId = null;
  return (...args) => {
    timeoutId !== null && clearTimeout(timeoutId), timeoutId = setTimeout(() => {
      callback(...args);
    }, durationMs);
  };
}
function initializeDefaultStorage(storageObject) {
  try {
    if (typeof localStorage < "u")
      storageObject.getItem = (name) => localStorage.getItem(name), storageObject.setItem = (name, value) => {
        localStorage.setItem(name, value);
      };
    else
      throw new Error("localStorage not supported in this environment");
  } catch (error) {
    console.error(error), storageObject.getItem = () => null, storageObject.setItem = () => {
    };
  }
}
function getPanelGroupKey(autoSaveId) {
  return `react-resizable-panels:${autoSaveId}`;
}
function getPanelKey(panels) {
  return panels.map((panel2) => {
    const {
      constraints,
      id: id2,
      idIsFromProps,
      order: order2
    } = panel2;
    return idIsFromProps ? id2 : order2 ? `${order2}:${JSON.stringify(constraints)}` : JSON.stringify(constraints);
  }).sort((a2, b2) => a2.localeCompare(b2)).join(",");
}
function loadSerializedPanelGroupState(autoSaveId, storage) {
  try {
    const panelGroupKey = getPanelGroupKey(autoSaveId), serialized = storage.getItem(panelGroupKey);
    if (serialized) {
      const parsed = JSON.parse(serialized);
      if (typeof parsed == "object" && parsed != null)
        return parsed;
    }
  } catch {
  }
  return null;
}
function loadPanelGroupState(autoSaveId, panels, storage) {
  var _loadSerializedPanelG, _state$panelKey;
  const state = (_loadSerializedPanelG = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG !== void 0 ? _loadSerializedPanelG : {}, panelKey = getPanelKey(panels);
  return (_state$panelKey = state[panelKey]) !== null && _state$panelKey !== void 0 ? _state$panelKey : null;
}
function savePanelGroupState(autoSaveId, panels, panelSizesBeforeCollapse, sizes, storage) {
  var _loadSerializedPanelG2;
  const panelGroupKey = getPanelGroupKey(autoSaveId), panelKey = getPanelKey(panels), state = (_loadSerializedPanelG2 = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG2 !== void 0 ? _loadSerializedPanelG2 : {};
  state[panelKey] = {
    expandToSizes: Object.fromEntries(panelSizesBeforeCollapse.entries()),
    layout: sizes
  };
  try {
    storage.setItem(panelGroupKey, JSON.stringify(state));
  } catch (error) {
    console.error(error);
  }
}
function validatePanelGroupLayout({
  layout: prevLayout,
  panelConstraints
}) {
  const nextLayout = [...prevLayout], nextLayoutTotalSize = nextLayout.reduce((accumulated, current) => accumulated + current, 0);
  if (nextLayout.length !== panelConstraints.length)
    throw Error(`Invalid ${panelConstraints.length} panel layout: ${nextLayout.map((size) => `${size}%`).join(", ")}`);
  if (!fuzzyNumbersEqual(nextLayoutTotalSize, 100) && nextLayout.length > 0)
    for (let index2 = 0; index2 < panelConstraints.length; index2++) {
      const unsafeSize = nextLayout[index2];
      assert(unsafeSize != null, `No layout data found for index ${index2}`);
      const safeSize = 100 / nextLayoutTotalSize * unsafeSize;
      nextLayout[index2] = safeSize;
    }
  let remainingSize = 0;
  for (let index2 = 0; index2 < panelConstraints.length; index2++) {
    const unsafeSize = nextLayout[index2];
    assert(unsafeSize != null, `No layout data found for index ${index2}`);
    const safeSize = resizePanel({
      panelConstraints,
      panelIndex: index2,
      size: unsafeSize
    });
    unsafeSize != safeSize && (remainingSize += unsafeSize - safeSize, nextLayout[index2] = safeSize);
  }
  if (!fuzzyNumbersEqual(remainingSize, 0))
    for (let index2 = 0; index2 < panelConstraints.length; index2++) {
      const prevSize = nextLayout[index2];
      assert(prevSize != null, `No layout data found for index ${index2}`);
      const unsafeSize = prevSize + remainingSize, safeSize = resizePanel({
        panelConstraints,
        panelIndex: index2,
        size: unsafeSize
      });
      if (prevSize !== safeSize && (remainingSize -= safeSize - prevSize, nextLayout[index2] = safeSize, fuzzyNumbersEqual(remainingSize, 0)))
        break;
    }
  return nextLayout;
}
const LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100, defaultStorage = {
  getItem: (name) => (initializeDefaultStorage(defaultStorage), defaultStorage.getItem(name)),
  setItem: (name, value) => {
    initializeDefaultStorage(defaultStorage), defaultStorage.setItem(name, value);
  }
}, debounceMap = {};
function PanelGroupWithForwardedRef({
  autoSaveId = null,
  children,
  className: classNameFromProps = "",
  direction,
  forwardedRef,
  id: idFromProps = null,
  onLayout = null,
  keyboardResizeBy = null,
  storage = defaultStorage,
  style: styleFromProps,
  tagName: Type = "div",
  ...rest
}) {
  const groupId = useUniqueId(idFromProps), panelGroupElementRef = useRef(null), [dragState, setDragState] = useState(null), [layout2, setLayout] = useState([]), forceUpdate = useForceUpdate(), panelIdToLastNotifiedSizeMapRef = useRef({}), panelSizeBeforeCollapseRef = useRef(/* @__PURE__ */ new Map()), prevDeltaRef = useRef(0), committedValuesRef = useRef({
    autoSaveId,
    direction,
    dragState,
    id: groupId,
    keyboardResizeBy,
    onLayout,
    storage
  }), eagerValuesRef = useRef({
    layout: layout2,
    panelDataArray: [],
    panelDataArrayChanged: !1
  });
  useRef({
    didLogIdAndOrderWarning: !1,
    didLogPanelConstraintsWarning: !1,
    prevPanelIds: []
  }), useImperativeHandle(forwardedRef, () => ({
    getId: () => committedValuesRef.current.id,
    getLayout: () => {
      const {
        layout: layout3
      } = eagerValuesRef.current;
      return layout3;
    },
    setLayout: (unsafeLayout) => {
      const {
        onLayout: onLayout2
      } = committedValuesRef.current, {
        layout: prevLayout,
        panelDataArray
      } = eagerValuesRef.current, safeLayout = validatePanelGroupLayout({
        layout: unsafeLayout,
        panelConstraints: panelDataArray.map((panelData) => panelData.constraints)
      });
      areEqual(prevLayout, safeLayout) || (setLayout(safeLayout), eagerValuesRef.current.layout = safeLayout, onLayout2 && onLayout2(safeLayout), callPanelCallbacks(panelDataArray, safeLayout, panelIdToLastNotifiedSizeMapRef.current));
    }
  }), []), useIsomorphicLayoutEffect(() => {
    committedValuesRef.current.autoSaveId = autoSaveId, committedValuesRef.current.direction = direction, committedValuesRef.current.dragState = dragState, committedValuesRef.current.id = groupId, committedValuesRef.current.onLayout = onLayout, committedValuesRef.current.storage = storage;
  }), useWindowSplitterPanelGroupBehavior({
    committedValuesRef,
    eagerValuesRef,
    groupId,
    layout: layout2,
    panelDataArray: eagerValuesRef.current.panelDataArray,
    setLayout,
    panelGroupElement: panelGroupElementRef.current
  }), useEffect(() => {
    const {
      panelDataArray
    } = eagerValuesRef.current;
    if (autoSaveId) {
      if (layout2.length === 0 || layout2.length !== panelDataArray.length)
        return;
      let debouncedSave = debounceMap[autoSaveId];
      debouncedSave == null && (debouncedSave = debounce(savePanelGroupState, LOCAL_STORAGE_DEBOUNCE_INTERVAL), debounceMap[autoSaveId] = debouncedSave);
      const clonedPanelDataArray = [...panelDataArray], clonedPanelSizesBeforeCollapse = new Map(panelSizeBeforeCollapseRef.current);
      debouncedSave(autoSaveId, clonedPanelDataArray, clonedPanelSizesBeforeCollapse, layout2, storage);
    }
  }, [autoSaveId, layout2, storage]), useEffect(() => {
  });
  const collapsePanel = useCallback((panelData) => {
    const {
      onLayout: onLayout2
    } = committedValuesRef.current, {
      layout: prevLayout,
      panelDataArray
    } = eagerValuesRef.current;
    if (panelData.constraints.collapsible) {
      const panelConstraintsArray = panelDataArray.map((panelData2) => panelData2.constraints), {
        collapsedSize = 0,
        panelSize,
        pivotIndices
      } = panelDataHelper(panelDataArray, panelData, prevLayout);
      if (assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`), !fuzzyNumbersEqual$1(panelSize, collapsedSize)) {
        panelSizeBeforeCollapseRef.current.set(panelData.id, panelSize);
        const delta = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1 ? panelSize - collapsedSize : collapsedSize - panelSize, nextLayout = adjustLayoutByDelta({
          delta,
          initialLayout: prevLayout,
          panelConstraints: panelConstraintsArray,
          pivotIndices,
          prevLayout,
          trigger: "imperative-api"
        });
        compareLayouts(prevLayout, nextLayout) || (setLayout(nextLayout), eagerValuesRef.current.layout = nextLayout, onLayout2 && onLayout2(nextLayout), callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current));
      }
    }
  }, []), expandPanel = useCallback((panelData, minSizeOverride) => {
    const {
      onLayout: onLayout2
    } = committedValuesRef.current, {
      layout: prevLayout,
      panelDataArray
    } = eagerValuesRef.current;
    if (panelData.constraints.collapsible) {
      const panelConstraintsArray = panelDataArray.map((panelData2) => panelData2.constraints), {
        collapsedSize = 0,
        panelSize = 0,
        minSize: minSizeFromProps = 0,
        pivotIndices
      } = panelDataHelper(panelDataArray, panelData, prevLayout), minSize = minSizeOverride ?? minSizeFromProps;
      if (fuzzyNumbersEqual$1(panelSize, collapsedSize)) {
        const prevPanelSize = panelSizeBeforeCollapseRef.current.get(panelData.id), baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize, delta = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1 ? panelSize - baseSize : baseSize - panelSize, nextLayout = adjustLayoutByDelta({
          delta,
          initialLayout: prevLayout,
          panelConstraints: panelConstraintsArray,
          pivotIndices,
          prevLayout,
          trigger: "imperative-api"
        });
        compareLayouts(prevLayout, nextLayout) || (setLayout(nextLayout), eagerValuesRef.current.layout = nextLayout, onLayout2 && onLayout2(nextLayout), callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current));
      }
    }
  }, []), getPanelSize = useCallback((panelData) => {
    const {
      layout: layout3,
      panelDataArray
    } = eagerValuesRef.current, {
      panelSize
    } = panelDataHelper(panelDataArray, panelData, layout3);
    return assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`), panelSize;
  }, []), getPanelStyle = useCallback((panelData, defaultSize) => {
    const {
      panelDataArray
    } = eagerValuesRef.current, panelIndex = findPanelDataIndex(panelDataArray, panelData);
    return computePanelFlexBoxStyle({
      defaultSize,
      dragState,
      layout: layout2,
      panelData: panelDataArray,
      panelIndex
    });
  }, [dragState, layout2]), isPanelCollapsed = useCallback((panelData) => {
    const {
      layout: layout3,
      panelDataArray
    } = eagerValuesRef.current, {
      collapsedSize = 0,
      collapsible,
      panelSize
    } = panelDataHelper(panelDataArray, panelData, layout3);
    return assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`), collapsible === !0 && fuzzyNumbersEqual$1(panelSize, collapsedSize);
  }, []), isPanelExpanded = useCallback((panelData) => {
    const {
      layout: layout3,
      panelDataArray
    } = eagerValuesRef.current, {
      collapsedSize = 0,
      collapsible,
      panelSize
    } = panelDataHelper(panelDataArray, panelData, layout3);
    return assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`), !collapsible || fuzzyCompareNumbers(panelSize, collapsedSize) > 0;
  }, []), registerPanel = useCallback((panelData) => {
    const {
      panelDataArray
    } = eagerValuesRef.current;
    panelDataArray.push(panelData), panelDataArray.sort((panelA, panelB) => {
      const orderA = panelA.order, orderB = panelB.order;
      return orderA == null && orderB == null ? 0 : orderA == null ? -1 : orderB == null ? 1 : orderA - orderB;
    }), eagerValuesRef.current.panelDataArrayChanged = !0, forceUpdate();
  }, [forceUpdate]);
  useIsomorphicLayoutEffect(() => {
    if (eagerValuesRef.current.panelDataArrayChanged) {
      eagerValuesRef.current.panelDataArrayChanged = !1;
      const {
        autoSaveId: autoSaveId2,
        onLayout: onLayout2,
        storage: storage2
      } = committedValuesRef.current, {
        layout: prevLayout,
        panelDataArray
      } = eagerValuesRef.current;
      let unsafeLayout = null;
      if (autoSaveId2) {
        const state = loadPanelGroupState(autoSaveId2, panelDataArray, storage2);
        state && (panelSizeBeforeCollapseRef.current = new Map(Object.entries(state.expandToSizes)), unsafeLayout = state.layout);
      }
      unsafeLayout == null && (unsafeLayout = calculateUnsafeDefaultLayout({
        panelDataArray
      }));
      const nextLayout = validatePanelGroupLayout({
        layout: unsafeLayout,
        panelConstraints: panelDataArray.map((panelData) => panelData.constraints)
      });
      areEqual(prevLayout, nextLayout) || (setLayout(nextLayout), eagerValuesRef.current.layout = nextLayout, onLayout2 && onLayout2(nextLayout), callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current));
    }
  }), useIsomorphicLayoutEffect(() => {
    const eagerValues = eagerValuesRef.current;
    return () => {
      eagerValues.layout = [];
    };
  }, []);
  const registerResizeHandle2 = useCallback((dragHandleId) => {
    let isRTL = !1;
    const panelGroupElement = panelGroupElementRef.current;
    return panelGroupElement && window.getComputedStyle(panelGroupElement, null).getPropertyValue("direction") === "rtl" && (isRTL = !0), function(event) {
      event.preventDefault();
      const panelGroupElement2 = panelGroupElementRef.current;
      if (!panelGroupElement2)
        return () => null;
      const {
        direction: direction2,
        dragState: dragState2,
        id: groupId2,
        keyboardResizeBy: keyboardResizeBy2,
        onLayout: onLayout2
      } = committedValuesRef.current, {
        layout: prevLayout,
        panelDataArray
      } = eagerValuesRef.current, {
        initialLayout
      } = dragState2 ?? {}, pivotIndices = determinePivotIndices(groupId2, dragHandleId, panelGroupElement2);
      let delta = calculateDeltaPercentage(event, dragHandleId, direction2, dragState2, keyboardResizeBy2, panelGroupElement2);
      const isHorizontal = direction2 === "horizontal";
      isHorizontal && isRTL && (delta = -delta);
      const panelConstraints = panelDataArray.map((panelData) => panelData.constraints), nextLayout = adjustLayoutByDelta({
        delta,
        initialLayout: initialLayout ?? prevLayout,
        panelConstraints,
        pivotIndices,
        prevLayout,
        trigger: isKeyDown(event) ? "keyboard" : "mouse-or-touch"
      }), layoutChanged = !compareLayouts(prevLayout, nextLayout);
      (isPointerEvent(event) || isMouseEvent(event)) && prevDeltaRef.current != delta && (prevDeltaRef.current = delta, !layoutChanged && delta !== 0 ? isHorizontal ? reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_HORIZONTAL_MIN : EXCEEDED_HORIZONTAL_MAX) : reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_VERTICAL_MIN : EXCEEDED_VERTICAL_MAX) : reportConstraintsViolation(dragHandleId, 0)), layoutChanged && (setLayout(nextLayout), eagerValuesRef.current.layout = nextLayout, onLayout2 && onLayout2(nextLayout), callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current));
    };
  }, []), resizePanel2 = useCallback((panelData, unsafePanelSize) => {
    const {
      onLayout: onLayout2
    } = committedValuesRef.current, {
      layout: prevLayout,
      panelDataArray
    } = eagerValuesRef.current, panelConstraintsArray = panelDataArray.map((panelData2) => panelData2.constraints), {
      panelSize,
      pivotIndices
    } = panelDataHelper(panelDataArray, panelData, prevLayout);
    assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`);
    const delta = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1 ? panelSize - unsafePanelSize : unsafePanelSize - panelSize, nextLayout = adjustLayoutByDelta({
      delta,
      initialLayout: prevLayout,
      panelConstraints: panelConstraintsArray,
      pivotIndices,
      prevLayout,
      trigger: "imperative-api"
    });
    compareLayouts(prevLayout, nextLayout) || (setLayout(nextLayout), eagerValuesRef.current.layout = nextLayout, onLayout2 && onLayout2(nextLayout), callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current));
  }, []), reevaluatePanelConstraints = useCallback((panelData, prevConstraints) => {
    const {
      layout: layout3,
      panelDataArray
    } = eagerValuesRef.current, {
      collapsedSize: prevCollapsedSize = 0,
      collapsible: prevCollapsible
    } = prevConstraints, {
      collapsedSize: nextCollapsedSize = 0,
      collapsible: nextCollapsible,
      maxSize: nextMaxSize = 100,
      minSize: nextMinSize = 0
    } = panelData.constraints, {
      panelSize: prevPanelSize
    } = panelDataHelper(panelDataArray, panelData, layout3);
    prevPanelSize != null && (prevCollapsible && nextCollapsible && fuzzyNumbersEqual$1(prevPanelSize, prevCollapsedSize) ? fuzzyNumbersEqual$1(prevCollapsedSize, nextCollapsedSize) || resizePanel2(panelData, nextCollapsedSize) : prevPanelSize < nextMinSize ? resizePanel2(panelData, nextMinSize) : prevPanelSize > nextMaxSize && resizePanel2(panelData, nextMaxSize));
  }, [resizePanel2]), startDragging = useCallback((dragHandleId, event) => {
    const {
      direction: direction2
    } = committedValuesRef.current, {
      layout: layout3
    } = eagerValuesRef.current;
    if (!panelGroupElementRef.current)
      return;
    const handleElement = getResizeHandleElement(dragHandleId, panelGroupElementRef.current);
    assert(handleElement, `Drag handle element not found for id "${dragHandleId}"`);
    const initialCursorPosition = getResizeEventCursorPosition(direction2, event);
    setDragState({
      dragHandleId,
      dragHandleRect: handleElement.getBoundingClientRect(),
      initialCursorPosition,
      initialLayout: layout3
    });
  }, []), stopDragging = useCallback(() => {
    setDragState(null);
  }, []), unregisterPanel = useCallback((panelData) => {
    const {
      panelDataArray
    } = eagerValuesRef.current, index2 = findPanelDataIndex(panelDataArray, panelData);
    index2 >= 0 && (panelDataArray.splice(index2, 1), delete panelIdToLastNotifiedSizeMapRef.current[panelData.id], eagerValuesRef.current.panelDataArrayChanged = !0, forceUpdate());
  }, [forceUpdate]), context = useMemo(() => ({
    collapsePanel,
    direction,
    dragState,
    expandPanel,
    getPanelSize,
    getPanelStyle,
    groupId,
    isPanelCollapsed,
    isPanelExpanded,
    reevaluatePanelConstraints,
    registerPanel,
    registerResizeHandle: registerResizeHandle2,
    resizePanel: resizePanel2,
    startDragging,
    stopDragging,
    unregisterPanel,
    panelGroupElement: panelGroupElementRef.current
  }), [collapsePanel, dragState, direction, expandPanel, getPanelSize, getPanelStyle, groupId, isPanelCollapsed, isPanelExpanded, reevaluatePanelConstraints, registerPanel, registerResizeHandle2, resizePanel2, startDragging, stopDragging, unregisterPanel]), style = {
    display: "flex",
    flexDirection: direction === "horizontal" ? "row" : "column",
    height: "100%",
    overflow: "hidden",
    width: "100%"
  };
  return createElement(PanelGroupContext.Provider, {
    value: context
  }, createElement(Type, {
    ...rest,
    children,
    className: classNameFromProps,
    id: idFromProps,
    ref: panelGroupElementRef,
    style: {
      ...style,
      ...styleFromProps
    },
    // CSS selectors
    "data-panel-group": "",
    "data-panel-group-direction": direction,
    "data-panel-group-id": groupId
  }));
}
const PanelGroup = forwardRef((props2, ref) => createElement(PanelGroupWithForwardedRef, {
  ...props2,
  forwardedRef: ref
}));
PanelGroupWithForwardedRef.displayName = "PanelGroup";
PanelGroup.displayName = "forwardRef(PanelGroup)";
function findPanelDataIndex(panelDataArray, panelData) {
  return panelDataArray.findIndex((prevPanelData) => prevPanelData === panelData || prevPanelData.id === panelData.id);
}
function panelDataHelper(panelDataArray, panelData, layout2) {
  const panelIndex = findPanelDataIndex(panelDataArray, panelData), pivotIndices = panelIndex === panelDataArray.length - 1 ? [panelIndex - 1, panelIndex] : [panelIndex, panelIndex + 1], panelSize = layout2[panelIndex];
  return {
    ...panelData.constraints,
    panelSize,
    pivotIndices
  };
}
function useWindowSplitterResizeHandlerBehavior({
  disabled,
  handleId,
  resizeHandler,
  panelGroupElement
}) {
  useEffect(() => {
    if (disabled || resizeHandler == null || panelGroupElement == null)
      return;
    const handleElement = getResizeHandleElement(handleId, panelGroupElement);
    if (handleElement == null)
      return;
    const onKeyDown = (event) => {
      if (!event.defaultPrevented)
        switch (event.key) {
          case "ArrowDown":
          case "ArrowLeft":
          case "ArrowRight":
          case "ArrowUp":
          case "End":
          case "Home": {
            event.preventDefault(), resizeHandler(event);
            break;
          }
          case "F6": {
            event.preventDefault();
            const groupId = handleElement.getAttribute("data-panel-group-id");
            assert(groupId, `No group element found for id "${groupId}"`);
            const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement), index2 = getResizeHandleElementIndex(groupId, handleId, panelGroupElement);
            assert(index2 !== null, `No resize element found for id "${handleId}"`);
            const nextIndex = event.shiftKey ? index2 > 0 ? index2 - 1 : handles.length - 1 : index2 + 1 < handles.length ? index2 + 1 : 0;
            handles[nextIndex].focus();
            break;
          }
        }
    };
    return handleElement.addEventListener("keydown", onKeyDown), () => {
      handleElement.removeEventListener("keydown", onKeyDown);
    };
  }, [panelGroupElement, disabled, handleId, resizeHandler]);
}
function PanelResizeHandle({
  children = null,
  className: classNameFromProps = "",
  disabled = !1,
  hitAreaMargins,
  id: idFromProps,
  onBlur,
  onDragging,
  onFocus,
  style: styleFromProps = {},
  tabIndex = 0,
  tagName: Type = "div",
  ...rest
}) {
  var _hitAreaMargins$coars, _hitAreaMargins$fine;
  const elementRef = useRef(null), callbacksRef = useRef({
    onDragging
  });
  useEffect(() => {
    callbacksRef.current.onDragging = onDragging;
  });
  const panelGroupContext = useContext(PanelGroupContext);
  if (panelGroupContext === null)
    throw Error("PanelResizeHandle components must be rendered within a PanelGroup container");
  const {
    direction,
    groupId,
    registerResizeHandle: registerResizeHandleWithParentGroup,
    startDragging,
    stopDragging,
    panelGroupElement
  } = panelGroupContext, resizeHandleId = useUniqueId(idFromProps), [state, setState] = useState("inactive"), [isFocused, setIsFocused] = useState(!1), [resizeHandler, setResizeHandler] = useState(null), committedValuesRef = useRef({
    state
  });
  useIsomorphicLayoutEffect(() => {
    committedValuesRef.current.state = state;
  }), useEffect(() => {
    if (disabled)
      setResizeHandler(null);
    else {
      const resizeHandler2 = registerResizeHandleWithParentGroup(resizeHandleId);
      setResizeHandler(() => resizeHandler2);
    }
  }, [disabled, resizeHandleId, registerResizeHandleWithParentGroup]);
  const coarseHitAreaMargins = (_hitAreaMargins$coars = hitAreaMargins?.coarse) !== null && _hitAreaMargins$coars !== void 0 ? _hitAreaMargins$coars : 15, fineHitAreaMargins = (_hitAreaMargins$fine = hitAreaMargins?.fine) !== null && _hitAreaMargins$fine !== void 0 ? _hitAreaMargins$fine : 5;
  return useEffect(() => {
    if (disabled || resizeHandler == null)
      return;
    const element = elementRef.current;
    return assert(element, "Element ref not attached"), registerResizeHandle(resizeHandleId, element, direction, {
      coarse: coarseHitAreaMargins,
      fine: fineHitAreaMargins
    }, (action, isActive, event) => {
      if (isActive)
        switch (action) {
          case "down": {
            setState("drag"), assert(event, 'Expected event to be defined for "down" action'), startDragging(resizeHandleId, event);
            const {
              onDragging: onDragging2
            } = callbacksRef.current;
            onDragging2 && onDragging2(!0);
            break;
          }
          case "move": {
            const {
              state: state2
            } = committedValuesRef.current;
            state2 !== "drag" && setState("hover"), assert(event, 'Expected event to be defined for "move" action'), resizeHandler(event);
            break;
          }
          case "up": {
            setState("hover"), stopDragging();
            const {
              onDragging: onDragging2
            } = callbacksRef.current;
            onDragging2 && onDragging2(!1);
            break;
          }
        }
      else
        setState("inactive");
    });
  }, [coarseHitAreaMargins, direction, disabled, fineHitAreaMargins, registerResizeHandleWithParentGroup, resizeHandleId, resizeHandler, startDragging, stopDragging]), useWindowSplitterResizeHandlerBehavior({
    disabled,
    handleId: resizeHandleId,
    resizeHandler,
    panelGroupElement
  }), createElement(Type, {
    ...rest,
    children,
    className: classNameFromProps,
    id: idFromProps,
    onBlur: () => {
      setIsFocused(!1), onBlur?.();
    },
    onFocus: () => {
      setIsFocused(!0), onFocus?.();
    },
    ref: elementRef,
    role: "separator",
    style: {
      ...{
        touchAction: "none",
        userSelect: "none"
      },
      ...styleFromProps
    },
    tabIndex,
    // CSS selectors
    "data-panel-group-direction": direction,
    "data-panel-group-id": groupId,
    "data-resize-handle": "",
    "data-resize-handle-active": state === "drag" ? "pointer" : isFocused ? "keyboard" : void 0,
    "data-resize-handle-state": state,
    "data-panel-resize-handle-enabled": !disabled,
    "data-panel-resize-handle-id": resizeHandleId
  });
}
PanelResizeHandle.displayName = "PanelResizeHandle";
function CopyButton({ text }) {
  return /* @__PURE__ */ jsx(CopyButton$1, { value: text, timeout: 2e3, children: ({ copied, copy }) => /* @__PURE__ */ jsx(Tooltip$5, { label: copied ? "Copied" : "Copy", withArrow: !0, position: "right", children: /* @__PURE__ */ jsx(ActionIcon$1, { color: copied ? "teal" : "gray", variant: copied ? "light" : "subtle", onClick: copy, children: copied ? /* @__PURE__ */ jsx(IconCheck, { style: { width: rem(16) } }) : /* @__PURE__ */ jsx(IconCopy, { style: { width: rem(16) } }) }) }) });
}
function CopyToClipboard({ text }) {
  return /* @__PURE__ */ jsx(Box, { pos: "absolute", top: "0", right: "0", p: "4", children: /* @__PURE__ */ jsx(CopyButton, { text }) });
}
var cssScrollArea = "_5k2wbq0", cssCodeBlock = "_5k2wbq1", viewWithTopPadding = "_5k2wbq2";
const Route$3 = createFileRoute("/view/$viewId/mmd")({
  component: ViewAsMmd,
  loader: async ({ params }) => {
    const { viewId } = params;
    try {
      const { mmdSource } = await import("./-view-lazy-data-WZmbIsHq.js");
      return {
        source: mmdSource(viewId)
      };
    } catch {
      throw notFound();
    }
  }
}), renderSvg = async (viewId, diagram) => {
  const { default: mermaid } = await import("https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs");
  mermaid.initialize({
    theme: "dark"
  });
  const { svg } = await mermaid.render(viewId, diagram);
  return svg;
};
function ViewAsMmd() {
  const { viewId } = Route$3.useParams(), { source } = Route$3.useLoaderData(), [mmdSvg, { execute }] = useAsync(renderSvg, null);
  return useEffect$1(() => {
    execute(viewId, source);
  }, [source]), /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsxs(PanelGroup, { className: viewWithTopPadding, direction: "horizontal", autoSaveId: "viewAsMmd", children: [
      /* @__PURE__ */ jsx(Panel, { children: /* @__PURE__ */ jsxs(
        ScrollArea,
        {
          className: cssScrollArea,
          p: 5,
          styles: {
            viewport: {
              borderRadius: 6
            }
          },
          children: [
            /* @__PURE__ */ jsx(Code, { block: !0, className: cssCodeBlock, children: source }),
            /* @__PURE__ */ jsx(CopyToClipboard, { text: source })
          ]
        }
      ) }),
      /* @__PURE__ */ jsx(
        PanelResizeHandle,
        {
          style: {
            width: 10
          }
        }
      ),
      /* @__PURE__ */ jsx(Panel, { children: /* @__PURE__ */ jsx(ScrollArea, { h: "100%", children: mmdSvg.result && /* @__PURE__ */ jsx("div", { className: svgContainer, dangerouslySetInnerHTML: { __html: mmdSvg.result } }) }) })
    ] }),
    /* @__PURE__ */ jsx(
      Box,
      {
        pos: "fixed",
        top: 14,
        left: 10,
        children: /* @__PURE__ */ jsx(
          Burger,
          {
            size: "sm",
            onClick: SidebarDrawerOps.open,
            "aria-label": "Toggle navigation"
          }
        )
      }
    )
  ] });
}
const Route$2 = createFileRoute("/view/$viewId/editor")({
  component: ViewEditor
});
function ViewEditor() {
  const router = useRouter(), { viewId } = Route$2.useParams(), view = useLikeC4DiagramView(viewId), onNavigateTo = useCallbackRef((viewId2) => {
    router.navigate({
      to: "/view/$viewId/editor",
      params: { viewId: viewId2 },
      startTransition: !0,
      search: !0
    });
  });
  if (!view)
    throw notFound();
  const hasNotations = (view.notation?.elements ?? []).length > 0;
  return /* @__PURE__ */ jsx(
    LikeC4Diagram,
    {
      view,
      readonly: !1,
      zoomable: !0,
      pannable: !0,
      nodesDraggable: !0,
      experimentalEdgeEditing: !0,
      fitViewPadding: 0.08,
      showDiagramTitle: !0,
      showNavigationButtons: !0,
      showNotations: isDevelopment || hasNotations,
      enableDynamicViewWalkthrough: !0,
      enableFocusMode: !1,
      enableElementDetails: !0,
      enableRelationshipDetails: !0,
      enableRelationshipBrowser: !0,
      onNavigateTo,
      renderIcon: RenderIcon,
      onChange: (e2) => console.log(e2),
      onBurgerMenuClick: withOverviewGraph ? () => {
        router.navigate({
          to: "/",
          search: !0
        });
      } : SidebarDrawerOps.open
    }
  );
}
const Route$1 = createFileRoute("/view/$viewId/dot")({
  component: ViewAsDot,
  loader: async ({ params }) => {
    const { viewId } = params;
    try {
      const { dotSource, svgSource } = await import("./-view-lazy-data-WZmbIsHq.js"), dot = dotSource(viewId), dotSvg = svgSource(viewId);
      return {
        dot,
        dotSvg
      };
    } catch (error) {
      throw console.error(error), notFound();
    }
  }
});
function ViewAsDot() {
  const { dot, dotSvg } = Route$1.useLoaderData();
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsxs(PanelGroup, { className: viewWithTopPadding, direction: "horizontal", autoSaveId: "viewAsDot", children: [
      /* @__PURE__ */ jsx(Panel, { children: /* @__PURE__ */ jsxs(
        ScrollArea,
        {
          className: cssScrollArea,
          p: 5,
          styles: {
            viewport: {
              borderRadius: 6
            }
          },
          children: [
            /* @__PURE__ */ jsx(Code, { block: !0, className: cssCodeBlock, children: dot }),
            /* @__PURE__ */ jsx(CopyToClipboard, { text: dot })
          ]
        }
      ) }),
      /* @__PURE__ */ jsx(
        PanelResizeHandle,
        {
          style: {
            width: 10
          }
        }
      ),
      /* @__PURE__ */ jsx(Panel, { children: /* @__PURE__ */ jsx(ScrollArea, { h: "100%", children: /* @__PURE__ */ jsx("div", { className: svgContainer, dangerouslySetInnerHTML: { __html: dotSvg } }) }) })
    ] }),
    /* @__PURE__ */ jsx(
      Box,
      {
        pos: "fixed",
        top: 14,
        left: 10,
        children: /* @__PURE__ */ jsx(
          Burger,
          {
            size: "sm",
            onClick: SidebarDrawerOps.open,
            "aria-label": "Toggle navigation"
          }
        )
      }
    )
  ] });
}
const Route = createFileRoute("/view/$viewId/d2")({
  component: ViewAsD2,
  loader: async ({ params }) => {
    const { viewId } = params;
    try {
      const { d2Source } = await import("./-view-lazy-data-WZmbIsHq.js");
      return {
        source: d2Source(viewId)
      };
    } catch {
      throw notFound();
    }
  }
}), fetchFromKroki = async (d2) => await (await fetch(krokiD2SvgUrl, {
  method: "POST",
  cache: "force-cache",
  body: JSON.stringify({
    diagram_source: d2,
    // diagram_options: {
    //   theme: 'colorblind-clear'
    // },
    output_format: "svg"
  }),
  headers: {
    "Content-Type": "application/json"
  }
})).text();
function ViewAsD2() {
  const { source } = Route.useLoaderData(), [krokiSvg, { execute }] = useAsync(fetchFromKroki, null);
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsxs(PanelGroup, { className: viewWithTopPadding, direction: "horizontal", autoSaveId: "viewAsD2", children: [
      /* @__PURE__ */ jsx(Panel, { children: /* @__PURE__ */ jsxs(
        ScrollArea,
        {
          className: cssScrollArea,
          p: 5,
          styles: {
            viewport: {
              borderRadius: 6
            }
          },
          children: [
            /* @__PURE__ */ jsx(Code, { block: !0, className: cssCodeBlock, children: source }),
            /* @__PURE__ */ jsx(CopyToClipboard, { text: source })
          ]
        }
      ) }),
      /* @__PURE__ */ jsx(
        PanelResizeHandle,
        {
          style: {
            width: 10
          }
        }
      ),
      /* @__PURE__ */ jsx(Panel, { children: /* @__PURE__ */ jsxs(ScrollArea, { h: "100%", children: [
        krokiSvg.status !== "success" && /* @__PURE__ */ jsxs(Fragment$1, { children: [
          /* @__PURE__ */ jsx(
            Button,
            {
              mt: "xs",
              variant: "light",
              disabled: krokiSvg.status === "loading",
              onClick: () => void execute(source),
              children: krokiSvg.status === "loading" ? "Loading..." : "Render with Kroki"
            }
          ),
          krokiSvg.status === "error" && /* @__PURE__ */ jsx(Box, { children: krokiSvg.error?.message })
        ] }),
        krokiSvg.status === "success" && /* @__PURE__ */ jsx(Box, { className: svgContainer, children: krokiSvg.result ? /* @__PURE__ */ jsx("div", { dangerouslySetInnerHTML: { __html: krokiSvg.result } }) : /* @__PURE__ */ jsx(Box, { children: "Empty result" }) })
      ] }) })
    ] }),
    /* @__PURE__ */ jsx(
      Box,
      {
        pos: "fixed",
        top: 14,
        left: 10,
        children: /* @__PURE__ */ jsx(
          Burger,
          {
            size: "sm",
            onClick: SidebarDrawerOps.open,
            "aria-label": "Toggle navigation"
          }
        )
      }
    )
  ] });
}
const IndexRoute = Route$9.update({
  path: "/",
  getParentRoute: () => Route$a
}), WebcomponentSplatRoute = Route$8.update({
  path: "/webcomponent/$",
  getParentRoute: () => Route$a
}), ViewViewIdRoute = Route$7.update({
  path: "/view/$viewId",
  getParentRoute: () => Route$a
}), ExportViewIdRoute = Route$6.update({
  path: "/export/$viewId",
  getParentRoute: () => Route$a
}), EmbedViewIdRoute = Route$5.update({
  path: "/embed/$viewId",
  getParentRoute: () => Route$a
}), ViewViewIdIndexRoute = Route$4.update({
  path: "/",
  getParentRoute: () => ViewViewIdRoute
}), ViewViewIdMmdRoute = Route$3.update({
  path: "/mmd",
  getParentRoute: () => ViewViewIdRoute
}), ViewViewIdEditorRoute = Route$2.update({
  path: "/editor",
  getParentRoute: () => ViewViewIdRoute
}), ViewViewIdDotRoute = Route$1.update({
  path: "/dot",
  getParentRoute: () => ViewViewIdRoute
}), ViewViewIdD2Route = Route.update({
  path: "/d2",
  getParentRoute: () => ViewViewIdRoute
}), routeTree = Route$a.addChildren({
  IndexRoute,
  EmbedViewIdRoute,
  ExportViewIdRoute,
  ViewViewIdRoute: ViewViewIdRoute.addChildren({
    ViewViewIdD2Route,
    ViewViewIdDotRoute,
    ViewViewIdEditorRoute,
    ViewViewIdMmdRoute,
    ViewViewIdIndexRoute
  }),
  WebcomponentSplatRoute
});
function createRouter() {
  return createRouter$1({
    routeTree,
    context: {},
    basepath,
    trailingSlash: "preserve",
    history: useHashHistory ? createHashHistory() : createBrowserHistory(),
    defaultStaleTime: 1 / 0,
    defaultNotFoundComponent: () => /* @__PURE__ */ jsx(NotFound, {}),
    defaultPendingComponent: () => /* @__PURE__ */ jsx(Box, { p: "md", children: /* @__PURE__ */ jsx(Loader, { type: "dots" }) })
  });
}
function Routes() {
  const router = useMemo$1(() => createRouter(), []);
  return /* @__PURE__ */ jsx(RouterProvider, { router });
}
createRoot(document.getElementById("like4-root")).render(
  /* @__PURE__ */ jsx(StrictMode, { children: /* @__PURE__ */ jsx(Routes, {}) })
);
export {
  IconFolderFilled as I,
  nonexhaustive as a,
  createReactComponent as c,
  i$6 as i,
  n$2 as n,
  useUpdateEffect as u
};
