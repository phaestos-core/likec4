import * as React from "react";
import React__default, { useState, Fragment, createContext, useContext, useRef, useEffect, useMemo, useCallback, useLayoutEffect, useId as useId$2, forwardRef, cloneElement, Children, createElement, useSyncExternalStore } from "react";
import { jsx, jsxs, Fragment as Fragment$1 } from "react/jsx-runtime";
import * as ReactDOM from "react-dom";
import ReactDOM__default, { createPortal } from "react-dom";
var __assign = function() {
  return __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
    }
    return t;
  }, __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
      e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
  return t;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++)
    (ar || !(i in from)) && (ar || (ar = Array.prototype.slice.call(from, 0, i)), ar[i] = from[i]);
  return to.concat(ar || Array.prototype.slice.call(from));
}
var zeroRightClassName = "right-scroll-bar-position", fullWidthClassName = "width-before-scroll-bar", noScrollbarsClassName = "with-scroll-bars-hidden", removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef$1(ref, value) {
  return typeof ref == "function" ? ref(value) : ref && (ref.current = value), ref;
}
function useCallbackRef$1(initialValue, callback) {
  var ref = useState(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          last !== value && (ref.value = value, ref.callback(value, last));
        }
      }
    };
  })[0];
  return ref.callback = callback, ref.facade;
}
var useIsomorphicLayoutEffect = typeof window < "u" ? React.useLayoutEffect : React.useEffect, currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef$1(null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef$1(ref, newValue);
    });
  });
  return useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue), nextRefs_1 = new Set(refs), current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        nextRefs_1.has(ref) || assignRef$1(ref, null);
      }), nextRefs_1.forEach(function(ref) {
        prevRefs_1.has(ref) || assignRef$1(ref, current_1);
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]), callbackRef;
}
function ItoI(a) {
  return a;
}
function innerCreateMedium(defaults, middleware) {
  middleware === void 0 && (middleware = ItoI);
  var buffer = [], assigned = !1, medium = {
    read: function() {
      if (assigned)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return buffer.length ? buffer[buffer.length - 1] : defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      return buffer.push(item), function() {
        buffer = buffer.filter(function(x) {
          return x !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      for (assigned = !0; buffer.length; ) {
        var cbs = buffer;
        buffer = [], cbs.forEach(cb);
      }
      buffer = {
        push: function(x) {
          return cb(x);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = !0;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [], cbs.forEach(cb), pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [], cbs2.forEach(cb);
      }, cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle(), buffer = {
        push: function(x) {
          pendingQueue.push(x), cycle();
        },
        filter: function(filter) {
          return pendingQueue = pendingQueue.filter(filter), buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  options === void 0 && (options = {});
  var medium = innerCreateMedium(null);
  return medium.options = __assign({ async: !0, ssr: !1 }, options), medium;
}
var SideCar$1 = function(_a) {
  var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
  if (!sideCar)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var Target = sideCar.read();
  if (!Target)
    throw new Error("Sidecar medium not found");
  return React.createElement(Target, __assign({}, rest));
};
SideCar$1.isSideCarExport = !0;
function exportSidecar(medium, exported) {
  return medium.useMedium(exported), SideCar$1;
}
var effectCar = createSidecarMedium(), nothing = function() {
}, RemoveScroll$1 = React.forwardRef(function(props, parentRef) {
  var ref = React.useRef(null), _a = React.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1], forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container2 = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), SideCar2 = sideCar, containerRef = useMergeRefs([ref, parentRef]), containerProps = __assign(__assign({}, rest), callbacks);
  return React.createElement(
    React.Fragment,
    null,
    enabled && React.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? React.cloneElement(React.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React.createElement(Container2, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll$1.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
RemoveScroll$1.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var currentNonce, getNonce = function() {
  if (currentNonce)
    return currentNonce;
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  return nonce && tag.setAttribute("nonce", nonce), tag;
}
function injectStyles(tag, css) {
  tag.styleSheet ? tag.styleSheet.cssText = css : tag.appendChild(document.createTextNode(css));
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0, stylesheet = null;
  return {
    add: function(style) {
      counter == 0 && (stylesheet = makeStyleTag()) && (injectStyles(stylesheet, style), insertStyleTag(stylesheet)), counter++;
    },
    remove: function() {
      counter--, !counter && stylesheet && (stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet), stylesheet = null);
    }
  };
}, styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React.useEffect(function() {
      return sheet.add(styles), function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
}, styleSingleton = function() {
  var useStyle = styleHookSingleton(), Sheet = function(_a) {
    var styles = _a.styles, dynamic = _a.dynamic;
    return useStyle(styles, dynamic), null;
  };
  return Sheet;
}, zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, parse = function(x) {
  return parseInt(x || "", 10) || 0;
}, getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body), left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"], top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"], right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top), parse(right)];
}, getGapWidth = function(gapMode) {
  if (gapMode === void 0 && (gapMode = "margin"), typeof window > "u")
    return zeroGap;
  var offsets = getOffset(gapMode), documentWidth = document.documentElement.clientWidth, windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
}, Style = styleSingleton(), lockAttribute = "data-scroll-locked", getStyles = function(_a, allowRelative, gapMode, important) {
  var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
  return gapMode === void 0 && (gapMode = "margin"), `
  .`.concat(noScrollbarsClassName, ` {
   overflow: hidden `).concat(important, `;
   padding-right: `).concat(gap, "px ").concat(important, `;
  }
  body[`).concat(lockAttribute, `] {
    overflow: hidden `).concat(important, `;
    overscroll-behavior: contain;
    `).concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && `
    padding-left: `.concat(left, `px;
    padding-top: `).concat(top, `px;
    padding-right: `).concat(right, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(gap, "px ").concat(important, `;
    `),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(zeroRightClassName, ` {
    right: `).concat(gap, "px ").concat(important, `;
  }
  
  .`).concat(fullWidthClassName, ` {
    margin-right: `).concat(gap, "px ").concat(important, `;
  }
  
  .`).concat(zeroRightClassName, " .").concat(zeroRightClassName, ` {
    right: 0 `).concat(important, `;
  }
  
  .`).concat(fullWidthClassName, " .").concat(fullWidthClassName, ` {
    margin-right: 0 `).concat(important, `;
  }
  
  body[`).concat(lockAttribute, `] {
    `).concat(removedBarSizeVariable, ": ").concat(gap, `px;
  }
`);
}, getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
}, useLockAttribute = function() {
  React.useEffect(function() {
    return document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString()), function() {
      var newCounter = getCurrentUseCounter() - 1;
      newCounter <= 0 ? document.body.removeAttribute(lockAttribute) : document.body.setAttribute(lockAttribute, newCounter.toString());
    };
  }, []);
}, RemoveScrollBar = function(_a) {
  var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = React.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, noImportant ? "" : "!important") });
}, passiveSupported = !1;
if (typeof window < "u")
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function() {
        return passiveSupported = !0, !0;
      }
    });
    window.addEventListener("test", options, options), window.removeEventListener("test", options, options);
  } catch {
    passiveSupported = !1;
  }
var nonPassive = passiveSupported ? { passive: !1 } : !1, alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
}, elementCanBeScrolled = function(node, overflow) {
  if (!(node instanceof Element))
    return !1;
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
}, elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
}, elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
}, locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument, current = node;
  do {
    typeof ShadowRoot < "u" && current instanceof ShadowRoot && (current = current.host);
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a = getScrollVariables(axis, current), scrollHeight = _a[1], clientHeight = _a[2];
      if (scrollHeight > clientHeight)
        return !0;
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return !1;
}, getVScrollVariables = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
}, getHScrollVariables = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
}, elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
}, getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
}, getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
}, handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction), delta = directionFactor * sourceDelta, target = event.target, targetInLock = endTarget.contains(target), shouldCancelScroll = !1, isDeltaPositive = delta > 0, availableScroll = 0, availableScrollTop = 0;
  do {
    var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2], elementScroll = scroll_1 - capacity - directionFactor * position;
    (position || elementScroll) && elementCouldBeScrolled(axis, target) && (availableScroll += elementScroll, availableScrollTop += position), target instanceof ShadowRoot ? target = target.host : target = target.parentNode;
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  return (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll) || !isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) && (shouldCancelScroll = !0), shouldCancelScroll;
}, getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
}, getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
}, extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
}, deltaCompare = function(x, y) {
  return x[0] === y[0] && x[1] === y[1];
}, generateStyle = function(id) {
  return `
  .block-interactivity-`.concat(id, ` {pointer-events: none;}
  .allow-interactivity-`).concat(id, ` {pointer-events: all;}
`);
}, idCounter = 0, lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React.useRef([]), touchStartRef = React.useRef([0, 0]), activeAxis = React.useRef(), id = React.useState(idCounter++)[0], Style2 = React.useState(styleSingleton)[0], lastProps = React.useRef(props);
  React.useEffect(function() {
    lastProps.current = props;
  }, [props]), React.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), !0).filter(Boolean);
      return allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(id)), allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey)
      return !lastProps.current.allowPinchZoom;
    var touch = getTouchXY(event), touchStart = touchStartRef.current, deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0], deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1], currentAxis, target = event.target, moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range")
      return !1;
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection)
      return !0;
    if (canBeScrolledInMainDirection ? currentAxis = moveDirection : (currentAxis = moveDirection === "v" ? "h" : "v", canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target)), !canBeScrolledInMainDirection)
      return !1;
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY) && (activeAxis.current = currentAxis), !currentAxis)
      return !0;
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, !0);
  }, []), shouldPrevent = React.useCallback(function(_event) {
    var event = _event;
    if (!(!lockStack.length || lockStack[lockStack.length - 1] !== Style2)) {
      var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event), sourceEvent = shouldPreventQueue.current.filter(function(e) {
        return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare(e.delta, delta);
      })[0];
      if (sourceEvent && sourceEvent.should) {
        event.cancelable && event.preventDefault();
        return;
      }
      if (!sourceEvent) {
        var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
          return node.contains(event.target);
        }), shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
        shouldStop && event.cancelable && event.preventDefault();
      }
    }
  }, []), shouldCancel = React.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event), setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e) {
        return e !== event;
      });
    }, 1);
  }, []), scrollTouchStart = React.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event), activeAxis.current = void 0;
  }, []), scrollWheel = React.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []), scrollTouchMove = React.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React.useEffect(function() {
    return lockStack.push(Style2), props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    }), document.addEventListener("wheel", shouldPrevent, nonPassive), document.addEventListener("touchmove", shouldPrevent, nonPassive), document.addEventListener("touchstart", scrollTouchStart, nonPassive), function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      }), document.removeEventListener("wheel", shouldPrevent, nonPassive), document.removeEventListener("touchmove", shouldPrevent, nonPassive), document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React.createElement(
    React.Fragment,
    null,
    inert ? React.createElement(Style2, { styles: generateStyle(id) }) : null,
    removeScrollBar ? React.createElement(RemoveScrollBar, { gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  for (var shadowParent = null; node !== null; )
    node instanceof ShadowRoot && (shadowParent = node.host, node = node.host), node = node.parentNode;
  return shadowParent;
}
const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = React.forwardRef(function(props, ref) {
  return React.createElement(RemoveScroll$1, __assign({}, props, { ref, sideCar: SideCar }));
});
ReactRemoveScroll.classNames = RemoveScroll$1.classNames;
const RemoveScroll = ReactRemoveScroll;
function keys(object) {
  return Object.keys(object);
}
function isObject(item) {
  return item && typeof item == "object" && !Array.isArray(item);
}
function deepMerge(target, source) {
  const result = { ...target }, _source = source;
  return isObject(target) && isObject(source) && Object.keys(source).forEach((key) => {
    isObject(_source[key]) && key in target ? result[key] = deepMerge(result[key], _source[key]) : result[key] = _source[key];
  }), result;
}
function camelToKebabCase(value) {
  return value.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`);
}
function getTransformedScaledValue(value) {
  return typeof value != "string" || !value.includes("var(--mantine-scale)") ? value : value.match(/^calc\((.*?)\)$/)?.[1].split("*")[0].trim();
}
function px(value) {
  const transformedValue = getTransformedScaledValue(value);
  return typeof transformedValue == "number" ? transformedValue : typeof transformedValue == "string" ? transformedValue.includes("calc") || transformedValue.includes("var") ? transformedValue : transformedValue.includes("px") ? Number(transformedValue.replace("px", "")) : transformedValue.includes("rem") ? Number(transformedValue.replace("rem", "")) * 16 : transformedValue.includes("em") ? Number(transformedValue.replace("em", "")) * 16 : Number(transformedValue) : NaN;
}
function scaleRem(remValue) {
  return remValue === "0rem" ? "0rem" : `calc(${remValue} * var(--mantine-scale))`;
}
function createConverter(units, { shouldScale = !1 } = {}) {
  function converter(value) {
    if (value === 0 || value === "0")
      return `0${units}`;
    if (typeof value == "number") {
      const val = `${value / 16}${units}`;
      return shouldScale ? scaleRem(val) : val;
    }
    if (typeof value == "string") {
      if (value === "" || value.startsWith("calc(") || value.startsWith("clamp(") || value.includes("rgba("))
        return value;
      if (value.includes(","))
        return value.split(",").map((val) => converter(val)).join(",");
      if (value.includes(" "))
        return value.split(" ").map((val) => converter(val)).join(" ");
      if (value.includes(units))
        return shouldScale ? scaleRem(value) : value;
      const replaced = value.replace("px", "");
      if (!Number.isNaN(Number(replaced))) {
        const val = `${Number(replaced) / 16}${units}`;
        return shouldScale ? scaleRem(val) : val;
      }
    }
    return value;
  }
  return converter;
}
const rem = createConverter("rem", { shouldScale: !0 }), em = createConverter("em");
function filterProps(props) {
  return Object.keys(props).reduce((acc, key) => (props[key] !== void 0 && (acc[key] = props[key]), acc), {});
}
function isNumberLike(value) {
  if (typeof value == "number")
    return !0;
  if (typeof value == "string") {
    if (value.startsWith("calc(") || value.startsWith("var(") || value.includes(" ") && value.trim() !== "")
      return !0;
    const cssUnitsRegex = /^[+-]?[0-9]+(\.[0-9]+)?(px|em|rem|ex|ch|lh|rlh|vw|vh|vmin|vmax|vb|vi|svw|svh|lvw|lvh|dvw|dvh|cm|mm|in|pt|pc|q|cqw|cqh|cqi|cqb|cqmin|cqmax|%)?$/;
    return value.trim().split(/\s+/).every((val) => cssUnitsRegex.test(val));
  }
  return !1;
}
function isElement$1(value) {
  return Array.isArray(value) || value === null ? !1 : typeof value == "object" ? value.type !== Fragment : !1;
}
function createSafeContext(errorMessage) {
  const Context = createContext(null);
  return [({ children, value }) => /* @__PURE__ */ jsx(Context.Provider, { value, children }), () => {
    const ctx = useContext(Context);
    if (ctx === null)
      throw new Error(errorMessage);
    return ctx;
  }];
}
function createOptionalContext(initialValue = null) {
  const Context = createContext(initialValue);
  return [({ children, value }) => /* @__PURE__ */ jsx(Context.Provider, { value, children }), () => useContext(Context)];
}
function getSafeId(uid, errorMessage) {
  return (value) => {
    if (typeof value != "string" || value.trim().length === 0)
      throw new Error(errorMessage);
    return `${uid}-${value}`;
  };
}
function findElementAncestor(element, selector) {
  let _element = element;
  for (; (_element = _element.parentElement) && !_element.matches(selector); )
    ;
  return _element;
}
function getPreviousIndex$1(current, elements, loop) {
  for (let i = current - 1; i >= 0; i -= 1)
    if (!elements[i].disabled)
      return i;
  if (loop) {
    for (let i = elements.length - 1; i > -1; i -= 1)
      if (!elements[i].disabled)
        return i;
  }
  return current;
}
function getNextIndex$1(current, elements, loop) {
  for (let i = current + 1; i < elements.length; i += 1)
    if (!elements[i].disabled)
      return i;
  if (loop) {
    for (let i = 0; i < elements.length; i += 1)
      if (!elements[i].disabled)
        return i;
  }
  return current;
}
function onSameLevel(target, sibling, parentSelector) {
  return findElementAncestor(target, parentSelector) === findElementAncestor(sibling, parentSelector);
}
function createScopedKeydownHandler({
  parentSelector,
  siblingSelector,
  onKeyDown,
  loop = !0,
  activateOnFocus = !1,
  dir = "rtl",
  orientation
}) {
  return (event) => {
    onKeyDown?.(event);
    const elements = Array.from(
      findElementAncestor(event.currentTarget, parentSelector)?.querySelectorAll(
        siblingSelector
      ) || []
    ).filter((node) => onSameLevel(event.currentTarget, node, parentSelector)), current = elements.findIndex((el) => event.currentTarget === el), _nextIndex = getNextIndex$1(current, elements, loop), _previousIndex = getPreviousIndex$1(current, elements, loop), nextIndex = dir === "rtl" ? _previousIndex : _nextIndex, previousIndex = dir === "rtl" ? _nextIndex : _previousIndex;
    switch (event.key) {
      case "ArrowRight": {
        orientation === "horizontal" && (event.stopPropagation(), event.preventDefault(), elements[nextIndex].focus(), activateOnFocus && elements[nextIndex].click());
        break;
      }
      case "ArrowLeft": {
        orientation === "horizontal" && (event.stopPropagation(), event.preventDefault(), elements[previousIndex].focus(), activateOnFocus && elements[previousIndex].click());
        break;
      }
      case "ArrowUp": {
        orientation === "vertical" && (event.stopPropagation(), event.preventDefault(), elements[_previousIndex].focus(), activateOnFocus && elements[_previousIndex].click());
        break;
      }
      case "ArrowDown": {
        orientation === "vertical" && (event.stopPropagation(), event.preventDefault(), elements[_nextIndex].focus(), activateOnFocus && elements[_nextIndex].click());
        break;
      }
      case "Home": {
        event.stopPropagation(), event.preventDefault(), !elements[0].disabled && elements[0].focus();
        break;
      }
      case "End": {
        event.stopPropagation(), event.preventDefault();
        const last = elements.length - 1;
        !elements[last].disabled && elements[last].focus();
        break;
      }
    }
  };
}
const elevations = {
  app: 100,
  modal: 200,
  popover: 300,
  overlay: 400,
  max: 9999
};
function getDefaultZIndex(level) {
  return elevations[level];
}
const noop = () => {
};
function closeOnEscape(callback, options = { active: !0 }) {
  return typeof callback != "function" || !options.active ? options.onKeyDown || noop : (event) => {
    event.key === "Escape" && (callback(event), options.onTrigger?.());
  };
}
function getSize(size2, prefix = "size", convertToRem = !0) {
  if (size2 !== void 0)
    return isNumberLike(size2) ? convertToRem ? rem(size2) : size2 : `var(--${prefix}-${size2})`;
}
function getSpacing(size2) {
  return getSize(size2, "mantine-spacing");
}
function getRadius(size2) {
  return size2 === void 0 ? "var(--mantine-radius-default)" : getSize(size2, "mantine-radius");
}
function getFontSize(size2) {
  return getSize(size2, "mantine-font-size");
}
function getLineHeight(size2) {
  return getSize(size2, "mantine-line-height", !1);
}
function getShadow(size2) {
  if (size2)
    return getSize(size2, "mantine-shadow", !1);
}
function createEventHandler(parentEventHandler, eventHandler) {
  return (event) => {
    parentEventHandler?.(event), eventHandler?.(event);
  };
}
function getBreakpointValue$2(breakpoint, breakpoints) {
  return breakpoint in breakpoints ? px(breakpoints[breakpoint]) : px(breakpoint);
}
function getSortedBreakpoints(values2, breakpoints) {
  const convertedBreakpoints = values2.map((breakpoint) => ({
    value: breakpoint,
    px: getBreakpointValue$2(breakpoint, breakpoints)
  }));
  return convertedBreakpoints.sort((a, b) => a.px - b.px), convertedBreakpoints;
}
function getBaseValue$1(value) {
  return typeof value == "object" && value !== null ? "base" in value ? value.base : void 0 : value;
}
function getContextItemIndex(elementSelector, parentSelector, node) {
  return node ? Array.from(
    findElementAncestor(node, parentSelector)?.querySelectorAll(elementSelector) || []
  ).findIndex((element) => element === node) : null;
}
function useHovered() {
  const [hovered, setHovered] = useState(-1);
  return [hovered, { setHovered, resetHovered: () => setHovered(-1) }];
}
function clamp$2(value, min2, max2) {
  return min2 === void 0 && max2 === void 0 ? value : min2 !== void 0 && max2 === void 0 ? Math.max(value, min2) : Math.min(min2 === void 0 && max2 !== void 0 ? value : Math.max(value, min2), max2);
}
function randomId() {
  return `mantine-${Math.random().toString(36).slice(2, 11)}`;
}
function useCallbackRef(callback) {
  const callbackRef = useRef(callback);
  return useEffect(() => {
    callbackRef.current = callback;
  }), useMemo(() => (...args) => callbackRef.current?.(...args), []);
}
function useDebouncedCallback(callback, delay) {
  const handleCallback = useCallbackRef(callback), debounceTimerRef = useRef(0);
  return useEffect(() => () => window.clearTimeout(debounceTimerRef.current), []), useCallback(
    (...args) => {
      window.clearTimeout(debounceTimerRef.current), debounceTimerRef.current = window.setTimeout(() => handleCallback(...args), delay);
    },
    [handleCallback, delay]
  );
}
const DEFAULT_EVENTS = ["mousedown", "touchstart"];
function useClickOutside(handler, events, nodes) {
  const ref = useRef();
  return useEffect(() => {
    const listener = (event) => {
      const { target } = event ?? {};
      if (Array.isArray(nodes)) {
        const shouldIgnore = target?.hasAttribute("data-ignore-outside-clicks") || !document.body.contains(target) && target.tagName !== "HTML";
        nodes.every((node) => !!node && !event.composedPath().includes(node)) && !shouldIgnore && handler();
      } else ref.current && !ref.current.contains(target) && handler();
    };
    return (events || DEFAULT_EVENTS).forEach((fn) => document.addEventListener(fn, listener)), () => {
      (events || DEFAULT_EVENTS).forEach((fn) => document.removeEventListener(fn, listener));
    };
  }, [ref, handler, nodes]), ref;
}
function useClipboard({ timeout = 2e3 } = {}) {
  const [error, setError] = useState(null), [copied, setCopied] = useState(!1), [copyTimeout, setCopyTimeout] = useState(null), handleCopyResult = (value) => {
    window.clearTimeout(copyTimeout), setCopyTimeout(window.setTimeout(() => setCopied(!1), timeout)), setCopied(value);
  };
  return { copy: (valueToCopy) => {
    "clipboard" in navigator ? navigator.clipboard.writeText(valueToCopy).then(() => handleCopyResult(!0)).catch((err) => setError(err)) : setError(new Error("useClipboard: navigator.clipboard is not supported"));
  }, reset: () => {
    setCopied(!1), setError(null), window.clearTimeout(copyTimeout);
  }, error, copied };
}
function attachMediaListener(query, callback) {
  try {
    return query.addEventListener("change", callback), () => query.removeEventListener("change", callback);
  } catch {
    return query.addListener(callback), () => query.removeListener(callback);
  }
}
function getInitialValue(query, initialValue) {
  return typeof window < "u" && "matchMedia" in window ? window.matchMedia(query).matches : !1;
}
function useMediaQuery(query, initialValue, { getInitialValueInEffect } = {
  getInitialValueInEffect: !0
}) {
  const [matches, setMatches] = useState(
    getInitialValueInEffect ? initialValue : getInitialValue(query)
  ), queryRef = useRef();
  return useEffect(() => {
    if ("matchMedia" in window)
      return queryRef.current = window.matchMedia(query), setMatches(queryRef.current.matches), attachMediaListener(queryRef.current, (event) => setMatches(event.matches));
  }, [query]), matches;
}
function useColorScheme(initialValue, options) {
  return useMediaQuery("(prefers-color-scheme: dark)", initialValue === "dark", options) ? "dark" : "light";
}
function useDebouncedValue(value, wait, options = { leading: !1 }) {
  const [_value, setValue] = useState(value), mountedRef = useRef(!1), timeoutRef = useRef(null), cooldownRef = useRef(!1), cancel = () => window.clearTimeout(timeoutRef.current);
  return useEffect(() => {
    mountedRef.current && (!cooldownRef.current && options.leading ? (cooldownRef.current = !0, setValue(value)) : (cancel(), timeoutRef.current = window.setTimeout(() => {
      cooldownRef.current = !1, setValue(value);
    }, wait)));
  }, [value, options.leading, wait]), useEffect(() => (mountedRef.current = !0, cancel), []), [_value, cancel];
}
const useIsomorphicEffect = typeof document < "u" ? useLayoutEffect : useEffect;
function useDidUpdate(fn, dependencies) {
  const mounted = useRef(!1);
  useEffect(
    () => () => {
      mounted.current = !1;
    },
    []
  ), useEffect(() => {
    if (mounted.current)
      return fn();
    mounted.current = !0;
  }, dependencies);
}
function useFocusReturn({ opened, shouldReturnFocus = !0 }) {
  const lastActiveElement = useRef(), returnFocus = () => {
    lastActiveElement.current && "focus" in lastActiveElement.current && typeof lastActiveElement.current.focus == "function" && lastActiveElement.current?.focus({ preventScroll: !0 });
  };
  return useDidUpdate(() => {
    let timeout = -1;
    const clearFocusTimeout = (event) => {
      event.key === "Tab" && window.clearTimeout(timeout);
    };
    return document.addEventListener("keydown", clearFocusTimeout), opened ? lastActiveElement.current = document.activeElement : shouldReturnFocus && (timeout = window.setTimeout(returnFocus, 10)), () => {
      window.clearTimeout(timeout), document.removeEventListener("keydown", clearFocusTimeout);
    };
  }, [opened, shouldReturnFocus]), returnFocus;
}
const TABBABLE_NODES = /input|select|textarea|button|object/, FOCUS_SELECTOR = "a, input, select, textarea, button, object, [tabindex]";
function hidden(element) {
  return element.style.display === "none";
}
function visible(element) {
  if (element.getAttribute("aria-hidden") || element.getAttribute("hidden") || element.getAttribute("type") === "hidden")
    return !1;
  let parentElement = element;
  for (; parentElement && !(parentElement === document.body || parentElement.nodeType === 11); ) {
    if (hidden(parentElement))
      return !1;
    parentElement = parentElement.parentNode;
  }
  return !0;
}
function getElementTabIndex(element) {
  let tabIndex = element.getAttribute("tabindex");
  return tabIndex === null && (tabIndex = void 0), parseInt(tabIndex, 10);
}
function focusable(element) {
  const nodeName = element.nodeName.toLowerCase(), isTabIndexNotNaN = !Number.isNaN(getElementTabIndex(element));
  return /* @ts-expect-error function accepts any html element but if it is a button, it should not be disabled to trigger the condition */ (TABBABLE_NODES.test(nodeName) && !element.disabled || element instanceof HTMLAnchorElement && element.href || isTabIndexNotNaN) && visible(element);
}
function tabbable(element) {
  const tabIndex = getElementTabIndex(element);
  return (Number.isNaN(tabIndex) || tabIndex >= 0) && focusable(element);
}
function findTabbableDescendants(element) {
  return Array.from(element.querySelectorAll(FOCUS_SELECTOR)).filter(tabbable);
}
function scopeTab(node, event) {
  const tabbable2 = findTabbableDescendants(node);
  if (!tabbable2.length) {
    event.preventDefault();
    return;
  }
  const finalTabbable = tabbable2[event.shiftKey ? 0 : tabbable2.length - 1], root = node.getRootNode();
  let leavingFinalTabbable = finalTabbable === root.activeElement || node === root.activeElement;
  const activeElement2 = root.activeElement;
  if (activeElement2.tagName === "INPUT" && activeElement2.getAttribute("type") === "radio" && (leavingFinalTabbable = tabbable2.filter(
    (element) => element.getAttribute("type") === "radio" && element.getAttribute("name") === activeElement2.getAttribute("name")
  ).includes(finalTabbable)), !leavingFinalTabbable)
    return;
  event.preventDefault();
  const target = tabbable2[event.shiftKey ? tabbable2.length - 1 : 0];
  target && target.focus();
}
function useFocusTrap(active = !0) {
  const ref = useRef(), focusNode = (node) => {
    let focusElement = node.querySelector("[data-autofocus]");
    if (!focusElement) {
      const children = Array.from(node.querySelectorAll(FOCUS_SELECTOR));
      focusElement = children.find(tabbable) || children.find(focusable) || null, !focusElement && focusable(node) && (focusElement = node);
    }
    focusElement && focusElement.focus({ preventScroll: !0 });
  }, setRef = useCallback(
    (node) => {
      active && node !== null && ref.current !== node && (node ? (setTimeout(() => {
        node.getRootNode() && focusNode(node);
      }), ref.current = node) : ref.current = null);
    },
    [active]
  );
  return useEffect(() => {
    if (!active)
      return;
    ref.current && setTimeout(() => focusNode(ref.current));
    const handleKeyDown = (event) => {
      event.key === "Tab" && ref.current && scopeTab(ref.current, event);
    };
    return document.addEventListener("keydown", handleKeyDown), () => document.removeEventListener("keydown", handleKeyDown);
  }, [active]), setRef;
}
const __useId = React__default.useId || (() => {
});
function useReactId$1() {
  const id = __useId();
  return id ? `mantine-${id.replace(/:/g, "")}` : "";
}
function useId$1(staticId) {
  const reactId = useReactId$1(), [uuid, setUuid] = useState(reactId);
  return useIsomorphicEffect(() => {
    setUuid(randomId());
  }, []), typeof staticId == "string" ? staticId : typeof window > "u" ? reactId : uuid;
}
function useWindowEvent(type, listener, options) {
  useEffect(() => (window.addEventListener(type, listener, options), () => window.removeEventListener(type, listener, options)), [type, listener]);
}
function serializeJSON(value, hookName = "use-local-storage") {
  try {
    return JSON.stringify(value);
  } catch {
    throw new Error(`@mantine/hooks ${hookName}: Failed to serialize the value`);
  }
}
function deserializeJSON(value) {
  try {
    return value && JSON.parse(value);
  } catch {
    return value;
  }
}
function createStorageHandler(type) {
  return { getItem: (key) => {
    try {
      return window[type].getItem(key);
    } catch {
      return console.warn("use-local-storage: Failed to get value from storage, localStorage is blocked"), null;
    }
  }, setItem: (key, value) => {
    try {
      window[type].setItem(key, value);
    } catch {
      console.warn("use-local-storage: Failed to set value to storage, localStorage is blocked");
    }
  }, removeItem: (key) => {
    try {
      window[type].removeItem(key);
    } catch {
      console.warn(
        "use-local-storage: Failed to remove value from storage, localStorage is blocked"
      );
    }
  } };
}
function createStorage(type, hookName) {
  const eventName = "mantine-local-storage", { getItem, setItem, removeItem } = createStorageHandler(type);
  return function({
    key,
    defaultValue,
    getInitialValueInEffect = !0,
    deserialize = deserializeJSON,
    serialize = (value) => serializeJSON(value, hookName)
  }) {
    const readStorageValue = useCallback(
      (skipStorage) => {
        let storageBlockedOrSkipped;
        try {
          storageBlockedOrSkipped = typeof window > "u" || !(type in window) || window[type] === null || !!skipStorage;
        } catch {
          storageBlockedOrSkipped = !0;
        }
        if (storageBlockedOrSkipped)
          return defaultValue;
        const storageValue = getItem(key);
        return storageValue !== null ? deserialize(storageValue) : defaultValue;
      },
      [key, defaultValue]
    ), [value, setValue] = useState(readStorageValue(getInitialValueInEffect)), setStorageValue = useCallback(
      (val) => {
        val instanceof Function ? setValue((current) => {
          const result = val(current);
          return setItem(key, serialize(result)), window.dispatchEvent(
            new CustomEvent(eventName, { detail: { key, value: val(current) } })
          ), result;
        }) : (setItem(key, serialize(val)), window.dispatchEvent(new CustomEvent(eventName, { detail: { key, value: val } })), setValue(val));
      },
      [key]
    ), removeStorageValue = useCallback(() => {
      removeItem(key), window.dispatchEvent(new CustomEvent(eventName, { detail: { key, value: defaultValue } }));
    }, []);
    return useWindowEvent("storage", (event) => {
      event.storageArea === window[type] && event.key === key && setValue(deserialize(event.newValue ?? void 0));
    }), useWindowEvent(eventName, (event) => {
      event.detail.key === key && setValue(event.detail.value);
    }), useEffect(() => {
      defaultValue !== void 0 && value === void 0 && setStorageValue(defaultValue);
    }, [defaultValue, value, setStorageValue]), useEffect(() => {
      const val = readStorageValue();
      val !== void 0 && setStorageValue(val);
    }, []), [value === void 0 ? defaultValue : value, setStorageValue, removeStorageValue];
  };
}
function useLocalStorage(props) {
  return createStorage("localStorage", "use-local-storage")(props);
}
function assignRef(ref, value) {
  typeof ref == "function" ? ref(value) : typeof ref == "object" && ref !== null && "current" in ref && (ref.current = value);
}
function mergeRefs(...refs) {
  return (node) => {
    refs.forEach((ref) => assignRef(ref, node));
  };
}
function useMergedRef(...refs) {
  return useCallback(mergeRefs(...refs), refs);
}
function clampUseMovePosition(position) {
  return {
    x: clamp$2(position.x, 0, 1),
    y: clamp$2(position.y, 0, 1)
  };
}
function useMove(onChange, handlers, dir = "ltr") {
  const ref = useRef(null), mounted = useRef(!1), isSliding = useRef(!1), frame = useRef(0), [active, setActive] = useState(!1);
  return useEffect(() => {
    mounted.current = !0;
  }, []), useEffect(() => {
    const onScrub = ({ x, y }) => {
      cancelAnimationFrame(frame.current), frame.current = requestAnimationFrame(() => {
        if (mounted.current && ref.current) {
          ref.current.style.userSelect = "none";
          const rect = ref.current.getBoundingClientRect();
          if (rect.width && rect.height) {
            const _x = clamp$2((x - rect.left) / rect.width, 0, 1);
            onChange({
              x: dir === "ltr" ? _x : 1 - _x,
              y: clamp$2((y - rect.top) / rect.height, 0, 1)
            });
          }
        }
      });
    }, bindEvents = () => {
      document.addEventListener("mousemove", onMouseMove), document.addEventListener("mouseup", stopScrubbing), document.addEventListener("touchmove", onTouchMove), document.addEventListener("touchend", stopScrubbing);
    }, unbindEvents = () => {
      document.removeEventListener("mousemove", onMouseMove), document.removeEventListener("mouseup", stopScrubbing), document.removeEventListener("touchmove", onTouchMove), document.removeEventListener("touchend", stopScrubbing);
    }, startScrubbing = () => {
      !isSliding.current && mounted.current && (isSliding.current = !0, typeof handlers?.onScrubStart == "function" && handlers.onScrubStart(), setActive(!0), bindEvents());
    }, stopScrubbing = () => {
      isSliding.current && mounted.current && (isSliding.current = !1, setActive(!1), unbindEvents(), setTimeout(() => {
        typeof handlers?.onScrubEnd == "function" && handlers.onScrubEnd();
      }, 0));
    }, onMouseDown = (event) => {
      startScrubbing(), event.preventDefault(), onMouseMove(event);
    }, onMouseMove = (event) => onScrub({ x: event.clientX, y: event.clientY }), onTouchStart = (event) => {
      event.cancelable && event.preventDefault(), startScrubbing(), onTouchMove(event);
    }, onTouchMove = (event) => {
      event.cancelable && event.preventDefault(), onScrub({ x: event.changedTouches[0].clientX, y: event.changedTouches[0].clientY });
    };
    return ref.current?.addEventListener("mousedown", onMouseDown), ref.current?.addEventListener("touchstart", onTouchStart, { passive: !1 }), () => {
      ref.current && (ref.current.removeEventListener("mousedown", onMouseDown), ref.current.removeEventListener("touchstart", onTouchStart));
    };
  }, [dir, onChange]), { ref, active };
}
function useUncontrolled({
  value,
  defaultValue,
  finalValue,
  onChange = () => {
  }
}) {
  const [uncontrolledValue, setUncontrolledValue] = useState(
    defaultValue !== void 0 ? defaultValue : finalValue
  ), handleUncontrolledChange = (val, ...payload) => {
    setUncontrolledValue(val), onChange?.(val, ...payload);
  };
  return value !== void 0 ? [value, onChange, !0] : [uncontrolledValue, handleUncontrolledChange, !1];
}
function useReducedMotion(initialValue, options) {
  return useMediaQuery("(prefers-reduced-motion: reduce)", initialValue, options);
}
const defaultState = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  top: 0,
  left: 0,
  bottom: 0,
  right: 0
};
function useResizeObserver$1(options) {
  const frameID = useRef(0), ref = useRef(null), [rect, setRect] = useState(defaultState), observer = useMemo(
    () => typeof window < "u" ? new ResizeObserver((entries) => {
      const entry = entries[0];
      entry && (cancelAnimationFrame(frameID.current), frameID.current = requestAnimationFrame(() => {
        ref.current && setRect(entry.contentRect);
      }));
    }) : null,
    []
  );
  return useEffect(() => (ref.current && observer?.observe(ref.current, options), () => {
    observer?.disconnect(), frameID.current && cancelAnimationFrame(frameID.current);
  }), [ref.current]), [ref, rect];
}
function useElementSize(options) {
  const [ref, { width, height }] = useResizeObserver$1(options);
  return { ref, width, height };
}
const eventListerOptions = {
  passive: !0
};
function useViewportSize() {
  const [windowSize, setWindowSize] = useState({
    width: 0,
    height: 0
  }), setSize = useCallback(() => {
    setWindowSize({ width: window.innerWidth || 0, height: window.innerHeight || 0 });
  }, []);
  return useWindowEvent("resize", setSize, eventListerOptions), useWindowEvent("orientationchange", setSize, eventListerOptions), useEffect(setSize, []), windowSize;
}
function parseHotkey(hotkey) {
  const keys2 = hotkey.toLowerCase().split("+").map((part) => part.trim()), modifiers = {
    alt: keys2.includes("alt"),
    ctrl: keys2.includes("ctrl"),
    meta: keys2.includes("meta"),
    mod: keys2.includes("mod"),
    shift: keys2.includes("shift"),
    plus: keys2.includes("[plus]")
  }, reservedKeys = ["alt", "ctrl", "meta", "shift", "mod"], freeKey = keys2.find((key) => !reservedKeys.includes(key));
  return {
    ...modifiers,
    key: freeKey === "[plus]" ? "+" : freeKey
  };
}
function isExactHotkey(hotkey, event) {
  const { alt, ctrl, meta, mod, shift: shift2, key } = hotkey, { altKey, ctrlKey, metaKey, shiftKey, key: pressedKey } = event;
  if (alt !== altKey)
    return !1;
  if (mod) {
    if (!ctrlKey && !metaKey)
      return !1;
  } else if (ctrl !== ctrlKey || meta !== metaKey)
    return !1;
  return shift2 !== shiftKey ? !1 : !!(key && (pressedKey.toLowerCase() === key.toLowerCase() || event.code.replace("Key", "").toLowerCase() === key.toLowerCase()));
}
function getHotkeyMatcher(hotkey) {
  return (event) => isExactHotkey(parseHotkey(hotkey), event);
}
function shouldFireEvent(event, tagsToIgnore, triggerOnContentEditable = !1) {
  return event.target instanceof HTMLElement ? (triggerOnContentEditable || !event.target.isContentEditable) && !tagsToIgnore.includes(event.target.tagName) : !0;
}
function useHotkeys(hotkeys, tagsToIgnore = ["INPUT", "TEXTAREA", "SELECT"], triggerOnContentEditable = !1) {
  useEffect(() => {
    const keydownListener = (event) => {
      hotkeys.forEach(([hotkey, handler, options = { preventDefault: !0 }]) => {
        getHotkeyMatcher(hotkey)(event) && shouldFireEvent(event, tagsToIgnore, triggerOnContentEditable) && (options.preventDefault && event.preventDefault(), handler(event));
      });
    };
    return document.documentElement.addEventListener("keydown", keydownListener), () => document.documentElement.removeEventListener("keydown", keydownListener);
  }, [hotkeys]);
}
function useHover$1() {
  const [hovered, setHovered] = useState(!1), ref = useRef(null), onMouseEnter = useCallback(() => setHovered(!0), []), onMouseLeave = useCallback(() => setHovered(!1), []);
  return useEffect(() => {
    if (ref.current)
      return ref.current.addEventListener("mouseenter", onMouseEnter), ref.current.addEventListener("mouseleave", onMouseLeave), () => {
        ref.current?.removeEventListener("mouseenter", onMouseEnter), ref.current?.removeEventListener("mouseleave", onMouseLeave);
      };
  }, [ref.current]), { ref, hovered };
}
function useDisclosure(initialState = !1, callbacks) {
  const { onOpen, onClose } = callbacks || {}, [opened, setOpened] = useState(initialState), open = useCallback(() => {
    setOpened((isOpened) => isOpened || (onOpen?.(), !0));
  }, [onOpen]), close = useCallback(() => {
    setOpened((isOpened) => isOpened && (onClose?.(), !1));
  }, [onClose]), toggle = useCallback(() => {
    opened ? close() : open();
  }, [close, open, opened]);
  return [opened, { open, close, toggle }];
}
function useTimeout(callback, delay, options = { autoInvoke: !1 }) {
  const timeoutRef = useRef(null), start = useCallback(
    (...callbackParams) => {
      timeoutRef.current || (timeoutRef.current = window.setTimeout(() => {
        callback(callbackParams), timeoutRef.current = null;
      }, delay));
    },
    [delay]
  ), clear = useCallback(() => {
    timeoutRef.current && (window.clearTimeout(timeoutRef.current), timeoutRef.current = null);
  }, []);
  return useEffect(() => (options.autoInvoke && start(), clear), [clear, start]), { start, clear };
}
function usePrevious(value) {
  const ref = useRef();
  return useEffect(() => {
    ref.current = value;
  }, [value]), ref.current;
}
function useInViewport() {
  const observer = useRef(null), [inViewport, setInViewport] = useState(!1);
  return { ref: useCallback((node) => {
    typeof IntersectionObserver < "u" && (node && !observer.current ? observer.current = new IntersectionObserver(
      ([entry]) => setInViewport(entry.isIntersecting)
    ) : observer.current?.disconnect(), node ? observer.current?.observe(node) : setInViewport(!1));
  }, []), inViewport };
}
function useMutationObserver(callback, options, target) {
  const observer = useRef(), ref = useRef(null);
  return useEffect(() => {
    const targetElement = typeof target == "function" ? target() : target;
    return (targetElement || ref.current) && (observer.current = new MutationObserver(callback), observer.current.observe(targetElement || ref.current, options)), () => {
      observer.current?.disconnect();
    };
  }, [callback, options]), ref;
}
function useMounted() {
  const [mounted, setMounted] = useState(!1);
  return useEffect(() => setMounted(!0), []), mounted;
}
function useStateHistory(initialValue) {
  const [state, setState] = useState({
    history: [initialValue],
    current: 0
  }), set = useCallback(
    (val) => setState((currentState) => {
      const nextState = [...currentState.history.slice(0, currentState.current + 1), val];
      return {
        history: nextState,
        current: nextState.length - 1
      };
    }),
    []
  ), back = useCallback(
    (steps = 1) => setState((currentState) => ({
      history: currentState.history,
      current: Math.max(0, currentState.current - steps)
    })),
    []
  ), forward = useCallback(
    (steps = 1) => setState((currentState) => ({
      history: currentState.history,
      current: Math.min(currentState.history.length - 1, currentState.current + steps)
    })),
    []
  ), reset = useCallback(() => {
    setState({ history: [initialValue], current: 0 });
  }, [initialValue]), handlers = useMemo(() => ({ back, forward, reset, set }), [back, forward, reset, set]);
  return [state.history[state.current], handlers, state];
}
function getEnv() {
  return typeof process < "u" && process.env ? "production" : "development";
}
function memoize(func) {
  const cache = /* @__PURE__ */ new Map();
  return (...args) => {
    const key = JSON.stringify(args);
    if (cache.has(key))
      return cache.get(key);
    const result = func(...args);
    return cache.set(key, result), result;
  };
}
function findClosestNumber(value, numbers) {
  return numbers.length === 0 ? value : numbers.reduce(
    (prev, curr) => Math.abs(curr - value) < Math.abs(prev - value) ? curr : prev
  );
}
function getRefProp(element) {
  const version = React__default.version;
  return typeof React__default.version != "string" || version.startsWith("18.") ? element?.ref : element?.props?.ref;
}
function r(e) {
  var t, f, n = "";
  if (typeof e == "string" || typeof e == "number") n += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  } else for (f in e) e[f] && (n && (n += " "), n += f);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
const EMPTY_CLASS_NAMES = {};
function mergeClassNames(objects) {
  const merged = {};
  return objects.forEach((obj) => {
    Object.entries(obj).forEach(([key, value]) => {
      merged[key] ? merged[key] = clsx(merged[key], value) : merged[key] = value;
    });
  }), merged;
}
function resolveClassNames({ theme, classNames, props, stylesCtx }) {
  const resolvedClassNames = (Array.isArray(classNames) ? classNames : [classNames]).map(
    (item) => typeof item == "function" ? item(theme, props, stylesCtx) : item || EMPTY_CLASS_NAMES
  );
  return mergeClassNames(resolvedClassNames);
}
function resolveStyles({ theme, styles, props, stylesCtx }) {
  return (Array.isArray(styles) ? styles : [styles]).reduce((acc, style) => typeof style == "function" ? { ...acc, ...style(theme, props, stylesCtx) } : { ...acc, ...style }, {});
}
const MantineContext = createContext(null);
function useMantineContext() {
  const ctx = useContext(MantineContext);
  if (!ctx)
    throw new Error("[@mantine/core] MantineProvider was not found in tree");
  return ctx;
}
function useMantineCssVariablesResolver() {
  return useMantineContext().cssVariablesResolver;
}
function useMantineClassNamesPrefix() {
  return useMantineContext().classNamesPrefix;
}
function useMantineStyleNonce() {
  return useMantineContext().getStyleNonce;
}
function useMantineWithStaticClasses() {
  return useMantineContext().withStaticClasses;
}
function useMantineIsHeadless() {
  return useMantineContext().headless;
}
function useMantineSxTransform() {
  return useMantineContext().stylesTransform?.sx;
}
function useMantineStylesTransform() {
  return useMantineContext().stylesTransform?.styles;
}
function isHexColor(hex) {
  return /^#?([0-9A-F]{3}){1,2}([0-9A-F]{2})?$/i.test(hex);
}
function hexToRgba(color) {
  let hexString = color.replace("#", "");
  if (hexString.length === 3) {
    const shorthandHex = hexString.split("");
    hexString = [
      shorthandHex[0],
      shorthandHex[0],
      shorthandHex[1],
      shorthandHex[1],
      shorthandHex[2],
      shorthandHex[2]
    ].join("");
  }
  if (hexString.length === 8) {
    const alpha2 = parseInt(hexString.slice(6, 8), 16) / 255;
    return {
      r: parseInt(hexString.slice(0, 2), 16),
      g: parseInt(hexString.slice(2, 4), 16),
      b: parseInt(hexString.slice(4, 6), 16),
      a: alpha2
    };
  }
  const parsed = parseInt(hexString, 16), r2 = parsed >> 16 & 255, g = parsed >> 8 & 255, b = parsed & 255;
  return {
    r: r2,
    g,
    b,
    a: 1
  };
}
function rgbStringToRgba(color) {
  const [r2, g, b, a] = color.replace(/[^0-9,./]/g, "").split(/[/,]/).map(Number);
  return { r: r2, g, b, a: a || 1 };
}
function hslStringToRgba(hslaString) {
  const hslaRegex = /^hsla?\(\s*(\d+)\s*,\s*(\d+%)\s*,\s*(\d+%)\s*(,\s*(0?\.\d+|\d+(\.\d+)?))?\s*\)$/i, matches = hslaString.match(hslaRegex);
  if (!matches)
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 1
    };
  const h = parseInt(matches[1], 10), s = parseInt(matches[2], 10) / 100, l = parseInt(matches[3], 10) / 100, a = matches[5] ? parseFloat(matches[5]) : void 0, chroma = (1 - Math.abs(2 * l - 1)) * s, huePrime = h / 60, x = chroma * (1 - Math.abs(huePrime % 2 - 1)), m = l - chroma / 2;
  let r2, g, b;
  return huePrime >= 0 && huePrime < 1 ? (r2 = chroma, g = x, b = 0) : huePrime >= 1 && huePrime < 2 ? (r2 = x, g = chroma, b = 0) : huePrime >= 2 && huePrime < 3 ? (r2 = 0, g = chroma, b = x) : huePrime >= 3 && huePrime < 4 ? (r2 = 0, g = x, b = chroma) : huePrime >= 4 && huePrime < 5 ? (r2 = x, g = 0, b = chroma) : (r2 = chroma, g = 0, b = x), {
    r: Math.round((r2 + m) * 255),
    g: Math.round((g + m) * 255),
    b: Math.round((b + m) * 255),
    a: a || 1
  };
}
function toRgba(color) {
  return isHexColor(color) ? hexToRgba(color) : color.startsWith("rgb") ? rgbStringToRgba(color) : color.startsWith("hsl") ? hslStringToRgba(color) : {
    r: 0,
    g: 0,
    b: 0,
    a: 1
  };
}
function darken(color, alpha2) {
  if (color.startsWith("var("))
    return `color-mix(in srgb, ${color}, black ${alpha2 * 100}%)`;
  const { r: r2, g, b, a } = toRgba(color), f = 1 - alpha2, dark = (input) => Math.round(input * f);
  return `rgba(${dark(r2)}, ${dark(g)}, ${dark(b)}, ${a})`;
}
function getPrimaryShade(theme, colorScheme) {
  return typeof theme.primaryShade == "number" ? theme.primaryShade : colorScheme === "dark" ? theme.primaryShade.dark : theme.primaryShade.light;
}
function gammaCorrect(c) {
  return c <= 0.03928 ? c / 12.92 : ((c + 0.055) / 1.055) ** 2.4;
}
function getLightnessFromOklch(oklchColor) {
  const match = oklchColor.match(/oklch\((.*?)%\s/);
  return match ? parseFloat(match[1]) : null;
}
function luminance(color) {
  if (color.startsWith("oklch("))
    return (getLightnessFromOklch(color) || 0) / 100;
  const { r: r2, g, b } = toRgba(color), sR = r2 / 255, sG = g / 255, sB = b / 255, rLinear = gammaCorrect(sR), gLinear = gammaCorrect(sG), bLinear = gammaCorrect(sB);
  return 0.2126 * rLinear + 0.7152 * gLinear + 0.0722 * bLinear;
}
function isLightColor(color, luminanceThreshold = 0.179) {
  return color.startsWith("var(") ? !1 : luminance(color) > luminanceThreshold;
}
function parseThemeColor({
  color,
  theme,
  colorScheme
}) {
  if (typeof color != "string")
    throw new Error(
      `[@mantine/core] Failed to parse color. Expected color to be a string, instead got ${typeof color}`
    );
  if (color === "bright")
    return {
      color,
      value: colorScheme === "dark" ? theme.white : theme.black,
      shade: void 0,
      isThemeColor: !1,
      isLight: isLightColor(
        colorScheme === "dark" ? theme.white : theme.black,
        theme.luminanceThreshold
      ),
      variable: "--mantine-color-bright"
    };
  if (color === "dimmed")
    return {
      color,
      value: colorScheme === "dark" ? theme.colors.dark[2] : theme.colors.gray[7],
      shade: void 0,
      isThemeColor: !1,
      isLight: isLightColor(
        colorScheme === "dark" ? theme.colors.dark[2] : theme.colors.gray[6],
        theme.luminanceThreshold
      ),
      variable: "--mantine-color-dimmed"
    };
  if (color === "white" || color === "black")
    return {
      color,
      value: color === "white" ? theme.white : theme.black,
      shade: void 0,
      isThemeColor: !1,
      isLight: isLightColor(
        color === "white" ? theme.white : theme.black,
        theme.luminanceThreshold
      ),
      variable: `--mantine-color-${color}`
    };
  const [_color, shade] = color.split("."), colorShade = shade ? Number(shade) : void 0, isThemeColor = _color in theme.colors;
  if (isThemeColor) {
    const colorValue = colorShade !== void 0 ? theme.colors[_color][colorShade] : theme.colors[_color][getPrimaryShade(theme, colorScheme || "light")];
    return {
      color: _color,
      value: colorValue,
      shade: colorShade,
      isThemeColor,
      isLight: isLightColor(colorValue, theme.luminanceThreshold),
      variable: shade ? `--mantine-color-${_color}-${colorShade}` : `--mantine-color-${_color}-filled`
    };
  }
  return {
    color,
    value: color,
    isThemeColor,
    isLight: isLightColor(color, theme.luminanceThreshold),
    shade: colorShade,
    variable: void 0
  };
}
function getThemeColor(color, theme) {
  const parsed = parseThemeColor({ color: color || theme.primaryColor, theme });
  return parsed.variable ? `var(${parsed.variable})` : color;
}
function getGradient(gradient, theme) {
  const merged = {
    from: gradient?.from || theme.defaultGradient.from,
    to: gradient?.to || theme.defaultGradient.to,
    deg: gradient?.deg || theme.defaultGradient.deg || 0
  }, fromColor = getThemeColor(merged.from, theme), toColor = getThemeColor(merged.to, theme);
  return `linear-gradient(${merged.deg}deg, ${fromColor} 0%, ${toColor} 100%)`;
}
function rgba(color, alpha2) {
  if (typeof color != "string" || alpha2 > 1 || alpha2 < 0)
    return "rgba(0, 0, 0, 1)";
  if (color.startsWith("var(")) {
    const mixPercentage = (1 - alpha2) * 100;
    return `color-mix(in srgb, ${color}, transparent ${mixPercentage}%)`;
  }
  if (color.startsWith("oklch"))
    return color.includes("/") ? color.replace(/\/\s*[\d.]+\s*\)/, `/ ${alpha2})`) : color.replace(")", ` / ${alpha2})`);
  const { r: r2, g, b } = toRgba(color);
  return `rgba(${r2}, ${g}, ${b}, ${alpha2})`;
}
const alpha = rgba, defaultVariantColorsResolver = ({
  color,
  theme,
  variant,
  gradient,
  autoContrast
}) => {
  const parsed = parseThemeColor({ color, theme }), _autoContrast = typeof autoContrast == "boolean" ? autoContrast : theme.autoContrast;
  if (variant === "filled") {
    const textColor = _autoContrast && parsed.isLight ? "var(--mantine-color-black)" : "var(--mantine-color-white)";
    return parsed.isThemeColor ? parsed.shade === void 0 ? {
      background: `var(--mantine-color-${color}-filled)`,
      hover: `var(--mantine-color-${color}-filled-hover)`,
      color: textColor,
      border: `${rem(1)} solid transparent`
    } : {
      background: `var(--mantine-color-${parsed.color}-${parsed.shade})`,
      hover: `var(--mantine-color-${parsed.color}-${parsed.shade === 9 ? 8 : parsed.shade + 1})`,
      color: textColor,
      border: `${rem(1)} solid transparent`
    } : {
      background: color,
      hover: darken(color, 0.1),
      color: textColor,
      border: `${rem(1)} solid transparent`
    };
  }
  if (variant === "light") {
    if (parsed.isThemeColor) {
      if (parsed.shade === void 0)
        return {
          background: `var(--mantine-color-${color}-light)`,
          hover: `var(--mantine-color-${color}-light-hover)`,
          color: `var(--mantine-color-${color}-light-color)`,
          border: `${rem(1)} solid transparent`
        };
      const parsedColor = theme.colors[parsed.color][parsed.shade];
      return {
        background: rgba(parsedColor, 0.1),
        hover: rgba(parsedColor, 0.12),
        color: `var(--mantine-color-${parsed.color}-${Math.min(parsed.shade, 6)})`,
        border: `${rem(1)} solid transparent`
      };
    }
    return {
      background: rgba(color, 0.1),
      hover: rgba(color, 0.12),
      color,
      border: `${rem(1)} solid transparent`
    };
  }
  if (variant === "outline")
    return parsed.isThemeColor ? parsed.shade === void 0 ? {
      background: "transparent",
      hover: `var(--mantine-color-${color}-outline-hover)`,
      color: `var(--mantine-color-${color}-outline)`,
      border: `${rem(1)} solid var(--mantine-color-${color}-outline)`
    } : {
      background: "transparent",
      hover: rgba(theme.colors[parsed.color][parsed.shade], 0.05),
      color: `var(--mantine-color-${parsed.color}-${parsed.shade})`,
      border: `${rem(1)} solid var(--mantine-color-${parsed.color}-${parsed.shade})`
    } : {
      background: "transparent",
      hover: rgba(color, 0.05),
      color,
      border: `${rem(1)} solid ${color}`
    };
  if (variant === "subtle") {
    if (parsed.isThemeColor) {
      if (parsed.shade === void 0)
        return {
          background: "transparent",
          hover: `var(--mantine-color-${color}-light-hover)`,
          color: `var(--mantine-color-${color}-light-color)`,
          border: `${rem(1)} solid transparent`
        };
      const parsedColor = theme.colors[parsed.color][parsed.shade];
      return {
        background: "transparent",
        hover: rgba(parsedColor, 0.12),
        color: `var(--mantine-color-${parsed.color}-${Math.min(parsed.shade, 6)})`,
        border: `${rem(1)} solid transparent`
      };
    }
    return {
      background: "transparent",
      hover: rgba(color, 0.12),
      color,
      border: `${rem(1)} solid transparent`
    };
  }
  return variant === "transparent" ? parsed.isThemeColor ? parsed.shade === void 0 ? {
    background: "transparent",
    hover: "transparent",
    color: `var(--mantine-color-${color}-light-color)`,
    border: `${rem(1)} solid transparent`
  } : {
    background: "transparent",
    hover: "transparent",
    color: `var(--mantine-color-${parsed.color}-${Math.min(parsed.shade, 6)})`,
    border: `${rem(1)} solid transparent`
  } : {
    background: "transparent",
    hover: "transparent",
    color,
    border: `${rem(1)} solid transparent`
  } : variant === "white" ? parsed.isThemeColor ? parsed.shade === void 0 ? {
    background: "var(--mantine-color-white)",
    hover: darken(theme.white, 0.01),
    color: `var(--mantine-color-${color}-filled)`,
    border: `${rem(1)} solid transparent`
  } : {
    background: "var(--mantine-color-white)",
    hover: darken(theme.white, 0.01),
    color: `var(--mantine-color-${parsed.color}-${parsed.shade})`,
    border: `${rem(1)} solid transparent`
  } : {
    background: "var(--mantine-color-white)",
    hover: darken(theme.white, 0.01),
    color,
    border: `${rem(1)} solid transparent`
  } : variant === "gradient" ? {
    background: getGradient(gradient, theme),
    hover: getGradient(gradient, theme),
    color: "var(--mantine-color-white)",
    border: "none"
  } : variant === "default" ? {
    background: "var(--mantine-color-default)",
    hover: "var(--mantine-color-default-hover)",
    color: "var(--mantine-color-default-color)",
    border: `${rem(1)} solid var(--mantine-color-default-border)`
  } : {};
}, DEFAULT_COLORS = {
  dark: [
    "#C9C9C9",
    "#b8b8b8",
    "#828282",
    "#696969",
    "#424242",
    "#3b3b3b",
    "#2e2e2e",
    "#242424",
    "#1f1f1f",
    "#141414"
  ],
  gray: [
    "#f8f9fa",
    "#f1f3f5",
    "#e9ecef",
    "#dee2e6",
    "#ced4da",
    "#adb5bd",
    "#868e96",
    "#495057",
    "#343a40",
    "#212529"
  ],
  red: [
    "#fff5f5",
    "#ffe3e3",
    "#ffc9c9",
    "#ffa8a8",
    "#ff8787",
    "#ff6b6b",
    "#fa5252",
    "#f03e3e",
    "#e03131",
    "#c92a2a"
  ],
  pink: [
    "#fff0f6",
    "#ffdeeb",
    "#fcc2d7",
    "#faa2c1",
    "#f783ac",
    "#f06595",
    "#e64980",
    "#d6336c",
    "#c2255c",
    "#a61e4d"
  ],
  grape: [
    "#f8f0fc",
    "#f3d9fa",
    "#eebefa",
    "#e599f7",
    "#da77f2",
    "#cc5de8",
    "#be4bdb",
    "#ae3ec9",
    "#9c36b5",
    "#862e9c"
  ],
  violet: [
    "#f3f0ff",
    "#e5dbff",
    "#d0bfff",
    "#b197fc",
    "#9775fa",
    "#845ef7",
    "#7950f2",
    "#7048e8",
    "#6741d9",
    "#5f3dc4"
  ],
  indigo: [
    "#edf2ff",
    "#dbe4ff",
    "#bac8ff",
    "#91a7ff",
    "#748ffc",
    "#5c7cfa",
    "#4c6ef5",
    "#4263eb",
    "#3b5bdb",
    "#364fc7"
  ],
  blue: [
    "#e7f5ff",
    "#d0ebff",
    "#a5d8ff",
    "#74c0fc",
    "#4dabf7",
    "#339af0",
    "#228be6",
    "#1c7ed6",
    "#1971c2",
    "#1864ab"
  ],
  cyan: [
    "#e3fafc",
    "#c5f6fa",
    "#99e9f2",
    "#66d9e8",
    "#3bc9db",
    "#22b8cf",
    "#15aabf",
    "#1098ad",
    "#0c8599",
    "#0b7285"
  ],
  teal: [
    "#e6fcf5",
    "#c3fae8",
    "#96f2d7",
    "#63e6be",
    "#38d9a9",
    "#20c997",
    "#12b886",
    "#0ca678",
    "#099268",
    "#087f5b"
  ],
  green: [
    "#ebfbee",
    "#d3f9d8",
    "#b2f2bb",
    "#8ce99a",
    "#69db7c",
    "#51cf66",
    "#40c057",
    "#37b24d",
    "#2f9e44",
    "#2b8a3e"
  ],
  lime: [
    "#f4fce3",
    "#e9fac8",
    "#d8f5a2",
    "#c0eb75",
    "#a9e34b",
    "#94d82d",
    "#82c91e",
    "#74b816",
    "#66a80f",
    "#5c940d"
  ],
  yellow: [
    "#fff9db",
    "#fff3bf",
    "#ffec99",
    "#ffe066",
    "#ffd43b",
    "#fcc419",
    "#fab005",
    "#f59f00",
    "#f08c00",
    "#e67700"
  ],
  orange: [
    "#fff4e6",
    "#ffe8cc",
    "#ffd8a8",
    "#ffc078",
    "#ffa94d",
    "#ff922b",
    "#fd7e14",
    "#f76707",
    "#e8590c",
    "#d9480f"
  ]
}, DEFAULT_FONT_FAMILY = "-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji", DEFAULT_THEME = {
  scale: 1,
  fontSmoothing: !0,
  focusRing: "auto",
  white: "#fff",
  black: "#000",
  colors: DEFAULT_COLORS,
  primaryShade: { light: 6, dark: 8 },
  primaryColor: "blue",
  variantColorResolver: defaultVariantColorsResolver,
  autoContrast: !1,
  luminanceThreshold: 0.3,
  fontFamily: DEFAULT_FONT_FAMILY,
  fontFamilyMonospace: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace",
  respectReducedMotion: !1,
  cursorType: "default",
  defaultGradient: { from: "blue", to: "cyan", deg: 45 },
  defaultRadius: "sm",
  activeClassName: "mantine-active",
  focusClassName: "",
  headings: {
    fontFamily: DEFAULT_FONT_FAMILY,
    fontWeight: "700",
    textWrap: "wrap",
    sizes: {
      h1: { fontSize: rem(34), lineHeight: "1.3" },
      h2: { fontSize: rem(26), lineHeight: "1.35" },
      h3: { fontSize: rem(22), lineHeight: "1.4" },
      h4: { fontSize: rem(18), lineHeight: "1.45" },
      h5: { fontSize: rem(16), lineHeight: "1.5" },
      h6: { fontSize: rem(14), lineHeight: "1.5" }
    }
  },
  fontSizes: {
    xs: rem(12),
    sm: rem(14),
    md: rem(16),
    lg: rem(18),
    xl: rem(20)
  },
  lineHeights: {
    xs: "1.4",
    sm: "1.45",
    md: "1.55",
    lg: "1.6",
    xl: "1.65"
  },
  radius: {
    xs: rem(2),
    sm: rem(4),
    md: rem(8),
    lg: rem(16),
    xl: rem(32)
  },
  spacing: {
    xs: rem(10),
    sm: rem(12),
    md: rem(16),
    lg: rem(20),
    xl: rem(32)
  },
  breakpoints: {
    xs: "36em",
    sm: "48em",
    md: "62em",
    lg: "75em",
    xl: "88em"
  },
  shadows: {
    xs: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), 0 ${rem(1)} ${rem(2)} rgba(0, 0, 0, 0.1)`,
    sm: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(10)} ${rem(
      15
    )} ${rem(-5)}, rgba(0, 0, 0, 0.04) 0 ${rem(7)} ${rem(7)} ${rem(-5)}`,
    md: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(20)} ${rem(
      25
    )} ${rem(-5)}, rgba(0, 0, 0, 0.04) 0 ${rem(10)} ${rem(10)} ${rem(-5)}`,
    lg: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(28)} ${rem(
      23
    )} ${rem(-7)}, rgba(0, 0, 0, 0.04) 0 ${rem(12)} ${rem(12)} ${rem(-7)}`,
    xl: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(36)} ${rem(
      28
    )} ${rem(-7)}, rgba(0, 0, 0, 0.04) 0 ${rem(17)} ${rem(17)} ${rem(-7)}`
  },
  other: {},
  components: {}
};
function isMantineColorScheme(value) {
  return value === "auto" || value === "dark" || value === "light";
}
function localStorageColorSchemeManager({
  key = "mantine-color-scheme-value"
} = {}) {
  let handleStorageEvent;
  return {
    get: (defaultValue) => {
      if (typeof window > "u")
        return defaultValue;
      try {
        const storedColorScheme = window.localStorage.getItem(key);
        return isMantineColorScheme(storedColorScheme) ? storedColorScheme : defaultValue;
      } catch {
        return defaultValue;
      }
    },
    set: (value) => {
      try {
        window.localStorage.setItem(key, value);
      } catch (error) {
        console.warn(
          "[@mantine/core] Local storage color scheme manager was unable to save color scheme.",
          error
        );
      }
    },
    subscribe: (onUpdate) => {
      handleStorageEvent = (event) => {
        event.storageArea === window.localStorage && event.key === key && isMantineColorScheme(event.newValue) && onUpdate(event.newValue);
      }, window.addEventListener("storage", handleStorageEvent);
    },
    unsubscribe: () => {
      window.removeEventListener("storage", handleStorageEvent);
    },
    clear: () => {
      window.localStorage.removeItem(key);
    }
  };
}
const INVALID_PRIMARY_COLOR_ERROR = "[@mantine/core] MantineProvider: Invalid theme.primaryColor, it accepts only key of theme.colors, learn more – https://mantine.dev/theming/colors/#primary-color", INVALID_PRIMARY_SHADE_ERROR = "[@mantine/core] MantineProvider: Invalid theme.primaryShade, it accepts only 0-9 integers or an object { light: 0-9, dark: 0-9 }";
function isValidPrimaryShade(shade) {
  return shade < 0 || shade > 9 ? !1 : parseInt(shade.toString(), 10) === shade;
}
function validateMantineTheme(theme) {
  if (!(theme.primaryColor in theme.colors))
    throw new Error(INVALID_PRIMARY_COLOR_ERROR);
  if (typeof theme.primaryShade == "object" && (!isValidPrimaryShade(theme.primaryShade.dark) || !isValidPrimaryShade(theme.primaryShade.light)))
    throw new Error(INVALID_PRIMARY_SHADE_ERROR);
  if (typeof theme.primaryShade == "number" && !isValidPrimaryShade(theme.primaryShade))
    throw new Error(INVALID_PRIMARY_SHADE_ERROR);
}
function mergeMantineTheme(currentTheme, themeOverride) {
  if (!themeOverride)
    return validateMantineTheme(currentTheme), currentTheme;
  const result = deepMerge(currentTheme, themeOverride);
  return themeOverride.fontFamily && !themeOverride.headings?.fontFamily && (result.headings.fontFamily = themeOverride.fontFamily), validateMantineTheme(result), result;
}
const MantineThemeContext = createContext(null), useSafeMantineTheme = () => useContext(MantineThemeContext) || DEFAULT_THEME;
function useMantineTheme() {
  const ctx = useContext(MantineThemeContext);
  if (!ctx)
    throw new Error(
      "@mantine/core: MantineProvider was not found in component tree, make sure you have it in your app"
    );
  return ctx;
}
function MantineThemeProvider({
  theme,
  children,
  inherit = !0
}) {
  const parentTheme = useSafeMantineTheme(), mergedTheme = useMemo(
    () => mergeMantineTheme(inherit ? parentTheme : DEFAULT_THEME, theme),
    [theme, parentTheme, inherit]
  );
  return /* @__PURE__ */ jsx(MantineThemeContext.Provider, { value: mergedTheme, children });
}
MantineThemeProvider.displayName = "@mantine/core/MantineThemeProvider";
function MantineClasses() {
  const theme = useMantineTheme(), nonce = useMantineStyleNonce(), classes2 = keys(theme.breakpoints).reduce((acc, breakpoint) => {
    const isPxBreakpoint = theme.breakpoints[breakpoint].includes("px"), pxValue = px(theme.breakpoints[breakpoint]), maxWidthBreakpoint = isPxBreakpoint ? `${pxValue - 0.1}px` : em(pxValue - 0.1), minWidthBreakpoint = isPxBreakpoint ? `${pxValue}px` : em(pxValue);
    return `${acc}@media (max-width: ${maxWidthBreakpoint}) {.mantine-visible-from-${breakpoint} {display: none !important;}}@media (min-width: ${minWidthBreakpoint}) {.mantine-hidden-from-${breakpoint} {display: none !important;}}`;
  }, "");
  return /* @__PURE__ */ jsx(
    "style",
    {
      "data-mantine-styles": "classes",
      nonce: nonce?.(),
      dangerouslySetInnerHTML: { __html: classes2 }
    }
  );
}
function cssVariablesObjectToString(variables) {
  return Object.entries(variables).map(([name, value]) => `${name}: ${value};`).join("");
}
function wrapWithSelector(selectors, code) {
  return (Array.isArray(selectors) ? selectors : [selectors]).reduce((acc, selector) => `${selector}{${acc}}`, code);
}
function convertCssVariables(input, selector) {
  const sharedVariables = cssVariablesObjectToString(input.variables), shared = sharedVariables ? wrapWithSelector(selector, sharedVariables) : "", dark = cssVariablesObjectToString(input.dark), light = cssVariablesObjectToString(input.light), darkForced = dark ? wrapWithSelector(selector === ":host" ? `${selector}([data-mantine-color-scheme="dark"])` : `${selector}[data-mantine-color-scheme="dark"]`, dark) : "", lightForced = light ? wrapWithSelector(selector === ":host" ? `${selector}([data-mantine-color-scheme="light"])` : `${selector}[data-mantine-color-scheme="light"]`, light) : "";
  return `${shared}${darkForced}${lightForced}`;
}
function getContrastColor({ color, theme, autoContrast }) {
  return (typeof autoContrast == "boolean" ? autoContrast : theme.autoContrast) && parseThemeColor({ color: color || theme.primaryColor, theme }).isLight ? "var(--mantine-color-black)" : "var(--mantine-color-white)";
}
function getPrimaryContrastColor(theme, colorScheme) {
  return getContrastColor({
    color: theme.colors[theme.primaryColor][getPrimaryShade(theme, colorScheme)],
    theme,
    autoContrast: null
  });
}
function getCSSColorVariables({
  theme,
  color,
  colorScheme,
  name = color,
  withColorValues = !0
}) {
  if (!theme.colors[color])
    return {};
  if (colorScheme === "light") {
    const primaryShade2 = getPrimaryShade(theme, "light"), dynamicVariables2 = {
      [`--mantine-color-${name}-text`]: `var(--mantine-color-${name}-filled)`,
      [`--mantine-color-${name}-filled`]: `var(--mantine-color-${name}-${primaryShade2})`,
      [`--mantine-color-${name}-filled-hover`]: `var(--mantine-color-${name}-${primaryShade2 === 9 ? 8 : primaryShade2 + 1})`,
      [`--mantine-color-${name}-light`]: alpha(theme.colors[color][primaryShade2], 0.1),
      [`--mantine-color-${name}-light-hover`]: alpha(theme.colors[color][primaryShade2], 0.12),
      [`--mantine-color-${name}-light-color`]: `var(--mantine-color-${name}-${primaryShade2})`,
      [`--mantine-color-${name}-outline`]: `var(--mantine-color-${name}-${primaryShade2})`,
      [`--mantine-color-${name}-outline-hover`]: alpha(theme.colors[color][primaryShade2], 0.05)
    };
    return withColorValues ? {
      [`--mantine-color-${name}-0`]: theme.colors[color][0],
      [`--mantine-color-${name}-1`]: theme.colors[color][1],
      [`--mantine-color-${name}-2`]: theme.colors[color][2],
      [`--mantine-color-${name}-3`]: theme.colors[color][3],
      [`--mantine-color-${name}-4`]: theme.colors[color][4],
      [`--mantine-color-${name}-5`]: theme.colors[color][5],
      [`--mantine-color-${name}-6`]: theme.colors[color][6],
      [`--mantine-color-${name}-7`]: theme.colors[color][7],
      [`--mantine-color-${name}-8`]: theme.colors[color][8],
      [`--mantine-color-${name}-9`]: theme.colors[color][9],
      ...dynamicVariables2
    } : dynamicVariables2;
  }
  const primaryShade = getPrimaryShade(theme, "dark"), dynamicVariables = {
    [`--mantine-color-${name}-text`]: `var(--mantine-color-${name}-4)`,
    [`--mantine-color-${name}-filled`]: `var(--mantine-color-${name}-${primaryShade})`,
    [`--mantine-color-${name}-filled-hover`]: `var(--mantine-color-${name}-${primaryShade === 9 ? 8 : primaryShade + 1})`,
    [`--mantine-color-${name}-light`]: alpha(
      theme.colors[color][Math.max(0, primaryShade - 2)],
      0.15
    ),
    [`--mantine-color-${name}-light-hover`]: alpha(
      theme.colors[color][Math.max(0, primaryShade - 2)],
      0.2
    ),
    [`--mantine-color-${name}-light-color`]: `var(--mantine-color-${name}-${Math.max(primaryShade - 5, 0)})`,
    [`--mantine-color-${name}-outline`]: `var(--mantine-color-${name}-${Math.max(primaryShade - 4, 0)})`,
    [`--mantine-color-${name}-outline-hover`]: alpha(
      theme.colors[color][Math.max(primaryShade - 4, 0)],
      0.05
    )
  };
  return withColorValues ? {
    [`--mantine-color-${name}-0`]: theme.colors[color][0],
    [`--mantine-color-${name}-1`]: theme.colors[color][1],
    [`--mantine-color-${name}-2`]: theme.colors[color][2],
    [`--mantine-color-${name}-3`]: theme.colors[color][3],
    [`--mantine-color-${name}-4`]: theme.colors[color][4],
    [`--mantine-color-${name}-5`]: theme.colors[color][5],
    [`--mantine-color-${name}-6`]: theme.colors[color][6],
    [`--mantine-color-${name}-7`]: theme.colors[color][7],
    [`--mantine-color-${name}-8`]: theme.colors[color][8],
    [`--mantine-color-${name}-9`]: theme.colors[color][9],
    ...dynamicVariables
  } : dynamicVariables;
}
function isVirtualColor(value) {
  return !!value && typeof value == "object" && "mantine-virtual-color" in value;
}
function assignSizeVariables(variables, sizes2, name) {
  keys(sizes2).forEach(
    (size2) => Object.assign(variables, { [`--mantine-${name}-${size2}`]: sizes2[size2] })
  );
}
const defaultCssVariablesResolver = (theme) => {
  const lightPrimaryShade = getPrimaryShade(theme, "light"), defaultRadius = theme.defaultRadius in theme.radius ? theme.radius[theme.defaultRadius] : rem(theme.defaultRadius), result = {
    variables: {
      "--mantine-scale": theme.scale.toString(),
      "--mantine-cursor-type": theme.cursorType,
      "--mantine-color-scheme": "light dark",
      "--mantine-webkit-font-smoothing": theme.fontSmoothing ? "antialiased" : "unset",
      "--mantine-moz-font-smoothing": theme.fontSmoothing ? "grayscale" : "unset",
      "--mantine-color-white": theme.white,
      "--mantine-color-black": theme.black,
      "--mantine-line-height": theme.lineHeights.md,
      "--mantine-font-family": theme.fontFamily,
      "--mantine-font-family-monospace": theme.fontFamilyMonospace,
      "--mantine-font-family-headings": theme.headings.fontFamily,
      "--mantine-heading-font-weight": theme.headings.fontWeight,
      "--mantine-heading-text-wrap": theme.headings.textWrap,
      "--mantine-radius-default": defaultRadius,
      // Primary colors
      "--mantine-primary-color-filled": `var(--mantine-color-${theme.primaryColor}-filled)`,
      "--mantine-primary-color-filled-hover": `var(--mantine-color-${theme.primaryColor}-filled-hover)`,
      "--mantine-primary-color-light": `var(--mantine-color-${theme.primaryColor}-light)`,
      "--mantine-primary-color-light-hover": `var(--mantine-color-${theme.primaryColor}-light-hover)`,
      "--mantine-primary-color-light-color": `var(--mantine-color-${theme.primaryColor}-light-color)`
    },
    light: {
      "--mantine-primary-color-contrast": getPrimaryContrastColor(theme, "light"),
      "--mantine-color-bright": "var(--mantine-color-black)",
      "--mantine-color-text": theme.black,
      "--mantine-color-body": theme.white,
      "--mantine-color-error": "var(--mantine-color-red-6)",
      "--mantine-color-placeholder": "var(--mantine-color-gray-5)",
      "--mantine-color-anchor": `var(--mantine-color-${theme.primaryColor}-${lightPrimaryShade})`,
      "--mantine-color-default": "var(--mantine-color-white)",
      "--mantine-color-default-hover": "var(--mantine-color-gray-0)",
      "--mantine-color-default-color": "var(--mantine-color-black)",
      "--mantine-color-default-border": "var(--mantine-color-gray-4)",
      "--mantine-color-dimmed": "var(--mantine-color-gray-6)"
    },
    dark: {
      "--mantine-primary-color-contrast": getPrimaryContrastColor(theme, "dark"),
      "--mantine-color-bright": "var(--mantine-color-white)",
      "--mantine-color-text": "var(--mantine-color-dark-0)",
      "--mantine-color-body": "var(--mantine-color-dark-7)",
      "--mantine-color-error": "var(--mantine-color-red-8)",
      "--mantine-color-placeholder": "var(--mantine-color-dark-3)",
      "--mantine-color-anchor": `var(--mantine-color-${theme.primaryColor}-4)`,
      "--mantine-color-default": "var(--mantine-color-dark-6)",
      "--mantine-color-default-hover": "var(--mantine-color-dark-5)",
      "--mantine-color-default-color": "var(--mantine-color-white)",
      "--mantine-color-default-border": "var(--mantine-color-dark-4)",
      "--mantine-color-dimmed": "var(--mantine-color-dark-2)"
    }
  };
  assignSizeVariables(result.variables, theme.breakpoints, "breakpoint"), assignSizeVariables(result.variables, theme.spacing, "spacing"), assignSizeVariables(result.variables, theme.fontSizes, "font-size"), assignSizeVariables(result.variables, theme.lineHeights, "line-height"), assignSizeVariables(result.variables, theme.shadows, "shadow"), assignSizeVariables(result.variables, theme.radius, "radius"), theme.colors[theme.primaryColor].forEach((_, index2) => {
    result.variables[`--mantine-primary-color-${index2}`] = `var(--mantine-color-${theme.primaryColor}-${index2})`;
  }), keys(theme.colors).forEach((color) => {
    const value = theme.colors[color];
    if (isVirtualColor(value)) {
      Object.assign(
        result.light,
        getCSSColorVariables({
          theme,
          name: value.name,
          color: value.light,
          colorScheme: "light",
          withColorValues: !0
        })
      ), Object.assign(
        result.dark,
        getCSSColorVariables({
          theme,
          name: value.name,
          color: value.dark,
          colorScheme: "dark",
          withColorValues: !0
        })
      );
      return;
    }
    value.forEach((shade, index2) => {
      result.variables[`--mantine-color-${color}-${index2}`] = shade;
    }), Object.assign(
      result.light,
      getCSSColorVariables({
        theme,
        color,
        colorScheme: "light",
        withColorValues: !1
      })
    ), Object.assign(
      result.dark,
      getCSSColorVariables({
        theme,
        color,
        colorScheme: "dark",
        withColorValues: !1
      })
    );
  });
  const headings2 = theme.headings.sizes;
  return keys(headings2).forEach((heading) => {
    result.variables[`--mantine-${heading}-font-size`] = headings2[heading].fontSize, result.variables[`--mantine-${heading}-line-height`] = headings2[heading].lineHeight, result.variables[`--mantine-${heading}-font-weight`] = headings2[heading].fontWeight || theme.headings.fontWeight;
  }), result;
};
function getMergedVariables({ theme, generator }) {
  const defaultResolver = defaultCssVariablesResolver(theme), providerGenerator = generator?.(theme);
  return providerGenerator ? deepMerge(defaultResolver, providerGenerator) : defaultResolver;
}
const defaultCssVariables = defaultCssVariablesResolver(DEFAULT_THEME);
function removeDefaultVariables(input) {
  const cleaned = {
    variables: {},
    light: {},
    dark: {}
  };
  return keys(input.variables).forEach((key) => {
    defaultCssVariables.variables[key] !== input.variables[key] && (cleaned.variables[key] = input.variables[key]);
  }), keys(input.light).forEach((key) => {
    defaultCssVariables.light[key] !== input.light[key] && (cleaned.light[key] = input.light[key]);
  }), keys(input.dark).forEach((key) => {
    defaultCssVariables.dark[key] !== input.dark[key] && (cleaned.dark[key] = input.dark[key]);
  }), cleaned;
}
function getColorSchemeCssVariables(selector) {
  return `
  ${selector}[data-mantine-color-scheme="dark"] { --mantine-color-scheme: dark; }
  ${selector}[data-mantine-color-scheme="light"] { --mantine-color-scheme: light; }
`;
}
function MantineCssVariables({
  cssVariablesSelector,
  deduplicateCssVariables
}) {
  const theme = useMantineTheme(), nonce = useMantineStyleNonce(), generator = useMantineCssVariablesResolver(), mergedVariables = getMergedVariables({ theme, generator }), shouldCleanVariables = cssVariablesSelector === ":root" && deduplicateCssVariables, cleanedVariables = shouldCleanVariables ? removeDefaultVariables(mergedVariables) : mergedVariables, css = convertCssVariables(cleanedVariables, cssVariablesSelector);
  return css ? /* @__PURE__ */ jsx(
    "style",
    {
      "data-mantine-styles": !0,
      nonce: nonce?.(),
      dangerouslySetInnerHTML: {
        __html: `${css}${shouldCleanVariables ? "" : getColorSchemeCssVariables(cssVariablesSelector)}`
      }
    }
  ) : null;
}
MantineCssVariables.displayName = "@mantine/CssVariables";
function suppressNextjsWarning() {
  const originalError = console.error;
  console.error = (...args) => {
    args.length > 1 && typeof args[0] == "string" && args[0].toLowerCase().includes("extra attributes from the server") && typeof args[1] == "string" && args[1].toLowerCase().includes("data-mantine-color-scheme") || originalError(...args);
  };
}
function setColorSchemeAttribute(colorScheme, getRootElement) {
  const computedColorScheme = colorScheme !== "auto" ? colorScheme : window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
  getRootElement()?.setAttribute("data-mantine-color-scheme", computedColorScheme);
}
function useProviderColorScheme({
  manager,
  defaultColorScheme,
  getRootElement,
  forceColorScheme
}) {
  const media = useRef(), [value, setValue] = useState(() => manager.get(defaultColorScheme)), colorSchemeValue = forceColorScheme || value, setColorScheme = useCallback(
    (colorScheme) => {
      forceColorScheme || (setColorSchemeAttribute(colorScheme, getRootElement), setValue(colorScheme), manager.set(colorScheme));
    },
    [manager.set, colorSchemeValue, forceColorScheme]
  ), clearColorScheme = useCallback(() => {
    setValue(defaultColorScheme), setColorSchemeAttribute(defaultColorScheme, getRootElement), manager.clear();
  }, [manager.clear, defaultColorScheme]);
  return useEffect(() => (manager.subscribe(setColorScheme), manager.unsubscribe), [manager.subscribe, manager.unsubscribe]), useIsomorphicEffect(() => {
    setColorSchemeAttribute(manager.get(defaultColorScheme), getRootElement);
  }, []), useEffect(() => {
    if (forceColorScheme)
      return setColorSchemeAttribute(forceColorScheme, getRootElement), () => {
      };
    forceColorScheme === void 0 && setColorSchemeAttribute(value, getRootElement), media.current = window.matchMedia("(prefers-color-scheme: dark)");
    const listener = (event) => {
      value === "auto" && setColorSchemeAttribute(event.matches ? "dark" : "light", getRootElement);
    };
    return media.current?.addEventListener("change", listener), () => media.current?.removeEventListener("change", listener);
  }, [value, forceColorScheme]), { colorScheme: colorSchemeValue, setColorScheme, clearColorScheme };
}
function useRespectReduceMotion({
  respectReducedMotion,
  getRootElement
}) {
  useIsomorphicEffect(() => {
    respectReducedMotion && getRootElement()?.setAttribute("data-respect-reduced-motion", "true");
  }, [respectReducedMotion]);
}
suppressNextjsWarning();
function MantineProvider({
  theme,
  children,
  getStyleNonce,
  withStaticClasses = !0,
  withGlobalClasses = !0,
  deduplicateCssVariables = !0,
  withCssVariables = !0,
  cssVariablesSelector = ":root",
  classNamesPrefix = "mantine",
  colorSchemeManager = localStorageColorSchemeManager(),
  defaultColorScheme = "light",
  getRootElement = () => document.documentElement,
  cssVariablesResolver,
  forceColorScheme,
  stylesTransform
}) {
  const { colorScheme, setColorScheme, clearColorScheme } = useProviderColorScheme({
    defaultColorScheme,
    forceColorScheme,
    manager: colorSchemeManager,
    getRootElement
  });
  return useRespectReduceMotion({
    respectReducedMotion: theme?.respectReducedMotion || !1,
    getRootElement
  }), /* @__PURE__ */ jsx(
    MantineContext.Provider,
    {
      value: {
        colorScheme,
        setColorScheme,
        clearColorScheme,
        getRootElement,
        classNamesPrefix,
        getStyleNonce,
        cssVariablesResolver,
        cssVariablesSelector,
        withStaticClasses,
        stylesTransform
      },
      children: /* @__PURE__ */ jsxs(MantineThemeProvider, { theme, children: [
        withCssVariables && /* @__PURE__ */ jsx(
          MantineCssVariables,
          {
            cssVariablesSelector,
            deduplicateCssVariables
          }
        ),
        withGlobalClasses && /* @__PURE__ */ jsx(MantineClasses, {}),
        children
      ] })
    }
  );
}
MantineProvider.displayName = "@mantine/core/MantineProvider";
function useResolvedStylesApi({
  classNames,
  styles,
  props,
  stylesCtx
}) {
  const theme = useMantineTheme();
  return {
    resolvedClassNames: resolveClassNames({
      theme,
      classNames,
      props,
      stylesCtx: stylesCtx || void 0
    }),
    resolvedStyles: resolveStyles({
      theme,
      styles,
      props,
      stylesCtx: stylesCtx || void 0
    })
  };
}
const FOCUS_CLASS_NAMES = {
  always: "mantine-focus-always",
  auto: "mantine-focus-auto",
  never: "mantine-focus-never"
};
function getGlobalClassNames({ theme, options, unstyled }) {
  return clsx(
    options?.focusable && !unstyled && (theme.focusClassName || FOCUS_CLASS_NAMES[theme.focusRing]),
    options?.active && !unstyled && theme.activeClassName
  );
}
function getOptionsClassNames({
  selector,
  stylesCtx,
  options,
  props,
  theme
}) {
  return resolveClassNames({
    theme,
    classNames: options?.classNames,
    props: options?.props || props,
    stylesCtx
  })[selector];
}
function getResolvedClassNames({
  selector,
  stylesCtx,
  theme,
  classNames,
  props
}) {
  return resolveClassNames({ theme, classNames, props, stylesCtx })[selector];
}
function getRootClassName({ rootSelector, selector, className }) {
  return rootSelector === selector ? className : void 0;
}
function getSelectorClassName({ selector, classes: classes2, unstyled }) {
  return unstyled ? void 0 : classes2[selector];
}
function getStaticClassNames({
  themeName,
  classNamesPrefix,
  selector,
  withStaticClass
}) {
  return withStaticClass === !1 ? [] : themeName.map((n) => `${classNamesPrefix}-${n}-${selector}`);
}
function getThemeClassNames({
  themeName,
  theme,
  selector,
  props,
  stylesCtx
}) {
  return themeName.map(
    (n) => resolveClassNames({
      theme,
      classNames: theme.components[n]?.classNames,
      props,
      stylesCtx
    })?.[selector]
  );
}
function getVariantClassName({
  options,
  classes: classes2,
  selector,
  unstyled
}) {
  return options?.variant && !unstyled ? classes2[`${selector}--${options.variant}`] : void 0;
}
function getClassName({
  theme,
  options,
  themeName,
  selector,
  classNamesPrefix,
  classNames,
  classes: classes2,
  unstyled,
  className,
  rootSelector,
  props,
  stylesCtx,
  withStaticClasses,
  headless,
  transformedStyles
}) {
  return clsx(
    getGlobalClassNames({ theme, options, unstyled: unstyled || headless }),
    getThemeClassNames({ theme, themeName, selector, props, stylesCtx }),
    getVariantClassName({ options, classes: classes2, selector, unstyled }),
    getResolvedClassNames({ selector, stylesCtx, theme, classNames, props }),
    getResolvedClassNames({ selector, stylesCtx, theme, classNames: transformedStyles, props }),
    getOptionsClassNames({ selector, stylesCtx, options, props, theme }),
    getRootClassName({ rootSelector, selector, className }),
    getSelectorClassName({ selector, classes: classes2, unstyled: unstyled || headless }),
    withStaticClasses && !headless && getStaticClassNames({
      themeName,
      classNamesPrefix,
      selector,
      withStaticClass: options?.withStaticClass
    }),
    options?.className
  );
}
function getThemeStyles({
  theme,
  themeName,
  props,
  stylesCtx,
  selector
}) {
  return themeName.map(
    (n) => resolveStyles({
      theme,
      styles: theme.components[n]?.styles,
      props,
      stylesCtx
    })[selector]
  ).reduce((acc, val) => ({ ...acc, ...val }), {});
}
function resolveStyle({ style, theme }) {
  return Array.isArray(style) ? [...style].reduce(
    (acc, item) => ({ ...acc, ...resolveStyle({ style: item, theme }) }),
    {}
  ) : typeof style == "function" ? style(theme) : style ?? {};
}
function mergeVars(vars) {
  return vars.reduce((acc, current) => (current && Object.keys(current).forEach((key) => {
    acc[key] = { ...acc[key], ...filterProps(current[key]) };
  }), acc), {});
}
function resolveVars({
  vars,
  varsResolver: varsResolver2,
  theme,
  props,
  stylesCtx,
  selector,
  themeName,
  headless
}) {
  return mergeVars([
    headless ? {} : varsResolver2?.(theme, props, stylesCtx),
    ...themeName.map((name) => theme.components?.[name]?.vars?.(theme, props, stylesCtx)),
    vars?.(theme, props, stylesCtx)
  ])?.[selector];
}
function getStyle({
  theme,
  themeName,
  selector,
  options,
  props,
  stylesCtx,
  rootSelector,
  styles,
  style,
  vars,
  varsResolver: varsResolver2,
  headless,
  withStylesTransform
}) {
  return {
    ...!withStylesTransform && getThemeStyles({ theme, themeName, props, stylesCtx, selector }),
    ...!withStylesTransform && resolveStyles({ theme, styles, props, stylesCtx })[selector],
    ...!withStylesTransform && resolveStyles({ theme, styles: options?.styles, props: options?.props || props, stylesCtx })[selector],
    ...resolveVars({ theme, props, stylesCtx, vars, varsResolver: varsResolver2, selector, themeName, headless }),
    ...rootSelector === selector ? resolveStyle({ style, theme }) : null,
    ...resolveStyle({ style: options?.style, theme })
  };
}
function useStylesTransform({ props, stylesCtx, themeName }) {
  const theme = useMantineTheme(), stylesTransform = useMantineStylesTransform()?.();
  return {
    getTransformedStyles: (styles) => stylesTransform ? [
      ...styles.map(
        (style) => stylesTransform(style, { props, theme, ctx: stylesCtx })
      ),
      ...themeName.map(
        (n) => stylesTransform(theme.components[n]?.styles, { props, theme, ctx: stylesCtx })
      )
    ].filter(Boolean) : [],
    withStylesTransform: !!stylesTransform
  };
}
function useStyles({
  name,
  classes: classes2,
  props,
  stylesCtx,
  className,
  style,
  rootSelector = "root",
  unstyled,
  classNames,
  styles,
  vars,
  varsResolver: varsResolver2
}) {
  const theme = useMantineTheme(), classNamesPrefix = useMantineClassNamesPrefix(), withStaticClasses = useMantineWithStaticClasses(), headless = useMantineIsHeadless(), themeName = (Array.isArray(name) ? name : [name]).filter((n) => n), { withStylesTransform, getTransformedStyles } = useStylesTransform({
    props,
    stylesCtx,
    themeName
  });
  return (selector, options) => ({
    className: getClassName({
      theme,
      options,
      themeName,
      selector,
      classNamesPrefix,
      classNames,
      classes: classes2,
      unstyled,
      className,
      rootSelector,
      props,
      stylesCtx,
      withStaticClasses,
      headless,
      transformedStyles: getTransformedStyles([options?.styles, styles])
    }),
    style: getStyle({
      theme,
      themeName,
      selector,
      options,
      props,
      stylesCtx,
      rootSelector,
      styles,
      style,
      vars,
      varsResolver: varsResolver2,
      headless,
      withStylesTransform
    })
  });
}
function getAutoContrastValue(autoContrast, theme) {
  return typeof autoContrast == "boolean" ? autoContrast : theme.autoContrast;
}
function disableTransition(nonce) {
  const style = document.createElement("style");
  return style.setAttribute("data-mantine-styles", "inline"), style.innerHTML = "*, *::before, *::after {transition: none !important;}", style.setAttribute("data-mantine-disable-transition", "true"), nonce && style.setAttribute("nonce", nonce), document.head.appendChild(style), () => document.querySelectorAll("[data-mantine-disable-transition]").forEach((element) => element.remove());
}
function useMantineColorScheme({ keepTransitions } = {}) {
  const clearStylesRef = useRef(), timeoutRef = useRef(), ctx = useContext(MantineContext), nonce = useMantineStyleNonce(), nonceValue = useRef(nonce?.());
  if (!ctx)
    throw new Error("[@mantine/core] MantineProvider was not found in tree");
  const setColorScheme = (value) => {
    ctx.setColorScheme(value), clearStylesRef.current = keepTransitions ? () => {
    } : disableTransition(nonceValue.current), window.clearTimeout(timeoutRef.current), timeoutRef.current = window.setTimeout(() => {
      clearStylesRef.current?.();
    }, 10);
  }, clearColorScheme = () => {
    ctx.clearColorScheme(), clearStylesRef.current = keepTransitions ? () => {
    } : disableTransition(nonceValue.current), window.clearTimeout(timeoutRef.current), timeoutRef.current = window.setTimeout(() => {
      clearStylesRef.current?.();
    }, 10);
  }, osColorScheme = useColorScheme("light", { getInitialValueInEffect: !1 }), computedColorScheme = ctx.colorScheme === "auto" ? osColorScheme : ctx.colorScheme, toggleColorScheme = useCallback(
    () => setColorScheme(computedColorScheme === "light" ? "dark" : "light"),
    [setColorScheme, computedColorScheme]
  );
  return useEffect(
    () => () => {
      clearStylesRef.current?.(), window.clearTimeout(timeoutRef.current);
    },
    []
  ), {
    colorScheme: ctx.colorScheme,
    setColorScheme,
    clearColorScheme,
    toggleColorScheme
  };
}
function useComputedColorScheme(defaultValue, options = { getInitialValueInEffect: !0 }) {
  const osColorScheme = useColorScheme(defaultValue, options), { colorScheme } = useMantineColorScheme();
  return colorScheme === "auto" ? osColorScheme : colorScheme;
}
function useProps(component, defaultProps2, props) {
  const theme = useMantineTheme(), contextPropsPayload = theme.components[component]?.defaultProps, contextProps = typeof contextPropsPayload == "function" ? contextPropsPayload(theme) : contextPropsPayload;
  return { ...defaultProps2, ...contextProps, ...filterProps(props) };
}
function createTheme(theme) {
  return theme;
}
function cssObjectToString(css) {
  return keys(css).reduce(
    (acc, rule) => css[rule] !== void 0 ? `${acc}${camelToKebabCase(rule)}:${css[rule]};` : acc,
    ""
  ).trim();
}
function stylesToString({ selector, styles, media, container }) {
  const baseStyles = styles ? cssObjectToString(styles) : "", mediaQueryStyles = Array.isArray(media) ? media.map((item) => `@media${item.query}{${selector}{${cssObjectToString(item.styles)}}}`) : [], containerStyles = Array.isArray(container) ? container.map(
    (item) => `@container ${item.query}{${selector}{${cssObjectToString(item.styles)}}}`
  ) : [];
  return `${baseStyles ? `${selector}{${baseStyles}}` : ""}${mediaQueryStyles.join("")}${containerStyles.join("")}`.trim();
}
function InlineStyles(props) {
  const nonce = useMantineStyleNonce();
  return /* @__PURE__ */ jsx(
    "style",
    {
      "data-mantine-styles": "inline",
      nonce: nonce?.(),
      dangerouslySetInnerHTML: { __html: stylesToString(props) }
    }
  );
}
function extractStyleProps(others) {
  const {
    m,
    mx,
    my,
    mt,
    mb,
    ml,
    mr,
    me,
    ms,
    p,
    px: px2,
    py,
    pt,
    pb,
    pl,
    pr,
    pe,
    ps,
    bd,
    bg,
    c,
    opacity,
    ff,
    fz,
    fw,
    lts,
    ta,
    lh,
    fs,
    tt,
    td,
    w,
    miw,
    maw,
    h,
    mih,
    mah,
    bgsz,
    bgp,
    bgr,
    bga,
    pos,
    top,
    left,
    bottom,
    right,
    inset,
    display,
    flex,
    hiddenFrom,
    visibleFrom,
    lightHidden,
    darkHidden,
    sx,
    ...rest
  } = others;
  return { styleProps: filterProps({
    m,
    mx,
    my,
    mt,
    mb,
    ml,
    mr,
    me,
    ms,
    p,
    px: px2,
    py,
    pt,
    pb,
    pl,
    pr,
    pe,
    ps,
    bd,
    bg,
    c,
    opacity,
    ff,
    fz,
    fw,
    lts,
    ta,
    lh,
    fs,
    tt,
    td,
    w,
    miw,
    maw,
    h,
    mih,
    mah,
    bgsz,
    bgp,
    bgr,
    bga,
    pos,
    top,
    left,
    bottom,
    right,
    inset,
    display,
    flex,
    hiddenFrom,
    visibleFrom,
    lightHidden,
    darkHidden,
    sx
  }), rest };
}
const STYlE_PROPS_DATA = {
  m: { type: "spacing", property: "margin" },
  mt: { type: "spacing", property: "marginTop" },
  mb: { type: "spacing", property: "marginBottom" },
  ml: { type: "spacing", property: "marginLeft" },
  mr: { type: "spacing", property: "marginRight" },
  ms: { type: "spacing", property: "marginInlineStart" },
  me: { type: "spacing", property: "marginInlineEnd" },
  mx: { type: "spacing", property: "marginInline" },
  my: { type: "spacing", property: "marginBlock" },
  p: { type: "spacing", property: "padding" },
  pt: { type: "spacing", property: "paddingTop" },
  pb: { type: "spacing", property: "paddingBottom" },
  pl: { type: "spacing", property: "paddingLeft" },
  pr: { type: "spacing", property: "paddingRight" },
  ps: { type: "spacing", property: "paddingInlineStart" },
  pe: { type: "spacing", property: "paddingInlineEnd" },
  px: { type: "spacing", property: "paddingInline" },
  py: { type: "spacing", property: "paddingBlock" },
  bd: { type: "border", property: "border" },
  bg: { type: "color", property: "background" },
  c: { type: "textColor", property: "color" },
  opacity: { type: "identity", property: "opacity" },
  ff: { type: "fontFamily", property: "fontFamily" },
  fz: { type: "fontSize", property: "fontSize" },
  fw: { type: "identity", property: "fontWeight" },
  lts: { type: "size", property: "letterSpacing" },
  ta: { type: "identity", property: "textAlign" },
  lh: { type: "lineHeight", property: "lineHeight" },
  fs: { type: "identity", property: "fontStyle" },
  tt: { type: "identity", property: "textTransform" },
  td: { type: "identity", property: "textDecoration" },
  w: { type: "spacing", property: "width" },
  miw: { type: "spacing", property: "minWidth" },
  maw: { type: "spacing", property: "maxWidth" },
  h: { type: "spacing", property: "height" },
  mih: { type: "spacing", property: "minHeight" },
  mah: { type: "spacing", property: "maxHeight" },
  bgsz: { type: "size", property: "backgroundSize" },
  bgp: { type: "identity", property: "backgroundPosition" },
  bgr: { type: "identity", property: "backgroundRepeat" },
  bga: { type: "identity", property: "backgroundAttachment" },
  pos: { type: "identity", property: "position" },
  top: { type: "size", property: "top" },
  left: { type: "size", property: "left" },
  bottom: { type: "size", property: "bottom" },
  right: { type: "size", property: "right" },
  inset: { type: "size", property: "inset" },
  display: { type: "identity", property: "display" },
  flex: { type: "identity", property: "flex" }
};
function colorResolver(color, theme) {
  const parsedColor = parseThemeColor({ color, theme });
  return parsedColor.color === "dimmed" ? "var(--mantine-color-dimmed)" : parsedColor.color === "bright" ? "var(--mantine-color-bright)" : parsedColor.variable ? `var(${parsedColor.variable})` : parsedColor.color;
}
function textColorResolver(color, theme) {
  const parsedColor = parseThemeColor({ color, theme });
  return parsedColor.isThemeColor && parsedColor.shade === void 0 ? `var(--mantine-color-${parsedColor.color}-text)` : colorResolver(color, theme);
}
function borderResolver(value, theme) {
  if (typeof value == "number")
    return rem(value);
  if (typeof value == "string") {
    const [size2, style, ...colorTuple] = value.split(" ").filter((val) => val.trim() !== "");
    let result = `${rem(size2)}`;
    return style && (result += ` ${style}`), colorTuple.length > 0 && (result += ` ${colorResolver(colorTuple.join(" "), theme)}`), result.trim();
  }
  return value;
}
const values = {
  text: "var(--mantine-font-family)",
  mono: "var(--mantine-font-family-monospace)",
  monospace: "var(--mantine-font-family-monospace)",
  heading: "var(--mantine-font-family-headings)",
  headings: "var(--mantine-font-family-headings)"
};
function fontFamilyResolver(fontFamily) {
  return typeof fontFamily == "string" && fontFamily in values ? values[fontFamily] : fontFamily;
}
const headings$2 = ["h1", "h2", "h3", "h4", "h5", "h6"];
function fontSizeResolver(value, theme) {
  return typeof value == "string" && value in theme.fontSizes ? `var(--mantine-font-size-${value})` : typeof value == "string" && headings$2.includes(value) ? `var(--mantine-${value}-font-size)` : typeof value == "number" || typeof value == "string" ? rem(value) : value;
}
function identityResolver(value) {
  return value;
}
const headings$1 = ["h1", "h2", "h3", "h4", "h5", "h6"];
function lineHeightResolver(value, theme) {
  return typeof value == "string" && value in theme.lineHeights ? `var(--mantine-line-height-${value})` : typeof value == "string" && headings$1.includes(value) ? `var(--mantine-${value}-line-height)` : value;
}
function sizeResolver(value) {
  return typeof value == "number" ? rem(value) : value;
}
function spacingResolver(value, theme) {
  if (typeof value == "number")
    return rem(value);
  if (typeof value == "string") {
    const mod = value.replace("-", "");
    if (!(mod in theme.spacing))
      return rem(value);
    const variable = `--mantine-spacing-${mod}`;
    return value.startsWith("-") ? `calc(var(${variable}) * -1)` : `var(${variable})`;
  }
  return value;
}
const resolvers = {
  color: colorResolver,
  textColor: textColorResolver,
  fontSize: fontSizeResolver,
  spacing: spacingResolver,
  identity: identityResolver,
  size: sizeResolver,
  lineHeight: lineHeightResolver,
  fontFamily: fontFamilyResolver,
  border: borderResolver
};
function replaceMediaQuery(query) {
  return query.replace("(min-width: ", "").replace("em)", "");
}
function sortMediaQueries({
  media,
  ...props
}) {
  const sortedMedia = Object.keys(media).sort((a, b) => Number(replaceMediaQuery(a)) - Number(replaceMediaQuery(b))).map((query) => ({ query, styles: media[query] }));
  return { ...props, media: sortedMedia };
}
function hasResponsiveStyles(styleProp) {
  if (typeof styleProp != "object" || styleProp === null)
    return !1;
  const breakpoints = Object.keys(styleProp);
  return !(breakpoints.length === 1 && breakpoints[0] === "base");
}
function getBaseValue(value) {
  return typeof value == "object" && value !== null ? "base" in value ? value.base : void 0 : value;
}
function getBreakpointKeys(value) {
  return typeof value == "object" && value !== null ? keys(value).filter((key) => key !== "base") : [];
}
function getBreakpointValue$1(value, breakpoint) {
  return typeof value == "object" && value !== null && breakpoint in value ? value[breakpoint] : value;
}
function parseStyleProps({
  styleProps,
  data,
  theme
}) {
  return sortMediaQueries(
    keys(styleProps).reduce(
      (acc, styleProp) => {
        if (styleProp === "hiddenFrom" || styleProp === "visibleFrom" || styleProp === "sx")
          return acc;
        const propertyData = data[styleProp], properties = Array.isArray(propertyData.property) ? propertyData.property : [propertyData.property], baseValue = getBaseValue(styleProps[styleProp]);
        if (!hasResponsiveStyles(styleProps[styleProp]))
          return properties.forEach((property) => {
            acc.inlineStyles[property] = resolvers[propertyData.type](baseValue, theme);
          }), acc;
        acc.hasResponsiveStyles = !0;
        const breakpoints = getBreakpointKeys(styleProps[styleProp]);
        return properties.forEach((property) => {
          baseValue && (acc.styles[property] = resolvers[propertyData.type](baseValue, theme)), breakpoints.forEach((breakpoint) => {
            const bp = `(min-width: ${theme.breakpoints[breakpoint]})`;
            acc.media[bp] = {
              ...acc.media[bp],
              [property]: resolvers[propertyData.type](
                getBreakpointValue$1(styleProps[styleProp], breakpoint),
                theme
              )
            };
          });
        }), acc;
      },
      {
        hasResponsiveStyles: !1,
        styles: {},
        inlineStyles: {},
        media: {}
      }
    )
  );
}
function useRandomClassName() {
  return `__m__-${useId$2().replace(/:/g, "")}`;
}
function getStyleObject(style, theme) {
  return Array.isArray(style) ? [...style].reduce(
    (acc, item) => ({ ...acc, ...getStyleObject(item, theme) }),
    {}
  ) : typeof style == "function" ? style(theme) : style ?? {};
}
function transformModKey(key) {
  return key.startsWith("data-") ? key : `data-${key}`;
}
function getMod(props) {
  return Object.keys(props).reduce((acc, key) => {
    const value = props[key];
    return value === void 0 || value === "" || value === !1 || value === null || (acc[transformModKey(key)] = props[key]), acc;
  }, {});
}
function getBoxMod(mod) {
  return mod ? typeof mod == "string" ? { [transformModKey(mod)]: !0 } : Array.isArray(mod) ? [...mod].reduce(
    (acc, value) => ({ ...acc, ...getBoxMod(value) }),
    {}
  ) : getMod(mod) : null;
}
function mergeStyles(styles, theme) {
  return Array.isArray(styles) ? [...styles].reduce(
    (acc, item) => ({ ...acc, ...mergeStyles(item, theme) }),
    {}
  ) : typeof styles == "function" ? styles(theme) : styles ?? {};
}
function getBoxStyle({
  theme,
  style,
  vars,
  styleProps
}) {
  const _style = mergeStyles(style, theme), _vars = mergeStyles(vars, theme);
  return { ..._style, ..._vars, ...styleProps };
}
const _Box = forwardRef(
  ({
    component,
    style,
    __vars,
    className,
    variant,
    mod,
    size: size2,
    hiddenFrom,
    visibleFrom,
    lightHidden,
    darkHidden,
    renderRoot,
    __size,
    ...others
  }, ref) => {
    const theme = useMantineTheme(), Element2 = component || "div", { styleProps, rest } = extractStyleProps(others), transformedSx = useMantineSxTransform()?.()?.(styleProps.sx), responsiveClassName = useRandomClassName(), parsedStyleProps = parseStyleProps({
      styleProps,
      theme,
      data: STYlE_PROPS_DATA
    }), props = {
      ref,
      style: getBoxStyle({
        theme,
        style,
        vars: __vars,
        styleProps: parsedStyleProps.inlineStyles
      }),
      className: clsx(className, transformedSx, {
        [responsiveClassName]: parsedStyleProps.hasResponsiveStyles,
        "mantine-light-hidden": lightHidden,
        "mantine-dark-hidden": darkHidden,
        [`mantine-hidden-from-${hiddenFrom}`]: hiddenFrom,
        [`mantine-visible-from-${visibleFrom}`]: visibleFrom
      }),
      "data-variant": variant,
      "data-size": isNumberLike(size2) ? void 0 : size2 || void 0,
      size: __size,
      ...getBoxMod(mod),
      ...rest
    };
    return /* @__PURE__ */ jsxs(Fragment$1, { children: [
      parsedStyleProps.hasResponsiveStyles && /* @__PURE__ */ jsx(
        InlineStyles,
        {
          selector: `.${responsiveClassName}`,
          styles: parsedStyleProps.styles,
          media: parsedStyleProps.media
        }
      ),
      typeof renderRoot == "function" ? renderRoot(props) : /* @__PURE__ */ jsx(Element2, { ...props })
    ] });
  }
);
_Box.displayName = "@mantine/core/Box";
const Box = _Box;
function identity(value) {
  return value;
}
function factory(ui) {
  const Component = forwardRef(ui);
  return Component.extend = identity, Component.withProps = (fixedProps) => {
    const Extended = forwardRef((props, ref) => /* @__PURE__ */ jsx(Component, { ...fixedProps, ...props, ref }));
    return Extended.extend = Component.extend, Extended.displayName = `WithProps(${Component.displayName})`, Extended;
  }, Component;
}
function polymorphicFactory(ui) {
  const Component = forwardRef(ui);
  return Component.withProps = (fixedProps) => {
    const Extended = forwardRef((props, ref) => /* @__PURE__ */ jsx(Component, { ...fixedProps, ...props, ref }));
    return Extended.extend = Component.extend, Extended.displayName = `WithProps(${Component.displayName})`, Extended;
  }, Component.extend = identity, Component;
}
const DirectionContext = createContext({
  dir: "ltr",
  toggleDirection: () => {
  },
  setDirection: () => {
  }
});
function useDirection() {
  return useContext(DirectionContext);
}
const [ScrollAreaProvider, useScrollAreaContext] = createSafeContext(
  "ScrollArea.Root component was not found in tree"
);
function useResizeObserver(element, onResize) {
  const handleResize = useCallbackRef(onResize);
  useIsomorphicEffect(() => {
    let rAF = 0;
    if (element) {
      const resizeObserver = new ResizeObserver(() => {
        cancelAnimationFrame(rAF), rAF = window.requestAnimationFrame(handleResize);
      });
      return resizeObserver.observe(element), () => {
        window.cancelAnimationFrame(rAF), resizeObserver.unobserve(element);
      };
    }
  }, [element, handleResize]);
}
const Corner = forwardRef((props, ref) => {
  const { style, ...others } = props, ctx = useScrollAreaContext(), [width, setWidth] = useState(0), [height, setHeight] = useState(0), hasSize = !!(width && height);
  return useResizeObserver(ctx.scrollbarX, () => {
    const h = ctx.scrollbarX?.offsetHeight || 0;
    ctx.onCornerHeightChange(h), setHeight(h);
  }), useResizeObserver(ctx.scrollbarY, () => {
    const w = ctx.scrollbarY?.offsetWidth || 0;
    ctx.onCornerWidthChange(w), setWidth(w);
  }), hasSize ? /* @__PURE__ */ jsx("div", { ...others, ref, style: { ...style, width, height } }) : null;
}), ScrollAreaCorner = forwardRef((props, ref) => {
  const ctx = useScrollAreaContext(), hasBothScrollbarsVisible = !!(ctx.scrollbarX && ctx.scrollbarY);
  return ctx.type !== "scroll" && hasBothScrollbarsVisible ? /* @__PURE__ */ jsx(Corner, { ...props, ref }) : null;
}), defaultProps$1I = {
  scrollHideDelay: 1e3,
  type: "hover"
}, ScrollAreaRoot = forwardRef((_props, ref) => {
  const props = useProps("ScrollAreaRoot", defaultProps$1I, _props), { type, scrollHideDelay, scrollbars, ...others } = props, [scrollArea, setScrollArea] = useState(null), [viewport, setViewport] = useState(null), [content, setContent] = useState(null), [scrollbarX, setScrollbarX] = useState(null), [scrollbarY, setScrollbarY] = useState(null), [cornerWidth, setCornerWidth] = useState(0), [cornerHeight, setCornerHeight] = useState(0), [scrollbarXEnabled, setScrollbarXEnabled] = useState(!1), [scrollbarYEnabled, setScrollbarYEnabled] = useState(!1), rootRef = useMergedRef(ref, (node) => setScrollArea(node));
  return /* @__PURE__ */ jsx(
    ScrollAreaProvider,
    {
      value: {
        type,
        scrollHideDelay,
        scrollArea,
        viewport,
        onViewportChange: setViewport,
        content,
        onContentChange: setContent,
        scrollbarX,
        onScrollbarXChange: setScrollbarX,
        scrollbarXEnabled,
        onScrollbarXEnabledChange: setScrollbarXEnabled,
        scrollbarY,
        onScrollbarYChange: setScrollbarY,
        scrollbarYEnabled,
        onScrollbarYEnabledChange: setScrollbarYEnabled,
        onCornerWidthChange: setCornerWidth,
        onCornerHeightChange: setCornerHeight
      },
      children: /* @__PURE__ */ jsx(
        Box,
        {
          ...others,
          ref: rootRef,
          __vars: {
            "--sa-corner-width": scrollbars !== "xy" ? "0px" : `${cornerWidth}px`,
            "--sa-corner-height": scrollbars !== "xy" ? "0px" : `${cornerHeight}px`
          }
        }
      )
    }
  );
});
ScrollAreaRoot.displayName = "@mantine/core/ScrollAreaRoot";
function getThumbRatio(viewportSize, contentSize) {
  const ratio = viewportSize / contentSize;
  return Number.isNaN(ratio) ? 0 : ratio;
}
function getThumbSize(sizes2) {
  const ratio = getThumbRatio(sizes2.viewport, sizes2.content), scrollbarPadding = sizes2.scrollbar.paddingStart + sizes2.scrollbar.paddingEnd, thumbSize = (sizes2.scrollbar.size - scrollbarPadding) * ratio;
  return Math.max(thumbSize, 18);
}
function linearScale(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1])
      return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function clamp$1(value, [min2, max2]) {
  return Math.min(max2, Math.max(min2, value));
}
function getThumbOffsetFromScroll(scrollPos, sizes2, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes2), scrollbarPadding = sizes2.scrollbar.paddingStart + sizes2.scrollbar.paddingEnd, scrollbar = sizes2.scrollbar.size - scrollbarPadding, maxScrollPos = sizes2.content - sizes2.viewport, maxThumbPos = scrollbar - thumbSizePx, scrollClampRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0], scrollWithoutMomentum = clamp$1(scrollPos, scrollClampRange);
  return linearScale([0, maxScrollPos], [0, maxThumbPos])(scrollWithoutMomentum);
}
function getScrollPositionFromPointer(pointerPos, pointerOffset, sizes2, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes2), thumbCenter = thumbSizePx / 2, offset2 = pointerOffset || thumbCenter, thumbOffsetFromEnd = thumbSizePx - offset2, minPointerPos = sizes2.scrollbar.paddingStart + offset2, maxPointerPos = sizes2.scrollbar.size - sizes2.scrollbar.paddingEnd - thumbOffsetFromEnd, maxScrollPos = sizes2.content - sizes2.viewport, scrollRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  return linearScale([minPointerPos, maxPointerPos], scrollRange)(pointerPos);
}
function isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {
  return scrollPos > 0 && scrollPos < maxScrollPos;
}
function toInt(value) {
  return value ? parseInt(value, 10) : 0;
}
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = !0 } = {}) {
  return (event) => {
    originalEventHandler?.(event), (checkForDefaultPrevented === !1 || !event.defaultPrevented) && ourEventHandler?.(event);
  };
}
const [ScrollbarProvider, useScrollbarContext] = createSafeContext(
  "ScrollAreaScrollbar was not found in tree"
), Scrollbar = forwardRef((props, forwardedRef) => {
  const {
    sizes: sizes2,
    hasThumb,
    onThumbChange,
    onThumbPointerUp,
    onThumbPointerDown,
    onThumbPositionChange,
    onDragScroll,
    onWheelScroll,
    onResize,
    ...scrollbarProps
  } = props, context = useScrollAreaContext(), [scrollbar, setScrollbar] = useState(null), composeRefs = useMergedRef(forwardedRef, (node) => setScrollbar(node)), rectRef = useRef(null), prevWebkitUserSelectRef = useRef(""), { viewport } = context, maxScrollPos = sizes2.content - sizes2.viewport, handleWheelScroll = useCallbackRef(onWheelScroll), handleThumbPositionChange = useCallbackRef(onThumbPositionChange), handleResize = useDebouncedCallback(onResize, 10), handleDragScroll = (event) => {
    if (rectRef.current) {
      const x = event.clientX - rectRef.current.left, y = event.clientY - rectRef.current.top;
      onDragScroll({ x, y });
    }
  };
  return useEffect(() => {
    const handleWheel = (event) => {
      const element = event.target;
      scrollbar?.contains(element) && handleWheelScroll(event, maxScrollPos);
    };
    return document.addEventListener("wheel", handleWheel, { passive: !1 }), () => document.removeEventListener("wheel", handleWheel, { passive: !1 });
  }, [viewport, scrollbar, maxScrollPos, handleWheelScroll]), useEffect(handleThumbPositionChange, [sizes2, handleThumbPositionChange]), useResizeObserver(scrollbar, handleResize), useResizeObserver(context.content, handleResize), /* @__PURE__ */ jsx(
    ScrollbarProvider,
    {
      value: {
        scrollbar,
        hasThumb,
        onThumbChange: useCallbackRef(onThumbChange),
        onThumbPointerUp: useCallbackRef(onThumbPointerUp),
        onThumbPositionChange: handleThumbPositionChange,
        onThumbPointerDown: useCallbackRef(onThumbPointerDown)
      },
      children: /* @__PURE__ */ jsx(
        "div",
        {
          ...scrollbarProps,
          ref: composeRefs,
          "data-mantine-scrollbar": !0,
          style: { position: "absolute", ...scrollbarProps.style },
          onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
            event.preventDefault(), event.button === 0 && (event.target.setPointerCapture(event.pointerId), rectRef.current = scrollbar.getBoundingClientRect(), prevWebkitUserSelectRef.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", handleDragScroll(event));
          }),
          onPointerMove: composeEventHandlers(props.onPointerMove, handleDragScroll),
          onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
            event.preventDefault();
            const element = event.target;
            element.hasPointerCapture(event.pointerId) && element.releasePointerCapture(event.pointerId), document.body.style.webkitUserSelect = prevWebkitUserSelectRef.current, rectRef.current = null;
          })
        }
      )
    }
  );
}), ScrollAreaScrollbarX = forwardRef(
  (props, forwardedRef) => {
    const { sizes: sizes2, onSizesChange, style, ...others } = props, ctx = useScrollAreaContext(), [computedStyle, setComputedStyle] = useState(), ref = useRef(null), composeRefs = useMergedRef(forwardedRef, ref, ctx.onScrollbarXChange);
    return useEffect(() => {
      ref.current && setComputedStyle(getComputedStyle(ref.current));
    }, [ref]), /* @__PURE__ */ jsx(
      Scrollbar,
      {
        "data-orientation": "horizontal",
        ...others,
        ref: composeRefs,
        sizes: sizes2,
        style: {
          ...style,
          "--sa-thumb-width": `${getThumbSize(sizes2)}px`
        },
        onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.x),
        onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.x),
        onWheelScroll: (event, maxScrollPos) => {
          if (ctx.viewport) {
            const scrollPos = ctx.viewport.scrollLeft + event.deltaX;
            props.onWheelScroll(scrollPos), isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) && event.preventDefault();
          }
        },
        onResize: () => {
          ref.current && ctx.viewport && computedStyle && onSizesChange({
            content: ctx.viewport.scrollWidth,
            viewport: ctx.viewport.offsetWidth,
            scrollbar: {
              size: ref.current.clientWidth,
              paddingStart: toInt(computedStyle.paddingLeft),
              paddingEnd: toInt(computedStyle.paddingRight)
            }
          });
        }
      }
    );
  }
);
ScrollAreaScrollbarX.displayName = "@mantine/core/ScrollAreaScrollbarX";
const ScrollAreaScrollbarY = forwardRef(
  (props, forwardedRef) => {
    const { sizes: sizes2, onSizesChange, style, ...others } = props, context = useScrollAreaContext(), [computedStyle, setComputedStyle] = useState(), ref = useRef(null), composeRefs = useMergedRef(forwardedRef, ref, context.onScrollbarYChange);
    return useEffect(() => {
      ref.current && setComputedStyle(window.getComputedStyle(ref.current));
    }, []), /* @__PURE__ */ jsx(
      Scrollbar,
      {
        ...others,
        "data-orientation": "vertical",
        ref: composeRefs,
        sizes: sizes2,
        style: {
          "--sa-thumb-height": `${getThumbSize(sizes2)}px`,
          ...style
        },
        onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.y),
        onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.y),
        onWheelScroll: (event, maxScrollPos) => {
          if (context.viewport) {
            const scrollPos = context.viewport.scrollTop + event.deltaY;
            props.onWheelScroll(scrollPos), isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) && event.preventDefault();
          }
        },
        onResize: () => {
          ref.current && context.viewport && computedStyle && onSizesChange({
            content: context.viewport.scrollHeight,
            viewport: context.viewport.offsetHeight,
            scrollbar: {
              size: ref.current.clientHeight,
              paddingStart: toInt(computedStyle.paddingTop),
              paddingEnd: toInt(computedStyle.paddingBottom)
            }
          });
        }
      }
    );
  }
);
ScrollAreaScrollbarY.displayName = "@mantine/core/ScrollAreaScrollbarY";
const ScrollAreaScrollbarVisible = forwardRef((props, forwardedRef) => {
  const { orientation = "vertical", ...scrollbarProps } = props, { dir } = useDirection(), context = useScrollAreaContext(), thumbRef = useRef(null), pointerOffsetRef = useRef(0), [sizes2, setSizes] = useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  }), thumbRatio = getThumbRatio(sizes2.viewport, sizes2.content), commonProps = {
    ...scrollbarProps,
    sizes: sizes2,
    onSizesChange: setSizes,
    hasThumb: thumbRatio > 0 && thumbRatio < 1,
    onThumbChange: (thumb) => {
      thumbRef.current = thumb;
    },
    onThumbPointerUp: () => {
      pointerOffsetRef.current = 0;
    },
    onThumbPointerDown: (pointerPos) => {
      pointerOffsetRef.current = pointerPos;
    }
  }, getScrollPosition = (pointerPos, direction) => getScrollPositionFromPointer(pointerPos, pointerOffsetRef.current, sizes2, direction);
  return orientation === "horizontal" ? /* @__PURE__ */ jsx(
    ScrollAreaScrollbarX,
    {
      ...commonProps,
      ref: forwardedRef,
      onThumbPositionChange: () => {
        if (context.viewport && thumbRef.current) {
          const scrollPos = context.viewport.scrollLeft, offset2 = getThumbOffsetFromScroll(scrollPos, sizes2, dir);
          thumbRef.current.style.transform = `translate3d(${offset2}px, 0, 0)`;
        }
      },
      onWheelScroll: (scrollPos) => {
        context.viewport && (context.viewport.scrollLeft = scrollPos);
      },
      onDragScroll: (pointerPos) => {
        context.viewport && (context.viewport.scrollLeft = getScrollPosition(pointerPos, dir));
      }
    }
  ) : orientation === "vertical" ? /* @__PURE__ */ jsx(
    ScrollAreaScrollbarY,
    {
      ...commonProps,
      ref: forwardedRef,
      onThumbPositionChange: () => {
        if (context.viewport && thumbRef.current) {
          const scrollPos = context.viewport.scrollTop, offset2 = getThumbOffsetFromScroll(scrollPos, sizes2);
          sizes2.scrollbar.size === 0 ? thumbRef.current.style.opacity = "0" : thumbRef.current.style.opacity = "1", thumbRef.current.style.transform = `translate3d(0, ${offset2}px, 0)`;
        }
      },
      onWheelScroll: (scrollPos) => {
        context.viewport && (context.viewport.scrollTop = scrollPos);
      },
      onDragScroll: (pointerPos) => {
        context.viewport && (context.viewport.scrollTop = getScrollPosition(pointerPos));
      }
    }
  ) : null;
});
ScrollAreaScrollbarVisible.displayName = "@mantine/core/ScrollAreaScrollbarVisible";
const ScrollAreaScrollbarAuto = forwardRef(
  (props, ref) => {
    const context = useScrollAreaContext(), { forceMount, ...scrollbarProps } = props, [visible2, setVisible] = useState(!1), isHorizontal = props.orientation === "horizontal", handleResize = useDebouncedCallback(() => {
      if (context.viewport) {
        const isOverflowX = context.viewport.offsetWidth < context.viewport.scrollWidth, isOverflowY = context.viewport.offsetHeight < context.viewport.scrollHeight;
        setVisible(isHorizontal ? isOverflowX : isOverflowY);
      }
    }, 10);
    return useResizeObserver(context.viewport, handleResize), useResizeObserver(context.content, handleResize), forceMount || visible2 ? /* @__PURE__ */ jsx(
      ScrollAreaScrollbarVisible,
      {
        "data-state": visible2 ? "visible" : "hidden",
        ...scrollbarProps,
        ref
      }
    ) : null;
  }
);
ScrollAreaScrollbarAuto.displayName = "@mantine/core/ScrollAreaScrollbarAuto";
const ScrollAreaScrollbarHover = forwardRef(
  (props, ref) => {
    const { forceMount, ...scrollbarProps } = props, context = useScrollAreaContext(), [visible2, setVisible] = useState(!1);
    return useEffect(() => {
      const { scrollArea } = context;
      let hideTimer = 0;
      if (scrollArea) {
        const handlePointerEnter = () => {
          window.clearTimeout(hideTimer), setVisible(!0);
        }, handlePointerLeave = () => {
          hideTimer = window.setTimeout(() => setVisible(!1), context.scrollHideDelay);
        };
        return scrollArea.addEventListener("pointerenter", handlePointerEnter), scrollArea.addEventListener("pointerleave", handlePointerLeave), () => {
          window.clearTimeout(hideTimer), scrollArea.removeEventListener("pointerenter", handlePointerEnter), scrollArea.removeEventListener("pointerleave", handlePointerLeave);
        };
      }
    }, [context.scrollArea, context.scrollHideDelay]), forceMount || visible2 ? /* @__PURE__ */ jsx(
      ScrollAreaScrollbarAuto,
      {
        "data-state": visible2 ? "visible" : "hidden",
        ...scrollbarProps,
        ref
      }
    ) : null;
  }
);
ScrollAreaScrollbarHover.displayName = "@mantine/core/ScrollAreaScrollbarHover";
const ScrollAreaScrollbarScroll = forwardRef(
  (props, red) => {
    const { forceMount, ...scrollbarProps } = props, context = useScrollAreaContext(), isHorizontal = props.orientation === "horizontal", [state, setState] = useState("hidden"), debounceScrollEnd = useDebouncedCallback(() => setState("idle"), 100);
    return useEffect(() => {
      if (state === "idle") {
        const hideTimer = window.setTimeout(() => setState("hidden"), context.scrollHideDelay);
        return () => window.clearTimeout(hideTimer);
      }
    }, [state, context.scrollHideDelay]), useEffect(() => {
      const { viewport } = context, scrollDirection = isHorizontal ? "scrollLeft" : "scrollTop";
      if (viewport) {
        let prevScrollPos = viewport[scrollDirection];
        const handleScroll2 = () => {
          const scrollPos = viewport[scrollDirection];
          prevScrollPos !== scrollPos && (setState("scrolling"), debounceScrollEnd()), prevScrollPos = scrollPos;
        };
        return viewport.addEventListener("scroll", handleScroll2), () => viewport.removeEventListener("scroll", handleScroll2);
      }
    }, [context.viewport, isHorizontal, debounceScrollEnd]), forceMount || state !== "hidden" ? /* @__PURE__ */ jsx(
      ScrollAreaScrollbarVisible,
      {
        "data-state": state === "hidden" ? "hidden" : "visible",
        ...scrollbarProps,
        ref: red,
        onPointerEnter: composeEventHandlers(props.onPointerEnter, () => setState("interacting")),
        onPointerLeave: composeEventHandlers(props.onPointerLeave, () => setState("idle"))
      }
    ) : null;
  }
), ScrollAreaScrollbar = forwardRef(
  (props, forwardedRef) => {
    const { forceMount, ...scrollbarProps } = props, context = useScrollAreaContext(), { onScrollbarXEnabledChange, onScrollbarYEnabledChange } = context, isHorizontal = props.orientation === "horizontal";
    return useEffect(() => (isHorizontal ? onScrollbarXEnabledChange(!0) : onScrollbarYEnabledChange(!0), () => {
      isHorizontal ? onScrollbarXEnabledChange(!1) : onScrollbarYEnabledChange(!1);
    }), [isHorizontal, onScrollbarXEnabledChange, onScrollbarYEnabledChange]), context.type === "hover" ? /* @__PURE__ */ jsx(ScrollAreaScrollbarHover, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "scroll" ? /* @__PURE__ */ jsx(ScrollAreaScrollbarScroll, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "auto" ? /* @__PURE__ */ jsx(ScrollAreaScrollbarAuto, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "always" ? /* @__PURE__ */ jsx(ScrollAreaScrollbarVisible, { ...scrollbarProps, ref: forwardedRef }) : null;
  }
);
ScrollAreaScrollbar.displayName = "@mantine/core/ScrollAreaScrollbar";
function addUnlinkedScrollListener(node, handler = () => {
}) {
  let prevPosition = { left: node.scrollLeft, top: node.scrollTop }, rAF = 0;
  return function loop() {
    const position = { left: node.scrollLeft, top: node.scrollTop }, isHorizontalScroll = prevPosition.left !== position.left, isVerticalScroll = prevPosition.top !== position.top;
    (isHorizontalScroll || isVerticalScroll) && handler(), prevPosition = position, rAF = window.requestAnimationFrame(loop);
  }(), () => window.cancelAnimationFrame(rAF);
}
const Thumb$1 = forwardRef((props, forwardedRef) => {
  const { style, ...others } = props, scrollAreaContext = useScrollAreaContext(), scrollbarContext = useScrollbarContext(), { onThumbPositionChange } = scrollbarContext, composedRef = useMergedRef(forwardedRef, (node) => scrollbarContext.onThumbChange(node)), removeUnlinkedScrollListenerRef = useRef(), debounceScrollEnd = useDebouncedCallback(() => {
    removeUnlinkedScrollListenerRef.current && (removeUnlinkedScrollListenerRef.current(), removeUnlinkedScrollListenerRef.current = void 0);
  }, 100);
  return useEffect(() => {
    const { viewport } = scrollAreaContext;
    if (viewport) {
      const handleScroll2 = () => {
        if (debounceScrollEnd(), !removeUnlinkedScrollListenerRef.current) {
          const listener = addUnlinkedScrollListener(viewport, onThumbPositionChange);
          removeUnlinkedScrollListenerRef.current = listener, onThumbPositionChange();
        }
      };
      return onThumbPositionChange(), viewport.addEventListener("scroll", handleScroll2), () => viewport.removeEventListener("scroll", handleScroll2);
    }
  }, [scrollAreaContext.viewport, debounceScrollEnd, onThumbPositionChange]), /* @__PURE__ */ jsx(
    "div",
    {
      "data-state": scrollbarContext.hasThumb ? "visible" : "hidden",
      ...others,
      ref: composedRef,
      style: {
        width: "var(--sa-thumb-width)",
        height: "var(--sa-thumb-height)",
        ...style
      },
      onPointerDownCapture: composeEventHandlers(props.onPointerDownCapture, (event) => {
        const thumbRect = event.target.getBoundingClientRect(), x = event.clientX - thumbRect.left, y = event.clientY - thumbRect.top;
        scrollbarContext.onThumbPointerDown({ x, y });
      }),
      onPointerUp: composeEventHandlers(props.onPointerUp, scrollbarContext.onThumbPointerUp)
    }
  );
});
Thumb$1.displayName = "@mantine/core/ScrollAreaThumb";
const ScrollAreaThumb = forwardRef(
  (props, forwardedRef) => {
    const { forceMount, ...thumbProps } = props, scrollbarContext = useScrollbarContext();
    return forceMount || scrollbarContext.hasThumb ? /* @__PURE__ */ jsx(Thumb$1, { ref: forwardedRef, ...thumbProps }) : null;
  }
);
ScrollAreaThumb.displayName = "@mantine/core/ScrollAreaThumb";
const ScrollAreaViewport = forwardRef(
  ({ children, style, ...others }, ref) => {
    const ctx = useScrollAreaContext(), rootRef = useMergedRef(ref, ctx.onViewportChange);
    return /* @__PURE__ */ jsx(
      Box,
      {
        ...others,
        ref: rootRef,
        style: {
          overflowX: ctx.scrollbarXEnabled ? "scroll" : "hidden",
          overflowY: ctx.scrollbarYEnabled ? "scroll" : "hidden",
          ...style
        },
        children: /* @__PURE__ */ jsx("div", { style: { minWidth: "100%", display: "table" }, ref: ctx.onContentChange, children })
      }
    );
  }
);
ScrollAreaViewport.displayName = "@mantine/core/ScrollAreaViewport";
var __default__$J = { root: "m_d57069b5", viewport: "m_c0783ff9", viewportInner: "m_f8f631dd", scrollbar: "m_c44ba933", thumb: "m_d8b5e363", corner: "m_21657268" };
const classes$J = __default__$J, defaultProps$1H = {
  scrollHideDelay: 1e3,
  type: "hover",
  scrollbars: "xy"
}, varsResolver$J = (_, { scrollbarSize }) => ({
  root: {
    "--scrollarea-scrollbar-size": rem(scrollbarSize)
  }
}), ScrollArea = factory((_props, ref) => {
  const props = useProps("ScrollArea", defaultProps$1H, _props), {
    classNames,
    className,
    style,
    styles,
    unstyled,
    scrollbarSize,
    vars,
    type,
    scrollHideDelay,
    viewportProps,
    viewportRef,
    onScrollPositionChange,
    children,
    offsetScrollbars,
    scrollbars,
    onBottomReached,
    onTopReached,
    ...others
  } = props, [scrollbarHovered, setScrollbarHovered] = useState(!1), getStyles2 = useStyles({
    name: "ScrollArea",
    props,
    classes: classes$J,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$J
  });
  return /* @__PURE__ */ jsxs(
    ScrollAreaRoot,
    {
      type: type === "never" ? "always" : type,
      scrollHideDelay,
      ref,
      scrollbars,
      ...getStyles2("root"),
      ...others,
      children: [
        /* @__PURE__ */ jsx(
          ScrollAreaViewport,
          {
            ...viewportProps,
            ...getStyles2("viewport", { style: viewportProps?.style }),
            ref: viewportRef,
            "data-offset-scrollbars": offsetScrollbars === !0 ? "xy" : offsetScrollbars || void 0,
            "data-scrollbars": scrollbars || void 0,
            onScroll: (e) => {
              viewportProps?.onScroll?.(e), onScrollPositionChange?.({ x: e.currentTarget.scrollLeft, y: e.currentTarget.scrollTop });
              const { scrollTop, scrollHeight, clientHeight } = e.currentTarget;
              scrollTop - (scrollHeight - clientHeight) >= 0 && onBottomReached?.(), scrollTop === 0 && onTopReached?.();
            },
            children
          }
        ),
        (scrollbars === "xy" || scrollbars === "x") && /* @__PURE__ */ jsx(
          ScrollAreaScrollbar,
          {
            ...getStyles2("scrollbar"),
            orientation: "horizontal",
            "data-hidden": type === "never" || void 0,
            forceMount: !0,
            onMouseEnter: () => setScrollbarHovered(!0),
            onMouseLeave: () => setScrollbarHovered(!1),
            children: /* @__PURE__ */ jsx(ScrollAreaThumb, { ...getStyles2("thumb") })
          }
        ),
        (scrollbars === "xy" || scrollbars === "y") && /* @__PURE__ */ jsx(
          ScrollAreaScrollbar,
          {
            ...getStyles2("scrollbar"),
            orientation: "vertical",
            "data-hidden": type === "never" || void 0,
            forceMount: !0,
            onMouseEnter: () => setScrollbarHovered(!0),
            onMouseLeave: () => setScrollbarHovered(!1),
            children: /* @__PURE__ */ jsx(ScrollAreaThumb, { ...getStyles2("thumb") })
          }
        ),
        /* @__PURE__ */ jsx(
          ScrollAreaCorner,
          {
            ...getStyles2("corner"),
            "data-hovered": scrollbarHovered || void 0,
            "data-hidden": type === "never" || void 0
          }
        )
      ]
    }
  );
});
ScrollArea.displayName = "@mantine/core/ScrollArea";
const ScrollAreaAutosize = factory((props, ref) => {
  const {
    children,
    classNames,
    styles,
    scrollbarSize,
    scrollHideDelay,
    type,
    dir,
    offsetScrollbars,
    viewportRef,
    onScrollPositionChange,
    unstyled,
    variant,
    viewportProps,
    scrollbars,
    style,
    vars,
    onBottomReached,
    onTopReached,
    ...others
  } = useProps("ScrollAreaAutosize", defaultProps$1H, props);
  return /* @__PURE__ */ jsx(Box, { ...others, ref, style: [{ display: "flex", overflow: "auto" }, style], children: /* @__PURE__ */ jsx(Box, { style: { display: "flex", flexDirection: "column", flex: 1 }, children: /* @__PURE__ */ jsx(
    ScrollArea,
    {
      classNames,
      styles,
      scrollHideDelay,
      scrollbarSize,
      type,
      dir,
      offsetScrollbars,
      viewportRef,
      onScrollPositionChange,
      unstyled,
      variant,
      viewportProps,
      vars,
      scrollbars,
      onBottomReached,
      onTopReached,
      children
    }
  ) }) });
});
ScrollArea.classes = classes$J;
ScrollAreaAutosize.displayName = "@mantine/core/ScrollAreaAutosize";
ScrollAreaAutosize.classes = classes$J;
ScrollArea.Autosize = ScrollAreaAutosize;
var __default__$I = { root: "m_87cf2631" };
const classes$I = __default__$I, defaultProps$1G = {
  __staticSelector: "UnstyledButton"
}, UnstyledButton = polymorphicFactory(
  (_props, ref) => {
    const props = useProps("UnstyledButton", defaultProps$1G, _props), {
      className,
      component = "button",
      __staticSelector,
      unstyled,
      classNames,
      styles,
      style,
      ...others
    } = props, getStyles2 = useStyles({
      name: __staticSelector,
      props,
      classes: classes$I,
      className,
      style,
      classNames,
      styles,
      unstyled
    });
    return /* @__PURE__ */ jsx(
      Box,
      {
        ...getStyles2("root", { focusable: !0 }),
        component,
        ref,
        type: component === "button" ? "button" : void 0,
        ...others
      }
    );
  }
);
UnstyledButton.classes = classes$I;
UnstyledButton.displayName = "@mantine/core/UnstyledButton";
var __default__$H = { root: "m_515a97f8" };
const classes$H = __default__$H, defaultProps$1F = {}, VisuallyHidden = factory((_props, ref) => {
  const props = useProps("VisuallyHidden", defaultProps$1F, _props), { classNames, className, style, styles, unstyled, vars, ...others } = props, getStyles2 = useStyles({
    name: "VisuallyHidden",
    classes: classes$H,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled
  });
  return /* @__PURE__ */ jsx(Box, { component: "span", ref, ...getStyles2("root"), ...others });
});
VisuallyHidden.classes = classes$H;
VisuallyHidden.displayName = "@mantine/core/VisuallyHidden";
var __default__$G = { root: "m_1b7284a3" };
const classes$G = __default__$G, defaultProps$1E = {}, varsResolver$I = (_, { radius, shadow }) => ({
  root: {
    "--paper-radius": radius === void 0 ? void 0 : getRadius(radius),
    "--paper-shadow": getShadow(shadow)
  }
}), Paper = polymorphicFactory((_props, ref) => {
  const props = useProps("Paper", defaultProps$1E, _props), {
    classNames,
    className,
    style,
    styles,
    unstyled,
    withBorder,
    vars,
    radius,
    shadow,
    variant,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Paper",
    props,
    classes: classes$G,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$I
  });
  return /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      mod: [{ "data-with-border": withBorder }, mod],
      ...getStyles2("root"),
      variant,
      ...others
    }
  );
});
Paper.classes = classes$G;
Paper.displayName = "@mantine/core/Paper";
function hasWindow() {
  return typeof window < "u";
}
function getNodeName(node) {
  return isNode(node) ? (node.nodeName || "").toLowerCase() : "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return hasWindow() ? value instanceof Node || value instanceof getWindow(value).Node : !1;
}
function isElement(value) {
  return hasWindow() ? value instanceof Element || value instanceof getWindow(value).Element : !1;
}
function isHTMLElement(value) {
  return hasWindow() ? value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement : !1;
}
function isShadowRoot(value) {
  return !hasWindow() || typeof ShadowRoot > "u" ? !1 : value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch {
      return !1;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit(), css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : !1) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : !1) || !webkit && (css.filter ? css.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  for (; isHTMLElement(currentNode) && !isLastTraversableNode(currentNode); ) {
    if (isContainingBlock(currentNode))
      return currentNode;
    if (isTopLayer(currentNode))
      return null;
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  return isElement(element) ? {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  } : {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html")
    return node;
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  return isLastTraversableNode(parentNode) ? node.ownerDocument ? node.ownerDocument.body : node.body : isHTMLElement(parentNode) && isOverflowElement(parentNode) ? parentNode : getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  list === void 0 && (list = []), traverseIframes === void 0 && (traverseIframes = !0);
  const scrollableAncestor = getNearestOverflowAncestor(node), isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body), win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function activeElement(doc) {
  let activeElement2 = doc.activeElement;
  for (; ((_activeElement = activeElement2) == null || (_activeElement = _activeElement.shadowRoot) == null ? void 0 : _activeElement.activeElement) != null; ) {
    var _activeElement;
    activeElement2 = activeElement2.shadowRoot.activeElement;
  }
  return activeElement2;
}
function contains(parent, child) {
  if (!parent || !child)
    return !1;
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
  if (parent.contains(child))
    return !0;
  if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    for (; next; ) {
      if (parent === next)
        return !0;
      next = next.parentNode || next.host;
    }
  }
  return !1;
}
function getPlatform() {
  const uaData = navigator.userAgentData;
  return uaData != null && uaData.platform ? uaData.platform : navigator.platform;
}
function getUserAgent() {
  const uaData = navigator.userAgentData;
  return uaData && Array.isArray(uaData.brands) ? uaData.brands.map((_ref) => {
    let {
      brand,
      version
    } = _ref;
    return brand + "/" + version;
  }).join(" ") : navigator.userAgent;
}
function isVirtualPointerEvent(event) {
  return isJSDOM() ? !1 : !isAndroid() && event.width === 0 && event.height === 0 || isAndroid() && event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "mouse" || // iOS VoiceOver returns 0.333• for width/height.
  event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "touch";
}
function isSafari() {
  return /apple/i.test(navigator.vendor);
}
function isAndroid() {
  const re = /android/i;
  return re.test(getPlatform()) || re.test(getUserAgent());
}
function isMac() {
  return getPlatform().toLowerCase().startsWith("mac") && !navigator.maxTouchPoints;
}
function isJSDOM() {
  return getUserAgent().includes("jsdom/");
}
function isMouseLikePointerType(pointerType, strict) {
  const values2 = ["mouse", "pen"];
  return values2.push("", void 0), values2.includes(pointerType);
}
function isReactEvent(event) {
  return "nativeEvent" in event;
}
function isRootElement(element) {
  return element.matches("html,body");
}
function getDocument(node) {
  return node?.ownerDocument || document;
}
function isEventTargetWithin(event, node) {
  if (node == null)
    return !1;
  if ("composedPath" in event)
    return event.composedPath().includes(node);
  const e = event;
  return e.target != null && node.contains(e.target);
}
function getTarget(event) {
  return "composedPath" in event ? event.composedPath()[0] : event.target;
}
const TYPEABLE_SELECTOR = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
function isTypeableElement(element) {
  return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);
}
const min = Math.min, max = Math.max, round = Math.round, floor = Math.floor, createCoords = (v) => ({
  x: v,
  y: v
}), oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value == "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  rtl === void 0 && (rtl = !1);
  const alignment = getAlignment(placement), alignmentAxis = getAlignmentAxis(placement), length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  return rects.reference[length] > rects.floating[length] && (mainAlignmentSide = getOppositePlacement(mainAlignmentSide)), [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"], rl = ["right", "left"], tb = ["top", "bottom"], bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      return rtl ? isStart ? rl : lr : isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  return alignment && (list = list.map((side) => side + "-" + alignment), flipAlignment && (list = list.concat(list.map(getOppositeAlignmentPlacement)))), list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding != "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement), alignmentAxis = getAlignmentAxis(placement), alignLength = getAxisLength(alignmentAxis), side = getSide(placement), isVertical = sideAxis === "y", commonX = reference.x + reference.width / 2 - floating.width / 2, commonY = reference.y + reference.height / 2 - floating.height / 2, commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config, validMiddleware = middleware.filter(Boolean), rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  }), {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl), statefulPlacement = placement, middlewareData = {}, resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i], {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX ?? x, y = nextY ?? y, middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    }, reset && resetCount <= 50 && (resetCount++, typeof reset == "object" && (reset.placement && (statefulPlacement = reset.placement), reset.rects && (rects = reset.rects === !0 ? await platform2.getElementRects({
      reference,
      floating,
      strategy
    }) : reset.rects), {
      x,
      y
    } = computeCoordsFromPlacement(rects, statefulPlacement, rtl)), i = -1);
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  options === void 0 && (options = {});
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state, {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = !1,
    padding = 0
  } = evaluate(options, state), paddingObject = getPaddingObject(padding), element = elements[altBoundary ? elementContext === "floating" ? "reference" : "floating" : elementContext], clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: (_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) == null || _await$platform$isEle ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  })), rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference, offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating)), offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$3 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state, {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null)
      return {};
    const paddingObject = getPaddingObject(padding), coords = {
      x,
      y
    }, axis = getAlignmentAxis(placement), length = getAxisLength(axis), arrowDimensions = await platform2.getDimensions(element), isYAxis = axis === "y", minProp = isYAxis ? "top" : "left", maxProp = isYAxis ? "bottom" : "right", clientProp = isYAxis ? "clientHeight" : "clientWidth", endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length], startDiff = coords[axis] - rects.reference[axis], arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) && (clientSize = elements.floating[clientProp] || rects.floating[length]);
    const centerToReference = endDiff / 2 - startDiff / 2, largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1, minPadding = min(paddingObject[minProp], largestPossiblePadding), maxPadding = min(paddingObject[maxProp], largestPossiblePadding), min$1 = minPadding, max2 = clientSize - arrowDimensions[length] - maxPadding, center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference, offset2 = clamp(min$1, center, max2), shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0, alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
}), flip$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state, {
        mainAxis: checkMainAxis = !0,
        crossAxis: checkCrossAxis = !0,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = !0,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset)
        return {};
      const side = getSide(placement), initialSideAxis = getSideAxis(initialPlacement), isBasePlacement = getSide(initialPlacement) === initialPlacement, rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)), fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement)), hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      !specifiedFallbackPlacements && hasFallbackAxisSideDirection && fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      const placements = [initialPlacement, ...fallbackPlacements], overflow = await detectOverflow(state, detectOverflowOptions), overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis && overflows.push(overflow[side]), checkCrossAxis) {
        const sides = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides[0]], overflow[sides[1]]);
      }
      if (overflowsData = [...overflowsData, {
        placement,
        overflows
      }], !overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1, nextPlacement = placements[nextIndex];
        if (nextPlacement)
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement)
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return !0;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              placement2 && (resetPlacement = placement2);
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        if (placement !== resetPlacement)
          return {
            reset: {
              placement: resetPlacement
            }
          };
      }
      return {};
    }
  };
};
function getBoundingRect(rects) {
  const minX = min(...rects.map((rect) => rect.left)), minY = min(...rects.map((rect) => rect.top)), maxX = max(...rects.map((rect) => rect.right)), maxY = max(...rects.map((rect) => rect.bottom));
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getRectsByLine(rects) {
  const sortedRects = rects.slice().sort((a, b) => a.y - b.y), groups = [];
  let prevRect = null;
  for (let i = 0; i < sortedRects.length; i++) {
    const rect = sortedRects[i];
    !prevRect || rect.y - prevRect.y > prevRect.height / 2 ? groups.push([rect]) : groups[groups.length - 1].push(rect), prevRect = rect;
  }
  return groups.map((rect) => rectToClientRect(getBoundingRect(rect)));
}
const inline$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "inline",
    options,
    async fn(state) {
      const {
        placement,
        elements,
        rects,
        platform: platform2,
        strategy
      } = state, {
        padding = 2,
        x,
        y
      } = evaluate(options, state), nativeClientRects = Array.from(await (platform2.getClientRects == null ? void 0 : platform2.getClientRects(elements.reference)) || []), clientRects = getRectsByLine(nativeClientRects), fallback = rectToClientRect(getBoundingRect(nativeClientRects)), paddingObject = getPaddingObject(padding);
      function getBoundingClientRect2() {
        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null)
          return clientRects.find((rect) => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;
        if (clientRects.length >= 2) {
          if (getSideAxis(placement) === "y") {
            const firstRect = clientRects[0], lastRect = clientRects[clientRects.length - 1], isTop = getSide(placement) === "top", top2 = firstRect.top, bottom2 = lastRect.bottom, left2 = isTop ? firstRect.left : lastRect.left, right2 = isTop ? firstRect.right : lastRect.right, width2 = right2 - left2, height2 = bottom2 - top2;
            return {
              top: top2,
              bottom: bottom2,
              left: left2,
              right: right2,
              width: width2,
              height: height2,
              x: left2,
              y: top2
            };
          }
          const isLeftSide = getSide(placement) === "left", maxRight = max(...clientRects.map((rect) => rect.right)), minLeft = min(...clientRects.map((rect) => rect.left)), measureRects = clientRects.filter((rect) => isLeftSide ? rect.left === minLeft : rect.right === maxRight), top = measureRects[0].top, bottom = measureRects[measureRects.length - 1].bottom, left = minLeft, right = maxRight, width = right - left, height = bottom - top;
          return {
            top,
            bottom,
            left,
            right,
            width,
            height,
            x: left,
            y: top
          };
        }
        return fallback;
      }
      const resetRects = await platform2.getElementRects({
        reference: {
          getBoundingClientRect: getBoundingClientRect2
        },
        floating: elements.floating,
        strategy
      });
      return rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height ? {
        reset: {
          rects: resetRects
        }
      } : {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state, rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)), side = getSide(placement), alignment = getAlignment(placement), isVertical = getSideAxis(placement) === "y", mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1, crossAxisMulti = rtl && isVertical ? -1 : 1, rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue == "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  return alignment && typeof alignmentAxis == "number" && (crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis), isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2 = function(options) {
  return options === void 0 && (options = 0), {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state, diffCoords = await convertValueToCoords(state, options);
      return placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset ? {} : {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
}, shift$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state, {
        mainAxis: checkMainAxis = !0,
        crossAxis: checkCrossAxis = !1,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state), coords = {
        x,
        y
      }, overflow = await detectOverflow(state, detectOverflowOptions), crossAxis = getSideAxis(getSide(placement)), mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis], crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left", maxSide = mainAxis === "y" ? "bottom" : "right", min2 = mainAxisCoord + overflow[minSide], max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left", maxSide = crossAxis === "y" ? "bottom" : "right", min2 = crossAxisCoord + overflow[minSide], max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      };
    }
  };
}, limitShift$2 = function(options) {
  return options === void 0 && (options = {}), {
    options,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state, {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = !0,
        crossAxis: checkCrossAxis = !0
      } = evaluate(options, state), coords = {
        x,
        y
      }, crossAxis = getSideAxis(placement), mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis], crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state), computedOffset = typeof rawOffset == "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width", limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis, limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        mainAxisCoord < limitMin ? mainAxisCoord = limitMin : mainAxisCoord > limitMax && (mainAxisCoord = limitMax);
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height", isOriginSide = ["top", "left"].includes(getSide(placement)), limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide && ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0) + (isOriginSide ? 0 : computedOffset.crossAxis), limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        crossAxisCoord < limitMin ? crossAxisCoord = limitMin : crossAxisCoord > limitMax && (crossAxisCoord = limitMax);
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
}, size$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "size",
    options,
    async fn(state) {
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state, {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state), overflow = await detectOverflow(state, detectOverflowOptions), side = getSide(placement), alignment = getAlignment(placement), isYAxis = getSideAxis(placement) === "y", {
        width,
        height
      } = rects.floating;
      let heightSide, widthSide;
      side === "top" || side === "bottom" ? (heightSide = side, widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right") : (widthSide = side, heightSide = alignment === "end" ? "top" : "bottom");
      const maximumClippingHeight = height - overflow.top - overflow.bottom, maximumClippingWidth = width - overflow.left - overflow.right, overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight), overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth), noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight, availableWidth = overflowAvailableWidth;
      if (isYAxis ? availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth : availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight, noShift && !alignment) {
        const xMin = max(overflow.left, 0), xMax = max(overflow.right, 0), yMin = max(overflow.top, 0), yMax = max(overflow.bottom, 0);
        isYAxis ? availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right)) : availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      return width !== nextDimensions.width || height !== nextDimensions.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0, height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element), offsetWidth = hasOffset ? element.offsetWidth : width, offsetHeight = hasOffset ? element.offsetHeight : height, shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  return shouldFallback && (width = offsetWidth, height = offsetHeight), {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return isElement(element) ? element : element.contextElement;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement))
    return createCoords(1);
  const rect = domElement.getBoundingClientRect(), {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width, y = ($ ? round(rect.height) : rect.height) / height;
  return (!x || !Number.isFinite(x)) && (x = 1), (!y || !Number.isFinite(y)) && (y = 1), {
    x,
    y
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  return !isWebKit() || !win.visualViewport ? noOffsets : {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  return isFixed === void 0 && (isFixed = !1), !floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element) ? !1 : isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  includeScale === void 0 && (includeScale = !1), isFixedStrategy === void 0 && (isFixedStrategy = !1);
  const clientRect = element.getBoundingClientRect(), domElement = unwrapElement(element);
  let scale = createCoords(1);
  includeScale && (offsetParent ? isElement(offsetParent) && (scale = getScale(offsetParent)) : scale = getScale(element));
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x, y = (clientRect.top + visualOffsets.y) / scale.y, width = clientRect.width / scale.x, height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement), offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win, currentIFrame = currentWin.frameElement;
    for (; currentIFrame && offsetParent && offsetWin !== currentWin; ) {
      const iframeScale = getScale(currentIFrame), iframeRect = currentIFrame.getBoundingClientRect(), css = getComputedStyle$1(currentIFrame), left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x, top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x, y *= iframeScale.y, width *= iframeScale.x, height *= iframeScale.y, x += left, y += top, currentWin = getWindow(currentIFrame), currentIFrame = currentWin.frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed", documentElement = getDocumentElement(offsetParent), topLayer = elements ? isTopLayer(elements.floating) : !1;
  if (offsetParent === documentElement || topLayer && isFixed)
    return rect;
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  }, scale = createCoords(1);
  const offsets = createCoords(0), isOffsetParentAnElement = isHTMLElement(offsetParent);
  if ((isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) && ((getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) && (scroll = getNodeScroll(offsetParent)), isHTMLElement(offsetParent))) {
    const offsetRect = getBoundingClientRect(offsetParent);
    scale = getScale(offsetParent), offsets.x = offsetRect.x + offsetParent.clientLeft, offsets.y = offsetRect.y + offsetParent.clientTop;
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element), scroll = getNodeScroll(element), body = element.ownerDocument.body, width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth), height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  return getComputedStyle$1(body).direction === "rtl" && (x += max(html.clientWidth, body.clientWidth) - width), {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element), html = getDocumentElement(element), visualViewport = win.visualViewport;
  let width = html.clientWidth, height = html.clientHeight, x = 0, y = 0;
  if (visualViewport) {
    width = visualViewport.width, height = visualViewport.height;
    const visualViewportBased = isWebKit();
    (!visualViewportBased || visualViewportBased && strategy === "fixed") && (x = visualViewport.offsetLeft, y = visualViewport.offsetTop);
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, !0, strategy === "fixed"), top = clientRect.top + element.clientTop, left = clientRect.left + element.clientLeft, scale = isHTMLElement(element) ? getScale(element) : createCoords(1), width = element.clientWidth * scale.x, height = element.clientHeight * scale.y, x = left * scale.x, y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport")
    rect = getViewportRect(element, strategy);
  else if (clippingAncestor === "document")
    rect = getDocumentRect(getDocumentElement(element));
  else if (isElement(clippingAncestor))
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  return parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode) ? !1 : getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult)
    return cachedResult;
  let result = getOverflowAncestors(element, [], !1).filter((el) => isElement(el) && getNodeName(el) !== "body"), currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  for (; isElement(currentNode) && !isLastTraversableNode(currentNode); ) {
    const computedStyle = getComputedStyle$1(currentNode), currentNodeIsContaining = isContainingBlock(currentNode);
    !currentNodeIsContaining && computedStyle.position === "fixed" && (currentContainingBlockComputedStyle = null), (elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode)) ? result = result.filter((ancestor) => ancestor !== currentNode) : currentContainingBlockComputedStyle = computedStyle, currentNode = getParentNode(currentNode);
  }
  return cache.set(element, result), result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const clippingAncestors = [...boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary), rootBoundary], firstClippingAncestor = clippingAncestors[0], clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    return accRect.top = max(rect.top, accRect.top), accRect.right = min(rect.right, accRect.right), accRect.bottom = min(rect.bottom, accRect.bottom), accRect.left = max(rect.left, accRect.left), accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent), documentElement = getDocumentElement(offsetParent), isFixed = strategy === "fixed", rect = getBoundingClientRect(element, !0, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed)
    if ((getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) && (scroll = getNodeScroll(offsetParent)), isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, !0, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft, offsets.y = offsetRect.y + offsetParent.clientTop;
    } else documentElement && (offsets.x = getWindowScrollBarX(documentElement));
  const x = rect.left + scroll.scrollLeft - offsets.x, y = rect.top + scroll.scrollTop - offsets.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  return !isHTMLElement(element) || getComputedStyle$1(element).position === "fixed" ? null : polyfill ? polyfill(element) : element.offsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element))
    return win;
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    for (; svgOffsetParent && !isLastTraversableNode(svgOffsetParent); ) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent))
        return svgOffsetParent;
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  for (; offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent); )
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  return offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent) ? win : offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent, getDimensionsFn = this.getDimensions, floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element, onMove) {
  let io = null, timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId), (_io = io) == null || _io.disconnect(), io = null;
  }
  function refresh(skip, threshold) {
    skip === void 0 && (skip = !1), threshold === void 0 && (threshold = 1), cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (skip || onMove(), !width || !height)
      return;
    const insetTop = floor(top), insetRight = floor(root.clientWidth - (left + width)), insetBottom = floor(root.clientHeight - (top + height)), insetLeft = floor(left), options = {
      rootMargin: -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px",
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = !0;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate)
          return refresh();
        ratio ? refresh(!1, ratio) : timeoutId = setTimeout(() => {
          refresh(!1, 1e-7);
        }, 1e3);
      }
      isFirstUpdate = !1;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  return refresh(!0), cleanup;
}
function autoUpdate(reference, floating, update, options) {
  options === void 0 && (options = {});
  const {
    ancestorScroll = !0,
    ancestorResize = !0,
    elementResize = typeof ResizeObserver == "function",
    layoutShift = typeof IntersectionObserver == "function",
    animationFrame = !1
  } = options, referenceEl = unwrapElement(reference), ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: !0
    }), ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1, resizeObserver = null;
  elementResize && (resizeObserver = new ResizeObserver((_ref) => {
    let [firstEntry] = _ref;
    firstEntry && firstEntry.target === referenceEl && resizeObserver && (resizeObserver.unobserve(floating), cancelAnimationFrame(reobserveFrame), reobserveFrame = requestAnimationFrame(() => {
      var _resizeObserver;
      (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
    })), update();
  }), referenceEl && !animationFrame && resizeObserver.observe(referenceEl), resizeObserver.observe(floating));
  let frameId, prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  animationFrame && frameLoop();
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height) && update(), prevRefRect = nextRefRect, frameId = requestAnimationFrame(frameLoop);
  }
  return update(), () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update), ancestorResize && ancestor.removeEventListener("resize", update);
    }), cleanupIo?.(), (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect(), resizeObserver = null, animationFrame && cancelAnimationFrame(frameId);
  };
}
const offset$1 = offset$2, shift$1 = shift$2, flip$1 = flip$2, size$1 = size$2, arrow$2 = arrow$3, inline$1 = inline$2, limitShift$1 = limitShift$2, computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map(), mergedOptions = {
    platform,
    ...options
  }, platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var index$1 = typeof document < "u" ? useLayoutEffect : useEffect;
function deepEqual(a, b) {
  if (a === b)
    return !0;
  if (typeof a != typeof b)
    return !1;
  if (typeof a == "function" && a.toString() === b.toString())
    return !0;
  let length, i, keys2;
  if (a && b && typeof a == "object") {
    if (Array.isArray(a)) {
      if (length = a.length, length !== b.length) return !1;
      for (i = length; i-- !== 0; )
        if (!deepEqual(a[i], b[i]))
          return !1;
      return !0;
    }
    if (keys2 = Object.keys(a), length = keys2.length, length !== Object.keys(b).length)
      return !1;
    for (i = length; i-- !== 0; )
      if (!{}.hasOwnProperty.call(b, keys2[i]))
        return !1;
    for (i = length; i-- !== 0; ) {
      const key = keys2[i];
      if (!(key === "_owner" && a.$$typeof) && !deepEqual(a[key], b[key]))
        return !1;
    }
    return !0;
  }
  return a !== a && b !== b;
}
function getDPR(element) {
  return typeof window > "u" ? 1 : (element.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef$1(value) {
  const ref = React.useRef(value);
  return index$1(() => {
    ref.current = value;
  }), ref;
}
function useFloating$1(options) {
  options === void 0 && (options = {});
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = !0,
    whileElementsMounted,
    open
  } = options, [data, setData] = React.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: !1
  }), [latestMiddleware, setLatestMiddleware] = React.useState(middleware);
  deepEqual(latestMiddleware, middleware) || setLatestMiddleware(middleware);
  const [_reference, _setReference] = React.useState(null), [_floating, _setFloating] = React.useState(null), setReference = React.useCallback((node) => {
    node !== referenceRef.current && (referenceRef.current = node, _setReference(node));
  }, []), setFloating = React.useCallback((node) => {
    node !== floatingRef.current && (floatingRef.current = node, _setFloating(node));
  }, []), referenceEl = externalReference || _reference, floatingEl = externalFloating || _floating, referenceRef = React.useRef(null), floatingRef = React.useRef(null), dataRef = React.useRef(data), hasWhileElementsMounted = whileElementsMounted != null, whileElementsMountedRef = useLatestRef$1(whileElementsMounted), platformRef = useLatestRef$1(platform2), openRef = useLatestRef$1(open), update = React.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current)
      return;
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    platformRef.current && (config.platform = platformRef.current), computePosition(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== !1
      };
      isMountedRef.current && !deepEqual(dataRef.current, fullData) && (dataRef.current = fullData, ReactDOM.flushSync(() => {
        setData(fullData);
      }));
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index$1(() => {
    open === !1 && dataRef.current.isPositioned && (dataRef.current.isPositioned = !1, setData((data2) => ({
      ...data2,
      isPositioned: !1
    })));
  }, [open]);
  const isMountedRef = React.useRef(!1);
  index$1(() => (isMountedRef.current = !0, () => {
    isMountedRef.current = !1;
  }), []), index$1(() => {
    if (referenceEl && (referenceRef.current = referenceEl), floatingEl && (floatingRef.current = floatingEl), referenceEl && floatingEl) {
      if (whileElementsMountedRef.current)
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]), elements = React.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]), floatingStyles = React.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating)
      return initialStyles;
    const x = roundByDPR(elements.floating, data.x), y = roundByDPR(elements.floating, data.y);
    return transform ? {
      ...initialStyles,
      transform: "translate(" + x + "px, " + y + "px)",
      ...getDPR(elements.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: strategy,
      left: x,
      top: y
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
const arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options == "function" ? options(state) : options;
      return element && isRef(element) ? element.current != null ? arrow$2({
        element: element.current,
        padding
      }).fn(state) : {} : element ? arrow$2({
        element,
        padding
      }).fn(state) : {};
    }
  };
}, offset = (options, deps) => ({
  ...offset$1(options),
  options: [options, deps]
}), shift = (options, deps) => ({
  ...shift$1(options),
  options: [options, deps]
}), limitShift = (options, deps) => ({
  ...limitShift$1(options),
  options: [options, deps]
}), flip = (options, deps) => ({
  ...flip$1(options),
  options: [options, deps]
}), size = (options, deps) => ({
  ...size$1(options),
  options: [options, deps]
}), inline = (options, deps) => ({
  ...inline$1(options),
  options: [options, deps]
}), arrow = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
}), SafeReact = {
  ...React
}, useInsertionEffect = SafeReact.useInsertionEffect, useSafeInsertionEffect = useInsertionEffect || ((fn) => fn());
function useEffectEvent(callback) {
  const ref = React.useRef(() => {
  });
  return useSafeInsertionEffect(() => {
    ref.current = callback;
  }), React.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}
var index = typeof document < "u" ? useLayoutEffect : useEffect;
let serverHandoffComplete = !1, count = 0;
const genId = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++
);
function useFloatingId() {
  const [id, setId] = React.useState(() => serverHandoffComplete ? genId() : void 0);
  return index(() => {
    id == null && setId(genId());
  }, []), React.useEffect(() => {
    serverHandoffComplete = !0;
  }, []), id;
}
const useReactId = SafeReact.useId, useId = useReactId || useFloatingId;
function createPubSub() {
  const map = /* @__PURE__ */ new Map();
  return {
    emit(event, data) {
      var _map$get;
      (_map$get = map.get(event)) == null || _map$get.forEach((handler) => handler(data));
    },
    on(event, listener) {
      map.set(event, [...map.get(event) || [], listener]);
    },
    off(event, listener) {
      var _map$get2;
      map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter((l) => l !== listener)) || []);
    }
  };
}
const FloatingNodeContext = /* @__PURE__ */ React.createContext(null), FloatingTreeContext = /* @__PURE__ */ React.createContext(null), useFloatingParentNodeId = () => {
  var _React$useContext;
  return ((_React$useContext = React.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
}, useFloatingTree = () => React.useContext(FloatingTreeContext);
function createAttribute(name) {
  return "data-floating-ui-" + name;
}
function useLatestRef(value) {
  const ref = useRef(value);
  return index(() => {
    ref.current = value;
  }), ref;
}
const safePolygonIdentifier = /* @__PURE__ */ createAttribute("safe-polygon");
function getDelay(value, prop, pointerType) {
  return pointerType && !isMouseLikePointerType(pointerType) ? 0 : typeof value == "number" ? value : value?.[prop];
}
function useHover(context, props) {
  props === void 0 && (props = {});
  const {
    open,
    onOpenChange,
    dataRef,
    events,
    elements
  } = context, {
    enabled = !0,
    delay = 0,
    handleClose = null,
    mouseOnly = !1,
    restMs = 0,
    move = !0
  } = props, tree = useFloatingTree(), parentId = useFloatingParentNodeId(), handleCloseRef = useLatestRef(handleClose), delayRef = useLatestRef(delay), openRef = useLatestRef(open), pointerTypeRef = React.useRef(), timeoutRef = React.useRef(-1), handlerRef = React.useRef(), restTimeoutRef = React.useRef(-1), blockMouseMoveRef = React.useRef(!0), performedPointerEventsMutationRef = React.useRef(!1), unbindMouseMoveRef = React.useRef(() => {
  }), restTimeoutPendingRef = React.useRef(!1), isHoverOpen = React.useCallback(() => {
    var _dataRef$current$open;
    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;
    return type?.includes("mouse") && type !== "mousedown";
  }, [dataRef]);
  React.useEffect(() => {
    if (!enabled) return;
    function onOpenChange2(_ref) {
      let {
        open: open2
      } = _ref;
      open2 || (clearTimeout(timeoutRef.current), clearTimeout(restTimeoutRef.current), blockMouseMoveRef.current = !0, restTimeoutPendingRef.current = !1);
    }
    return events.on("openchange", onOpenChange2), () => {
      events.off("openchange", onOpenChange2);
    };
  }, [enabled, events]), React.useEffect(() => {
    if (!enabled || !handleCloseRef.current || !open) return;
    function onLeave(event) {
      isHoverOpen() && onOpenChange(!1, event, "hover");
    }
    const html = getDocument(elements.floating).documentElement;
    return html.addEventListener("mouseleave", onLeave), () => {
      html.removeEventListener("mouseleave", onLeave);
    };
  }, [elements.floating, open, onOpenChange, enabled, handleCloseRef, isHoverOpen]);
  const closeWithDelay = React.useCallback(function(event, runElseBranch, reason) {
    runElseBranch === void 0 && (runElseBranch = !0), reason === void 0 && (reason = "hover");
    const closeDelay = getDelay(delayRef.current, "close", pointerTypeRef.current);
    closeDelay && !handlerRef.current ? (clearTimeout(timeoutRef.current), timeoutRef.current = window.setTimeout(() => onOpenChange(!1, event, reason), closeDelay)) : runElseBranch && (clearTimeout(timeoutRef.current), onOpenChange(!1, event, reason));
  }, [delayRef, onOpenChange]), cleanupMouseMoveHandler = useEffectEvent(() => {
    unbindMouseMoveRef.current(), handlerRef.current = void 0;
  }), clearPointerEvents = useEffectEvent(() => {
    if (performedPointerEventsMutationRef.current) {
      const body = getDocument(elements.floating).body;
      body.style.pointerEvents = "", body.removeAttribute(safePolygonIdentifier), performedPointerEventsMutationRef.current = !1;
    }
  }), isClickLikeOpenEvent = useEffectEvent(() => dataRef.current.openEvent ? ["click", "mousedown"].includes(dataRef.current.openEvent.type) : !1);
  React.useEffect(() => {
    if (!enabled) return;
    function onMouseEnter(event) {
      if (clearTimeout(timeoutRef.current), blockMouseMoveRef.current = !1, mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || restMs > 0 && !getDelay(delayRef.current, "open"))
        return;
      const openDelay = getDelay(delayRef.current, "open", pointerTypeRef.current);
      openDelay ? timeoutRef.current = window.setTimeout(() => {
        openRef.current || onOpenChange(!0, event, "hover");
      }, openDelay) : open || onOpenChange(!0, event, "hover");
    }
    function onMouseLeave(event) {
      if (isClickLikeOpenEvent()) return;
      unbindMouseMoveRef.current();
      const doc = getDocument(elements.floating);
      if (clearTimeout(restTimeoutRef.current), restTimeoutPendingRef.current = !1, handleCloseRef.current && dataRef.current.floatingContext) {
        open || clearTimeout(timeoutRef.current), handlerRef.current = handleCloseRef.current({
          ...dataRef.current.floatingContext,
          tree,
          x: event.clientX,
          y: event.clientY,
          onClose() {
            clearPointerEvents(), cleanupMouseMoveHandler(), isClickLikeOpenEvent() || closeWithDelay(event, !0, "safe-polygon");
          }
        });
        const handler = handlerRef.current;
        doc.addEventListener("mousemove", handler), unbindMouseMoveRef.current = () => {
          doc.removeEventListener("mousemove", handler);
        };
        return;
      }
      (pointerTypeRef.current === "touch" ? !contains(elements.floating, event.relatedTarget) : !0) && closeWithDelay(event);
    }
    function onScrollMouseLeave(event) {
      isClickLikeOpenEvent() || dataRef.current.floatingContext && (handleCloseRef.current == null || handleCloseRef.current({
        ...dataRef.current.floatingContext,
        tree,
        x: event.clientX,
        y: event.clientY,
        onClose() {
          clearPointerEvents(), cleanupMouseMoveHandler(), isClickLikeOpenEvent() || closeWithDelay(event);
        }
      })(event));
    }
    if (isElement(elements.domReference)) {
      var _elements$floating;
      const ref = elements.domReference;
      return open && ref.addEventListener("mouseleave", onScrollMouseLeave), (_elements$floating = elements.floating) == null || _elements$floating.addEventListener("mouseleave", onScrollMouseLeave), move && ref.addEventListener("mousemove", onMouseEnter, {
        once: !0
      }), ref.addEventListener("mouseenter", onMouseEnter), ref.addEventListener("mouseleave", onMouseLeave), () => {
        var _elements$floating2;
        open && ref.removeEventListener("mouseleave", onScrollMouseLeave), (_elements$floating2 = elements.floating) == null || _elements$floating2.removeEventListener("mouseleave", onScrollMouseLeave), move && ref.removeEventListener("mousemove", onMouseEnter), ref.removeEventListener("mouseenter", onMouseEnter), ref.removeEventListener("mouseleave", onMouseLeave);
      };
    }
  }, [elements, enabled, context, mouseOnly, restMs, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, openRef, tree, delayRef, handleCloseRef, dataRef, isClickLikeOpenEvent]), index(() => {
    var _handleCloseRef$curre;
    if (enabled && open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {
      performedPointerEventsMutationRef.current = !0;
      const floatingEl = elements.floating;
      if (isElement(elements.domReference) && floatingEl) {
        var _tree$nodesRef$curren;
        const body = getDocument(elements.floating).body;
        body.setAttribute(safePolygonIdentifier, "");
        const ref = elements.domReference, parentFloating = tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find((node) => node.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren.elements.floating;
        return parentFloating && (parentFloating.style.pointerEvents = ""), body.style.pointerEvents = "none", ref.style.pointerEvents = "auto", floatingEl.style.pointerEvents = "auto", () => {
          body.style.pointerEvents = "", ref.style.pointerEvents = "", floatingEl.style.pointerEvents = "";
        };
      }
    }
  }, [enabled, open, parentId, elements, tree, handleCloseRef, isHoverOpen]), index(() => {
    open || (pointerTypeRef.current = void 0, restTimeoutPendingRef.current = !1, cleanupMouseMoveHandler(), clearPointerEvents());
  }, [open, cleanupMouseMoveHandler, clearPointerEvents]), React.useEffect(() => () => {
    cleanupMouseMoveHandler(), clearTimeout(timeoutRef.current), clearTimeout(restTimeoutRef.current), clearPointerEvents();
  }, [enabled, elements.domReference, cleanupMouseMoveHandler, clearPointerEvents]);
  const reference = React.useMemo(() => {
    function setPointerRef(event) {
      pointerTypeRef.current = event.pointerType;
    }
    return {
      onPointerDown: setPointerRef,
      onPointerEnter: setPointerRef,
      onMouseMove(event) {
        const {
          nativeEvent
        } = event;
        function handleMouseMove() {
          !blockMouseMoveRef.current && !openRef.current && onOpenChange(!0, nativeEvent, "hover");
        }
        mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || open || restMs === 0 || restTimeoutPendingRef.current && event.movementX ** 2 + event.movementY ** 2 < 2 || (clearTimeout(restTimeoutRef.current), pointerTypeRef.current === "touch" ? handleMouseMove() : (restTimeoutPendingRef.current = !0, restTimeoutRef.current = window.setTimeout(handleMouseMove, restMs)));
      }
    };
  }, [mouseOnly, onOpenChange, open, openRef, restMs]), floating = React.useMemo(() => ({
    onMouseEnter() {
      clearTimeout(timeoutRef.current);
    },
    onMouseLeave(event) {
      isClickLikeOpenEvent() || closeWithDelay(event.nativeEvent, !1);
    }
  }), [closeWithDelay, isClickLikeOpenEvent]);
  return React.useMemo(() => enabled ? {
    reference,
    floating
  } : {}, [enabled, reference, floating]);
}
const NOOP = () => {
}, FloatingDelayGroupContext = /* @__PURE__ */ React.createContext({
  delay: 0,
  initialDelay: 0,
  timeoutMs: 0,
  currentId: null,
  setCurrentId: NOOP,
  setState: NOOP,
  isInstantPhase: !1
}), useDelayGroupContext = () => React.useContext(FloatingDelayGroupContext);
function FloatingDelayGroup(props) {
  const {
    children,
    delay,
    timeoutMs = 0
  } = props, [state, setState] = React.useReducer((prev, next) => ({
    ...prev,
    ...next
  }), {
    delay,
    timeoutMs,
    initialDelay: delay,
    currentId: null,
    isInstantPhase: !1
  }), initialCurrentIdRef = React.useRef(null), setCurrentId = React.useCallback((currentId) => {
    setState({
      currentId
    });
  }, []);
  return index(() => {
    state.currentId ? initialCurrentIdRef.current === null ? initialCurrentIdRef.current = state.currentId : state.isInstantPhase || setState({
      isInstantPhase: !0
    }) : (state.isInstantPhase && setState({
      isInstantPhase: !1
    }), initialCurrentIdRef.current = null);
  }, [state.currentId, state.isInstantPhase]), /* @__PURE__ */ React.createElement(FloatingDelayGroupContext.Provider, {
    value: React.useMemo(() => ({
      ...state,
      setState,
      setCurrentId
    }), [state, setCurrentId])
  }, children);
}
function useDelayGroup(context, options) {
  options === void 0 && (options = {});
  const {
    open,
    onOpenChange,
    floatingId
  } = context, {
    id: optionId,
    enabled = !0
  } = options, id = optionId ?? floatingId, groupContext = useDelayGroupContext(), {
    currentId,
    setCurrentId,
    initialDelay,
    setState,
    timeoutMs
  } = groupContext;
  return index(() => {
    enabled && currentId && (setState({
      delay: {
        open: 1,
        close: getDelay(initialDelay, "close")
      }
    }), currentId !== id && onOpenChange(!1));
  }, [enabled, id, onOpenChange, setState, currentId, initialDelay]), index(() => {
    function unset() {
      onOpenChange(!1), setState({
        delay: initialDelay,
        currentId: null
      });
    }
    if (enabled && currentId && !open && currentId === id) {
      if (timeoutMs) {
        const timeout = window.setTimeout(unset, timeoutMs);
        return () => {
          clearTimeout(timeout);
        };
      }
      unset();
    }
  }, [enabled, open, setState, currentId, id, onOpenChange, initialDelay, timeoutMs]), index(() => {
    enabled && (setCurrentId === NOOP || !open || setCurrentId(id));
  }, [enabled, open, setCurrentId, id]), groupContext;
}
function getChildren(nodes, id) {
  let allChildren = nodes.filter((node) => {
    var _node$context;
    return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);
  }), currentChildren = allChildren;
  for (; currentChildren.length; )
    currentChildren = nodes.filter((node) => {
      var _currentChildren;
      return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some((n) => {
        var _node$context2;
        return node.parentId === n.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);
      });
    }), allChildren = allChildren.concat(currentChildren);
  return allChildren;
}
const FOCUSABLE_ATTRIBUTE = "data-floating-ui-focusable", bubbleHandlerKeys = {
  pointerdown: "onPointerDown",
  mousedown: "onMouseDown",
  click: "onClick"
}, captureHandlerKeys = {
  pointerdown: "onPointerDownCapture",
  mousedown: "onMouseDownCapture",
  click: "onClickCapture"
}, normalizeProp = (normalizable) => {
  var _normalizable$escapeK, _normalizable$outside;
  return {
    escapeKey: typeof normalizable == "boolean" ? normalizable : (_normalizable$escapeK = normalizable?.escapeKey) != null ? _normalizable$escapeK : !1,
    outsidePress: typeof normalizable == "boolean" ? normalizable : (_normalizable$outside = normalizable?.outsidePress) != null ? _normalizable$outside : !0
  };
};
function useDismiss(context, props) {
  props === void 0 && (props = {});
  const {
    open,
    onOpenChange,
    elements,
    dataRef
  } = context, {
    enabled = !0,
    escapeKey = !0,
    outsidePress: unstable_outsidePress = !0,
    outsidePressEvent = "pointerdown",
    referencePress = !1,
    referencePressEvent = "pointerdown",
    ancestorScroll = !1,
    bubbles,
    capture
  } = props, tree = useFloatingTree(), outsidePressFn = useEffectEvent(typeof unstable_outsidePress == "function" ? unstable_outsidePress : () => !1), outsidePress = typeof unstable_outsidePress == "function" ? outsidePressFn : unstable_outsidePress, insideReactTreeRef = React.useRef(!1), endedOrStartedInsideRef = React.useRef(!1), {
    escapeKey: escapeKeyBubbles,
    outsidePress: outsidePressBubbles
  } = normalizeProp(bubbles), {
    escapeKey: escapeKeyCapture,
    outsidePress: outsidePressCapture
  } = normalizeProp(capture), isComposingRef = React.useRef(!1), closeOnEscapeKeyDown = useEffectEvent((event) => {
    var _dataRef$current$floa;
    if (!open || !enabled || !escapeKey || event.key !== "Escape" || isComposingRef.current)
      return;
    const nodeId = (_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.nodeId, children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];
    if (!escapeKeyBubbles && (event.stopPropagation(), children.length > 0)) {
      let shouldDismiss = !0;
      if (children.forEach((child) => {
        var _child$context;
        if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {
          shouldDismiss = !1;
          return;
        }
      }), !shouldDismiss)
        return;
    }
    onOpenChange(!1, isReactEvent(event) ? event.nativeEvent : event, "escape-key");
  }), closeOnEscapeKeyDownCapture = useEffectEvent((event) => {
    var _getTarget2;
    const callback = () => {
      var _getTarget;
      closeOnEscapeKeyDown(event), (_getTarget = getTarget(event)) == null || _getTarget.removeEventListener("keydown", callback);
    };
    (_getTarget2 = getTarget(event)) == null || _getTarget2.addEventListener("keydown", callback);
  }), closeOnPressOutside = useEffectEvent((event) => {
    var _dataRef$current$floa2;
    const insideReactTree = insideReactTreeRef.current;
    insideReactTreeRef.current = !1;
    const endedOrStartedInside = endedOrStartedInsideRef.current;
    if (endedOrStartedInsideRef.current = !1, outsidePressEvent === "click" && endedOrStartedInside || insideReactTree || typeof outsidePress == "function" && !outsidePress(event))
      return;
    const target = getTarget(event), inertSelector = "[" + createAttribute("inert") + "]", markers = getDocument(elements.floating).querySelectorAll(inertSelector);
    let targetRootAncestor = isElement(target) ? target : null;
    for (; targetRootAncestor && !isLastTraversableNode(targetRootAncestor); ) {
      const nextParent = getParentNode(targetRootAncestor);
      if (isLastTraversableNode(nextParent) || !isElement(nextParent))
        break;
      targetRootAncestor = nextParent;
    }
    if (markers.length && isElement(target) && !isRootElement(target) && // Clicked on a direct ancestor (e.g. FloatingOverlay).
    !contains(target, elements.floating) && // If the target root element contains none of the markers, then the
    // element was injected after the floating element rendered.
    Array.from(markers).every((marker) => !contains(targetRootAncestor, marker)))
      return;
    if (isHTMLElement(target) && floating) {
      const canScrollX = target.clientWidth > 0 && target.scrollWidth > target.clientWidth, canScrollY = target.clientHeight > 0 && target.scrollHeight > target.clientHeight;
      let xCond = canScrollY && event.offsetX > target.clientWidth;
      if (canScrollY && getComputedStyle$1(target).direction === "rtl" && (xCond = event.offsetX <= target.offsetWidth - target.clientWidth), xCond || canScrollX && event.offsetY > target.clientHeight)
        return;
    }
    const nodeId = (_dataRef$current$floa2 = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa2.nodeId, targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some((node) => {
      var _node$context;
      return isEventTargetWithin(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);
    });
    if (isEventTargetWithin(event, elements.floating) || isEventTargetWithin(event, elements.domReference) || targetIsInsideChildren)
      return;
    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];
    if (children.length > 0) {
      let shouldDismiss = !0;
      if (children.forEach((child) => {
        var _child$context2;
        if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {
          shouldDismiss = !1;
          return;
        }
      }), !shouldDismiss)
        return;
    }
    onOpenChange(!1, event, "outside-press");
  }), closeOnPressOutsideCapture = useEffectEvent((event) => {
    var _getTarget4;
    const callback = () => {
      var _getTarget3;
      closeOnPressOutside(event), (_getTarget3 = getTarget(event)) == null || _getTarget3.removeEventListener(outsidePressEvent, callback);
    };
    (_getTarget4 = getTarget(event)) == null || _getTarget4.addEventListener(outsidePressEvent, callback);
  });
  React.useEffect(() => {
    if (!open || !enabled)
      return;
    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles, dataRef.current.__outsidePressBubbles = outsidePressBubbles;
    let compositionTimeout = -1;
    function onScroll(event) {
      onOpenChange(!1, event, "ancestor-scroll");
    }
    function handleCompositionStart() {
      window.clearTimeout(compositionTimeout), isComposingRef.current = !0;
    }
    function handleCompositionEnd() {
      compositionTimeout = window.setTimeout(
        () => {
          isComposingRef.current = !1;
        },
        // 0ms or 1ms don't work in Safari. 5ms appears to consistently work.
        // Only apply to WebKit for the test to remain 0ms.
        isWebKit() ? 5 : 0
      );
    }
    const doc = getDocument(elements.floating);
    escapeKey && (doc.addEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture), doc.addEventListener("compositionstart", handleCompositionStart), doc.addEventListener("compositionend", handleCompositionEnd)), outsidePress && doc.addEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);
    let ancestors = [];
    return ancestorScroll && (isElement(elements.domReference) && (ancestors = getOverflowAncestors(elements.domReference)), isElement(elements.floating) && (ancestors = ancestors.concat(getOverflowAncestors(elements.floating))), !isElement(elements.reference) && elements.reference && elements.reference.contextElement && (ancestors = ancestors.concat(getOverflowAncestors(elements.reference.contextElement)))), ancestors = ancestors.filter((ancestor) => {
      var _doc$defaultView;
      return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);
    }), ancestors.forEach((ancestor) => {
      ancestor.addEventListener("scroll", onScroll, {
        passive: !0
      });
    }), () => {
      escapeKey && (doc.removeEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture), doc.removeEventListener("compositionstart", handleCompositionStart), doc.removeEventListener("compositionend", handleCompositionEnd)), outsidePress && doc.removeEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture), ancestors.forEach((ancestor) => {
        ancestor.removeEventListener("scroll", onScroll);
      }), window.clearTimeout(compositionTimeout);
    };
  }, [dataRef, elements, escapeKey, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, escapeKeyCapture, closeOnEscapeKeyDownCapture, closeOnPressOutside, outsidePressCapture, closeOnPressOutsideCapture]), React.useEffect(() => {
    insideReactTreeRef.current = !1;
  }, [outsidePress, outsidePressEvent]);
  const reference = React.useMemo(() => ({
    onKeyDown: closeOnEscapeKeyDown,
    [bubbleHandlerKeys[referencePressEvent]]: (event) => {
      referencePress && onOpenChange(!1, event.nativeEvent, "reference-press");
    }
  }), [closeOnEscapeKeyDown, onOpenChange, referencePress, referencePressEvent]), floating = React.useMemo(() => ({
    onKeyDown: closeOnEscapeKeyDown,
    onMouseDown() {
      endedOrStartedInsideRef.current = !0;
    },
    onMouseUp() {
      endedOrStartedInsideRef.current = !0;
    },
    [captureHandlerKeys[outsidePressEvent]]: () => {
      insideReactTreeRef.current = !0;
    }
  }), [closeOnEscapeKeyDown, outsidePressEvent]);
  return React.useMemo(() => enabled ? {
    reference,
    floating
  } : {}, [enabled, reference, floating]);
}
function useFloatingRootContext(options) {
  const {
    open = !1,
    onOpenChange: onOpenChangeProp,
    elements: elementsProp
  } = options, floatingId = useId(), dataRef = React.useRef({}), [events] = React.useState(() => createPubSub()), nested = useFloatingParentNodeId() != null, [positionReference, setPositionReference] = React.useState(elementsProp.reference), onOpenChange = useEffectEvent((open2, event, reason) => {
    dataRef.current.openEvent = open2 ? event : void 0, events.emit("openchange", {
      open: open2,
      event,
      reason,
      nested
    }), onOpenChangeProp?.(open2, event, reason);
  }), refs = React.useMemo(() => ({
    setPositionReference
  }), []), elements = React.useMemo(() => ({
    reference: positionReference || elementsProp.reference || null,
    floating: elementsProp.floating || null,
    domReference: elementsProp.reference
  }), [positionReference, elementsProp.reference, elementsProp.floating]);
  return React.useMemo(() => ({
    dataRef,
    open,
    onOpenChange,
    elements,
    events,
    floatingId,
    refs
  }), [open, onOpenChange, elements, events, floatingId, refs]);
}
function useFloating(options) {
  options === void 0 && (options = {});
  const {
    nodeId
  } = options, internalRootContext = useFloatingRootContext({
    ...options,
    elements: {
      reference: null,
      floating: null,
      ...options.elements
    }
  }), rootContext = options.rootContext || internalRootContext, computedElements = rootContext.elements, [_domReference, setDomReference] = React.useState(null), [positionReference, _setPositionReference] = React.useState(null), domReference = computedElements?.domReference || _domReference, domReferenceRef = React.useRef(null), tree = useFloatingTree();
  index(() => {
    domReference && (domReferenceRef.current = domReference);
  }, [domReference]);
  const position = useFloating$1({
    ...options,
    elements: {
      ...computedElements,
      ...positionReference && {
        reference: positionReference
      }
    }
  }), setPositionReference = React.useCallback((node) => {
    const computedPositionReference = isElement(node) ? {
      getBoundingClientRect: () => node.getBoundingClientRect(),
      contextElement: node
    } : node;
    _setPositionReference(computedPositionReference), position.refs.setReference(computedPositionReference);
  }, [position.refs]), setReference = React.useCallback((node) => {
    (isElement(node) || node === null) && (domReferenceRef.current = node, setDomReference(node)), (isElement(position.refs.reference.current) || position.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node !== null && !isElement(node)) && position.refs.setReference(node);
  }, [position.refs]), refs = React.useMemo(() => ({
    ...position.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position.refs, setReference, setPositionReference]), elements = React.useMemo(() => ({
    ...position.elements,
    domReference
  }), [position.elements, domReference]), context = React.useMemo(() => ({
    ...position,
    ...rootContext,
    refs,
    elements,
    nodeId
  }), [position, refs, elements, nodeId, rootContext]);
  return index(() => {
    rootContext.dataRef.current.floatingContext = context;
    const node = tree?.nodesRef.current.find((node2) => node2.id === nodeId);
    node && (node.context = context);
  }), React.useMemo(() => ({
    ...position,
    context,
    refs,
    elements
  }), [position, refs, elements, context]);
}
function useFocus(context, props) {
  props === void 0 && (props = {});
  const {
    open,
    onOpenChange,
    events,
    dataRef,
    elements
  } = context, {
    enabled = !0,
    visibleOnly = !0
  } = props, blockFocusRef = React.useRef(!1), timeoutRef = React.useRef(), keyboardModalityRef = React.useRef(!0);
  React.useEffect(() => {
    if (!enabled) return;
    const win = getWindow(elements.domReference);
    function onBlur() {
      !open && isHTMLElement(elements.domReference) && elements.domReference === activeElement(getDocument(elements.domReference)) && (blockFocusRef.current = !0);
    }
    function onKeyDown() {
      keyboardModalityRef.current = !0;
    }
    return win.addEventListener("blur", onBlur), win.addEventListener("keydown", onKeyDown, !0), () => {
      win.removeEventListener("blur", onBlur), win.removeEventListener("keydown", onKeyDown, !0);
    };
  }, [elements.domReference, open, enabled]), React.useEffect(() => {
    if (!enabled) return;
    function onOpenChange2(_ref) {
      let {
        reason
      } = _ref;
      (reason === "reference-press" || reason === "escape-key") && (blockFocusRef.current = !0);
    }
    return events.on("openchange", onOpenChange2), () => {
      events.off("openchange", onOpenChange2);
    };
  }, [events, enabled]), React.useEffect(() => () => {
    clearTimeout(timeoutRef.current);
  }, []);
  const reference = React.useMemo(() => ({
    onPointerDown(event) {
      isVirtualPointerEvent(event.nativeEvent) || (keyboardModalityRef.current = !1);
    },
    onMouseLeave() {
      blockFocusRef.current = !1;
    },
    onFocus(event) {
      if (blockFocusRef.current) return;
      const target = getTarget(event.nativeEvent);
      if (visibleOnly && isElement(target))
        try {
          if (isSafari() && isMac()) throw Error();
          if (!target.matches(":focus-visible")) return;
        } catch {
          if (!keyboardModalityRef.current && !isTypeableElement(target))
            return;
        }
      onOpenChange(!0, event.nativeEvent, "focus");
    },
    onBlur(event) {
      blockFocusRef.current = !1;
      const relatedTarget = event.relatedTarget, nativeEvent = event.nativeEvent, movedToFocusGuard = isElement(relatedTarget) && relatedTarget.hasAttribute(createAttribute("focus-guard")) && relatedTarget.getAttribute("data-type") === "outside";
      timeoutRef.current = window.setTimeout(() => {
        var _dataRef$current$floa;
        const activeEl = activeElement(elements.domReference ? elements.domReference.ownerDocument : document);
        !relatedTarget && activeEl === elements.domReference || contains((_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.refs.floating.current, activeEl) || contains(elements.domReference, activeEl) || movedToFocusGuard || onOpenChange(!1, nativeEvent, "focus");
      });
    }
  }), [dataRef, elements.domReference, onOpenChange, visibleOnly]);
  return React.useMemo(() => enabled ? {
    reference
  } : {}, [enabled, reference]);
}
const ACTIVE_KEY = "active", SELECTED_KEY = "selected";
function mergeProps(userProps, propsList, elementKey) {
  const map = /* @__PURE__ */ new Map(), isItem = elementKey === "item";
  let domUserProps = userProps;
  if (isItem && userProps) {
    const {
      [ACTIVE_KEY]: _,
      [SELECTED_KEY]: __,
      ...validProps
    } = userProps;
    domUserProps = validProps;
  }
  return {
    ...elementKey === "floating" && {
      tabIndex: -1,
      [FOCUSABLE_ATTRIBUTE]: ""
    },
    ...domUserProps,
    ...propsList.map((value) => {
      const propsOrGetProps = value ? value[elementKey] : null;
      return typeof propsOrGetProps == "function" ? userProps ? propsOrGetProps(userProps) : null : propsOrGetProps;
    }).concat(userProps).reduce((acc, props) => (props && Object.entries(props).forEach((_ref) => {
      let [key, value] = _ref;
      if (!(isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)))
        if (key.indexOf("on") === 0) {
          if (map.has(key) || map.set(key, []), typeof value == "function") {
            var _map$get;
            (_map$get = map.get(key)) == null || _map$get.push(value), acc[key] = function() {
              for (var _map$get2, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
                args[_key] = arguments[_key];
              return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map((fn) => fn(...args)).find((val) => val !== void 0);
            };
          }
        } else
          acc[key] = value;
    }), acc), {})
  };
}
function useInteractions(propsList) {
  propsList === void 0 && (propsList = []);
  const referenceDeps = propsList.map((key) => key?.reference), floatingDeps = propsList.map((key) => key?.floating), itemDeps = propsList.map((key) => key?.item), getReferenceProps = React.useCallback(
    (userProps) => mergeProps(userProps, propsList, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    referenceDeps
  ), getFloatingProps = React.useCallback(
    (userProps) => mergeProps(userProps, propsList, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    floatingDeps
  ), getItemProps = React.useCallback(
    (userProps) => mergeProps(userProps, propsList, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    itemDeps
  );
  return React.useMemo(() => ({
    getReferenceProps,
    getFloatingProps,
    getItemProps
  }), [getReferenceProps, getFloatingProps, getItemProps]);
}
const componentRoleToAriaRoleMap = /* @__PURE__ */ new Map([["select", "listbox"], ["combobox", "listbox"], ["label", !1]]);
function useRole(context, props) {
  var _componentRoleToAriaR;
  props === void 0 && (props = {});
  const {
    open,
    floatingId
  } = context, {
    enabled = !0,
    role = "dialog"
  } = props, ariaRole = (_componentRoleToAriaR = componentRoleToAriaRoleMap.get(role)) != null ? _componentRoleToAriaR : role, referenceId = useId(), isNested = useFloatingParentNodeId() != null, reference = React.useMemo(() => ariaRole === "tooltip" || role === "label" ? {
    ["aria-" + (role === "label" ? "labelledby" : "describedby")]: open ? floatingId : void 0
  } : {
    "aria-expanded": open ? "true" : "false",
    "aria-haspopup": ariaRole === "alertdialog" ? "dialog" : ariaRole,
    "aria-controls": open ? floatingId : void 0,
    ...ariaRole === "listbox" && {
      role: "combobox"
    },
    ...ariaRole === "menu" && {
      id: referenceId
    },
    ...ariaRole === "menu" && isNested && {
      role: "menuitem"
    },
    ...role === "select" && {
      "aria-autocomplete": "none"
    },
    ...role === "combobox" && {
      "aria-autocomplete": "list"
    }
  }, [ariaRole, floatingId, isNested, open, referenceId, role]), floating = React.useMemo(() => {
    const floatingProps = {
      id: floatingId,
      ...ariaRole && {
        role: ariaRole
      }
    };
    return ariaRole === "tooltip" || role === "label" ? floatingProps : {
      ...floatingProps,
      ...ariaRole === "menu" && {
        "aria-labelledby": referenceId
      }
    };
  }, [ariaRole, floatingId, referenceId, role]), item = React.useCallback((_ref) => {
    let {
      active,
      selected
    } = _ref;
    const commonProps = {
      role: "option",
      ...active && {
        id: floatingId + "-option"
      }
    };
    switch (role) {
      case "select":
        return {
          ...commonProps,
          "aria-selected": active && selected
        };
      case "combobox":
        return {
          ...commonProps,
          ...active && {
            "aria-selected": !0
          }
        };
    }
    return {};
  }, [floatingId, role]);
  return React.useMemo(() => enabled ? {
    reference,
    floating,
    item
  } : {}, [enabled, reference, floating, item]);
}
function getFloatingPosition(dir, position) {
  if (dir === "rtl" && (position.includes("right") || position.includes("left"))) {
    const [side, placement] = position.split("-"), flippedPosition = side === "right" ? "left" : "right";
    return placement === void 0 ? flippedPosition : `${flippedPosition}-${placement}`;
  }
  return position;
}
function horizontalSide(placement, arrowY, arrowOffset, arrowPosition) {
  return placement === "center" || arrowPosition === "center" ? { top: arrowY } : placement === "end" ? { bottom: arrowOffset } : placement === "start" ? { top: arrowOffset } : {};
}
function verticalSide(placement, arrowX, arrowOffset, arrowPosition, dir) {
  return placement === "center" || arrowPosition === "center" ? { left: arrowX } : placement === "end" ? { [dir === "ltr" ? "right" : "left"]: arrowOffset } : placement === "start" ? { [dir === "ltr" ? "left" : "right"]: arrowOffset } : {};
}
const radiusByFloatingSide = {
  bottom: "borderTopLeftRadius",
  left: "borderTopRightRadius",
  right: "borderBottomLeftRadius",
  top: "borderBottomRightRadius"
};
function getArrowPositionStyles({
  position,
  arrowSize,
  arrowOffset,
  arrowRadius,
  arrowPosition,
  arrowX,
  arrowY,
  dir
}) {
  const [side, placement = "center"] = position.split("-"), baseStyles = {
    width: arrowSize,
    height: arrowSize,
    transform: "rotate(45deg)",
    position: "absolute",
    [radiusByFloatingSide[side]]: arrowRadius
  }, arrowPlacement = -arrowSize / 2;
  return side === "left" ? {
    ...baseStyles,
    ...horizontalSide(placement, arrowY, arrowOffset, arrowPosition),
    right: arrowPlacement,
    borderLeftColor: "transparent",
    borderBottomColor: "transparent"
  } : side === "right" ? {
    ...baseStyles,
    ...horizontalSide(placement, arrowY, arrowOffset, arrowPosition),
    left: arrowPlacement,
    borderRightColor: "transparent",
    borderTopColor: "transparent"
  } : side === "top" ? {
    ...baseStyles,
    ...verticalSide(placement, arrowX, arrowOffset, arrowPosition, dir),
    bottom: arrowPlacement,
    borderTopColor: "transparent",
    borderLeftColor: "transparent"
  } : side === "bottom" ? {
    ...baseStyles,
    ...verticalSide(placement, arrowX, arrowOffset, arrowPosition, dir),
    top: arrowPlacement,
    borderBottomColor: "transparent",
    borderRightColor: "transparent"
  } : {};
}
const FloatingArrow = forwardRef(
  ({
    position,
    arrowSize,
    arrowOffset,
    arrowRadius,
    arrowPosition,
    visible: visible2,
    arrowX,
    arrowY,
    style,
    ...others
  }, ref) => {
    const { dir } = useDirection();
    return visible2 ? /* @__PURE__ */ jsx(
      "div",
      {
        ...others,
        ref,
        style: {
          ...style,
          ...getArrowPositionStyles({
            position,
            arrowSize,
            arrowOffset,
            arrowRadius,
            arrowPosition,
            dir,
            arrowX,
            arrowY
          })
        }
      }
    ) : null;
  }
);
FloatingArrow.displayName = "@mantine/core/FloatingArrow";
const [PopoverContextProvider, usePopoverContext] = createSafeContext(
  "Popover component was not found in the tree"
);
function FocusTrap({
  children,
  active = !0,
  refProp = "ref",
  innerRef
}) {
  const focusTrapRef = useFocusTrap(active), ref = useMergedRef(focusTrapRef, innerRef);
  return isElement$1(children) ? cloneElement(children, { [refProp]: ref }) : children;
}
function FocusTrapInitialFocus(props) {
  return /* @__PURE__ */ jsx(VisuallyHidden, { tabIndex: -1, "data-autofocus": !0, ...props });
}
FocusTrap.displayName = "@mantine/core/FocusTrap";
FocusTrapInitialFocus.displayName = "@mantine/core/FocusTrapInitialFocus";
FocusTrap.InitialFocus = FocusTrapInitialFocus;
function createPortalNode(props) {
  const node = document.createElement("div");
  return node.setAttribute("data-portal", "true"), typeof props.className == "string" && node.classList.add(...props.className.split(" ").filter(Boolean)), typeof props.style == "object" && Object.assign(node.style, props.style), typeof props.id == "string" && node.setAttribute("id", props.id), node;
}
const defaultProps$1D = {}, Portal = forwardRef((props, ref) => {
  const { children, target, ...others } = useProps("Portal", defaultProps$1D, props), [mounted, setMounted] = useState(!1), nodeRef = useRef(null);
  return useIsomorphicEffect(() => (setMounted(!0), nodeRef.current = target ? typeof target == "string" ? document.querySelector(target) : target : createPortalNode(others), assignRef(ref, nodeRef.current), !target && nodeRef.current && document.body.appendChild(nodeRef.current), () => {
    !target && nodeRef.current && document.body.removeChild(nodeRef.current);
  }), [target]), !mounted || !nodeRef.current ? null : createPortal(/* @__PURE__ */ jsx(Fragment$1, { children }), nodeRef.current);
});
Portal.displayName = "@mantine/core/Portal";
function OptionalPortal({ withinPortal = !0, children, ...others }) {
  return withinPortal ? /* @__PURE__ */ jsx(Portal, { ...others, children }) : /* @__PURE__ */ jsx(Fragment$1, { children });
}
OptionalPortal.displayName = "@mantine/core/OptionalPortal";
const popIn = (from) => ({
  in: { opacity: 1, transform: "scale(1)" },
  out: { opacity: 0, transform: `scale(.9) translateY(${rem(from === "bottom" ? 10 : -10)})` },
  transitionProperty: "transform, opacity"
}), transitions$1 = {
  fade: {
    in: { opacity: 1 },
    out: { opacity: 0 },
    transitionProperty: "opacity"
  },
  "fade-up": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: `translateY(${rem(30)}` },
    transitionProperty: "opacity, transform"
  },
  "fade-down": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: `translateY(${rem(-30)}` },
    transitionProperty: "opacity, transform"
  },
  "fade-left": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: `translateX(${rem(30)}` },
    transitionProperty: "opacity, transform"
  },
  "fade-right": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: `translateX(${rem(-30)}` },
    transitionProperty: "opacity, transform"
  },
  scale: {
    in: { opacity: 1, transform: "scale(1)" },
    out: { opacity: 0, transform: "scale(0)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "scale-y": {
    in: { opacity: 1, transform: "scaleY(1)" },
    out: { opacity: 0, transform: "scaleY(0)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "scale-x": {
    in: { opacity: 1, transform: "scaleX(1)" },
    out: { opacity: 0, transform: "scaleX(0)" },
    common: { transformOrigin: "left" },
    transitionProperty: "transform, opacity"
  },
  "skew-up": {
    in: { opacity: 1, transform: "translateY(0) skew(0deg, 0deg)" },
    out: { opacity: 0, transform: `translateY(${rem(-20)}) skew(-10deg, -5deg)` },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "skew-down": {
    in: { opacity: 1, transform: "translateY(0) skew(0deg, 0deg)" },
    out: { opacity: 0, transform: `translateY(${rem(20)}) skew(-10deg, -5deg)` },
    common: { transformOrigin: "bottom" },
    transitionProperty: "transform, opacity"
  },
  "rotate-left": {
    in: { opacity: 1, transform: "translateY(0) rotate(0deg)" },
    out: { opacity: 0, transform: `translateY(${rem(20)}) rotate(-5deg)` },
    common: { transformOrigin: "bottom" },
    transitionProperty: "transform, opacity"
  },
  "rotate-right": {
    in: { opacity: 1, transform: "translateY(0) rotate(0deg)" },
    out: { opacity: 0, transform: `translateY(${rem(20)}) rotate(5deg)` },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "slide-down": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: "translateY(-100%)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "slide-up": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: "translateY(100%)" },
    common: { transformOrigin: "bottom" },
    transitionProperty: "transform, opacity"
  },
  "slide-left": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: "translateX(100%)" },
    common: { transformOrigin: "left" },
    transitionProperty: "transform, opacity"
  },
  "slide-right": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: "translateX(-100%)" },
    common: { transformOrigin: "right" },
    transitionProperty: "transform, opacity"
  },
  pop: {
    ...popIn("bottom"),
    common: { transformOrigin: "center center" }
  },
  "pop-bottom-left": {
    ...popIn("bottom"),
    common: { transformOrigin: "bottom left" }
  },
  "pop-bottom-right": {
    ...popIn("bottom"),
    common: { transformOrigin: "bottom right" }
  },
  "pop-top-left": {
    ...popIn("top"),
    common: { transformOrigin: "top left" }
  },
  "pop-top-right": {
    ...popIn("top"),
    common: { transformOrigin: "top right" }
  }
}, transitionStatuses = {
  entering: "in",
  entered: "in",
  exiting: "out",
  exited: "out",
  "pre-exiting": "out",
  "pre-entering": "out"
};
function getTransitionStyles({
  transition,
  state,
  duration,
  timingFunction
}) {
  const shared = {
    transitionDuration: `${duration}ms`,
    transitionTimingFunction: timingFunction
  };
  return typeof transition == "string" ? transition in transitions$1 ? {
    transitionProperty: transitions$1[transition].transitionProperty,
    ...shared,
    ...transitions$1[transition].common,
    ...transitions$1[transition][transitionStatuses[state]]
  } : {} : {
    transitionProperty: transition.transitionProperty,
    ...shared,
    ...transition.common,
    ...transition[transitionStatuses[state]]
  };
}
function useTransition({
  duration,
  exitDuration,
  timingFunction,
  mounted,
  onEnter,
  onExit,
  onEntered,
  onExited,
  enterDelay,
  exitDelay
}) {
  const theme = useMantineTheme(), shouldReduceMotion = useReducedMotion(), reduceMotion = theme.respectReducedMotion ? shouldReduceMotion : !1, [transitionDuration, setTransitionDuration] = useState(reduceMotion ? 0 : duration), [transitionStatus, setStatus] = useState(mounted ? "entered" : "exited"), transitionTimeoutRef = useRef(-1), delayTimeoutRef = useRef(-1), rafRef = useRef(-1), handleStateChange = (shouldMount) => {
    const preHandler = shouldMount ? onEnter : onExit, handler = shouldMount ? onEntered : onExited;
    window.clearTimeout(transitionTimeoutRef.current);
    const newTransitionDuration = reduceMotion ? 0 : shouldMount ? duration : exitDuration;
    setTransitionDuration(newTransitionDuration), newTransitionDuration === 0 ? (typeof preHandler == "function" && preHandler(), typeof handler == "function" && handler(), setStatus(shouldMount ? "entered" : "exited")) : rafRef.current = requestAnimationFrame(() => {
      ReactDOM__default.flushSync(() => {
        setStatus(shouldMount ? "pre-entering" : "pre-exiting");
      }), rafRef.current = requestAnimationFrame(() => {
        typeof preHandler == "function" && preHandler(), setStatus(shouldMount ? "entering" : "exiting"), transitionTimeoutRef.current = window.setTimeout(() => {
          typeof handler == "function" && handler(), setStatus(shouldMount ? "entered" : "exited");
        }, newTransitionDuration);
      });
    });
  }, handleTransitionWithDelay = (shouldMount) => {
    if (window.clearTimeout(delayTimeoutRef.current), typeof (shouldMount ? enterDelay : exitDelay) != "number") {
      handleStateChange(shouldMount);
      return;
    }
    delayTimeoutRef.current = window.setTimeout(
      () => {
        handleStateChange(shouldMount);
      },
      shouldMount ? enterDelay : exitDelay
    );
  };
  return useDidUpdate(() => {
    handleTransitionWithDelay(mounted);
  }, [mounted]), useEffect(
    () => () => {
      window.clearTimeout(transitionTimeoutRef.current), cancelAnimationFrame(rafRef.current);
    },
    []
  ), {
    transitionDuration,
    transitionStatus,
    transitionTimingFunction: timingFunction || "ease"
  };
}
function Transition({
  keepMounted,
  transition = "fade",
  duration = 250,
  exitDuration = duration,
  mounted,
  children,
  timingFunction = "ease",
  onExit,
  onEntered,
  onEnter,
  onExited,
  enterDelay,
  exitDelay
}) {
  const { transitionDuration, transitionStatus, transitionTimingFunction } = useTransition({
    mounted,
    exitDuration,
    duration,
    timingFunction,
    onExit,
    onEntered,
    onEnter,
    onExited,
    enterDelay,
    exitDelay
  });
  return transitionDuration === 0 ? mounted ? /* @__PURE__ */ jsx(Fragment$1, { children: children({}) }) : keepMounted ? children({ display: "none" }) : null : transitionStatus === "exited" ? keepMounted ? children({ display: "none" }) : null : /* @__PURE__ */ jsx(Fragment$1, { children: children(
    getTransitionStyles({
      transition,
      duration: transitionDuration,
      state: transitionStatus,
      timingFunction: transitionTimingFunction
    })
  ) });
}
Transition.displayName = "@mantine/core/Transition";
var __default__$F = { dropdown: "m_38a85659", arrow: "m_a31dc6c1" };
const classes$F = __default__$F, defaultProps$1C = {}, PopoverDropdown = factory((_props, ref) => {
  const props = useProps("PopoverDropdown", defaultProps$1C, _props), {
    className,
    style,
    vars,
    children,
    onKeyDownCapture,
    variant,
    classNames,
    styles,
    ...others
  } = props, ctx = usePopoverContext(), returnFocus = useFocusReturn({
    opened: ctx.opened,
    shouldReturnFocus: ctx.returnFocus
  }), accessibleProps = ctx.withRoles ? {
    "aria-labelledby": ctx.getTargetId(),
    id: ctx.getDropdownId(),
    role: "dialog",
    tabIndex: -1
  } : {}, mergedRef = useMergedRef(ref, ctx.floating);
  return ctx.disabled ? null : /* @__PURE__ */ jsx(OptionalPortal, { ...ctx.portalProps, withinPortal: ctx.withinPortal, children: /* @__PURE__ */ jsx(
    Transition,
    {
      mounted: ctx.opened,
      ...ctx.transitionProps,
      transition: ctx.transitionProps?.transition || "fade",
      duration: ctx.transitionProps?.duration ?? 150,
      keepMounted: ctx.keepMounted,
      exitDuration: typeof ctx.transitionProps?.exitDuration == "number" ? ctx.transitionProps.exitDuration : ctx.transitionProps?.duration,
      children: (transitionStyles) => /* @__PURE__ */ jsx(FocusTrap, { active: ctx.trapFocus && ctx.opened, innerRef: mergedRef, children: /* @__PURE__ */ jsxs(
        Box,
        {
          ...accessibleProps,
          ...others,
          variant,
          onKeyDownCapture: closeOnEscape(ctx.onClose, {
            active: ctx.closeOnEscape,
            onTrigger: returnFocus,
            onKeyDown: onKeyDownCapture
          }),
          "data-position": ctx.placement,
          "data-fixed": ctx.floatingStrategy === "fixed" || void 0,
          ...ctx.getStyles("dropdown", {
            className,
            props,
            classNames,
            styles,
            style: [
              {
                ...transitionStyles,
                zIndex: ctx.zIndex,
                top: ctx.y ?? 0,
                left: ctx.x ?? 0,
                width: ctx.width === "target" ? void 0 : rem(ctx.width)
              },
              ctx.resolvedStyles.dropdown,
              styles?.dropdown,
              style
            ]
          }),
          children: [
            children,
            /* @__PURE__ */ jsx(
              FloatingArrow,
              {
                ref: ctx.arrowRef,
                arrowX: ctx.arrowX,
                arrowY: ctx.arrowY,
                visible: ctx.withArrow,
                position: ctx.placement,
                arrowSize: ctx.arrowSize,
                arrowRadius: ctx.arrowRadius,
                arrowOffset: ctx.arrowOffset,
                arrowPosition: ctx.arrowPosition,
                ...ctx.getStyles("arrow", {
                  props,
                  classNames,
                  styles
                })
              }
            )
          ]
        }
      ) })
    }
  ) });
});
PopoverDropdown.classes = classes$F;
PopoverDropdown.displayName = "@mantine/core/PopoverDropdown";
const defaultProps$1B = {
  refProp: "ref",
  popupType: "dialog"
}, PopoverTarget = factory((props, ref) => {
  const { children, refProp, popupType, ...others } = useProps(
    "PopoverTarget",
    defaultProps$1B,
    props
  );
  if (!isElement$1(children))
    throw new Error(
      "Popover.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  const forwardedProps = others, ctx = usePopoverContext(), targetRef = useMergedRef(ctx.reference, getRefProp(children), ref), accessibleProps = ctx.withRoles ? {
    "aria-haspopup": popupType,
    "aria-expanded": ctx.opened,
    "aria-controls": ctx.getDropdownId(),
    id: ctx.getTargetId()
  } : {};
  return cloneElement(children, {
    ...forwardedProps,
    ...accessibleProps,
    ...ctx.targetProps,
    className: clsx(ctx.targetProps.className, forwardedProps.className, children.props.className),
    [refProp]: targetRef,
    ...ctx.controlled ? null : { onClick: ctx.onToggle }
  });
});
PopoverTarget.displayName = "@mantine/core/PopoverTarget";
function useFloatingAutoUpdate({
  opened,
  floating,
  position,
  positionDependencies
}) {
  const [delayedUpdate, setDelayedUpdate] = useState(0);
  useEffect(() => {
    if (floating.refs.reference.current && floating.refs.floating.current && opened)
      return autoUpdate(
        floating.refs.reference.current,
        floating.refs.floating.current,
        floating.update
      );
  }, [
    floating.refs.reference.current,
    floating.refs.floating.current,
    opened,
    delayedUpdate,
    position
  ]), useDidUpdate(() => {
    floating.update();
  }, positionDependencies), useDidUpdate(() => {
    setDelayedUpdate((c) => c + 1);
  }, [opened]);
}
function getDefaultMiddlewares(middlewares) {
  if (middlewares === void 0)
    return { shift: !0, flip: !0 };
  const result = { ...middlewares };
  return middlewares.shift === void 0 && (result.shift = !0), middlewares.flip === void 0 && (result.flip = !0), result;
}
function getPopoverMiddlewares(options, getFloating) {
  const middlewaresOptions = getDefaultMiddlewares(options.middlewares), middlewares = [offset(options.offset)];
  return middlewaresOptions.shift && middlewares.push(
    shift(
      typeof middlewaresOptions.shift == "boolean" ? { limiter: limitShift(), padding: 5 } : { limiter: limitShift(), padding: 5, ...middlewaresOptions.shift }
    )
  ), middlewaresOptions.flip && middlewares.push(
    typeof middlewaresOptions.flip == "boolean" ? flip() : flip(middlewaresOptions.flip)
  ), middlewaresOptions.inline && middlewares.push(
    typeof middlewaresOptions.inline == "boolean" ? inline() : inline(middlewaresOptions.inline)
  ), middlewares.push(arrow({ element: options.arrowRef, padding: options.arrowOffset })), (middlewaresOptions.size || options.width === "target") && middlewares.push(
    size({
      ...typeof middlewaresOptions.size == "boolean" ? {} : middlewaresOptions.size,
      apply({ rects, availableWidth, availableHeight, ...rest }) {
        const styles = getFloating().refs.floating.current?.style ?? {};
        middlewaresOptions.size && (typeof middlewaresOptions.size == "object" && middlewaresOptions.size.apply ? middlewaresOptions.size.apply({ rects, availableWidth, availableHeight, ...rest }) : Object.assign(styles, {
          maxWidth: `${availableWidth}px`,
          maxHeight: `${availableHeight}px`
        })), options.width === "target" && Object.assign(styles, {
          width: `${rects.reference.width}px`
        });
      }
    })
  ), middlewares;
}
function usePopover(options) {
  const [_opened, setOpened] = useUncontrolled({
    value: options.opened,
    defaultValue: options.defaultOpened,
    finalValue: !1,
    onChange: options.onChange
  }), previouslyOpened = useRef(_opened), onClose = () => {
    _opened && setOpened(!1);
  }, onToggle = () => setOpened(!_opened), floating = useFloating({
    strategy: options.strategy,
    placement: options.position,
    middleware: getPopoverMiddlewares(options, () => floating)
  });
  return useFloatingAutoUpdate({
    opened: _opened,
    position: options.position,
    positionDependencies: options.positionDependencies || [],
    floating
  }), useDidUpdate(() => {
    options.onPositionChange?.(floating.placement);
  }, [floating.placement]), useDidUpdate(() => {
    _opened !== previouslyOpened.current && (_opened ? options.onOpen?.() : options.onClose?.()), previouslyOpened.current = _opened;
  }, [_opened, options.onClose, options.onOpen]), {
    floating,
    controlled: typeof options.opened == "boolean",
    opened: _opened,
    onClose,
    onToggle
  };
}
const defaultProps$1A = {
  position: "bottom",
  offset: 8,
  positionDependencies: [],
  transitionProps: { transition: "fade", duration: 150 },
  middlewares: { flip: !0, shift: !0, inline: !1 },
  arrowSize: 7,
  arrowOffset: 5,
  arrowRadius: 0,
  arrowPosition: "side",
  closeOnClickOutside: !0,
  withinPortal: !0,
  closeOnEscape: !0,
  trapFocus: !1,
  withRoles: !0,
  returnFocus: !1,
  clickOutsideEvents: ["mousedown", "touchstart"],
  zIndex: getDefaultZIndex("popover"),
  __staticSelector: "Popover",
  width: "max-content"
}, varsResolver$H = (_, { radius, shadow }) => ({
  dropdown: {
    "--popover-radius": radius === void 0 ? void 0 : getRadius(radius),
    "--popover-shadow": getShadow(shadow)
  }
});
function Popover(_props) {
  const props = useProps("Popover", defaultProps$1A, _props), {
    children,
    position,
    offset: offset2,
    onPositionChange,
    positionDependencies,
    opened,
    transitionProps,
    width,
    middlewares,
    withArrow,
    arrowSize,
    arrowOffset,
    arrowRadius,
    arrowPosition,
    unstyled,
    classNames,
    styles,
    closeOnClickOutside,
    withinPortal,
    portalProps,
    closeOnEscape: closeOnEscape2,
    clickOutsideEvents,
    trapFocus,
    onClose,
    onOpen,
    onChange,
    zIndex,
    radius,
    shadow,
    id,
    defaultOpened,
    __staticSelector,
    withRoles,
    disabled,
    returnFocus,
    variant,
    keepMounted,
    vars,
    floatingStrategy,
    ...others
  } = props, getStyles2 = useStyles({
    name: __staticSelector,
    props,
    classes: classes$F,
    classNames,
    styles,
    unstyled,
    rootSelector: "dropdown",
    vars,
    varsResolver: varsResolver$H
  }), { resolvedStyles } = useResolvedStylesApi({ classNames, styles, props }), arrowRef = useRef(null), [targetNode, setTargetNode] = useState(null), [dropdownNode, setDropdownNode] = useState(null), { dir } = useDirection(), uid = useId$1(id), popover = usePopover({
    middlewares,
    width,
    position: getFloatingPosition(dir, position),
    offset: typeof offset2 == "number" ? offset2 + (withArrow ? arrowSize / 2 : 0) : offset2,
    arrowRef,
    arrowOffset,
    onPositionChange,
    positionDependencies,
    opened,
    defaultOpened,
    onChange,
    onOpen,
    onClose,
    strategy: floatingStrategy
  });
  useClickOutside(() => closeOnClickOutside && popover.onClose(), clickOutsideEvents, [
    targetNode,
    dropdownNode
  ]);
  const reference = useCallback(
    (node) => {
      setTargetNode(node), popover.floating.refs.setReference(node);
    },
    [popover.floating.refs.setReference]
  ), floating = useCallback(
    (node) => {
      setDropdownNode(node), popover.floating.refs.setFloating(node);
    },
    [popover.floating.refs.setFloating]
  );
  return /* @__PURE__ */ jsx(
    PopoverContextProvider,
    {
      value: {
        returnFocus,
        disabled,
        controlled: popover.controlled,
        reference,
        floating,
        x: popover.floating.x,
        y: popover.floating.y,
        arrowX: popover.floating?.middlewareData?.arrow?.x,
        arrowY: popover.floating?.middlewareData?.arrow?.y,
        opened: popover.opened,
        arrowRef,
        transitionProps,
        width,
        withArrow,
        arrowSize,
        arrowOffset,
        arrowRadius,
        arrowPosition,
        placement: popover.floating.placement,
        trapFocus,
        withinPortal,
        portalProps,
        zIndex,
        radius,
        shadow,
        closeOnEscape: closeOnEscape2,
        onClose: popover.onClose,
        onToggle: popover.onToggle,
        getTargetId: () => `${uid}-target`,
        getDropdownId: () => `${uid}-dropdown`,
        withRoles,
        targetProps: others,
        __staticSelector,
        classNames,
        styles,
        unstyled,
        variant,
        keepMounted,
        getStyles: getStyles2,
        resolvedStyles,
        floatingStrategy
      },
      children
    }
  );
}
Popover.Target = PopoverTarget;
Popover.Dropdown = PopoverDropdown;
Popover.displayName = "@mantine/core/Popover";
Popover.extend = (input) => input;
var __default__$E = { root: "m_5ae2e3c", barsLoader: "m_7a2bd4cd", bar: "m_870bb79", "bars-loader-animation": "m_5d2b3b9d", dotsLoader: "m_4e3f22d7", dot: "m_870c4af", "loader-dots-animation": "m_aac34a1", ovalLoader: "m_b34414df", "oval-loader-animation": "m_f8e89c4b" };
const classes$E = __default__$E, Bars = forwardRef(({ className, ...others }, ref) => /* @__PURE__ */ jsxs(Box, { component: "span", className: clsx(classes$E.barsLoader, className), ...others, ref, children: [
  /* @__PURE__ */ jsx("span", { className: classes$E.bar }),
  /* @__PURE__ */ jsx("span", { className: classes$E.bar }),
  /* @__PURE__ */ jsx("span", { className: classes$E.bar })
] }));
Bars.displayName = "@mantine/core/Bars";
const Dots = forwardRef(({ className, ...others }, ref) => /* @__PURE__ */ jsxs(Box, { component: "span", className: clsx(classes$E.dotsLoader, className), ...others, ref, children: [
  /* @__PURE__ */ jsx("span", { className: classes$E.dot }),
  /* @__PURE__ */ jsx("span", { className: classes$E.dot }),
  /* @__PURE__ */ jsx("span", { className: classes$E.dot })
] }));
Dots.displayName = "@mantine/core/Dots";
const Oval = forwardRef(({ className, ...others }, ref) => /* @__PURE__ */ jsx(Box, { component: "span", className: clsx(classes$E.ovalLoader, className), ...others, ref }));
Oval.displayName = "@mantine/core/Oval";
const defaultLoaders = {
  bars: Bars,
  oval: Oval,
  dots: Dots
}, defaultProps$1z = {
  loaders: defaultLoaders,
  type: "oval"
}, varsResolver$G = (theme, { size: size2, color }) => ({
  root: {
    "--loader-size": getSize(size2, "loader-size"),
    "--loader-color": color ? getThemeColor(color, theme) : void 0
  }
}), Loader = factory((_props, ref) => {
  const props = useProps("Loader", defaultProps$1z, _props), {
    size: size2,
    color,
    type,
    vars,
    className,
    style,
    classNames,
    styles,
    unstyled,
    loaders,
    variant,
    children,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Loader",
    props,
    classes: classes$E,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$G
  });
  return children ? /* @__PURE__ */ jsx(Box, { ...getStyles2("root"), ref, ...others, children }) : /* @__PURE__ */ jsx(
    Box,
    {
      ...getStyles2("root"),
      ref,
      component: loaders[type],
      variant,
      size: size2,
      ...others
    }
  );
});
Loader.defaultLoaders = defaultLoaders;
Loader.classes = classes$E;
Loader.displayName = "@mantine/core/Loader";
var __default__$D = { root: "m_8d3f4000", icon: "m_8d3afb97", loader: "m_302b9fb1", group: "m_1a0f1b21" };
const classes$D = __default__$D, defaultProps$1y = {
  orientation: "horizontal"
}, varsResolver$F = (_, { borderWidth }) => ({
  group: { "--ai-border-width": rem(borderWidth) }
}), ActionIconGroup = factory((_props, ref) => {
  const props = useProps("ActionIconGroup", defaultProps$1y, _props), {
    className,
    style,
    classNames,
    styles,
    unstyled,
    orientation,
    vars,
    borderWidth,
    variant,
    mod,
    ...others
  } = useProps("ActionIconGroup", defaultProps$1y, _props), getStyles2 = useStyles({
    name: "ActionIconGroup",
    props,
    classes: classes$D,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$F,
    rootSelector: "group"
  });
  return /* @__PURE__ */ jsx(
    Box,
    {
      ...getStyles2("group"),
      ref,
      variant,
      mod: [{ "data-orientation": orientation }, mod],
      role: "group",
      ...others
    }
  );
});
ActionIconGroup.classes = classes$D;
ActionIconGroup.displayName = "@mantine/core/ActionIconGroup";
const defaultProps$1x = {}, varsResolver$E = (theme, { size: size2, radius, variant, gradient, color, autoContrast }) => {
  const colors = theme.variantColorResolver({
    color: color || theme.primaryColor,
    theme,
    gradient,
    variant: variant || "filled",
    autoContrast
  });
  return {
    root: {
      "--ai-size": getSize(size2, "ai-size"),
      "--ai-radius": radius === void 0 ? void 0 : getRadius(radius),
      "--ai-bg": color || variant ? colors.background : void 0,
      "--ai-hover": color || variant ? colors.hover : void 0,
      "--ai-hover-color": color || variant ? colors.hoverColor : void 0,
      "--ai-color": colors.color,
      "--ai-bd": color || variant ? colors.border : void 0
    }
  };
}, ActionIcon = polymorphicFactory((_props, ref) => {
  const props = useProps("ActionIcon", defaultProps$1x, _props), {
    className,
    unstyled,
    variant,
    classNames,
    styles,
    style,
    loading,
    loaderProps,
    size: size2,
    color,
    radius,
    __staticSelector,
    gradient,
    vars,
    children,
    disabled,
    "data-disabled": dataDisabled,
    autoContrast,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: ["ActionIcon", __staticSelector],
    props,
    className,
    style,
    classes: classes$D,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$E
  });
  return /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      ...getStyles2("root", { active: !disabled && !loading && !dataDisabled }),
      ...others,
      unstyled,
      variant,
      size: size2,
      disabled: disabled || loading,
      ref,
      mod: [{ loading, disabled: disabled || dataDisabled }, mod],
      children: [
        /* @__PURE__ */ jsx(Transition, { mounted: !!loading, transition: "slide-down", duration: 150, children: (transitionStyles) => /* @__PURE__ */ jsx(Box, { component: "span", ...getStyles2("loader", { style: transitionStyles }), "aria-hidden": !0, children: /* @__PURE__ */ jsx(Loader, { color: "var(--ai-color)", size: "calc(var(--ai-size) * 0.55)", ...loaderProps }) }) }),
        /* @__PURE__ */ jsx(Box, { component: "span", mod: { loading }, ...getStyles2("icon"), children })
      ]
    }
  );
});
ActionIcon.classes = classes$D;
ActionIcon.displayName = "@mantine/core/ActionIcon";
ActionIcon.Group = ActionIconGroup;
const CloseIcon = forwardRef(
  ({ size: size2 = "var(--cb-icon-size, 70%)", style, ...others }, ref) => /* @__PURE__ */ jsx(
    "svg",
    {
      viewBox: "0 0 15 15",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      style: { ...style, width: size2, height: size2 },
      ref,
      ...others,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z",
          fill: "currentColor",
          fillRule: "evenodd",
          clipRule: "evenodd"
        }
      )
    }
  )
);
CloseIcon.displayName = "@mantine/core/CloseIcon";
var __default__$C = { root: "m_86a44da5", "root--subtle": "m_220c80f2" };
const classes$C = __default__$C, defaultProps$1w = {
  variant: "subtle"
}, varsResolver$D = (_, { size: size2, radius, iconSize }) => ({
  root: {
    "--cb-size": getSize(size2, "cb-size"),
    "--cb-radius": radius === void 0 ? void 0 : getRadius(radius),
    "--cb-icon-size": rem(iconSize)
  }
}), CloseButton = polymorphicFactory((_props, ref) => {
  const props = useProps("CloseButton", defaultProps$1w, _props), {
    iconSize,
    children,
    vars,
    radius,
    className,
    classNames,
    style,
    styles,
    unstyled,
    "data-disabled": dataDisabled,
    disabled,
    variant,
    icon,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: "CloseButton",
    props,
    className,
    style,
    classes: classes$C,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$D
  });
  return /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      ref,
      ...others,
      unstyled,
      variant,
      disabled,
      mod: [{ disabled: disabled || dataDisabled }, mod],
      ...getStyles2("root", { variant, active: !disabled && !dataDisabled }),
      children: [
        icon || /* @__PURE__ */ jsx(CloseIcon, {}),
        children
      ]
    }
  );
});
CloseButton.classes = classes$C;
CloseButton.displayName = "@mantine/core/CloseButton";
function filterFalsyChildren(children) {
  return Children.toArray(children).filter(Boolean);
}
var __default__$B = { root: "m_4081bf90" };
const classes$B = __default__$B, defaultProps$1v = {
  preventGrowOverflow: !0,
  gap: "md",
  align: "center",
  justify: "flex-start",
  wrap: "wrap"
}, varsResolver$C = (_, { grow, preventGrowOverflow, gap, align, justify, wrap }, { childWidth }) => ({
  root: {
    "--group-child-width": grow && preventGrowOverflow ? childWidth : void 0,
    "--group-gap": getSpacing(gap),
    "--group-align": align,
    "--group-justify": justify,
    "--group-wrap": wrap
  }
}), Group = factory((_props, ref) => {
  const props = useProps("Group", defaultProps$1v, _props), {
    classNames,
    className,
    style,
    styles,
    unstyled,
    children,
    gap,
    align,
    justify,
    wrap,
    grow,
    preventGrowOverflow,
    vars,
    variant,
    __size,
    mod,
    ...others
  } = props, filteredChildren = filterFalsyChildren(children), childrenCount = filteredChildren.length, resolvedGap = getSpacing(gap ?? "md"), stylesCtx = { childWidth: `calc(${100 / childrenCount}% - (${resolvedGap} - ${resolvedGap} / ${childrenCount}))` }, getStyles2 = useStyles({
    name: "Group",
    props,
    stylesCtx,
    className,
    style,
    classes: classes$B,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$C
  });
  return /* @__PURE__ */ jsx(
    Box,
    {
      ...getStyles2("root"),
      ref,
      variant,
      mod: [{ grow }, mod],
      size: __size,
      ...others,
      children: filteredChildren
    }
  );
});
Group.classes = classes$B;
Group.displayName = "@mantine/core/Group";
var __default__$A = { root: "m_9814e45f" };
const classes$A = __default__$A, defaultProps$1u = {
  zIndex: getDefaultZIndex("modal")
}, varsResolver$B = (_, { gradient, color, backgroundOpacity, blur, radius, zIndex }) => ({
  root: {
    "--overlay-bg": gradient || (color !== void 0 || backgroundOpacity !== void 0) && rgba(color || "#000", backgroundOpacity ?? 0.6) || void 0,
    "--overlay-filter": blur ? `blur(${rem(blur)})` : void 0,
    "--overlay-radius": radius === void 0 ? void 0 : getRadius(radius),
    "--overlay-z-index": zIndex?.toString()
  }
}), Overlay = polymorphicFactory((_props, ref) => {
  const props = useProps("Overlay", defaultProps$1u, _props), {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    fixed,
    center,
    children,
    radius,
    zIndex,
    gradient,
    blur,
    color,
    backgroundOpacity,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Overlay",
    props,
    classes: classes$A,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$B
  });
  return /* @__PURE__ */ jsx(Box, { ref, ...getStyles2("root"), mod: [{ center, fixed }, mod], ...others, children });
});
Overlay.classes = classes$A;
Overlay.displayName = "@mantine/core/Overlay";
const [ModalBaseProvider, useModalBaseContext] = createSafeContext(
  "ModalBase component was not found in tree"
);
function useLockScroll({ opened, transitionDuration }) {
  const [shouldLockScroll, setShouldLockScroll] = useState(opened), timeout = useRef(), _transitionDuration = useReducedMotion() ? 0 : transitionDuration;
  return useEffect(() => (opened ? (setShouldLockScroll(!0), window.clearTimeout(timeout.current)) : _transitionDuration === 0 ? setShouldLockScroll(!1) : timeout.current = window.setTimeout(() => setShouldLockScroll(!1), _transitionDuration), () => window.clearTimeout(timeout.current)), [opened, _transitionDuration]), shouldLockScroll;
}
function useModal({
  id,
  transitionProps,
  opened,
  trapFocus,
  closeOnEscape: closeOnEscape2,
  onClose,
  returnFocus
}) {
  const _id = useId$1(id), [titleMounted, setTitleMounted] = useState(!1), [bodyMounted, setBodyMounted] = useState(!1), transitionDuration = typeof transitionProps?.duration == "number" ? transitionProps?.duration : 200, shouldLockScroll = useLockScroll({ opened, transitionDuration });
  return useWindowEvent(
    "keydown",
    (event) => {
      event.key === "Escape" && closeOnEscape2 && opened && event.target?.getAttribute("data-mantine-stop-propagation") !== "true" && onClose();
    },
    { capture: !0 }
  ), useFocusReturn({ opened, shouldReturnFocus: trapFocus && returnFocus }), {
    _id,
    titleMounted,
    bodyMounted,
    shouldLockScroll,
    setTitleMounted,
    setBodyMounted
  };
}
const ModalBase = forwardRef(
  ({
    keepMounted,
    opened,
    onClose,
    id,
    transitionProps,
    trapFocus,
    closeOnEscape: closeOnEscape2,
    returnFocus,
    closeOnClickOutside,
    withinPortal,
    portalProps,
    lockScroll,
    children,
    zIndex,
    shadow,
    padding,
    __vars,
    unstyled,
    removeScrollProps,
    ...others
  }, ref) => {
    const { _id, titleMounted, bodyMounted, shouldLockScroll, setTitleMounted, setBodyMounted } = useModal({ id, transitionProps, opened, trapFocus, closeOnEscape: closeOnEscape2, onClose, returnFocus }), { key: removeScrollKey, ...otherRemoveScrollProps } = removeScrollProps || {};
    return /* @__PURE__ */ jsx(OptionalPortal, { ...portalProps, withinPortal, children: /* @__PURE__ */ jsx(
      ModalBaseProvider,
      {
        value: {
          opened,
          onClose,
          closeOnClickOutside,
          transitionProps: { ...transitionProps, keepMounted },
          getTitleId: () => `${_id}-title`,
          getBodyId: () => `${_id}-body`,
          titleMounted,
          bodyMounted,
          setTitleMounted,
          setBodyMounted,
          trapFocus,
          closeOnEscape: closeOnEscape2,
          zIndex,
          unstyled
        },
        children: /* @__PURE__ */ jsx(
          RemoveScroll,
          {
            enabled: shouldLockScroll && lockScroll,
            ...otherRemoveScrollProps,
            children: /* @__PURE__ */ jsx(
              Box,
              {
                ref,
                ...others,
                __vars: {
                  ...__vars,
                  "--mb-z-index": (zIndex || getDefaultZIndex("modal")).toString(),
                  "--mb-shadow": getShadow(shadow),
                  "--mb-padding": getSpacing(padding)
                },
                children
              }
            )
          },
          removeScrollKey
        )
      }
    ) });
  }
);
ModalBase.displayName = "@mantine/core/ModalBase";
function useModalBodyId() {
  const ctx = useModalBaseContext();
  return useEffect(() => (ctx.setBodyMounted(!0), () => ctx.setBodyMounted(!1)), []), ctx.getBodyId();
}
var __default__$z = { title: "m_615af6c9", header: "m_b5489c3c", inner: "m_60c222c7", content: "m_fd1ab0aa", close: "m_606cb269", body: "m_5df29311" };
const classes$z = __default__$z, ModalBaseBody = forwardRef(
  ({ className, ...others }, ref) => {
    const bodyId = useModalBodyId(), ctx = useModalBaseContext();
    return /* @__PURE__ */ jsx(
      Box,
      {
        ref,
        ...others,
        id: bodyId,
        className: clsx({ [classes$z.body]: !ctx.unstyled }, className)
      }
    );
  }
);
ModalBaseBody.displayName = "@mantine/core/ModalBaseBody";
const ModalBaseCloseButton = forwardRef(
  ({ className, onClick, ...others }, ref) => {
    const ctx = useModalBaseContext();
    return /* @__PURE__ */ jsx(
      CloseButton,
      {
        ref,
        ...others,
        onClick: (event) => {
          ctx.onClose(), onClick?.(event);
        },
        className: clsx({ [classes$z.close]: !ctx.unstyled }, className),
        unstyled: ctx.unstyled
      }
    );
  }
);
ModalBaseCloseButton.displayName = "@mantine/core/ModalBaseCloseButton";
const ModalBaseContent = forwardRef(
  ({ transitionProps, className, innerProps, onKeyDown, style, ...others }, ref) => {
    const ctx = useModalBaseContext();
    return /* @__PURE__ */ jsx(
      Transition,
      {
        mounted: ctx.opened,
        transition: "pop",
        ...ctx.transitionProps,
        ...transitionProps,
        children: (transitionStyles) => /* @__PURE__ */ jsx(
          "div",
          {
            ...innerProps,
            className: clsx({ [classes$z.inner]: !ctx.unstyled }, innerProps.className),
            children: /* @__PURE__ */ jsx(FocusTrap, { active: ctx.opened && ctx.trapFocus, innerRef: ref, children: /* @__PURE__ */ jsx(
              Paper,
              {
                ...others,
                component: "section",
                role: "dialog",
                tabIndex: -1,
                "aria-modal": !0,
                "aria-describedby": ctx.bodyMounted ? ctx.getBodyId() : void 0,
                "aria-labelledby": ctx.titleMounted ? ctx.getTitleId() : void 0,
                style: [style, transitionStyles],
                className: clsx({ [classes$z.content]: !ctx.unstyled }, className),
                unstyled: ctx.unstyled,
                children: others.children
              }
            ) })
          }
        )
      }
    );
  }
);
ModalBaseContent.displayName = "@mantine/core/ModalBaseContent";
const ModalBaseHeader = forwardRef(
  ({ className, ...others }, ref) => {
    const ctx = useModalBaseContext();
    return /* @__PURE__ */ jsx(
      Box,
      {
        component: "header",
        ref,
        className: clsx({ [classes$z.header]: !ctx.unstyled }, className),
        ...others
      }
    );
  }
);
ModalBaseHeader.displayName = "@mantine/core/ModalBaseHeader";
const DEFAULT_TRANSITION = {
  duration: 200,
  timingFunction: "ease",
  transition: "fade"
};
function useModalTransition(transitionOverride) {
  const ctx = useModalBaseContext();
  return { ...DEFAULT_TRANSITION, ...ctx.transitionProps, ...transitionOverride };
}
const ModalBaseOverlay = forwardRef(
  ({ onClick, transitionProps, style, visible: visible2, ...others }, ref) => {
    const ctx = useModalBaseContext(), transition = useModalTransition(transitionProps);
    return /* @__PURE__ */ jsx(
      Transition,
      {
        mounted: visible2 !== void 0 ? visible2 : ctx.opened,
        ...transition,
        transition: "fade",
        children: (transitionStyles) => /* @__PURE__ */ jsx(
          Overlay,
          {
            ref,
            fixed: !0,
            style: [style, transitionStyles],
            zIndex: ctx.zIndex,
            unstyled: ctx.unstyled,
            onClick: (event) => {
              onClick?.(event), ctx.closeOnClickOutside && ctx.onClose();
            },
            ...others
          }
        )
      }
    );
  }
);
ModalBaseOverlay.displayName = "@mantine/core/ModalBaseOverlay";
function useModalTitle() {
  const ctx = useModalBaseContext();
  return useEffect(() => (ctx.setTitleMounted(!0), () => ctx.setTitleMounted(!1)), []), ctx.getTitleId();
}
const ModalBaseTitle = forwardRef(
  ({ className, ...others }, ref) => {
    const id = useModalTitle(), ctx = useModalBaseContext();
    return /* @__PURE__ */ jsx(
      Box,
      {
        component: "h2",
        ref,
        className: clsx({ [classes$z.title]: !ctx.unstyled }, className),
        ...others,
        id
      }
    );
  }
);
ModalBaseTitle.displayName = "@mantine/core/ModalBaseTitle";
function NativeScrollArea({ children }) {
  return /* @__PURE__ */ jsx(Fragment$1, { children });
}
const [InputWrapperProvider, useInputWrapperContext] = createOptionalContext({
  offsetBottom: !1,
  offsetTop: !1,
  describedBy: void 0,
  getStyles: null,
  inputId: void 0,
  labelId: void 0
});
var __default__$y = { wrapper: "m_6c018570", input: "m_8fb7ebe7", section: "m_82577fc2", placeholder: "m_88bacfd0", root: "m_46b77525", label: "m_8fdc1311", required: "m_78a94662", error: "m_8f816625", description: "m_fe47ce59" };
const classes$y = __default__$y, defaultProps$1t = {}, varsResolver$A = (_, { size: size2 }) => ({
  description: {
    "--input-description-size": size2 === void 0 ? void 0 : `calc(${getFontSize(size2)} - ${rem(2)})`
  }
}), InputDescription = factory((_props, ref) => {
  const props = useProps("InputDescription", defaultProps$1t, _props), {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    size: size2,
    __staticSelector,
    __inheritStyles = !0,
    variant,
    ...others
  } = useProps("InputDescription", defaultProps$1t, props), ctx = useInputWrapperContext(), _getStyles = useStyles({
    name: ["InputWrapper", __staticSelector],
    props,
    classes: classes$y,
    className,
    style,
    classNames,
    styles,
    unstyled,
    rootSelector: "description",
    vars,
    varsResolver: varsResolver$A
  }), getStyles2 = __inheritStyles && ctx?.getStyles || _getStyles;
  return /* @__PURE__ */ jsx(
    Box,
    {
      component: "p",
      ref,
      variant,
      size: size2,
      ...getStyles2("description", ctx?.getStyles ? { className, style } : void 0),
      ...others
    }
  );
});
InputDescription.classes = classes$y;
InputDescription.displayName = "@mantine/core/InputDescription";
const defaultProps$1s = {}, varsResolver$z = (_, { size: size2 }) => ({
  error: {
    "--input-error-size": size2 === void 0 ? void 0 : `calc(${getFontSize(size2)} - ${rem(2)})`
  }
}), InputError = factory((_props, ref) => {
  const props = useProps("InputError", defaultProps$1s, _props), {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    size: size2,
    __staticSelector,
    __inheritStyles = !0,
    variant,
    ...others
  } = props, _getStyles = useStyles({
    name: ["InputWrapper", __staticSelector],
    props,
    classes: classes$y,
    className,
    style,
    classNames,
    styles,
    unstyled,
    rootSelector: "error",
    vars,
    varsResolver: varsResolver$z
  }), ctx = useInputWrapperContext(), getStyles2 = __inheritStyles && ctx?.getStyles || _getStyles;
  return /* @__PURE__ */ jsx(
    Box,
    {
      component: "p",
      ref,
      variant,
      size: size2,
      ...getStyles2("error", ctx?.getStyles ? { className, style } : void 0),
      ...others
    }
  );
});
InputError.classes = classes$y;
InputError.displayName = "@mantine/core/InputError";
const defaultProps$1r = {
  labelElement: "label"
}, varsResolver$y = (_, { size: size2 }) => ({
  label: {
    "--input-label-size": getFontSize(size2),
    "--input-asterisk-color": void 0
  }
}), InputLabel = factory((_props, ref) => {
  const props = useProps("InputLabel", defaultProps$1r, _props), {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    labelElement,
    size: size2,
    required,
    htmlFor,
    onMouseDown,
    children,
    __staticSelector,
    variant,
    mod,
    ...others
  } = useProps("InputLabel", defaultProps$1r, props), _getStyles = useStyles({
    name: ["InputWrapper", __staticSelector],
    props,
    classes: classes$y,
    className,
    style,
    classNames,
    styles,
    unstyled,
    rootSelector: "label",
    vars,
    varsResolver: varsResolver$y
  }), ctx = useInputWrapperContext(), getStyles2 = ctx?.getStyles || _getStyles;
  return /* @__PURE__ */ jsxs(
    Box,
    {
      ...getStyles2("label", ctx?.getStyles ? { className, style } : void 0),
      component: labelElement,
      variant,
      size: size2,
      ref,
      htmlFor: labelElement === "label" ? htmlFor : void 0,
      mod: [{ required }, mod],
      onMouseDown: (event) => {
        onMouseDown?.(event), !event.defaultPrevented && event.detail > 1 && event.preventDefault();
      },
      ...others,
      children: [
        children,
        required && /* @__PURE__ */ jsx("span", { ...getStyles2("required"), "aria-hidden": !0, children: " *" })
      ]
    }
  );
});
InputLabel.classes = classes$y;
InputLabel.displayName = "@mantine/core/InputLabel";
const defaultProps$1q = {}, InputPlaceholder = factory((_props, ref) => {
  const props = useProps("InputPlaceholder", defaultProps$1q, _props), {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    __staticSelector,
    variant,
    error,
    mod,
    ...others
  } = useProps("InputPlaceholder", defaultProps$1q, props), getStyles2 = useStyles({
    name: ["InputPlaceholder", __staticSelector],
    props,
    classes: classes$y,
    className,
    style,
    classNames,
    styles,
    unstyled,
    rootSelector: "placeholder"
  });
  return /* @__PURE__ */ jsx(
    Box,
    {
      ...getStyles2("placeholder"),
      mod: [{ error: !!error }, mod],
      component: "span",
      variant,
      ref,
      ...others
    }
  );
});
InputPlaceholder.classes = classes$y;
InputPlaceholder.displayName = "@mantine/core/InputPlaceholder";
function getInputOffsets(inputWrapperOrder, { hasDescription, hasError }) {
  const inputIndex = inputWrapperOrder.findIndex((part) => part === "input"), aboveInput = inputWrapperOrder.slice(0, inputIndex), belowInput = inputWrapperOrder.slice(inputIndex + 1), offsetTop = hasDescription && aboveInput.includes("description") || hasError && aboveInput.includes("error");
  return { offsetBottom: hasDescription && belowInput.includes("description") || hasError && belowInput.includes("error"), offsetTop };
}
const defaultProps$1p = {
  labelElement: "label",
  inputContainer: (children) => children,
  inputWrapperOrder: ["label", "description", "input", "error"]
}, varsResolver$x = (_, { size: size2 }) => ({
  label: {
    "--input-label-size": getFontSize(size2),
    "--input-asterisk-color": void 0
  },
  error: {
    "--input-error-size": size2 === void 0 ? void 0 : `calc(${getFontSize(size2)} - ${rem(2)})`
  },
  description: {
    "--input-description-size": size2 === void 0 ? void 0 : `calc(${getFontSize(size2)} - ${rem(2)})`
  }
}), InputWrapper = factory((_props, ref) => {
  const props = useProps("InputWrapper", defaultProps$1p, _props), {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    size: size2,
    variant,
    __staticSelector,
    inputContainer,
    inputWrapperOrder,
    label,
    error,
    description,
    labelProps,
    descriptionProps,
    errorProps,
    labelElement,
    children,
    withAsterisk,
    id,
    required,
    __stylesApiProps,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: ["InputWrapper", __staticSelector],
    props: __stylesApiProps || props,
    classes: classes$y,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$x
  }), sharedProps = {
    size: size2,
    variant,
    __staticSelector
  }, idBase = useId$1(id), isRequired = typeof withAsterisk == "boolean" ? withAsterisk : required, errorId = errorProps?.id || `${idBase}-error`, descriptionId = descriptionProps?.id || `${idBase}-description`, inputId = idBase, hasError = !!error && typeof error != "boolean", hasDescription = !!description, _describedBy = `${hasError ? errorId : ""} ${hasDescription ? descriptionId : ""}`, describedBy = _describedBy.trim().length > 0 ? _describedBy.trim() : void 0, labelId = labelProps?.id || `${idBase}-label`, _label = label && /* @__PURE__ */ jsx(
    InputLabel,
    {
      labelElement,
      id: labelId,
      htmlFor: inputId,
      required: isRequired,
      ...sharedProps,
      ...labelProps,
      children: label
    },
    "label"
  ), _description = hasDescription && /* @__PURE__ */ jsx(
    InputDescription,
    {
      ...descriptionProps,
      ...sharedProps,
      size: descriptionProps?.size || sharedProps.size,
      id: descriptionProps?.id || descriptionId,
      children: description
    },
    "description"
  ), _input = /* @__PURE__ */ jsx(Fragment, { children: inputContainer(children) }, "input"), _error = hasError && /* @__PURE__ */ createElement(
    InputError,
    {
      ...errorProps,
      ...sharedProps,
      size: errorProps?.size || sharedProps.size,
      key: "error",
      id: errorProps?.id || errorId
    },
    error
  ), content = inputWrapperOrder.map((part) => {
    switch (part) {
      case "label":
        return _label;
      case "input":
        return _input;
      case "description":
        return _description;
      case "error":
        return _error;
      default:
        return null;
    }
  });
  return /* @__PURE__ */ jsx(
    InputWrapperProvider,
    {
      value: {
        getStyles: getStyles2,
        describedBy,
        inputId,
        labelId,
        ...getInputOffsets(inputWrapperOrder, { hasDescription, hasError })
      },
      children: /* @__PURE__ */ jsx(
        Box,
        {
          ref,
          variant,
          size: size2,
          mod: [{ error: !!error }, mod],
          ...getStyles2("root"),
          ...others,
          children: content
        }
      )
    }
  );
});
InputWrapper.classes = classes$y;
InputWrapper.displayName = "@mantine/core/InputWrapper";
const defaultProps$1o = {
  variant: "default",
  leftSectionPointerEvents: "none",
  rightSectionPointerEvents: "none",
  withAria: !0,
  withErrorStyles: !0
}, varsResolver$w = (_, props, ctx) => ({
  wrapper: {
    "--input-margin-top": ctx.offsetTop ? "calc(var(--mantine-spacing-xs) / 2)" : void 0,
    "--input-margin-bottom": ctx.offsetBottom ? "calc(var(--mantine-spacing-xs) / 2)" : void 0,
    "--input-height": getSize(props.size, "input-height"),
    "--input-fz": getFontSize(props.size),
    "--input-radius": props.radius === void 0 ? void 0 : getRadius(props.radius),
    "--input-left-section-width": props.leftSectionWidth !== void 0 ? rem(props.leftSectionWidth) : void 0,
    "--input-right-section-width": props.rightSectionWidth !== void 0 ? rem(props.rightSectionWidth) : void 0,
    "--input-padding-y": props.multiline ? getSize(props.size, "input-padding-y") : void 0,
    "--input-left-section-pointer-events": props.leftSectionPointerEvents,
    "--input-right-section-pointer-events": props.rightSectionPointerEvents
  }
}), Input = polymorphicFactory((_props, ref) => {
  const props = useProps("Input", defaultProps$1o, _props), {
    classNames,
    className,
    style,
    styles,
    unstyled,
    required,
    __staticSelector,
    __stylesApiProps,
    size: size2,
    wrapperProps,
    error,
    disabled,
    leftSection,
    leftSectionProps,
    leftSectionWidth,
    rightSection,
    rightSectionProps,
    rightSectionWidth,
    rightSectionPointerEvents,
    leftSectionPointerEvents,
    variant,
    vars,
    pointer,
    multiline,
    radius,
    id,
    withAria,
    withErrorStyles,
    mod,
    inputSize,
    ...others
  } = props, { styleProps, rest } = extractStyleProps(others), ctx = useInputWrapperContext(), stylesCtx = { offsetBottom: ctx?.offsetBottom, offsetTop: ctx?.offsetTop }, getStyles2 = useStyles({
    name: ["Input", __staticSelector],
    props: __stylesApiProps || props,
    classes: classes$y,
    className,
    style,
    classNames,
    styles,
    unstyled,
    stylesCtx,
    rootSelector: "wrapper",
    vars,
    varsResolver: varsResolver$w
  }), ariaAttributes = withAria ? {
    required,
    disabled,
    "aria-invalid": !!error,
    "aria-describedby": ctx?.describedBy,
    id: ctx?.inputId || id
  } : {};
  return /* @__PURE__ */ jsxs(
    Box,
    {
      ...getStyles2("wrapper"),
      ...styleProps,
      ...wrapperProps,
      mod: [
        {
          error: !!error && withErrorStyles,
          pointer,
          disabled,
          multiline,
          "data-with-right-section": !!rightSection,
          "data-with-left-section": !!leftSection
        },
        mod
      ],
      variant,
      size: size2,
      children: [
        leftSection && /* @__PURE__ */ jsx(
          "div",
          {
            ...leftSectionProps,
            "data-position": "left",
            ...getStyles2("section", {
              className: leftSectionProps?.className,
              style: leftSectionProps?.style
            }),
            children: leftSection
          }
        ),
        /* @__PURE__ */ jsx(
          Box,
          {
            component: "input",
            ...rest,
            ...ariaAttributes,
            ref,
            required,
            mod: { disabled, error: !!error && withErrorStyles },
            variant,
            __size: inputSize,
            ...getStyles2("input")
          }
        ),
        rightSection && /* @__PURE__ */ jsx(
          "div",
          {
            ...rightSectionProps,
            "data-position": "right",
            ...getStyles2("section", {
              className: rightSectionProps?.className,
              style: rightSectionProps?.style
            }),
            children: rightSection
          }
        )
      ]
    }
  );
});
Input.classes = classes$y;
Input.Wrapper = InputWrapper;
Input.Label = InputLabel;
Input.Error = InputError;
Input.Description = InputDescription;
Input.Placeholder = InputPlaceholder;
Input.displayName = "@mantine/core/Input";
function useInputProps(component, defaultProps2, _props) {
  const props = useProps(component, defaultProps2, _props), {
    label,
    description,
    error,
    required,
    classNames,
    styles,
    className,
    unstyled,
    __staticSelector,
    __stylesApiProps,
    errorProps,
    labelProps,
    descriptionProps,
    wrapperProps: _wrapperProps,
    id,
    size: size2,
    style,
    inputContainer,
    inputWrapperOrder,
    withAsterisk,
    variant,
    vars,
    mod,
    ...others
  } = props, { styleProps, rest } = extractStyleProps(others), wrapperProps = {
    label,
    description,
    error,
    required,
    classNames,
    className,
    __staticSelector,
    __stylesApiProps: __stylesApiProps || props,
    errorProps,
    labelProps,
    descriptionProps,
    unstyled,
    styles,
    size: size2,
    style,
    inputContainer,
    inputWrapperOrder,
    withAsterisk,
    variant,
    id,
    mod,
    ..._wrapperProps
  };
  return {
    ...rest,
    classNames,
    styles,
    unstyled,
    wrapperProps: { ...wrapperProps, ...styleProps },
    inputProps: {
      required,
      classNames,
      styles,
      unstyled,
      size: size2,
      __staticSelector,
      __stylesApiProps: __stylesApiProps || props,
      error,
      variant,
      id
    }
  };
}
const defaultProps$1n = {
  __staticSelector: "InputBase",
  withAria: !0
}, InputBase = polymorphicFactory((props, ref) => {
  const { inputProps, wrapperProps, ...others } = useInputProps("InputBase", defaultProps$1n, props);
  return /* @__PURE__ */ jsx(Input.Wrapper, { ...wrapperProps, children: /* @__PURE__ */ jsx(Input, { ...inputProps, ...others, ref }) });
});
InputBase.classes = { ...Input.classes, ...Input.Wrapper.classes };
InputBase.displayName = "@mantine/core/InputBase";
const FLEX_STYLE_PROPS_DATA = {
  gap: { type: "spacing", property: "gap" },
  rowGap: { type: "spacing", property: "rowGap" },
  columnGap: { type: "spacing", property: "columnGap" },
  align: { type: "identity", property: "alignItems" },
  justify: { type: "identity", property: "justifyContent" },
  wrap: { type: "identity", property: "flexWrap" },
  direction: { type: "identity", property: "flexDirection" }
};
var __default__$x = { root: "m_8bffd616" };
const classes$x = __default__$x, defaultProps$1m = {}, Flex = polymorphicFactory((_props, ref) => {
  const props = useProps("Flex", defaultProps$1m, _props), {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    gap,
    rowGap,
    columnGap,
    align,
    justify,
    wrap,
    direction,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Flex",
    classes: classes$x,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars
  }), theme = useMantineTheme(), responsiveClassName = useRandomClassName(), parsedStyleProps = parseStyleProps({
    styleProps: { gap, rowGap, columnGap, align, justify, wrap, direction },
    theme,
    data: FLEX_STYLE_PROPS_DATA
  });
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    parsedStyleProps.hasResponsiveStyles && /* @__PURE__ */ jsx(
      InlineStyles,
      {
        selector: `.${responsiveClassName}`,
        styles: parsedStyleProps.styles,
        media: parsedStyleProps.media
      }
    ),
    /* @__PURE__ */ jsx(
      Box,
      {
        ref,
        ...getStyles2("root", {
          className: responsiveClassName,
          style: filterProps(parsedStyleProps.inlineStyles)
        }),
        ...others
      }
    )
  ] });
});
Flex.classes = classes$x;
Flex.displayName = "@mantine/core/Flex";
function isParent(parentElement, childElement) {
  if (!childElement || !parentElement)
    return !1;
  let parent = childElement.parentNode;
  for (; parent != null; ) {
    if (parent === parentElement)
      return !0;
    parent = parent.parentNode;
  }
  return !1;
}
function useFloatingIndicator({
  target,
  parent,
  ref,
  displayAfterTransitionEnd
}) {
  const transitionTimeout = useRef(), [initialized, setInitialized] = useState(!1), [hidden2, setHidden] = useState(
    typeof displayAfterTransitionEnd == "boolean" ? displayAfterTransitionEnd : !1
  ), updatePosition = () => {
    if (!target || !parent)
      return;
    const targetRect = target.getBoundingClientRect(), parentRect = parent.getBoundingClientRect(), position = {
      top: targetRect.top - parentRect.top,
      left: targetRect.left - parentRect.left,
      width: targetRect.width,
      height: targetRect.height
    };
    ref.current && (ref.current.style.transform = `translateY(${position.top}px) translateX(${position.left}px)`, ref.current.style.width = `${position.width}px`, ref.current.style.height = `${position.height}px`);
  }, updatePositionWithoutAnimation = () => {
    window.clearTimeout(transitionTimeout.current), ref.current && (ref.current.style.transitionDuration = "0ms"), updatePosition(), transitionTimeout.current = window.setTimeout(() => {
      ref.current && (ref.current.style.transitionDuration = "");
    }, 30);
  }, targetResizeObserver = useRef(), parentResizeObserver = useRef();
  return useEffect(() => {
    if (updatePosition(), target)
      return targetResizeObserver.current = new ResizeObserver(updatePositionWithoutAnimation), targetResizeObserver.current.observe(target), parent && (parentResizeObserver.current = new ResizeObserver(updatePositionWithoutAnimation), parentResizeObserver.current.observe(parent)), () => {
        targetResizeObserver.current?.disconnect(), parentResizeObserver.current?.disconnect();
      };
  }, [parent, target]), useEffect(() => {
    if (parent) {
      const handleTransitionEnd = (event) => {
        isParent(event.target, parent) && (updatePositionWithoutAnimation(), setHidden(!1));
      };
      return parent.addEventListener("transitionend", handleTransitionEnd), () => {
        parent.removeEventListener("transitionend", handleTransitionEnd);
      };
    }
  }, [parent]), useTimeout(
    () => {
      getEnv() !== "test" && setInitialized(!0);
    },
    20,
    { autoInvoke: !0 }
  ), useMutationObserver(
    (mutations) => {
      mutations.forEach((mutation) => {
        mutation.type === "attributes" && mutation.attributeName === "dir" && updatePositionWithoutAnimation();
      });
    },
    { attributes: !0, attributeFilter: ["dir"] },
    () => document.documentElement
  ), { initialized, hidden: hidden2 };
}
var __default__$w = { root: "m_96b553a6" };
const classes$w = __default__$w, defaultProps$1l = {}, varsResolver$v = (_theme, { transitionDuration }) => ({
  root: {
    "--transition-duration": typeof transitionDuration == "number" ? `${transitionDuration}ms` : transitionDuration
  }
}), FloatingIndicator = factory((_props, ref) => {
  const props = useProps("FloatingIndicator", defaultProps$1l, _props), {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    target,
    parent,
    transitionDuration,
    mod,
    displayAfterTransitionEnd,
    ...others
  } = props, getStyles2 = useStyles({
    name: "FloatingIndicator",
    classes: classes$w,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$v
  }), innerRef = useRef(null), { initialized, hidden: hidden2 } = useFloatingIndicator({
    target,
    parent,
    ref: innerRef,
    displayAfterTransitionEnd
  }), mergedRef = useMergedRef(ref, innerRef);
  return !target || !parent ? null : /* @__PURE__ */ jsx(Box, { ref: mergedRef, mod: [{ initialized, hidden: hidden2 }, mod], ...getStyles2("root"), ...others });
});
FloatingIndicator.displayName = "@mantine/core/FloatingIndicator";
FloatingIndicator.classes = classes$w;
var __default__$v = { root: "m_66836ed3", wrapper: "m_a5d60502", body: "m_667c2793", title: "m_6a03f287", label: "m_698f4f23", icon: "m_667f2a6a", message: "m_7fa78076", closeButton: "m_87f54839" };
const classes$v = __default__$v, defaultProps$1k = {}, varsResolver$u = (theme, { radius, color, variant, autoContrast }) => {
  const colors = theme.variantColorResolver({
    color: color || theme.primaryColor,
    theme,
    variant: variant || "light",
    autoContrast
  });
  return {
    root: {
      "--alert-radius": radius === void 0 ? void 0 : getRadius(radius),
      "--alert-bg": color || variant ? colors.background : void 0,
      "--alert-color": colors.color,
      "--alert-bd": color || variant ? colors.border : void 0
    }
  };
}, Alert = factory((_props, ref) => {
  const props = useProps("Alert", defaultProps$1k, _props), {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    radius,
    color,
    title,
    children,
    id,
    icon,
    withCloseButton,
    onClose,
    closeButtonLabel,
    variant,
    autoContrast,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Alert",
    classes: classes$v,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$u
  }), rootId = useId$1(id), titleId = title && `${rootId}-title` || void 0, bodyId = `${rootId}-body`;
  return /* @__PURE__ */ jsx(
    Box,
    {
      id: rootId,
      ...getStyles2("root", { variant }),
      variant,
      ref,
      ...others,
      role: "alert",
      "aria-describedby": bodyId,
      "aria-labelledby": titleId,
      children: /* @__PURE__ */ jsxs("div", { ...getStyles2("wrapper"), children: [
        icon && /* @__PURE__ */ jsx("div", { ...getStyles2("icon"), children: icon }),
        /* @__PURE__ */ jsxs("div", { ...getStyles2("body"), children: [
          title && /* @__PURE__ */ jsx("div", { ...getStyles2("title"), "data-with-close-button": withCloseButton || void 0, children: /* @__PURE__ */ jsx("span", { id: titleId, ...getStyles2("label"), children: title }) }),
          children && /* @__PURE__ */ jsx("div", { id: bodyId, ...getStyles2("message"), "data-variant": variant, children })
        ] }),
        withCloseButton && /* @__PURE__ */ jsx(
          CloseButton,
          {
            ...getStyles2("closeButton"),
            onClick: onClose,
            variant: "transparent",
            size: 16,
            iconSize: 16,
            "aria-label": closeButtonLabel,
            unstyled
          }
        )
      ] })
    }
  );
});
Alert.classes = classes$v;
Alert.displayName = "@mantine/core/Alert";
var __default__$u = { root: "m_b6d8b162" };
const classes$u = __default__$u;
function getTextTruncate(truncate) {
  if (truncate === "start")
    return "start";
  if (truncate === "end" || truncate)
    return "end";
}
const defaultProps$1j = {
  inherit: !1
}, varsResolver$t = (theme, { variant, lineClamp, gradient, size: size2, color }) => ({
  root: {
    "--text-fz": getFontSize(size2),
    "--text-lh": getLineHeight(size2),
    "--text-gradient": variant === "gradient" ? getGradient(gradient, theme) : void 0,
    "--text-line-clamp": typeof lineClamp == "number" ? lineClamp.toString() : void 0,
    "--text-color": color ? getThemeColor(color, theme) : void 0
  }
}), Text = polymorphicFactory((_props, ref) => {
  const props = useProps("Text", defaultProps$1j, _props), {
    lineClamp,
    truncate,
    inline: inline2,
    inherit,
    gradient,
    span,
    __staticSelector,
    vars,
    className,
    style,
    classNames,
    styles,
    unstyled,
    variant,
    mod,
    size: size2,
    ...others
  } = props, getStyles2 = useStyles({
    name: ["Text", __staticSelector],
    props,
    classes: classes$u,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$t
  });
  return /* @__PURE__ */ jsx(
    Box,
    {
      ...getStyles2("root", { focusable: !0 }),
      ref,
      component: span ? "span" : "p",
      variant,
      mod: [
        {
          "data-truncate": getTextTruncate(truncate),
          "data-line-clamp": typeof lineClamp == "number",
          "data-inline": inline2,
          "data-inherit": inherit
        },
        mod
      ],
      size: size2,
      ...others
    }
  );
});
Text.classes = classes$u;
Text.displayName = "@mantine/core/Text";
var __default__$t = { root: "m_849cf0da" };
const classes$t = __default__$t, defaultProps$1i = {
  underline: "hover"
}, Anchor = polymorphicFactory((props, ref) => {
  const { underline, className, unstyled, mod, ...others } = useProps(
    "Anchor",
    defaultProps$1i,
    props
  );
  return /* @__PURE__ */ jsx(
    Text,
    {
      component: "a",
      ref,
      className: clsx({ [classes$t.root]: !unstyled }, className),
      ...others,
      mod: [{ underline }, mod],
      __staticSelector: "Anchor",
      unstyled
    }
  );
});
Anchor.classes = classes$t;
Anchor.displayName = "@mantine/core/Anchor";
function parseItem(item) {
  return typeof item == "string" ? { value: item, label: item } : "value" in item && !("label" in item) ? { value: item.value, label: item.value, disabled: item.disabled } : typeof item == "number" ? { value: item.toString(), label: item.toString() } : "group" in item ? {
    group: item.group,
    items: item.items.map((i) => parseItem(i))
  } : item;
}
function getParsedComboboxData(data) {
  return data ? data.map((item) => parseItem(item)) : [];
}
function getOptionsLockup(options) {
  return options.reduce((acc, item) => "group" in item ? { ...acc, ...getOptionsLockup(item.items) } : (acc[item.value] = item, acc), {});
}
var __default__$s = { dropdown: "m_88b62a41", search: "m_985517d8", options: "m_b2821a6e", option: "m_92253aa5", empty: "m_2530cd1d", header: "m_858f94bd", footer: "m_82b967cb", group: "m_254f3e4f", groupLabel: "m_2bb2e9e5", chevron: "m_2943220b", optionsDropdownOption: "m_390b5f4", optionsDropdownCheckIcon: "m_8ee53fc2" };
const classes$s = __default__$s, defaultProps$1h = {
  error: null
}, varsResolver$s = (_, { size: size2 }) => ({
  chevron: {
    "--combobox-chevron-size": getSize(size2, "combobox-chevron-size")
  }
}), ComboboxChevron = factory((_props, ref) => {
  const props = useProps("ComboboxChevron", defaultProps$1h, _props), { size: size2, error, style, className, classNames, styles, unstyled, vars, mod, ...others } = props, getStyles2 = useStyles({
    name: "ComboboxChevron",
    classes: classes$s,
    props,
    style,
    className,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$s,
    rootSelector: "chevron"
  });
  return /* @__PURE__ */ jsx(
    Box,
    {
      component: "svg",
      ...others,
      ...getStyles2("chevron"),
      size: size2,
      viewBox: "0 0 15 15",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      mod: ["combobox-chevron", { error }, mod],
      ref,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M4.93179 5.43179C4.75605 5.60753 4.75605 5.89245 4.93179 6.06819C5.10753 6.24392 5.39245 6.24392 5.56819 6.06819L7.49999 4.13638L9.43179 6.06819C9.60753 6.24392 9.89245 6.24392 10.0682 6.06819C10.2439 5.89245 10.2439 5.60753 10.0682 5.43179L7.81819 3.18179C7.73379 3.0974 7.61933 3.04999 7.49999 3.04999C7.38064 3.04999 7.26618 3.0974 7.18179 3.18179L4.93179 5.43179ZM10.0682 9.56819C10.2439 9.39245 10.2439 9.10753 10.0682 8.93179C9.89245 8.75606 9.60753 8.75606 9.43179 8.93179L7.49999 10.8636L5.56819 8.93179C5.39245 8.75606 5.10753 8.75606 4.93179 8.93179C4.75605 9.10753 4.75605 9.39245 4.93179 9.56819L7.18179 11.8182C7.35753 11.9939 7.64245 11.9939 7.81819 11.8182L10.0682 9.56819Z",
          fill: "currentColor",
          fillRule: "evenodd",
          clipRule: "evenodd"
        }
      )
    }
  );
});
ComboboxChevron.classes = classes$s;
ComboboxChevron.displayName = "@mantine/core/ComboboxChevron";
const [ComboboxProvider, useComboboxContext] = createSafeContext(
  "Combobox component was not found in tree"
), ComboboxClearButton = forwardRef(
  ({ size: size2, onMouseDown, onClick, onClear, ...others }, ref) => /* @__PURE__ */ jsx(
    CloseButton,
    {
      ref,
      size: size2 || "sm",
      variant: "transparent",
      tabIndex: -1,
      "aria-hidden": !0,
      ...others,
      onMouseDown: (event) => {
        event.preventDefault(), onMouseDown?.(event);
      },
      onClick: (event) => {
        onClear(), onClick?.(event);
      }
    }
  )
);
ComboboxClearButton.displayName = "@mantine/core/ComboboxClearButton";
const defaultProps$1g = {}, ComboboxDropdown = factory((props, ref) => {
  const { classNames, styles, className, style, hidden: hidden2, ...others } = useProps(
    "ComboboxDropdown",
    defaultProps$1g,
    props
  ), ctx = useComboboxContext();
  return /* @__PURE__ */ jsx(
    Popover.Dropdown,
    {
      ...others,
      ref,
      role: "presentation",
      "data-hidden": hidden2 || void 0,
      ...ctx.getStyles("dropdown", { className, style, classNames, styles })
    }
  );
});
ComboboxDropdown.classes = classes$s;
ComboboxDropdown.displayName = "@mantine/core/ComboboxDropdown";
const defaultProps$1f = {
  refProp: "ref"
}, ComboboxDropdownTarget = factory((props, ref) => {
  const { children, refProp } = useProps("ComboboxDropdownTarget", defaultProps$1f, props);
  if (useComboboxContext(), !isElement$1(children))
    throw new Error(
      "Combobox.DropdownTarget component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  return /* @__PURE__ */ jsx(Popover.Target, { ref, refProp, children });
});
ComboboxDropdownTarget.displayName = "@mantine/core/ComboboxDropdownTarget";
const defaultProps$1e = {}, ComboboxEmpty = factory((props, ref) => {
  const { classNames, className, style, styles, vars, ...others } = useProps(
    "ComboboxEmpty",
    defaultProps$1e,
    props
  ), ctx = useComboboxContext();
  return /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      ...ctx.getStyles("empty", { className, classNames, styles, style }),
      ...others
    }
  );
});
ComboboxEmpty.classes = classes$s;
ComboboxEmpty.displayName = "@mantine/core/ComboboxEmpty";
function useComboboxTargetProps({
  onKeyDown,
  withKeyboardNavigation,
  withAriaAttributes,
  withExpandedAttribute,
  targetType,
  autoComplete
}) {
  const ctx = useComboboxContext(), [selectedOptionId, setSelectedOptionId] = useState(null), handleKeyDown = (event) => {
    if (onKeyDown?.(event), !ctx.readOnly && withKeyboardNavigation) {
      if (event.nativeEvent.isComposing)
        return;
      if (event.nativeEvent.code === "ArrowDown" && (event.preventDefault(), ctx.store.dropdownOpened ? setSelectedOptionId(ctx.store.selectNextOption()) : (ctx.store.openDropdown("keyboard"), setSelectedOptionId(ctx.store.selectActiveOption()), ctx.store.updateSelectedOptionIndex("selected", { scrollIntoView: !0 }))), event.nativeEvent.code === "ArrowUp" && (event.preventDefault(), ctx.store.dropdownOpened ? setSelectedOptionId(ctx.store.selectPreviousOption()) : (ctx.store.openDropdown("keyboard"), setSelectedOptionId(ctx.store.selectActiveOption()), ctx.store.updateSelectedOptionIndex("selected", { scrollIntoView: !0 }))), event.nativeEvent.code === "Enter" || event.nativeEvent.code === "NumpadEnter") {
        if (event.nativeEvent.keyCode === 229)
          return;
        const selectedOptionIndex = ctx.store.getSelectedOptionIndex();
        ctx.store.dropdownOpened && selectedOptionIndex !== -1 ? (event.preventDefault(), ctx.store.clickSelectedOption()) : targetType === "button" && (event.preventDefault(), ctx.store.openDropdown("keyboard"));
      }
      event.nativeEvent.code === "Escape" && ctx.store.closeDropdown("keyboard"), event.nativeEvent.code === "Space" && targetType === "button" && (event.preventDefault(), ctx.store.toggleDropdown("keyboard"));
    }
  };
  return {
    ...withAriaAttributes ? {
      "aria-haspopup": "listbox",
      "aria-expanded": withExpandedAttribute && !!(ctx.store.listId && ctx.store.dropdownOpened) || void 0,
      "aria-controls": ctx.store.dropdownOpened ? ctx.store.listId : void 0,
      "aria-activedescendant": ctx.store.dropdownOpened && selectedOptionId || void 0,
      autoComplete,
      "data-expanded": ctx.store.dropdownOpened || void 0,
      "data-mantine-stop-propagation": ctx.store.dropdownOpened || void 0
    } : {},
    onKeyDown: handleKeyDown
  };
}
const defaultProps$1d = {
  refProp: "ref",
  targetType: "input",
  withKeyboardNavigation: !0,
  withAriaAttributes: !0,
  withExpandedAttribute: !1,
  autoComplete: "off"
}, ComboboxEventsTarget = factory((props, ref) => {
  const {
    children,
    refProp,
    withKeyboardNavigation,
    withAriaAttributes,
    withExpandedAttribute,
    targetType,
    autoComplete,
    ...others
  } = useProps("ComboboxEventsTarget", defaultProps$1d, props);
  if (!isElement$1(children))
    throw new Error(
      "Combobox.EventsTarget component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  const ctx = useComboboxContext(), targetProps = useComboboxTargetProps({
    targetType,
    withAriaAttributes,
    withKeyboardNavigation,
    withExpandedAttribute,
    onKeyDown: children.props.onKeyDown,
    autoComplete
  });
  return cloneElement(children, {
    ...targetProps,
    ...others,
    [refProp]: useMergedRef(ref, ctx.store.targetRef, getRefProp(children))
  });
});
ComboboxEventsTarget.displayName = "@mantine/core/ComboboxEventsTarget";
const defaultProps$1c = {}, ComboboxFooter = factory((props, ref) => {
  const { classNames, className, style, styles, vars, ...others } = useProps(
    "ComboboxFooter",
    defaultProps$1c,
    props
  ), ctx = useComboboxContext();
  return /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      ...ctx.getStyles("footer", { className, classNames, style, styles }),
      ...others,
      onMouseDown: (event) => {
        event.preventDefault();
      }
    }
  );
});
ComboboxFooter.classes = classes$s;
ComboboxFooter.displayName = "@mantine/core/ComboboxFooter";
const defaultProps$1b = {}, ComboboxGroup = factory((props, ref) => {
  const { classNames, className, style, styles, vars, children, label, ...others } = useProps(
    "ComboboxGroup",
    defaultProps$1b,
    props
  ), ctx = useComboboxContext();
  return /* @__PURE__ */ jsxs(
    Box,
    {
      ref,
      ...ctx.getStyles("group", { className, classNames, style, styles }),
      ...others,
      children: [
        label && /* @__PURE__ */ jsx("div", { ...ctx.getStyles("groupLabel", { classNames, styles }), children: label }),
        children
      ]
    }
  );
});
ComboboxGroup.classes = classes$s;
ComboboxGroup.displayName = "@mantine/core/ComboboxGroup";
const defaultProps$1a = {}, ComboboxHeader = factory((props, ref) => {
  const { classNames, className, style, styles, vars, ...others } = useProps(
    "ComboboxHeader",
    defaultProps$1a,
    props
  ), ctx = useComboboxContext();
  return /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      ...ctx.getStyles("header", { className, classNames, style, styles }),
      ...others,
      onMouseDown: (event) => {
        event.preventDefault();
      }
    }
  );
});
ComboboxHeader.classes = classes$s;
ComboboxHeader.displayName = "@mantine/core/ComboboxHeader";
function ComboboxHiddenInput({
  value,
  valuesDivider = ",",
  ...others
}) {
  return /* @__PURE__ */ jsx(
    "input",
    {
      type: "hidden",
      value: Array.isArray(value) ? value.join(valuesDivider) : value || "",
      ...others
    }
  );
}
ComboboxHiddenInput.displayName = "@mantine/core/ComboboxHiddenInput";
const defaultProps$19 = {}, ComboboxOption = factory((_props, ref) => {
  const props = useProps("ComboboxOption", defaultProps$19, _props), {
    classNames,
    className,
    style,
    styles,
    vars,
    onClick,
    id,
    active,
    onMouseDown,
    onMouseOver,
    disabled,
    selected,
    mod,
    ...others
  } = props, ctx = useComboboxContext(), uuid = useId$2(), _id = id || uuid;
  return /* @__PURE__ */ jsx(
    Box,
    {
      ...ctx.getStyles("option", { className, classNames, styles, style }),
      ...others,
      ref,
      id: _id,
      mod: [
        "combobox-option",
        { "combobox-active": active, "combobox-disabled": disabled, "combobox-selected": selected },
        mod
      ],
      role: "option",
      onClick: (event) => {
        disabled ? event.preventDefault() : (ctx.onOptionSubmit?.(props.value, props), onClick?.(event));
      },
      onMouseDown: (event) => {
        event.preventDefault(), onMouseDown?.(event);
      },
      onMouseOver: (event) => {
        ctx.resetSelectionOnOptionHover && ctx.store.resetSelectedOption(), onMouseOver?.(event);
      }
    }
  );
});
ComboboxOption.classes = classes$s;
ComboboxOption.displayName = "@mantine/core/ComboboxOption";
const defaultProps$18 = {}, ComboboxOptions = factory((_props, ref) => {
  const props = useProps("ComboboxOptions", defaultProps$18, _props), { classNames, className, style, styles, id, onMouseDown, labelledBy, ...others } = props, ctx = useComboboxContext(), _id = useId$1(id);
  return useEffect(() => {
    ctx.store.setListId(_id);
  }, [_id]), /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      ...ctx.getStyles("options", { className, style, classNames, styles }),
      ...others,
      id: _id,
      role: "listbox",
      "aria-labelledby": labelledBy,
      onMouseDown: (event) => {
        event.preventDefault(), onMouseDown?.(event);
      }
    }
  );
});
ComboboxOptions.classes = classes$s;
ComboboxOptions.displayName = "@mantine/core/ComboboxOptions";
const defaultProps$17 = {
  withAriaAttributes: !0,
  withKeyboardNavigation: !0
}, ComboboxSearch = factory((_props, ref) => {
  const props = useProps("ComboboxSearch", defaultProps$17, _props), {
    classNames,
    styles,
    unstyled,
    vars,
    withAriaAttributes,
    onKeyDown,
    withKeyboardNavigation,
    size: size2,
    ...others
  } = props, ctx = useComboboxContext(), _styles = ctx.getStyles("search"), targetProps = useComboboxTargetProps({
    targetType: "input",
    withAriaAttributes,
    withKeyboardNavigation,
    withExpandedAttribute: !1,
    onKeyDown,
    autoComplete: "off"
  });
  return /* @__PURE__ */ jsx(
    Input,
    {
      ref: useMergedRef(ref, ctx.store.searchRef),
      classNames: [{ input: _styles.className }, classNames],
      styles: [{ input: _styles.style }, styles],
      size: size2 || ctx.size,
      ...targetProps,
      ...others,
      __staticSelector: "Combobox"
    }
  );
});
ComboboxSearch.classes = classes$s;
ComboboxSearch.displayName = "@mantine/core/ComboboxSearch";
const defaultProps$16 = {
  refProp: "ref",
  targetType: "input",
  withKeyboardNavigation: !0,
  withAriaAttributes: !0,
  withExpandedAttribute: !1,
  autoComplete: "off"
}, ComboboxTarget = factory((props, ref) => {
  const {
    children,
    refProp,
    withKeyboardNavigation,
    withAriaAttributes,
    withExpandedAttribute,
    targetType,
    autoComplete,
    ...others
  } = useProps("ComboboxTarget", defaultProps$16, props);
  if (!isElement$1(children))
    throw new Error(
      "Combobox.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  const ctx = useComboboxContext(), targetProps = useComboboxTargetProps({
    targetType,
    withAriaAttributes,
    withKeyboardNavigation,
    withExpandedAttribute,
    onKeyDown: children.props.onKeyDown,
    autoComplete
  }), clonedElement = cloneElement(children, {
    ...targetProps,
    ...others
  });
  return /* @__PURE__ */ jsx(Popover.Target, { ref: useMergedRef(ref, ctx.store.targetRef), children: clonedElement });
});
ComboboxTarget.displayName = "@mantine/core/ComboboxTarget";
function getPreviousIndex(currentIndex, elements, loop) {
  for (let i = currentIndex - 1; i >= 0; i -= 1)
    if (!elements[i].hasAttribute("data-combobox-disabled"))
      return i;
  if (loop) {
    for (let i = elements.length - 1; i > -1; i -= 1)
      if (!elements[i].hasAttribute("data-combobox-disabled"))
        return i;
  }
  return currentIndex;
}
function getNextIndex(currentIndex, elements, loop) {
  for (let i = currentIndex + 1; i < elements.length; i += 1)
    if (!elements[i].hasAttribute("data-combobox-disabled"))
      return i;
  if (loop) {
    for (let i = 0; i < elements.length; i += 1)
      if (!elements[i].hasAttribute("data-combobox-disabled"))
        return i;
  }
  return currentIndex;
}
function getFirstIndex(elements) {
  for (let i = 0; i < elements.length; i += 1)
    if (!elements[i].hasAttribute("data-combobox-disabled"))
      return i;
  return -1;
}
function useCombobox({
  defaultOpened,
  opened,
  onOpenedChange,
  onDropdownClose,
  onDropdownOpen,
  loop = !0,
  scrollBehavior = "instant"
} = {}) {
  const [dropdownOpened, setDropdownOpened] = useUncontrolled({
    value: opened,
    defaultValue: defaultOpened,
    finalValue: !1,
    onChange: onOpenedChange
  }), listId = useRef(null), selectedOptionIndex = useRef(-1), searchRef = useRef(null), targetRef = useRef(null), focusSearchTimeout = useRef(-1), focusTargetTimeout = useRef(-1), selectedIndexUpdateTimeout = useRef(-1), openDropdown = useCallback(
    (eventSource = "unknown") => {
      dropdownOpened || (setDropdownOpened(!0), onDropdownOpen?.(eventSource));
    },
    [setDropdownOpened, onDropdownOpen, dropdownOpened]
  ), closeDropdown = useCallback(
    (eventSource = "unknown") => {
      dropdownOpened && (setDropdownOpened(!1), onDropdownClose?.(eventSource));
    },
    [setDropdownOpened, onDropdownClose, dropdownOpened]
  ), toggleDropdown = useCallback(
    (eventSource = "unknown") => {
      dropdownOpened ? closeDropdown(eventSource) : openDropdown(eventSource);
    },
    [closeDropdown, openDropdown, dropdownOpened]
  ), clearSelectedItem = useCallback(() => {
    const selected = document.querySelector(`#${listId.current} [data-combobox-selected]`);
    selected?.removeAttribute("data-combobox-selected"), selected?.removeAttribute("aria-selected");
  }, []), selectOption = useCallback(
    (index2) => {
      const items = document.getElementById(listId.current)?.querySelectorAll("[data-combobox-option]");
      if (!items)
        return null;
      const nextIndex = index2 >= items.length ? 0 : index2 < 0 ? items.length - 1 : index2;
      return selectedOptionIndex.current = nextIndex, items?.[nextIndex] && !items[nextIndex].hasAttribute("data-combobox-disabled") ? (clearSelectedItem(), items[nextIndex].setAttribute("data-combobox-selected", "true"), items[nextIndex].setAttribute("aria-selected", "true"), items[nextIndex].scrollIntoView({ block: "nearest", behavior: scrollBehavior }), items[nextIndex].id) : null;
    },
    [scrollBehavior, clearSelectedItem]
  ), selectActiveOption = useCallback(() => {
    const activeOption = document.querySelector(
      `#${listId.current} [data-combobox-active]`
    );
    if (activeOption) {
      const items = document.querySelectorAll(
        `#${listId.current} [data-combobox-option]`
      ), index2 = Array.from(items).findIndex((option) => option === activeOption);
      return selectOption(index2);
    }
    return selectOption(0);
  }, [selectOption]), selectNextOption = useCallback(
    () => selectOption(
      getNextIndex(
        selectedOptionIndex.current,
        document.querySelectorAll(`#${listId.current} [data-combobox-option]`),
        loop
      )
    ),
    [selectOption, loop]
  ), selectPreviousOption = useCallback(
    () => selectOption(
      getPreviousIndex(
        selectedOptionIndex.current,
        document.querySelectorAll(`#${listId.current} [data-combobox-option]`),
        loop
      )
    ),
    [selectOption, loop]
  ), selectFirstOption = useCallback(
    () => selectOption(
      getFirstIndex(
        document.querySelectorAll(`#${listId.current} [data-combobox-option]`)
      )
    ),
    [selectOption]
  ), updateSelectedOptionIndex = useCallback(
    (target = "selected", options) => {
      selectedIndexUpdateTimeout.current = window.setTimeout(() => {
        const items = document.querySelectorAll(
          `#${listId.current} [data-combobox-option]`
        ), index2 = Array.from(items).findIndex(
          (option) => option.hasAttribute(`data-combobox-${target}`)
        );
        selectedOptionIndex.current = index2, options?.scrollIntoView && items[index2]?.scrollIntoView({ block: "nearest", behavior: scrollBehavior });
      }, 0);
    },
    []
  ), resetSelectedOption = useCallback(() => {
    selectedOptionIndex.current = -1, clearSelectedItem();
  }, [clearSelectedItem]), clickSelectedOption = useCallback(() => {
    document.querySelectorAll(
      `#${listId.current} [data-combobox-option]`
    )?.[selectedOptionIndex.current]?.click();
  }, []), setListId2 = useCallback((id) => {
    listId.current = id;
  }, []), focusSearchInput = useCallback(() => {
    focusSearchTimeout.current = window.setTimeout(() => searchRef.current.focus(), 0);
  }, []), focusTarget = useCallback(() => {
    focusTargetTimeout.current = window.setTimeout(() => targetRef.current.focus(), 0);
  }, []), getSelectedOptionIndex = useCallback(() => selectedOptionIndex.current, []);
  return useEffect(
    () => () => {
      window.clearTimeout(focusSearchTimeout.current), window.clearTimeout(focusTargetTimeout.current), window.clearTimeout(selectedIndexUpdateTimeout.current);
    },
    []
  ), {
    dropdownOpened,
    openDropdown,
    closeDropdown,
    toggleDropdown,
    selectedOptionIndex: selectedOptionIndex.current,
    getSelectedOptionIndex,
    selectOption,
    selectFirstOption,
    selectActiveOption,
    selectNextOption,
    selectPreviousOption,
    resetSelectedOption,
    updateSelectedOptionIndex,
    listId: listId.current,
    setListId: setListId2,
    clickSelectedOption,
    searchRef,
    focusSearchInput,
    targetRef,
    focusTarget
  };
}
const defaultProps$15 = {
  keepMounted: !0,
  withinPortal: !0,
  resetSelectionOnOptionHover: !1,
  width: "target",
  transitionProps: { transition: "fade", duration: 0 }
}, varsResolver$r = (_, { size: size2, dropdownPadding }) => ({
  options: {
    "--combobox-option-fz": getFontSize(size2),
    "--combobox-option-padding": getSize(size2, "combobox-option-padding")
  },
  dropdown: {
    "--combobox-padding": dropdownPadding === void 0 ? void 0 : rem(dropdownPadding),
    "--combobox-option-fz": getFontSize(size2),
    "--combobox-option-padding": getSize(size2, "combobox-option-padding")
  }
});
function Combobox(_props) {
  const props = useProps("Combobox", defaultProps$15, _props), {
    classNames,
    styles,
    unstyled,
    children,
    store: controlledStore,
    vars,
    onOptionSubmit,
    onClose,
    size: size2,
    dropdownPadding,
    resetSelectionOnOptionHover,
    __staticSelector,
    readOnly,
    ...others
  } = props, uncontrolledStore = useCombobox(), store = controlledStore || uncontrolledStore, getStyles2 = useStyles({
    name: __staticSelector || "Combobox",
    classes: classes$s,
    props,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$r
  }), onDropdownClose = () => {
    onClose?.(), store.closeDropdown();
  };
  return /* @__PURE__ */ jsx(
    ComboboxProvider,
    {
      value: {
        getStyles: getStyles2,
        store,
        onOptionSubmit,
        size: size2,
        resetSelectionOnOptionHover,
        readOnly
      },
      children: /* @__PURE__ */ jsx(
        Popover,
        {
          opened: store.dropdownOpened,
          ...others,
          onChange: (_opened) => !_opened && onDropdownClose(),
          withRoles: !1,
          unstyled,
          children
        }
      )
    }
  );
}
const extendCombobox = (c) => c;
Combobox.extend = extendCombobox;
Combobox.classes = classes$s;
Combobox.displayName = "@mantine/core/Combobox";
Combobox.Target = ComboboxTarget;
Combobox.Dropdown = ComboboxDropdown;
Combobox.Options = ComboboxOptions;
Combobox.Option = ComboboxOption;
Combobox.Search = ComboboxSearch;
Combobox.Empty = ComboboxEmpty;
Combobox.Chevron = ComboboxChevron;
Combobox.Footer = ComboboxFooter;
Combobox.Header = ComboboxHeader;
Combobox.EventsTarget = ComboboxEventsTarget;
Combobox.DropdownTarget = ComboboxDropdownTarget;
Combobox.Group = ComboboxGroup;
Combobox.ClearButton = ComboboxClearButton;
Combobox.HiddenInput = ComboboxHiddenInput;
function CheckIcon({ size: size2, style, ...others }) {
  const _style = size2 !== void 0 ? { width: rem(size2), height: rem(size2), ...style } : style;
  return /* @__PURE__ */ jsx(
    "svg",
    {
      viewBox: "0 0 10 7",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      style: _style,
      "aria-hidden": !0,
      ...others,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M4 4.586L1.707 2.293A1 1 0 1 0 .293 3.707l3 3a.997.997 0 0 0 1.414 0l5-5A1 1 0 1 0 8.293.293L4 4.586z",
          fill: "currentColor",
          fillRule: "evenodd",
          clipRule: "evenodd"
        }
      )
    }
  );
}
function isOptionsGroup(item) {
  return "group" in item;
}
function defaultOptionsFilter({
  options,
  search,
  limit
}) {
  const parsedSearch = search.trim().toLowerCase(), result = [];
  for (let i = 0; i < options.length; i += 1) {
    const item = options[i];
    if (result.length === limit)
      return result;
    isOptionsGroup(item) && result.push({
      group: item.group,
      items: defaultOptionsFilter({
        options: item.items,
        search,
        limit: limit - result.length
      })
    }), isOptionsGroup(item) || item.label.toLowerCase().includes(parsedSearch) && result.push(item);
  }
  return result;
}
function isEmptyComboboxData(data) {
  if (data.length === 0)
    return !0;
  for (const item of data)
    if (!("group" in item) || item.items.length > 0)
      return !1;
  return !0;
}
function validateOptions(options, valuesSet = /* @__PURE__ */ new Set()) {
  if (Array.isArray(options))
    for (const option of options)
      if (isOptionsGroup(option))
        validateOptions(option.items, valuesSet);
      else {
        if (typeof option.value > "u")
          throw new Error("[@mantine/core] Each option must have value property");
        if (typeof option.value != "string")
          throw new Error(
            `[@mantine/core] Option value must be a string, other data formats are not supported, got ${typeof option.value}`
          );
        if (valuesSet.has(option.value))
          throw new Error(
            `[@mantine/core] Duplicate options are not supported. Option with value "${option.value}" was provided more than once`
          );
        valuesSet.add(option.value);
      }
}
function isValueChecked(value, optionValue) {
  return Array.isArray(value) ? value.includes(optionValue) : value === optionValue;
}
function Option({
  data,
  withCheckIcon,
  value,
  checkIconPosition,
  unstyled,
  renderOption
}) {
  if (!isOptionsGroup(data)) {
    const checked = isValueChecked(value, data.value), check = withCheckIcon && checked && /* @__PURE__ */ jsx(CheckIcon, { className: classes$s.optionsDropdownCheckIcon }), defaultContent = /* @__PURE__ */ jsxs(Fragment$1, { children: [
      checkIconPosition === "left" && check,
      /* @__PURE__ */ jsx("span", { children: data.label }),
      checkIconPosition === "right" && check
    ] });
    return /* @__PURE__ */ jsx(
      Combobox.Option,
      {
        value: data.value,
        disabled: data.disabled,
        className: clsx({ [classes$s.optionsDropdownOption]: !unstyled }),
        "data-reverse": checkIconPosition === "right" || void 0,
        "data-checked": checked || void 0,
        "aria-selected": checked,
        active: checked,
        children: typeof renderOption == "function" ? renderOption({ option: data, checked }) : defaultContent
      }
    );
  }
  const options = data.items.map((item) => /* @__PURE__ */ jsx(
    Option,
    {
      data: item,
      value,
      unstyled,
      withCheckIcon,
      checkIconPosition,
      renderOption
    },
    item.value
  ));
  return /* @__PURE__ */ jsx(Combobox.Group, { label: data.group, children: options });
}
function OptionsDropdown({
  data,
  hidden: hidden2,
  hiddenWhenEmpty,
  filter,
  search,
  limit,
  maxDropdownHeight,
  withScrollArea = !0,
  filterOptions = !0,
  withCheckIcon = !1,
  value,
  checkIconPosition,
  nothingFoundMessage,
  unstyled,
  labelId,
  renderOption,
  scrollAreaProps,
  "aria-label": ariaLabel
}) {
  validateOptions(data);
  const filteredData = typeof search == "string" ? (filter || defaultOptionsFilter)({
    options: data,
    search: filterOptions ? search : "",
    limit: limit ?? 1 / 0
  }) : data, isEmpty = isEmptyComboboxData(filteredData), options = filteredData.map((item) => /* @__PURE__ */ jsx(
    Option,
    {
      data: item,
      withCheckIcon,
      value,
      checkIconPosition,
      unstyled,
      renderOption
    },
    isOptionsGroup(item) ? item.group : item.value
  ));
  return /* @__PURE__ */ jsx(Combobox.Dropdown, { hidden: hidden2 || hiddenWhenEmpty && isEmpty, children: /* @__PURE__ */ jsxs(Combobox.Options, { labelledBy: labelId, "aria-label": ariaLabel, children: [
    withScrollArea ? /* @__PURE__ */ jsx(
      ScrollArea.Autosize,
      {
        mah: maxDropdownHeight ?? 220,
        type: "scroll",
        scrollbarSize: "var(--combobox-padding)",
        offsetScrollbars: "y",
        ...scrollAreaProps,
        children: options
      }
    ) : options,
    isEmpty && nothingFoundMessage && /* @__PURE__ */ jsx(Combobox.Empty, { children: nothingFoundMessage })
  ] }) });
}
var __default__$r = { root: "m_347db0ec", "root--dot": "m_fbd81e3d", label: "m_5add502a", section: "m_91fdda9b" };
const classes$r = __default__$r, defaultProps$14 = {}, varsResolver$q = (theme, { radius, color, gradient, variant, size: size2, autoContrast }) => {
  const colors = theme.variantColorResolver({
    color: color || theme.primaryColor,
    theme,
    gradient,
    variant: variant || "filled",
    autoContrast
  });
  return {
    root: {
      "--badge-height": getSize(size2, "badge-height"),
      "--badge-padding-x": getSize(size2, "badge-padding-x"),
      "--badge-fz": getSize(size2, "badge-fz"),
      "--badge-radius": radius === void 0 ? void 0 : getRadius(radius),
      "--badge-bg": color || variant ? colors.background : void 0,
      "--badge-color": color || variant ? colors.color : void 0,
      "--badge-bd": color || variant ? colors.border : void 0,
      "--badge-dot-color": variant === "dot" ? getThemeColor(color, theme) : void 0
    }
  };
}, Badge = polymorphicFactory((_props, ref) => {
  const props = useProps("Badge", defaultProps$14, _props), {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    radius,
    color,
    gradient,
    leftSection,
    rightSection,
    children,
    variant,
    fullWidth,
    autoContrast,
    circle,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Badge",
    props,
    classes: classes$r,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$q
  });
  return /* @__PURE__ */ jsxs(
    Box,
    {
      variant,
      mod: [
        {
          block: fullWidth,
          circle,
          "with-right-section": !!rightSection,
          "with-left-section": !!leftSection
        },
        mod
      ],
      ...getStyles2("root", { variant }),
      ref,
      ...others,
      children: [
        leftSection && /* @__PURE__ */ jsx("span", { ...getStyles2("section"), "data-position": "left", children: leftSection }),
        /* @__PURE__ */ jsx("span", { ...getStyles2("label"), children }),
        rightSection && /* @__PURE__ */ jsx("span", { ...getStyles2("section"), "data-position": "right", children: rightSection })
      ]
    }
  );
});
Badge.classes = classes$r;
Badge.displayName = "@mantine/core/Badge";
var __default__$q = { root: "m_fea6bf1a", burger: "m_d4fb9cad" };
const classes$q = __default__$q, defaultProps$13 = {}, varsResolver$p = (theme, { color, size: size2, lineSize, transitionDuration, transitionTimingFunction }) => ({
  root: {
    "--burger-color": color ? getThemeColor(color, theme) : void 0,
    "--burger-size": getSize(size2, "burger-size"),
    "--burger-line-size": lineSize ? rem(lineSize) : void 0,
    "--burger-transition-duration": transitionDuration === void 0 ? void 0 : `${transitionDuration}ms`,
    "--burger-transition-timing-function": transitionTimingFunction
  }
}), Burger = factory((_props, ref) => {
  const props = useProps("Burger", defaultProps$13, _props), {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    opened,
    children,
    transitionDuration,
    transitionTimingFunction,
    lineSize,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Burger",
    classes: classes$q,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$p
  });
  return /* @__PURE__ */ jsxs(UnstyledButton, { ...getStyles2("root"), ref, ...others, children: [
    /* @__PURE__ */ jsx(Box, { mod: ["reduce-motion", { opened }], ...getStyles2("burger") }),
    children
  ] });
});
Burger.classes = classes$q;
Burger.displayName = "@mantine/core/Burger";
var __default__$p = { root: "m_77c9d27d", inner: "m_80f1301b", label: "m_811560b9", section: "m_a74036a", loader: "m_a25b86ee", group: "m_80d6d844" };
const classes$p = __default__$p, defaultProps$12 = {
  orientation: "horizontal"
}, varsResolver$o = (_, { borderWidth }) => ({
  group: { "--button-border-width": rem(borderWidth) }
}), ButtonGroup = factory((_props, ref) => {
  const props = useProps("ButtonGroup", defaultProps$12, _props), {
    className,
    style,
    classNames,
    styles,
    unstyled,
    orientation,
    vars,
    borderWidth,
    variant,
    mod,
    ...others
  } = useProps("ButtonGroup", defaultProps$12, _props), getStyles2 = useStyles({
    name: "ButtonGroup",
    props,
    classes: classes$p,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$o,
    rootSelector: "group"
  });
  return /* @__PURE__ */ jsx(
    Box,
    {
      ...getStyles2("group"),
      ref,
      variant,
      mod: [{ "data-orientation": orientation }, mod],
      role: "group",
      ...others
    }
  );
});
ButtonGroup.classes = classes$p;
ButtonGroup.displayName = "@mantine/core/ButtonGroup";
const loaderTransition = {
  in: { opacity: 1, transform: `translate(-50%, calc(-50% + ${rem(1)}))` },
  out: { opacity: 0, transform: "translate(-50%, -200%)" },
  common: { transformOrigin: "center" },
  transitionProperty: "transform, opacity"
}, defaultProps$11 = {}, varsResolver$n = (theme, { radius, color, gradient, variant, size: size2, justify, autoContrast }) => {
  const colors = theme.variantColorResolver({
    color: color || theme.primaryColor,
    theme,
    gradient,
    variant: variant || "filled",
    autoContrast
  });
  return {
    root: {
      "--button-justify": justify,
      "--button-height": getSize(size2, "button-height"),
      "--button-padding-x": getSize(size2, "button-padding-x"),
      "--button-fz": size2?.includes("compact") ? getFontSize(size2.replace("compact-", "")) : getFontSize(size2),
      "--button-radius": radius === void 0 ? void 0 : getRadius(radius),
      "--button-bg": color || variant ? colors.background : void 0,
      "--button-hover": color || variant ? colors.hover : void 0,
      "--button-color": colors.color,
      "--button-bd": color || variant ? colors.border : void 0,
      "--button-hover-color": color || variant ? colors.hoverColor : void 0
    }
  };
}, Button = polymorphicFactory((_props, ref) => {
  const props = useProps("Button", defaultProps$11, _props), {
    style,
    vars,
    className,
    color,
    disabled,
    children,
    leftSection,
    rightSection,
    fullWidth,
    variant,
    radius,
    loading,
    loaderProps,
    gradient,
    classNames,
    styles,
    unstyled,
    "data-disabled": dataDisabled,
    autoContrast,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Button",
    props,
    classes: classes$p,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$n
  }), hasLeftSection = !!leftSection, hasRightSection = !!rightSection;
  return /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      ref,
      ...getStyles2("root", { active: !disabled && !loading && !dataDisabled }),
      unstyled,
      variant,
      disabled: disabled || loading,
      mod: [
        {
          disabled: disabled || dataDisabled,
          loading,
          block: fullWidth,
          "with-left-section": hasLeftSection,
          "with-right-section": hasRightSection
        },
        mod
      ],
      ...others,
      children: [
        /* @__PURE__ */ jsx(Transition, { mounted: !!loading, transition: loaderTransition, duration: 150, children: (transitionStyles) => /* @__PURE__ */ jsx(Box, { component: "span", ...getStyles2("loader", { style: transitionStyles }), "aria-hidden": !0, children: /* @__PURE__ */ jsx(
          Loader,
          {
            color: "var(--button-color)",
            size: "calc(var(--button-height) / 1.8)",
            ...loaderProps
          }
        ) }) }),
        /* @__PURE__ */ jsxs("span", { ...getStyles2("inner"), children: [
          leftSection && /* @__PURE__ */ jsx(Box, { component: "span", ...getStyles2("section"), mod: { position: "left" }, children: leftSection }),
          /* @__PURE__ */ jsx(Box, { component: "span", mod: { loading }, ...getStyles2("label"), children }),
          rightSection && /* @__PURE__ */ jsx(Box, { component: "span", ...getStyles2("section"), mod: { position: "right" }, children: rightSection })
        ] })
      ]
    }
  );
});
Button.classes = classes$p;
Button.displayName = "@mantine/core/Button";
Button.Group = ButtonGroup;
const [CardProvider, useCardContext] = createSafeContext(
  "Card component was not found in tree"
);
var __default__$o = { root: "m_e615b15f", section: "m_599a2148" };
const classes$o = __default__$o, defaultProps$10 = {}, CardSection = polymorphicFactory((_props, ref) => {
  const props = useProps("CardSection", defaultProps$10, _props), { classNames, className, style, styles, vars, withBorder, inheritPadding, mod, ...others } = props, ctx = useCardContext();
  return /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      mod: [{ "with-border": withBorder, "inherit-padding": inheritPadding }, mod],
      ...ctx.getStyles("section", { className, style, styles, classNames }),
      ...others
    }
  );
});
CardSection.classes = classes$o;
CardSection.displayName = "@mantine/core/CardSection";
const defaultProps$$ = {}, varsResolver$m = (_, { padding }) => ({
  root: {
    "--card-padding": getSpacing(padding)
  }
}), Card = polymorphicFactory((_props, ref) => {
  const props = useProps("Card", defaultProps$$, _props), { classNames, className, style, styles, unstyled, vars, children, padding, ...others } = props, getStyles2 = useStyles({
    name: "Card",
    props,
    classes: classes$o,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$m
  }), _children = Children.toArray(children), content = _children.map((child, index2) => typeof child == "object" && child && "type" in child && child.type === CardSection ? cloneElement(child, {
    "data-first-section": index2 === 0 || void 0,
    "data-last-section": index2 === _children.length - 1 || void 0
  }) : child);
  return /* @__PURE__ */ jsx(CardProvider, { value: { getStyles: getStyles2 }, children: /* @__PURE__ */ jsx(Paper, { ref, unstyled, ...getStyles2("root"), ...others, children: content }) });
});
Card.classes = classes$o;
Card.displayName = "@mantine/core/Card";
Card.Section = CardSection;
var __default__$n = { root: "m_4451eb3a" };
const classes$n = __default__$n, defaultProps$_ = {}, Center = polymorphicFactory((_props, ref) => {
  const props = useProps("Center", defaultProps$_, _props), { classNames, className, style, styles, unstyled, vars, inline: inline2, mod, ...others } = props, getStyles2 = useStyles({
    name: "Center",
    props,
    classes: classes$n,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars
  });
  return /* @__PURE__ */ jsx(Box, { ref, mod: [{ inline: inline2 }, mod], ...getStyles2("root"), ...others });
});
Center.classes = classes$n;
Center.displayName = "@mantine/core/Center";
var __default__$m = { root: "m_b183c0a2" };
const classes$m = __default__$m, defaultProps$Z = {}, varsResolver$l = (theme, { color }) => ({
  root: {
    "--code-bg": color ? getThemeColor(color, theme) : void 0
  }
}), Code = factory((_props, ref) => {
  const props = useProps("Code", defaultProps$Z, _props), {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    color,
    block,
    variant,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Code",
    props,
    classes: classes$m,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$l
  });
  return /* @__PURE__ */ jsx(
    Box,
    {
      component: block ? "pre" : "code",
      variant,
      ref,
      mod: [{ block }, mod],
      ...getStyles2("root"),
      ...others,
      dir: "ltr"
    }
  );
});
Code.classes = classes$m;
Code.displayName = "@mantine/core/Code";
var __default__$l = { root: "m_de3d2490", colorOverlay: "m_862f3d1b", shadowOverlay: "m_98ae7f22", alphaOverlay: "m_95709ac0", childrenOverlay: "m_93e74e3" };
const classes$l = __default__$l, defaultProps$Y = {
  withShadow: !0
}, varsResolver$k = (_, { radius, size: size2 }) => ({
  root: {
    "--cs-radius": radius === void 0 ? void 0 : getRadius(radius),
    "--cs-size": rem(size2)
  }
}), ColorSwatch = polymorphicFactory((_props, ref) => {
  const props = useProps("ColorSwatch", defaultProps$Y, _props), {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    color,
    size: size2,
    radius,
    withShadow,
    children,
    variant,
    ...others
  } = useProps("ColorSwatch", defaultProps$Y, props), getStyles2 = useStyles({
    name: "ColorSwatch",
    props,
    classes: classes$l,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$k
  });
  return /* @__PURE__ */ jsxs(
    Box,
    {
      ref,
      variant,
      size: size2,
      ...getStyles2("root", { focusable: !0 }),
      ...others,
      children: [
        /* @__PURE__ */ jsx("span", { ...getStyles2("alphaOverlay") }),
        withShadow && /* @__PURE__ */ jsx("span", { ...getStyles2("shadowOverlay") }),
        /* @__PURE__ */ jsx("span", { ...getStyles2("colorOverlay", { style: { backgroundColor: color } }) }),
        /* @__PURE__ */ jsx("span", { ...getStyles2("childrenOverlay"), children })
      ]
    }
  );
});
ColorSwatch.classes = classes$l;
ColorSwatch.displayName = "@mantine/core/ColorSwatch";
var __default__$k = { root: "m_7485cace" };
const classes$k = __default__$k, defaultProps$X = {}, varsResolver$j = (_, { size: size2, fluid }) => ({
  root: {
    "--container-size": fluid ? void 0 : getSize(size2, "container-size")
  }
}), Container = factory((_props, ref) => {
  const props = useProps("Container", defaultProps$X, _props), { classNames, className, style, styles, unstyled, vars, fluid, mod, ...others } = props, getStyles2 = useStyles({
    name: "Container",
    classes: classes$k,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$j
  });
  return /* @__PURE__ */ jsx(Box, { ref, mod: [{ fluid }, mod], ...getStyles2("root"), ...others });
});
Container.classes = classes$k;
Container.displayName = "@mantine/core/Container";
const defaultProps$W = {
  timeout: 1e3
};
function CopyButton(props) {
  const { children, timeout, value, ...others } = useProps("CopyButton", defaultProps$W, props), clipboard = useClipboard({ timeout });
  return /* @__PURE__ */ jsx(Fragment$1, { children: children({ copy: () => clipboard.copy(value), copied: clipboard.copied, ...others }) });
}
CopyButton.displayName = "@mantine/core/CopyButton";
var __default__$j = { root: "m_3eebeb36", label: "m_9e365f20" };
const classes$j = __default__$j, defaultProps$V = {
  orientation: "horizontal"
}, varsResolver$i = (theme, { color, variant, size: size2 }) => ({
  root: {
    "--divider-color": color ? getThemeColor(color, theme) : void 0,
    "--divider-border-style": variant,
    "--divider-size": getSize(size2, "divider-size")
  }
}), Divider = factory((_props, ref) => {
  const props = useProps("Divider", defaultProps$V, _props), {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    color,
    orientation,
    label,
    labelPosition,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Divider",
    classes: classes$j,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$i
  });
  return /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      mod: [{ orientation, "with-label": !!label }, mod],
      ...getStyles2("root"),
      ...others,
      role: "separator",
      children: label && /* @__PURE__ */ jsx(Box, { component: "span", mod: { position: labelPosition }, ...getStyles2("label"), children: label })
    }
  );
});
Divider.classes = classes$j;
Divider.displayName = "@mantine/core/Divider";
const [DrawerProvider, useDrawerContext] = createSafeContext(
  "Drawer component was not found in tree"
);
var __default__$i = { root: "m_f11b401e", header: "m_5a7c2c9", content: "m_b8a05bbd", inner: "m_31cd769a" };
const classes$i = __default__$i, defaultProps$U = {}, DrawerBody = factory((_props, ref) => {
  const props = useProps("DrawerBody", defaultProps$U, _props), { classNames, className, style, styles, vars, ...others } = props, ctx = useDrawerContext();
  return /* @__PURE__ */ jsx(
    ModalBaseBody,
    {
      ref,
      ...ctx.getStyles("body", { classNames, style, styles, className }),
      ...others
    }
  );
});
DrawerBody.classes = classes$i;
DrawerBody.displayName = "@mantine/core/DrawerBody";
const defaultProps$T = {}, DrawerCloseButton = factory((_props, ref) => {
  const props = useProps("DrawerCloseButton", defaultProps$T, _props), { classNames, className, style, styles, vars, ...others } = props, ctx = useDrawerContext();
  return /* @__PURE__ */ jsx(
    ModalBaseCloseButton,
    {
      ref,
      ...ctx.getStyles("close", { classNames, style, styles, className }),
      ...others
    }
  );
});
DrawerCloseButton.classes = classes$i;
DrawerCloseButton.displayName = "@mantine/core/DrawerCloseButton";
const defaultProps$S = {}, DrawerContent = factory((_props, ref) => {
  const props = useProps("DrawerContent", defaultProps$S, _props), { classNames, className, style, styles, vars, children, radius, __hidden, ...others } = props, ctx = useDrawerContext(), Scroll = ctx.scrollAreaComponent || NativeScrollArea;
  return /* @__PURE__ */ jsx(
    ModalBaseContent,
    {
      ...ctx.getStyles("content", { className, style, styles, classNames }),
      innerProps: ctx.getStyles("inner", { className, style, styles, classNames }),
      ref,
      ...others,
      radius: radius || ctx.radius || 0,
      "data-hidden": __hidden || void 0,
      children: /* @__PURE__ */ jsx(Scroll, { style: { height: "calc(100vh - var(--drawer-offset) * 2)" }, children })
    }
  );
});
DrawerContent.classes = classes$i;
DrawerContent.displayName = "@mantine/core/DrawerContent";
const defaultProps$R = {}, DrawerHeader = factory((_props, ref) => {
  const props = useProps("DrawerHeader", defaultProps$R, _props), { classNames, className, style, styles, vars, ...others } = props, ctx = useDrawerContext();
  return /* @__PURE__ */ jsx(
    ModalBaseHeader,
    {
      ref,
      ...ctx.getStyles("header", { classNames, style, styles, className }),
      ...others
    }
  );
});
DrawerHeader.classes = classes$i;
DrawerHeader.displayName = "@mantine/core/DrawerHeader";
const defaultProps$Q = {}, DrawerOverlay = factory((_props, ref) => {
  const props = useProps("DrawerOverlay", defaultProps$Q, _props), { classNames, className, style, styles, vars, ...others } = props, ctx = useDrawerContext();
  return /* @__PURE__ */ jsx(
    ModalBaseOverlay,
    {
      ref,
      ...ctx.getStyles("overlay", { classNames, style, styles, className }),
      ...others
    }
  );
});
DrawerOverlay.classes = classes$i;
DrawerOverlay.displayName = "@mantine/core/DrawerOverlay";
function getDrawerAlign(position) {
  switch (position) {
    case "top":
      return "flex-start";
    case "bottom":
      return "flex-end";
    default:
      return;
  }
}
function getDrawerFlex(position) {
  if (position === "top" || position === "bottom")
    return "0 0 calc(100% - var(--drawer-offset, 0rem) * 2)";
}
const transitions = {
  top: "slide-down",
  bottom: "slide-up",
  left: "slide-right",
  right: "slide-left"
}, rtlTransitions = {
  top: "slide-down",
  bottom: "slide-up",
  right: "slide-right",
  left: "slide-left"
}, defaultProps$P = {
  closeOnClickOutside: !0,
  withinPortal: !0,
  lockScroll: !0,
  trapFocus: !0,
  returnFocus: !0,
  closeOnEscape: !0,
  keepMounted: !1,
  zIndex: getDefaultZIndex("modal"),
  position: "left"
}, varsResolver$h = (_, { position, size: size2, offset: offset2 }) => ({
  root: {
    "--drawer-size": getSize(size2, "drawer-size"),
    "--drawer-flex": getDrawerFlex(position),
    "--drawer-height": position === "left" || position === "right" ? void 0 : "var(--drawer-size)",
    "--drawer-align": getDrawerAlign(position),
    "--drawer-justify": position === "right" ? "flex-end" : void 0,
    "--drawer-offset": rem(offset2)
  }
}), DrawerRoot = factory((_props, ref) => {
  const props = useProps("DrawerRoot", defaultProps$P, _props), {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    scrollAreaComponent,
    position,
    transitionProps,
    radius,
    ...others
  } = props, { dir } = useDirection(), getStyles2 = useStyles({
    name: "Drawer",
    classes: classes$i,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$h
  }), drawerTransition = (dir === "rtl" ? rtlTransitions : transitions)[position];
  return /* @__PURE__ */ jsx(DrawerProvider, { value: { scrollAreaComponent, getStyles: getStyles2, radius }, children: /* @__PURE__ */ jsx(
    ModalBase,
    {
      ref,
      ...getStyles2("root"),
      transitionProps: { transition: drawerTransition, ...transitionProps },
      unstyled,
      ...others
    }
  ) });
});
DrawerRoot.classes = classes$i;
DrawerRoot.displayName = "@mantine/core/DrawerRoot";
const [DrawerStackProvider, useDrawerStackContext] = createOptionalContext();
function DrawerStack({ children }) {
  const [stack, setStack] = useState([]), [maxZIndex, setMaxZIndex] = useState(getDefaultZIndex("modal"));
  return /* @__PURE__ */ jsx(
    DrawerStackProvider,
    {
      value: {
        stack,
        addModal: (id, zIndex) => {
          setStack((current) => [.../* @__PURE__ */ new Set([...current, id])]), setMaxZIndex(
            (current) => typeof zIndex == "number" && typeof current == "number" ? Math.max(current, zIndex) : current
          );
        },
        removeModal: (id) => setStack((current) => current.filter((currentId) => currentId !== id)),
        getZIndex: (id) => `calc(${maxZIndex} + ${stack.indexOf(id)} + 1)`,
        currentId: stack[stack.length - 1],
        maxZIndex
      },
      children
    }
  );
}
DrawerStack.displayName = "@mantine/core/DrawerStack";
const defaultProps$O = {}, DrawerTitle = factory((_props, ref) => {
  const props = useProps("DrawerTitle", defaultProps$O, _props), { classNames, className, style, styles, vars, ...others } = props, ctx = useDrawerContext();
  return /* @__PURE__ */ jsx(
    ModalBaseTitle,
    {
      ref,
      ...ctx.getStyles("title", { classNames, style, styles, className }),
      ...others
    }
  );
});
DrawerTitle.classes = classes$i;
DrawerTitle.displayName = "@mantine/core/DrawerTitle";
const defaultProps$N = {
  closeOnClickOutside: !0,
  withinPortal: !0,
  lockScroll: !0,
  trapFocus: !0,
  returnFocus: !0,
  closeOnEscape: !0,
  keepMounted: !1,
  zIndex: getDefaultZIndex("modal"),
  withOverlay: !0,
  withCloseButton: !0
}, Drawer = factory((_props, ref) => {
  const {
    title,
    withOverlay,
    overlayProps,
    withCloseButton,
    closeButtonProps,
    children,
    opened,
    stackId,
    zIndex,
    ...others
  } = useProps("Drawer", defaultProps$N, _props), ctx = useDrawerStackContext(), hasHeader = !!title || withCloseButton, stackProps = ctx && stackId ? {
    closeOnEscape: ctx.currentId === stackId,
    trapFocus: ctx.currentId === stackId,
    zIndex: ctx.getZIndex(stackId)
  } : {}, overlayVisible = withOverlay === !1 ? !1 : stackId && ctx ? ctx.currentId === stackId : opened;
  return useEffect(() => {
    ctx && stackId && (opened ? ctx.addModal(stackId, zIndex || getDefaultZIndex("modal")) : ctx.removeModal(stackId));
  }, [opened, stackId, zIndex]), /* @__PURE__ */ jsxs(
    DrawerRoot,
    {
      ref,
      opened,
      zIndex: ctx && stackId ? ctx.getZIndex(stackId) : zIndex,
      ...others,
      ...stackProps,
      children: [
        withOverlay && /* @__PURE__ */ jsx(
          DrawerOverlay,
          {
            visible: overlayVisible,
            transitionProps: ctx && stackId ? { duration: 0 } : void 0,
            ...overlayProps
          }
        ),
        /* @__PURE__ */ jsxs(DrawerContent, { __hidden: ctx && stackId && opened ? stackId !== ctx.currentId : !1, children: [
          hasHeader && /* @__PURE__ */ jsxs(DrawerHeader, { children: [
            title && /* @__PURE__ */ jsx(DrawerTitle, { children: title }),
            withCloseButton && /* @__PURE__ */ jsx(DrawerCloseButton, { ...closeButtonProps })
          ] }),
          /* @__PURE__ */ jsx(DrawerBody, { children })
        ] })
      ]
    }
  );
});
Drawer.classes = classes$i;
Drawer.displayName = "@mantine/core/Drawer";
Drawer.Root = DrawerRoot;
Drawer.Overlay = DrawerOverlay;
Drawer.Content = DrawerContent;
Drawer.Body = DrawerBody;
Drawer.Header = DrawerHeader;
Drawer.Title = DrawerTitle;
Drawer.CloseButton = DrawerCloseButton;
Drawer.Stack = DrawerStack;
function useDelayedHover({ open, close, openDelay, closeDelay }) {
  const openTimeout = useRef(-1), closeTimeout = useRef(-1), clearTimeouts = () => {
    window.clearTimeout(openTimeout.current), window.clearTimeout(closeTimeout.current);
  }, openDropdown = () => {
    clearTimeouts(), openDelay === 0 || openDelay === void 0 ? open() : openTimeout.current = window.setTimeout(open, openDelay);
  }, closeDropdown = () => {
    clearTimeouts(), closeDelay === 0 || closeDelay === void 0 ? close() : closeTimeout.current = window.setTimeout(close, closeDelay);
  };
  return useEffect(() => clearTimeouts, []), { openDropdown, closeDropdown };
}
function getMarkColor({ color, theme, defaultShade }) {
  const parsed = parseThemeColor({ color, theme });
  return parsed.isThemeColor ? parsed.shade === void 0 ? `var(--mantine-color-${parsed.color}-${defaultShade})` : `var(${parsed.variable})` : color;
}
var __default__$h = { root: "m_bcb3f3c2" };
const classes$h = __default__$h, defaultProps$M = {
  color: "yellow"
}, varsResolver$g = (theme, { color }) => ({
  root: {
    "--mark-bg-dark": getMarkColor({ color, theme, defaultShade: 5 }),
    "--mark-bg-light": getMarkColor({ color, theme, defaultShade: 2 })
  }
}), Mark = factory((_props, ref) => {
  const props = useProps("Mark", defaultProps$M, _props), { classNames, className, style, styles, unstyled, vars, color, variant, ...others } = props, getStyles2 = useStyles({
    name: "Mark",
    props,
    className,
    style,
    classes: classes$h,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$g
  });
  return /* @__PURE__ */ jsx(Box, { component: "mark", ref, variant, ...getStyles2("root"), ...others });
});
Mark.classes = classes$h;
Mark.displayName = "@mantine/core/Mark";
function escapeRegex(value) {
  return value.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&");
}
function highlighter(value, _highlight) {
  if (_highlight == null)
    return [{ chunk: value, highlighted: !1 }];
  const highlight = Array.isArray(_highlight) ? _highlight.map(escapeRegex) : escapeRegex(_highlight);
  if (!(Array.isArray(highlight) ? highlight.filter((part) => part.trim().length > 0).length > 0 : highlight.trim() !== ""))
    return [{ chunk: value, highlighted: !1 }];
  const matcher = typeof highlight == "string" ? highlight.trim() : highlight.filter((part) => part.trim().length !== 0).map((part) => part.trim()).sort((a, b) => b.length - a.length).join("|"), re = new RegExp(`(${matcher})`, "gi");
  return value.split(re).map((part) => ({ chunk: part, highlighted: re.test(part) })).filter(({ chunk }) => chunk);
}
const defaultProps$L = {}, Highlight = polymorphicFactory((props, ref) => {
  const { unstyled, children, highlight, highlightStyles, color, ...others } = useProps(
    "Highlight",
    defaultProps$L,
    props
  ), highlightChunks = highlighter(children, highlight);
  return /* @__PURE__ */ jsx(Text, { unstyled, ref, ...others, __staticSelector: "Highlight", children: highlightChunks.map(
    ({ chunk, highlighted }, i) => highlighted ? /* @__PURE__ */ jsx(
      Mark,
      {
        unstyled,
        color,
        style: highlightStyles,
        "data-highlight": chunk,
        children: chunk
      },
      i
    ) : /* @__PURE__ */ jsx("span", { children: chunk }, i)
  ) });
});
Highlight.classes = Text.classes;
Highlight.displayName = "@mantine/core/Highlight";
const [HoverCardContextProvider, useHoverCardContext] = createSafeContext(
  "HoverCard component was not found in the tree"
), defaultProps$K = {};
function HoverCardDropdown(props) {
  const { children, onMouseEnter, onMouseLeave, ...others } = useProps(
    "HoverCardDropdown",
    defaultProps$K,
    props
  ), ctx = useHoverCardContext(), handleMouseEnter = createEventHandler(onMouseEnter, ctx.openDropdown), handleMouseLeave = createEventHandler(onMouseLeave, ctx.closeDropdown);
  return /* @__PURE__ */ jsx(Popover.Dropdown, { onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, ...others, children });
}
HoverCardDropdown.displayName = "@mantine/core/HoverCardDropdown";
const defaultProps$J = {
  refProp: "ref"
}, HoverCardTarget = forwardRef((props, ref) => {
  const { children, refProp, eventPropsWrapperName, ...others } = useProps(
    "HoverCardTarget",
    defaultProps$J,
    props
  );
  if (!isElement$1(children))
    throw new Error(
      "HoverCard.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  const ctx = useHoverCardContext(), onMouseEnter = createEventHandler(children.props.onMouseEnter, ctx.openDropdown), onMouseLeave = createEventHandler(children.props.onMouseLeave, ctx.closeDropdown), eventListeners = { onMouseEnter, onMouseLeave };
  return /* @__PURE__ */ jsx(Popover.Target, { refProp, ref, ...others, children: cloneElement(
    children,
    eventPropsWrapperName ? { [eventPropsWrapperName]: eventListeners } : eventListeners
  ) });
});
HoverCardTarget.displayName = "@mantine/core/HoverCardTarget";
const defaultProps$I = {
  openDelay: 0,
  closeDelay: 150,
  initiallyOpened: !1
};
function HoverCard(props) {
  const { children, onOpen, onClose, openDelay, closeDelay, initiallyOpened, ...others } = useProps(
    "HoverCard",
    defaultProps$I,
    props
  ), [opened, { open, close }] = useDisclosure(initiallyOpened, { onClose, onOpen }), { openDropdown, closeDropdown } = useDelayedHover({ open, close, openDelay, closeDelay });
  return /* @__PURE__ */ jsx(HoverCardContextProvider, { value: { openDropdown, closeDropdown }, children: /* @__PURE__ */ jsx(Popover, { ...others, opened, __staticSelector: "HoverCard", children }) });
}
HoverCard.displayName = "@mantine/core/HoverCard";
HoverCard.Target = HoverCardTarget;
HoverCard.Dropdown = HoverCardDropdown;
HoverCard.extend = (input) => input;
var __default__$g = { root: "m_9e117634" };
const classes$g = __default__$g, defaultProps$H = {}, varsResolver$f = (_, { radius, fit }) => ({
  root: {
    "--image-radius": radius === void 0 ? void 0 : getRadius(radius),
    "--image-object-fit": fit
  }
}), Image = polymorphicFactory((_props, ref) => {
  const props = useProps("Image", defaultProps$H, _props), {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    onError,
    src,
    radius,
    fit,
    fallbackSrc,
    mod,
    ...others
  } = props, [error, setError] = useState(!src);
  useEffect(() => setError(!src), [src]);
  const getStyles2 = useStyles({
    name: "Image",
    classes: classes$g,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$f
  });
  return error && fallbackSrc ? /* @__PURE__ */ jsx(
    Box,
    {
      component: "img",
      ref,
      src: fallbackSrc,
      ...getStyles2("root"),
      onError,
      mod: ["fallback", mod],
      ...others
    }
  ) : /* @__PURE__ */ jsx(
    Box,
    {
      component: "img",
      ref,
      ...getStyles2("root"),
      src,
      onError: (event) => {
        onError?.(event), setError(!0);
      },
      mod,
      ...others
    }
  );
});
Image.classes = classes$g;
Image.displayName = "@mantine/core/Image";
var __default__$f = { root: "m_6e45937b", loader: "m_e8eb006c", overlay: "m_df587f17" };
const classes$f = __default__$f, defaultProps$G = {
  transitionProps: { transition: "fade", duration: 0 },
  overlayProps: { backgroundOpacity: 0.75 },
  zIndex: getDefaultZIndex("overlay")
}, varsResolver$e = (_, { zIndex }) => ({
  root: {
    "--lo-z-index": zIndex?.toString()
  }
}), LoadingOverlay = factory((_props, ref) => {
  const props = useProps("LoadingOverlay", defaultProps$G, _props), {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    transitionProps,
    loaderProps,
    overlayProps,
    visible: visible2,
    zIndex,
    ...others
  } = props, theme = useMantineTheme(), getStyles2 = useStyles({
    name: "LoadingOverlay",
    classes: classes$f,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$e
  }), _overlayProps = { ...defaultProps$G.overlayProps, ...overlayProps };
  return /* @__PURE__ */ jsx(Transition, { transition: "fade", ...transitionProps, mounted: !!visible2, children: (transitionStyles) => /* @__PURE__ */ jsxs(Box, { ...getStyles2("root", { style: transitionStyles }), ref, ...others, children: [
    /* @__PURE__ */ jsx(Loader, { ...getStyles2("loader"), unstyled, ...loaderProps }),
    /* @__PURE__ */ jsx(
      Overlay,
      {
        ..._overlayProps,
        ...getStyles2("overlay"),
        darkHidden: !0,
        unstyled,
        color: overlayProps?.color || theme.white
      }
    ),
    /* @__PURE__ */ jsx(
      Overlay,
      {
        ..._overlayProps,
        ...getStyles2("overlay"),
        lightHidden: !0,
        unstyled,
        color: overlayProps?.color || theme.colors.dark[5]
      }
    )
  ] }) });
});
LoadingOverlay.classes = classes$f;
LoadingOverlay.displayName = "@mantine/core/LoadingOverlay";
const [MenuContextProvider, useMenuContext] = createSafeContext(
  "Menu component was not found in the tree"
);
var __default__$e = { dropdown: "m_dc9b7c9f", label: "m_9bfac126", divider: "m_efdf90cb", item: "m_99ac2aa1", itemLabel: "m_5476e0d3", itemSection: "m_8b75e504" };
const classes$e = __default__$e, defaultProps$F = {}, MenuDivider = factory((props, ref) => {
  const { classNames, className, style, styles, vars, ...others } = useProps(
    "MenuDivider",
    defaultProps$F,
    props
  ), ctx = useMenuContext();
  return /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      ...ctx.getStyles("divider", { className, style, styles, classNames }),
      ...others
    }
  );
});
MenuDivider.classes = classes$e;
MenuDivider.displayName = "@mantine/core/MenuDivider";
const defaultProps$E = {}, MenuDropdown = factory((props, ref) => {
  const {
    classNames,
    className,
    style,
    styles,
    vars,
    onMouseEnter,
    onMouseLeave,
    onKeyDown,
    children,
    ...others
  } = useProps("MenuDropdown", defaultProps$E, props), wrapperRef = useRef(null), ctx = useMenuContext(), handleKeyDown = createEventHandler(onKeyDown, (event) => {
    (event.key === "ArrowUp" || event.key === "ArrowDown") && (event.preventDefault(), wrapperRef.current?.querySelectorAll("[data-menu-item]:not(:disabled)")[0]?.focus());
  }), handleMouseEnter = createEventHandler(
    onMouseEnter,
    () => (ctx.trigger === "hover" || ctx.trigger === "click-hover") && ctx.openDropdown()
  ), handleMouseLeave = createEventHandler(
    onMouseLeave,
    () => (ctx.trigger === "hover" || ctx.trigger === "click-hover") && ctx.closeDropdown()
  );
  return /* @__PURE__ */ jsxs(
    Popover.Dropdown,
    {
      ...others,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      role: "menu",
      "aria-orientation": "vertical",
      ref: useMergedRef(ref, wrapperRef),
      ...ctx.getStyles("dropdown", {
        className,
        style,
        styles,
        classNames,
        withStaticClass: !1
      }),
      tabIndex: -1,
      "data-menu-dropdown": !0,
      onKeyDown: handleKeyDown,
      children: [
        /* @__PURE__ */ jsx("div", { tabIndex: -1, "data-autofocus": !0, "data-mantine-stop-propagation": !0, style: { outline: 0 } }),
        children
      ]
    }
  );
});
MenuDropdown.classes = classes$e;
MenuDropdown.displayName = "@mantine/core/MenuDropdown";
const defaultProps$D = {}, MenuItem = polymorphicFactory((props, ref) => {
  const {
    classNames,
    className,
    style,
    styles,
    vars,
    color,
    closeMenuOnClick,
    leftSection,
    rightSection,
    children,
    disabled,
    ...others
  } = useProps("MenuItem", defaultProps$D, props), ctx = useMenuContext(), theme = useMantineTheme(), { dir } = useDirection(), itemRef = useRef(), itemIndex = ctx.getItemIndex(itemRef.current), _others = others, handleMouseLeave = createEventHandler(_others.onMouseLeave, () => ctx.setHovered(-1)), handleMouseEnter = createEventHandler(
    _others.onMouseEnter,
    () => ctx.setHovered(ctx.getItemIndex(itemRef.current))
  ), handleClick = createEventHandler(_others.onClick, () => {
    typeof closeMenuOnClick == "boolean" ? closeMenuOnClick && ctx.closeDropdownImmediately() : ctx.closeOnItemClick && ctx.closeDropdownImmediately();
  }), handleFocus = createEventHandler(
    _others.onFocus,
    () => ctx.setHovered(ctx.getItemIndex(itemRef.current))
  ), colors = color ? theme.variantColorResolver({ color, theme, variant: "light" }) : void 0, parsedThemeColor = color ? parseThemeColor({ color, theme }) : null;
  return /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      ...others,
      unstyled: ctx.unstyled,
      tabIndex: ctx.menuItemTabIndex,
      onFocus: handleFocus,
      ...ctx.getStyles("item", { className, style, styles, classNames }),
      ref: useMergedRef(itemRef, ref),
      role: "menuitem",
      disabled,
      "data-menu-item": !0,
      "data-disabled": disabled || void 0,
      "data-hovered": ctx.hovered === itemIndex ? !0 : void 0,
      "data-mantine-stop-propagation": !0,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      onClick: handleClick,
      onKeyDown: createScopedKeydownHandler({
        siblingSelector: "[data-menu-item]",
        parentSelector: "[data-menu-dropdown]",
        activateOnFocus: !1,
        loop: ctx.loop,
        dir,
        orientation: "vertical",
        onKeyDown: _others.onKeyDown
      }),
      __vars: {
        "--menu-item-color": parsedThemeColor?.isThemeColor && parsedThemeColor?.shade === void 0 ? `var(--mantine-color-${parsedThemeColor.color}-6)` : colors?.color,
        "--menu-item-hover": colors?.hover
      },
      children: [
        leftSection && /* @__PURE__ */ jsx("div", { ...ctx.getStyles("itemSection", { styles, classNames }), "data-position": "left", children: leftSection }),
        children && /* @__PURE__ */ jsx("div", { ...ctx.getStyles("itemLabel", { styles, classNames }), children }),
        rightSection && /* @__PURE__ */ jsx("div", { ...ctx.getStyles("itemSection", { styles, classNames }), "data-position": "right", children: rightSection })
      ]
    }
  );
});
MenuItem.classes = classes$e;
MenuItem.displayName = "@mantine/core/MenuItem";
const defaultProps$C = {}, MenuLabel = factory((props, ref) => {
  const { classNames, className, style, styles, vars, ...others } = useProps(
    "MenuLabel",
    defaultProps$C,
    props
  ), ctx = useMenuContext();
  return /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      ...ctx.getStyles("label", { className, style, styles, classNames }),
      ...others
    }
  );
});
MenuLabel.classes = classes$e;
MenuLabel.displayName = "@mantine/core/MenuLabel";
const defaultProps$B = {
  refProp: "ref"
}, MenuTarget = forwardRef((props, ref) => {
  const { children, refProp, ...others } = useProps("MenuTarget", defaultProps$B, props);
  if (!isElement$1(children))
    throw new Error(
      "Menu.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  const ctx = useMenuContext(), onClick = createEventHandler(children.props.onClick, () => {
    ctx.trigger === "click" ? ctx.toggleDropdown() : ctx.trigger === "click-hover" && (ctx.setOpenedViaClick(!0), ctx.opened || ctx.openDropdown());
  }), onMouseEnter = createEventHandler(
    children.props.onMouseEnter,
    () => (ctx.trigger === "hover" || ctx.trigger === "click-hover") && ctx.openDropdown()
  ), onMouseLeave = createEventHandler(children.props.onMouseLeave, () => {
    (ctx.trigger === "hover" || ctx.trigger === "click-hover" && !ctx.openedViaClick) && ctx.closeDropdown();
  });
  return /* @__PURE__ */ jsx(Popover.Target, { refProp, popupType: "menu", ref, ...others, children: cloneElement(children, {
    onClick,
    onMouseEnter,
    onMouseLeave,
    "data-expanded": ctx.opened ? !0 : void 0
  }) });
});
MenuTarget.displayName = "@mantine/core/MenuTarget";
const defaultProps$A = {
  trapFocus: !0,
  closeOnItemClick: !0,
  clickOutsideEvents: ["mousedown", "touchstart", "keydown"],
  loop: !0,
  trigger: "click",
  openDelay: 0,
  closeDelay: 100,
  menuItemTabIndex: -1
};
function Menu(_props) {
  const props = useProps("Menu", defaultProps$A, _props), {
    children,
    onOpen,
    onClose,
    opened,
    defaultOpened,
    trapFocus,
    onChange,
    closeOnItemClick,
    loop,
    closeOnEscape: closeOnEscape2,
    trigger,
    openDelay,
    closeDelay,
    classNames,
    styles,
    unstyled,
    variant,
    vars,
    menuItemTabIndex,
    keepMounted,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Menu",
    classes: classes$e,
    props,
    classNames,
    styles,
    unstyled
  }), [hovered, { setHovered, resetHovered }] = useHovered(), [_opened, setOpened] = useUncontrolled({
    value: opened,
    defaultValue: defaultOpened,
    finalValue: !1,
    onChange
  }), [openedViaClick, setOpenedViaClick] = useState(!1), close = () => {
    setOpened(!1), setOpenedViaClick(!1), _opened && onClose?.();
  }, open = () => {
    setOpened(!0), !_opened && onOpen?.();
  }, toggleDropdown = () => {
    _opened ? close() : open();
  }, { openDropdown, closeDropdown } = useDelayedHover({ open, close, closeDelay, openDelay }), getItemIndex = (node) => getContextItemIndex("[data-menu-item]", "[data-menu-dropdown]", node), { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    classNames,
    styles,
    props
  });
  return useDidUpdate(() => {
    resetHovered();
  }, [_opened]), /* @__PURE__ */ jsx(
    MenuContextProvider,
    {
      value: {
        getStyles: getStyles2,
        opened: _opened,
        toggleDropdown,
        getItemIndex,
        hovered,
        setHovered,
        openedViaClick,
        setOpenedViaClick,
        closeOnItemClick,
        closeDropdown: trigger === "click" ? close : closeDropdown,
        openDropdown: trigger === "click" ? open : openDropdown,
        closeDropdownImmediately: close,
        loop,
        trigger,
        unstyled,
        menuItemTabIndex
      },
      children: /* @__PURE__ */ jsx(
        Popover,
        {
          ...others,
          opened: _opened,
          onChange: toggleDropdown,
          defaultOpened,
          trapFocus: keepMounted ? !1 : trapFocus,
          closeOnEscape: closeOnEscape2,
          __staticSelector: "Menu",
          classNames: resolvedClassNames,
          styles: resolvedStyles,
          unstyled,
          variant,
          keepMounted,
          children
        }
      )
    }
  );
}
Menu.extend = (input) => input;
Menu.classes = classes$e;
Menu.displayName = "@mantine/core/Menu";
Menu.Item = MenuItem;
Menu.Label = MenuLabel;
Menu.Dropdown = MenuDropdown;
Menu.Target = MenuTarget;
Menu.Divider = MenuDivider;
const [ModalProvider, useModalContext] = createSafeContext(
  "Modal component was not found in tree"
);
var __default__$d = { root: "m_9df02822", content: "m_54c44539", inner: "m_1f958f16", header: "m_d0e2b9cd" };
const classes$d = __default__$d, defaultProps$z = {}, ModalBody = factory((_props, ref) => {
  const props = useProps("ModalBody", defaultProps$z, _props), { classNames, className, style, styles, vars, ...others } = props, ctx = useModalContext();
  return /* @__PURE__ */ jsx(
    ModalBaseBody,
    {
      ref,
      ...ctx.getStyles("body", { classNames, style, styles, className }),
      ...others
    }
  );
});
ModalBody.classes = classes$d;
ModalBody.displayName = "@mantine/core/ModalBody";
const defaultProps$y = {}, ModalCloseButton = factory((_props, ref) => {
  const props = useProps("ModalCloseButton", defaultProps$y, _props), { classNames, className, style, styles, vars, ...others } = props, ctx = useModalContext();
  return /* @__PURE__ */ jsx(
    ModalBaseCloseButton,
    {
      ref,
      ...ctx.getStyles("close", { classNames, style, styles, className }),
      ...others
    }
  );
});
ModalCloseButton.classes = classes$d;
ModalCloseButton.displayName = "@mantine/core/ModalCloseButton";
const defaultProps$x = {}, ModalContent = factory((_props, ref) => {
  const props = useProps("ModalContent", defaultProps$x, _props), { classNames, className, style, styles, vars, children, __hidden, ...others } = props, ctx = useModalContext(), Scroll = ctx.scrollAreaComponent || NativeScrollArea;
  return /* @__PURE__ */ jsx(
    ModalBaseContent,
    {
      ...ctx.getStyles("content", { className, style, styles, classNames }),
      innerProps: ctx.getStyles("inner", { className, style, styles, classNames }),
      "data-full-screen": ctx.fullScreen || void 0,
      "data-modal-content": !0,
      "data-hidden": __hidden || void 0,
      ref,
      ...others,
      children: /* @__PURE__ */ jsx(
        Scroll,
        {
          style: {
            maxHeight: ctx.fullScreen ? "100dvh" : `calc(100dvh - (${rem(ctx.yOffset)} * 2))`
          },
          children
        }
      )
    }
  );
});
ModalContent.classes = classes$d;
ModalContent.displayName = "@mantine/core/ModalContent";
const defaultProps$w = {}, ModalHeader = factory((_props, ref) => {
  const props = useProps("ModalHeader", defaultProps$w, _props), { classNames, className, style, styles, vars, ...others } = props, ctx = useModalContext();
  return /* @__PURE__ */ jsx(
    ModalBaseHeader,
    {
      ref,
      ...ctx.getStyles("header", { classNames, style, styles, className }),
      ...others
    }
  );
});
ModalHeader.classes = classes$d;
ModalHeader.displayName = "@mantine/core/ModalHeader";
const defaultProps$v = {}, ModalOverlay = factory((_props, ref) => {
  const props = useProps("ModalOverlay", defaultProps$v, _props), { classNames, className, style, styles, vars, ...others } = props, ctx = useModalContext();
  return /* @__PURE__ */ jsx(
    ModalBaseOverlay,
    {
      ref,
      ...ctx.getStyles("overlay", { classNames, style, styles, className }),
      ...others
    }
  );
});
ModalOverlay.classes = classes$d;
ModalOverlay.displayName = "@mantine/core/ModalOverlay";
const defaultProps$u = {
  __staticSelector: "Modal",
  closeOnClickOutside: !0,
  withinPortal: !0,
  lockScroll: !0,
  trapFocus: !0,
  returnFocus: !0,
  closeOnEscape: !0,
  keepMounted: !1,
  zIndex: getDefaultZIndex("modal"),
  transitionProps: { duration: 200, transition: "fade-down" },
  yOffset: "5dvh"
}, varsResolver$d = (_, { radius, size: size2, yOffset, xOffset }) => ({
  root: {
    "--modal-radius": radius === void 0 ? void 0 : getRadius(radius),
    "--modal-size": getSize(size2, "modal-size"),
    "--modal-y-offset": rem(yOffset),
    "--modal-x-offset": rem(xOffset)
  }
}), ModalRoot = factory((_props, ref) => {
  const props = useProps("ModalRoot", defaultProps$u, _props), {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    yOffset,
    scrollAreaComponent,
    radius,
    fullScreen,
    centered,
    xOffset,
    __staticSelector,
    ...others
  } = props, getStyles2 = useStyles({
    name: __staticSelector,
    classes: classes$d,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$d
  });
  return /* @__PURE__ */ jsx(ModalProvider, { value: { yOffset, scrollAreaComponent, getStyles: getStyles2, fullScreen }, children: /* @__PURE__ */ jsx(
    ModalBase,
    {
      ref,
      ...getStyles2("root"),
      "data-full-screen": fullScreen || void 0,
      "data-centered": centered || void 0,
      unstyled,
      ...others
    }
  ) });
});
ModalRoot.classes = classes$d;
ModalRoot.displayName = "@mantine/core/ModalRoot";
const [ModalStackProvider, useModalStackContext] = createOptionalContext();
function ModalStack({ children }) {
  const [stack, setStack] = useState([]), [maxZIndex, setMaxZIndex] = useState(getDefaultZIndex("modal"));
  return /* @__PURE__ */ jsx(
    ModalStackProvider,
    {
      value: {
        stack,
        addModal: (id, zIndex) => {
          setStack((current) => [.../* @__PURE__ */ new Set([...current, id])]), setMaxZIndex(
            (current) => typeof zIndex == "number" && typeof current == "number" ? Math.max(current, zIndex) : current
          );
        },
        removeModal: (id) => setStack((current) => current.filter((currentId) => currentId !== id)),
        getZIndex: (id) => `calc(${maxZIndex} + ${stack.indexOf(id)} + 1)`,
        currentId: stack[stack.length - 1],
        maxZIndex
      },
      children
    }
  );
}
ModalStack.displayName = "@mantine/core/ModalStack";
const defaultProps$t = {}, ModalTitle = factory((_props, ref) => {
  const props = useProps("ModalTitle", defaultProps$t, _props), { classNames, className, style, styles, vars, ...others } = props, ctx = useModalContext();
  return /* @__PURE__ */ jsx(
    ModalBaseTitle,
    {
      ref,
      ...ctx.getStyles("title", { classNames, style, styles, className }),
      ...others
    }
  );
});
ModalTitle.classes = classes$d;
ModalTitle.displayName = "@mantine/core/ModalTitle";
const defaultProps$s = {
  closeOnClickOutside: !0,
  withinPortal: !0,
  lockScroll: !0,
  trapFocus: !0,
  returnFocus: !0,
  closeOnEscape: !0,
  keepMounted: !1,
  zIndex: getDefaultZIndex("modal"),
  transitionProps: { duration: 200, transition: "fade-down" },
  withOverlay: !0,
  withCloseButton: !0
}, Modal = factory((_props, ref) => {
  const {
    title,
    withOverlay,
    overlayProps,
    withCloseButton,
    closeButtonProps,
    children,
    radius,
    opened,
    stackId,
    zIndex,
    ...others
  } = useProps("Modal", defaultProps$s, _props), ctx = useModalStackContext(), hasHeader = !!title || withCloseButton, stackProps = ctx && stackId ? {
    closeOnEscape: ctx.currentId === stackId,
    trapFocus: ctx.currentId === stackId,
    zIndex: ctx.getZIndex(stackId)
  } : {}, overlayVisible = withOverlay === !1 ? !1 : stackId && ctx ? ctx.currentId === stackId : opened;
  return useEffect(() => {
    ctx && stackId && (opened ? ctx.addModal(stackId, zIndex || getDefaultZIndex("modal")) : ctx.removeModal(stackId));
  }, [opened, stackId, zIndex]), /* @__PURE__ */ jsxs(
    ModalRoot,
    {
      ref,
      radius,
      opened,
      zIndex: ctx && stackId ? ctx.getZIndex(stackId) : zIndex,
      ...others,
      ...stackProps,
      children: [
        withOverlay && /* @__PURE__ */ jsx(
          ModalOverlay,
          {
            visible: overlayVisible,
            transitionProps: ctx && stackId ? { duration: 0 } : void 0,
            ...overlayProps
          }
        ),
        /* @__PURE__ */ jsxs(
          ModalContent,
          {
            radius,
            __hidden: ctx && stackId && opened ? stackId !== ctx.currentId : !1,
            children: [
              hasHeader && /* @__PURE__ */ jsxs(ModalHeader, { children: [
                title && /* @__PURE__ */ jsx(ModalTitle, { children: title }),
                withCloseButton && /* @__PURE__ */ jsx(ModalCloseButton, { ...closeButtonProps })
              ] }),
              /* @__PURE__ */ jsx(ModalBody, { children })
            ]
          }
        )
      ]
    }
  );
});
Modal.classes = classes$d;
Modal.displayName = "@mantine/core/Modal";
Modal.Root = ModalRoot;
Modal.Overlay = ModalOverlay;
Modal.Content = ModalContent;
Modal.Body = ModalBody;
Modal.Header = ModalHeader;
Modal.Title = ModalTitle;
Modal.CloseButton = ModalCloseButton;
Modal.Stack = ModalStack;
const [PillsInputProvider, usePillsInputContext] = createOptionalContext(), [PillGroupProvider, usePillGroupContext] = createOptionalContext();
var __default__$c = { root: "m_7cda1cd6", "root--default": "m_44da308b", "root--contrast": "m_e3a01f8", label: "m_1e0e6180", remove: "m_ae386778", group: "m_1dcfd90b" };
const classes$c = __default__$c, defaultProps$r = {}, varsResolver$c = (_, { gap }, { size: size2 }) => ({
  group: {
    "--pg-gap": gap !== void 0 ? getSize(gap) : getSize(size2, "pg-gap")
  }
}), PillGroup = factory((_props, ref) => {
  const props = useProps("PillGroup", defaultProps$r, _props), { classNames, className, style, styles, unstyled, vars, size: size2, disabled, ...others } = props, _size = usePillsInputContext()?.size || size2 || void 0, getStyles2 = useStyles({
    name: "PillGroup",
    classes: classes$c,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$c,
    stylesCtx: { size: _size },
    rootSelector: "group"
  });
  return /* @__PURE__ */ jsx(PillGroupProvider, { value: { size: _size, disabled }, children: /* @__PURE__ */ jsx(Box, { ref, size: _size, ...getStyles2("group"), ...others }) });
});
PillGroup.classes = classes$c;
PillGroup.displayName = "@mantine/core/PillGroup";
const defaultProps$q = {
  variant: "default"
}, varsResolver$b = (_, { radius }, { size: size2 }) => ({
  root: {
    "--pill-fz": getSize(size2, "pill-fz"),
    "--pill-height": getSize(size2, "pill-height"),
    "--pill-radius": radius === void 0 ? void 0 : getRadius(radius)
  }
}), Pill = factory((_props, ref) => {
  const props = useProps("Pill", defaultProps$q, _props), {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    variant,
    children,
    withRemoveButton,
    onRemove,
    removeButtonProps,
    radius,
    size: size2,
    disabled,
    mod,
    ...others
  } = props, ctx = usePillGroupContext(), pillsInputCtx = usePillsInputContext(), _size = size2 || ctx?.size || void 0, _variant = pillsInputCtx?.variant === "filled" ? "contrast" : variant || "default", getStyles2 = useStyles({
    name: "Pill",
    classes: classes$c,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$b,
    stylesCtx: { size: _size }
  });
  return /* @__PURE__ */ jsxs(
    Box,
    {
      component: "span",
      ref,
      variant: _variant,
      size: _size,
      ...getStyles2("root", { variant: _variant }),
      mod: [
        { "with-remove": withRemoveButton && !disabled, disabled: disabled || ctx?.disabled },
        mod
      ],
      ...others,
      children: [
        /* @__PURE__ */ jsx("span", { ...getStyles2("label"), children }),
        withRemoveButton && /* @__PURE__ */ jsx(
          CloseButton,
          {
            variant: "transparent",
            radius,
            tabIndex: -1,
            "aria-hidden": !0,
            unstyled,
            ...removeButtonProps,
            ...getStyles2("remove", {
              className: removeButtonProps?.className,
              style: removeButtonProps?.style
            }),
            onMouseDown: (event) => {
              event.preventDefault(), event.stopPropagation(), removeButtonProps?.onMouseDown?.(event);
            },
            onClick: (event) => {
              event.stopPropagation(), onRemove?.(), removeButtonProps?.onClick?.(event);
            }
          }
        )
      ]
    }
  );
});
Pill.classes = classes$c;
Pill.displayName = "@mantine/core/Pill";
Pill.Group = PillGroup;
var __default__$b = { root: "m_a513464", icon: "m_a4ceffb", loader: "m_b0920b15", body: "m_a49ed24", title: "m_3feedf16", description: "m_3d733a3a", closeButton: "m_919a4d88" };
const classes$b = __default__$b, defaultProps$p = {
  withCloseButton: !0
}, varsResolver$a = (theme, { radius, color }) => ({
  root: {
    "--notification-radius": radius === void 0 ? void 0 : getRadius(radius),
    "--notification-color": color ? getThemeColor(color, theme) : void 0
  }
}), Notification = factory((_props, ref) => {
  const props = useProps("Notification", defaultProps$p, _props), {
    className,
    color,
    radius,
    loading,
    withCloseButton,
    withBorder,
    title,
    icon,
    children,
    onClose,
    closeButtonProps,
    classNames,
    style,
    styles,
    unstyled,
    variant,
    vars,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Notification",
    classes: classes$b,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$a
  });
  return /* @__PURE__ */ jsxs(
    Box,
    {
      ...getStyles2("root"),
      mod: [{ "data-with-icon": !!icon || loading, "data-with-border": withBorder }, mod],
      ref,
      variant,
      ...others,
      role: "alert",
      children: [
        icon && !loading && /* @__PURE__ */ jsx("div", { ...getStyles2("icon"), children: icon }),
        loading && /* @__PURE__ */ jsx(Loader, { size: 28, color, ...getStyles2("loader") }),
        /* @__PURE__ */ jsxs("div", { ...getStyles2("body"), children: [
          title && /* @__PURE__ */ jsx("div", { ...getStyles2("title"), children: title }),
          /* @__PURE__ */ jsx(Box, { ...getStyles2("description"), mod: { "data-with-title": !!title }, children })
        ] }),
        withCloseButton && /* @__PURE__ */ jsx(
          CloseButton,
          {
            iconSize: 16,
            color: "gray",
            ...closeButtonProps,
            unstyled,
            onClick: onClose,
            ...getStyles2("closeButton")
          }
        )
      ]
    }
  );
});
Notification.classes = classes$b;
Notification.displayName = "@mantine/core/Notification";
const defaultTransition = {
  duration: 100,
  transition: "fade"
};
function getTransitionProps(transitionProps, componentTransition) {
  return { ...defaultTransition, ...componentTransition, ...transitionProps };
}
function useFloatingTooltip({
  offset: offset2,
  position,
  defaultOpened
}) {
  const [opened, setOpened] = useState(defaultOpened), boundaryRef = useRef(), { x, y, elements, refs, update, placement } = useFloating({
    placement: position,
    middleware: [
      shift({
        crossAxis: !0,
        padding: 5,
        rootBoundary: "document"
      })
    ]
  }), horizontalOffset = placement.includes("right") ? offset2 : position.includes("left") ? offset2 * -1 : 0, verticalOffset = placement.includes("bottom") ? offset2 : position.includes("top") ? offset2 * -1 : 0, handleMouseMove = useCallback(
    ({ clientX, clientY }) => {
      refs.setPositionReference({
        getBoundingClientRect() {
          return {
            width: 0,
            height: 0,
            x: clientX,
            y: clientY,
            left: clientX + horizontalOffset,
            top: clientY + verticalOffset,
            right: clientX,
            bottom: clientY
          };
        }
      });
    },
    [elements.reference]
  );
  return useEffect(() => {
    if (refs.floating.current) {
      const boundary = boundaryRef.current;
      boundary.addEventListener("mousemove", handleMouseMove);
      const parents = getOverflowAncestors(refs.floating.current);
      return parents.forEach((parent) => {
        parent.addEventListener("scroll", update);
      }), () => {
        boundary.removeEventListener("mousemove", handleMouseMove), parents.forEach((parent) => {
          parent.removeEventListener("scroll", update);
        });
      };
    }
  }, [elements.reference, refs.floating.current, update, handleMouseMove, opened]), { handleMouseMove, x, y, opened, setOpened, boundaryRef, floating: refs.setFloating };
}
var __default__$a = { tooltip: "m_1b3c8819", arrow: "m_f898399f" };
const classes$a = __default__$a, defaultProps$o = {
  refProp: "ref",
  withinPortal: !0,
  offset: 10,
  defaultOpened: !1,
  position: "right",
  zIndex: getDefaultZIndex("popover")
}, varsResolver$9 = (theme, { radius, color }) => ({
  tooltip: {
    "--tooltip-radius": radius === void 0 ? void 0 : getRadius(radius),
    "--tooltip-bg": color ? getThemeColor(color, theme) : void 0,
    "--tooltip-color": color ? "var(--mantine-color-white)" : void 0
  }
}), TooltipFloating = factory((_props, ref) => {
  const props = useProps("TooltipFloating", defaultProps$o, _props), {
    children,
    refProp,
    withinPortal,
    style,
    className,
    classNames,
    styles,
    unstyled,
    radius,
    color,
    label,
    offset: offset2,
    position,
    multiline,
    zIndex,
    disabled,
    defaultOpened,
    variant,
    vars,
    portalProps,
    ...others
  } = props, theme = useMantineTheme(), getStyles2 = useStyles({
    name: "TooltipFloating",
    props,
    classes: classes$a,
    className,
    style,
    classNames,
    styles,
    unstyled,
    rootSelector: "tooltip",
    vars,
    varsResolver: varsResolver$9
  }), { handleMouseMove, x, y, opened, boundaryRef, floating, setOpened } = useFloatingTooltip({
    offset: offset2,
    position,
    defaultOpened
  });
  if (!isElement$1(children))
    throw new Error(
      "[@mantine/core] Tooltip.Floating component children should be an element or a component that accepts ref, fragments, strings, numbers and other primitive values are not supported"
    );
  const targetRef = useMergedRef(boundaryRef, getRefProp(children), ref), onMouseEnter = (event) => {
    children.props.onMouseEnter?.(event), handleMouseMove(event), setOpened(!0);
  }, onMouseLeave = (event) => {
    children.props.onMouseLeave?.(event), setOpened(!1);
  };
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(OptionalPortal, { ...portalProps, withinPortal, children: /* @__PURE__ */ jsx(
      Box,
      {
        ...others,
        ...getStyles2("tooltip", {
          style: {
            ...getStyleObject(style, theme),
            zIndex,
            display: !disabled && opened ? "block" : "none",
            top: (y && Math.round(y)) ?? "",
            left: (x && Math.round(x)) ?? ""
          }
        }),
        variant,
        ref: floating,
        mod: { multiline },
        children: label
      }
    ) }),
    cloneElement(children, {
      ...children.props,
      [refProp]: targetRef,
      onMouseEnter,
      onMouseLeave
    })
  ] });
});
TooltipFloating.classes = classes$a;
TooltipFloating.displayName = "@mantine/core/TooltipFloating";
const TooltipGroupContext = createContext(!1), TooltipGroupProvider = TooltipGroupContext.Provider, useTooltipGroupContext = () => useContext(TooltipGroupContext), defaultProps$n = {
  openDelay: 0,
  closeDelay: 0
};
function TooltipGroup(props) {
  const { openDelay, closeDelay, children } = useProps("TooltipGroup", defaultProps$n, props);
  return /* @__PURE__ */ jsx(TooltipGroupProvider, { value: !0, children: /* @__PURE__ */ jsx(FloatingDelayGroup, { delay: { open: openDelay, close: closeDelay }, children }) });
}
TooltipGroup.displayName = "@mantine/core/TooltipGroup";
TooltipGroup.extend = (c) => c;
function useTooltip(settings) {
  const [uncontrolledOpened, setUncontrolledOpened] = useState(settings.defaultOpened), opened = typeof settings.opened == "boolean" ? settings.opened : uncontrolledOpened, withinGroup = useTooltipGroupContext(), uid = useId$1(), { delay: groupDelay, currentId, setCurrentId } = useDelayGroupContext(), onChange = useCallback(
    (_opened) => {
      setUncontrolledOpened(_opened), _opened && setCurrentId(uid);
    },
    [setCurrentId, uid]
  ), {
    x,
    y,
    context,
    refs,
    update,
    placement,
    middlewareData: { arrow: { x: arrowX, y: arrowY } = {} }
  } = useFloating({
    strategy: settings.strategy,
    placement: settings.position,
    open: opened,
    onOpenChange: onChange,
    middleware: [
      offset(settings.offset),
      shift({ padding: 8 }),
      flip(),
      arrow({ element: settings.arrowRef, padding: settings.arrowOffset }),
      ...settings.inline ? [inline()] : []
    ]
  });
  useDelayGroup(context, { id: uid });
  const { getReferenceProps, getFloatingProps } = useInteractions([
    useHover(context, {
      enabled: settings.events?.hover,
      delay: withinGroup ? groupDelay : { open: settings.openDelay, close: settings.closeDelay },
      mouseOnly: !settings.events?.touch
    }),
    useFocus(context, { enabled: settings.events?.focus, visibleOnly: !0 }),
    useRole(context, { role: "tooltip" }),
    // Cannot be used with controlled tooltip, page jumps
    useDismiss(context, { enabled: typeof settings.opened > "u" })
  ]);
  useFloatingAutoUpdate({
    opened,
    position: settings.position,
    positionDependencies: settings.positionDependencies,
    floating: { refs, update }
  }), useDidUpdate(() => {
    settings.onPositionChange?.(placement);
  }, [placement]);
  const isGroupPhase = opened && currentId && currentId !== uid;
  return {
    x,
    y,
    arrowX,
    arrowY,
    reference: refs.setReference,
    floating: refs.setFloating,
    getFloatingProps,
    getReferenceProps,
    isGroupPhase,
    opened,
    placement
  };
}
const defaultProps$m = {
  position: "top",
  refProp: "ref",
  withinPortal: !0,
  inline: !1,
  defaultOpened: !1,
  arrowSize: 4,
  arrowOffset: 5,
  arrowRadius: 0,
  arrowPosition: "side",
  offset: 5,
  transitionProps: { duration: 100, transition: "fade" },
  events: { hover: !0, focus: !1, touch: !1 },
  zIndex: getDefaultZIndex("popover"),
  positionDependencies: []
}, varsResolver$8 = (theme, { radius, color }) => ({
  tooltip: {
    "--tooltip-radius": radius === void 0 ? void 0 : getRadius(radius),
    "--tooltip-bg": color ? getThemeColor(color, theme) : void 0,
    "--tooltip-color": color ? "var(--mantine-color-white)" : void 0
  }
}), Tooltip = factory((_props, ref) => {
  const props = useProps("Tooltip", defaultProps$m, _props), {
    children,
    position,
    refProp,
    label,
    openDelay,
    closeDelay,
    onPositionChange,
    opened,
    defaultOpened,
    withinPortal,
    radius,
    color,
    classNames,
    styles,
    unstyled,
    style,
    className,
    withArrow,
    arrowSize,
    arrowOffset,
    arrowRadius,
    arrowPosition,
    offset: offset2,
    transitionProps,
    multiline,
    events,
    zIndex,
    disabled,
    positionDependencies,
    onClick,
    onMouseEnter,
    onMouseLeave,
    inline: inline2,
    variant,
    keepMounted,
    vars,
    portalProps,
    mod,
    floatingStrategy,
    ...others
  } = useProps("Tooltip", defaultProps$m, props), { dir } = useDirection(), arrowRef = useRef(null), tooltip = useTooltip({
    position: getFloatingPosition(dir, position),
    closeDelay,
    openDelay,
    onPositionChange,
    opened,
    defaultOpened,
    events,
    arrowRef,
    arrowOffset,
    offset: typeof offset2 == "number" ? offset2 + (withArrow ? arrowSize / 2 : 0) : offset2,
    positionDependencies: [...positionDependencies, children],
    inline: inline2,
    strategy: floatingStrategy
  }), getStyles2 = useStyles({
    name: "Tooltip",
    props,
    classes: classes$a,
    className,
    style,
    classNames,
    styles,
    unstyled,
    rootSelector: "tooltip",
    vars,
    varsResolver: varsResolver$8
  });
  if (!isElement$1(children))
    throw new Error(
      "[@mantine/core] Tooltip component children should be an element or a component that accepts ref, fragments, strings, numbers and other primitive values are not supported"
    );
  const targetRef = useMergedRef(tooltip.reference, getRefProp(children), ref), transition = getTransitionProps(transitionProps, { duration: 100, transition: "fade" });
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(OptionalPortal, { ...portalProps, withinPortal, children: /* @__PURE__ */ jsx(
      Transition,
      {
        ...transition,
        keepMounted,
        mounted: !disabled && !!tooltip.opened,
        duration: tooltip.isGroupPhase ? 10 : transition.duration,
        children: (transitionStyles) => /* @__PURE__ */ jsxs(
          Box,
          {
            ...others,
            "data-fixed": floatingStrategy === "fixed" || void 0,
            variant,
            mod: [{ multiline }, mod],
            ...tooltip.getFloatingProps({
              ref: tooltip.floating,
              className: getStyles2("tooltip").className,
              style: {
                ...getStyles2("tooltip").style,
                ...transitionStyles,
                zIndex,
                top: tooltip.y ?? 0,
                left: tooltip.x ?? 0
              }
            }),
            children: [
              label,
              /* @__PURE__ */ jsx(
                FloatingArrow,
                {
                  ref: arrowRef,
                  arrowX: tooltip.arrowX,
                  arrowY: tooltip.arrowY,
                  visible: withArrow,
                  position: tooltip.placement,
                  arrowSize,
                  arrowOffset,
                  arrowRadius,
                  arrowPosition,
                  ...getStyles2("arrow")
                }
              )
            ]
          }
        )
      }
    ) }),
    cloneElement(
      children,
      tooltip.getReferenceProps({
        onClick,
        onMouseEnter,
        onMouseLeave,
        onMouseMove: props.onMouseMove,
        onPointerDown: props.onPointerDown,
        onPointerEnter: props.onPointerEnter,
        [refProp]: targetRef,
        className: clsx(className, children.props.className),
        ...children.props
      })
    )
  ] });
});
Tooltip.classes = classes$a;
Tooltip.displayName = "@mantine/core/Tooltip";
Tooltip.Floating = TooltipFloating;
Tooltip.Group = TooltipGroup;
var __default__$9 = { root: "m_cf365364", indicator: "m_9e182ccd", label: "m_1738fcb2", input: "m_1714d588", control: "m_69686b9b", innerLabel: "m_78882f40" };
const classes$9 = __default__$9, defaultProps$l = {
  withItemsBorders: !0
}, varsResolver$7 = (theme, { radius, color, transitionDuration, size: size2, transitionTimingFunction }) => ({
  root: {
    "--sc-radius": radius === void 0 ? void 0 : getRadius(radius),
    "--sc-color": color ? getThemeColor(color, theme) : void 0,
    "--sc-shadow": color ? void 0 : "var(--mantine-shadow-xs)",
    "--sc-transition-duration": transitionDuration === void 0 ? void 0 : `${transitionDuration}ms`,
    "--sc-transition-timing-function": transitionTimingFunction,
    "--sc-padding": getSize(size2, "sc-padding"),
    "--sc-font-size": getFontSize(size2)
  }
}), SegmentedControl = factory((_props, ref) => {
  const props = useProps("SegmentedControl", defaultProps$l, _props), {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    data,
    value,
    defaultValue,
    onChange,
    size: size2,
    name,
    disabled,
    readOnly,
    fullWidth,
    orientation,
    radius,
    color,
    transitionDuration,
    transitionTimingFunction,
    variant,
    autoContrast,
    withItemsBorders,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: "SegmentedControl",
    props,
    classes: classes$9,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$7
  }), theme = useMantineTheme(), _data = data.map(
    (item) => typeof item == "string" ? { label: item, value: item } : item
  ), initialized = useMounted(), [parent, setParent] = useState(null), [refs, setRefs] = useState({}), setElementRef = (element, val) => {
    refs[val] = element, setRefs(refs);
  }, [_value, handleValueChange] = useUncontrolled({
    value,
    defaultValue,
    finalValue: Array.isArray(data) ? _data.find((item) => !item.disabled)?.value ?? data[0]?.value ?? null : null,
    onChange
  }), uuid = useId$1(name), controls = _data.map((item) => /* @__PURE__ */ createElement(
    Box,
    {
      ...getStyles2("control"),
      mod: { active: _value === item.value, orientation },
      key: item.value
    },
    /* @__PURE__ */ createElement(
      "input",
      {
        ...getStyles2("input"),
        disabled: disabled || item.disabled,
        type: "radio",
        name: uuid,
        value: item.value,
        id: `${uuid}-${item.value}`,
        checked: _value === item.value,
        onChange: () => !readOnly && handleValueChange(item.value),
        "data-focus-ring": theme.focusRing,
        key: `${item.value}-input`
      }
    ),
    /* @__PURE__ */ createElement(
      Box,
      {
        component: "label",
        ...getStyles2("label"),
        mod: {
          active: _value === item.value && !(disabled || item.disabled),
          disabled: disabled || item.disabled,
          "read-only": readOnly
        },
        htmlFor: `${uuid}-${item.value}`,
        ref: (node) => setElementRef(node, item.value),
        __vars: {
          "--sc-label-color": color !== void 0 ? getContrastColor({ color, theme, autoContrast }) : void 0
        },
        key: `${item.value}-label`
      },
      /* @__PURE__ */ jsx("span", { ...getStyles2("innerLabel"), children: item.label })
    )
  )), mergedRef = useMergedRef(ref, (node) => setParent(node));
  return data.length === 0 ? null : /* @__PURE__ */ jsxs(
    Box,
    {
      ...getStyles2("root"),
      variant,
      size: size2,
      ref: mergedRef,
      mod: [
        {
          "full-width": fullWidth,
          orientation,
          initialized,
          "with-items-borders": withItemsBorders
        },
        mod
      ],
      ...others,
      role: "radiogroup",
      "data-disabled": disabled,
      children: [
        typeof _value == "string" && /* @__PURE__ */ jsx(
          FloatingIndicator,
          {
            target: refs[_value],
            parent,
            component: "span",
            transitionDuration: "var(--sc-transition-duration)",
            ...getStyles2("indicator")
          }
        ),
        controls
      ]
    }
  );
});
SegmentedControl.classes = classes$9;
SegmentedControl.displayName = "@mantine/core/SegmentedControl";
const defaultProps$k = {
  searchable: !1,
  withCheckIcon: !0,
  allowDeselect: !0,
  checkIconPosition: "left"
}, Select = factory((_props, ref) => {
  const props = useProps("Select", defaultProps$k, _props), {
    classNames,
    styles,
    unstyled,
    vars,
    dropdownOpened,
    defaultDropdownOpened,
    onDropdownClose,
    onDropdownOpen,
    onFocus,
    onBlur,
    onClick,
    onChange,
    data,
    value,
    defaultValue,
    selectFirstOptionOnChange,
    onOptionSubmit,
    comboboxProps,
    readOnly,
    disabled,
    filter,
    limit,
    withScrollArea,
    maxDropdownHeight,
    size: size2,
    searchable,
    rightSection,
    checkIconPosition,
    withCheckIcon,
    nothingFoundMessage,
    name,
    form,
    searchValue,
    defaultSearchValue,
    onSearchChange,
    allowDeselect,
    error,
    rightSectionPointerEvents,
    id,
    clearable,
    clearButtonProps,
    hiddenInputProps,
    renderOption,
    onClear,
    autoComplete,
    scrollAreaProps,
    ...others
  } = props, parsedData = useMemo(() => getParsedComboboxData(data), [data]), optionsLockup = useMemo(() => getOptionsLockup(parsedData), [parsedData]), _id = useId$1(id), [_value, setValue, controlled] = useUncontrolled({
    value,
    defaultValue,
    finalValue: null,
    onChange
  }), selectedOption = typeof _value == "string" ? optionsLockup[_value] : void 0, previousSelectedOption = usePrevious(selectedOption), [search, setSearch] = useUncontrolled({
    value: searchValue,
    defaultValue: defaultSearchValue,
    finalValue: selectedOption ? selectedOption.label : "",
    onChange: onSearchChange
  }), combobox = useCombobox({
    opened: dropdownOpened,
    defaultOpened: defaultDropdownOpened,
    onDropdownOpen: () => {
      onDropdownOpen?.(), combobox.updateSelectedOptionIndex("active", { scrollIntoView: !0 });
    },
    onDropdownClose: () => {
      onDropdownClose?.(), combobox.resetSelectedOption();
    }
  }), { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    props,
    styles,
    classNames
  });
  useEffect(() => {
    selectFirstOptionOnChange && combobox.selectFirstOption();
  }, [selectFirstOptionOnChange, _value]), useEffect(() => {
    value === null && setSearch(""), typeof value == "string" && selectedOption && (previousSelectedOption?.value !== selectedOption.value || previousSelectedOption?.label !== selectedOption.label) && setSearch(selectedOption.label);
  }, [value, selectedOption]);
  const clearButton = clearable && !!_value && !disabled && !readOnly && /* @__PURE__ */ jsx(
    Combobox.ClearButton,
    {
      size: size2,
      ...clearButtonProps,
      onClear: () => {
        setValue(null, null), setSearch(""), onClear?.();
      }
    }
  );
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsxs(
      Combobox,
      {
        store: combobox,
        __staticSelector: "Select",
        classNames: resolvedClassNames,
        styles: resolvedStyles,
        unstyled,
        readOnly,
        onOptionSubmit: (val) => {
          onOptionSubmit?.(val);
          const optionLockup = allowDeselect && optionsLockup[val].value === _value ? null : optionsLockup[val], nextValue = optionLockup ? optionLockup.value : null;
          nextValue !== _value && setValue(nextValue, optionLockup), !controlled && setSearch(typeof nextValue == "string" && optionLockup?.label || ""), combobox.closeDropdown();
        },
        size: size2,
        ...comboboxProps,
        children: [
          /* @__PURE__ */ jsx(Combobox.Target, { targetType: searchable ? "input" : "button", autoComplete, children: /* @__PURE__ */ jsx(
            InputBase,
            {
              id: _id,
              ref,
              rightSection: rightSection || clearButton || /* @__PURE__ */ jsx(Combobox.Chevron, { size: size2, error, unstyled }),
              rightSectionPointerEvents: rightSectionPointerEvents || (clearButton ? "all" : "none"),
              ...others,
              size: size2,
              __staticSelector: "Select",
              disabled,
              readOnly: readOnly || !searchable,
              value: search,
              onChange: (event) => {
                setSearch(event.currentTarget.value), combobox.openDropdown(), selectFirstOptionOnChange && combobox.selectFirstOption();
              },
              onFocus: (event) => {
                searchable && combobox.openDropdown(), onFocus?.(event);
              },
              onBlur: (event) => {
                searchable && combobox.closeDropdown(), setSearch(_value != null && optionsLockup[_value]?.label || ""), onBlur?.(event);
              },
              onClick: (event) => {
                searchable ? combobox.openDropdown() : combobox.toggleDropdown(), onClick?.(event);
              },
              classNames: resolvedClassNames,
              styles: resolvedStyles,
              unstyled,
              pointer: !searchable,
              error
            }
          ) }),
          /* @__PURE__ */ jsx(
            OptionsDropdown,
            {
              data: parsedData,
              hidden: readOnly || disabled,
              filter,
              search,
              limit,
              hiddenWhenEmpty: !nothingFoundMessage,
              withScrollArea,
              maxDropdownHeight,
              filterOptions: searchable && selectedOption?.label !== search,
              value: _value,
              checkIconPosition,
              withCheckIcon,
              nothingFoundMessage,
              unstyled,
              labelId: others.label ? `${_id}-label` : void 0,
              "aria-label": others.label ? void 0 : others["aria-label"],
              renderOption,
              scrollAreaProps
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ jsx(
      Combobox.HiddenInput,
      {
        value: _value,
        name,
        form,
        disabled,
        ...hiddenInputProps
      }
    )
  ] });
});
Select.classes = { ...InputBase.classes, ...Combobox.classes };
Select.displayName = "@mantine/core/Select";
function SimpleGridMediaVariables({
  spacing,
  verticalSpacing,
  cols,
  selector
}) {
  const theme = useMantineTheme(), _verticalSpacing = verticalSpacing === void 0 ? spacing : verticalSpacing, baseStyles = filterProps({
    "--sg-spacing-x": getSpacing(getBaseValue$1(spacing)),
    "--sg-spacing-y": getSpacing(getBaseValue$1(_verticalSpacing)),
    "--sg-cols": getBaseValue$1(cols)?.toString()
  }), queries = keys(theme.breakpoints).reduce(
    (acc, breakpoint) => (acc[breakpoint] || (acc[breakpoint] = {}), typeof spacing == "object" && spacing[breakpoint] !== void 0 && (acc[breakpoint]["--sg-spacing-x"] = getSpacing(spacing[breakpoint])), typeof _verticalSpacing == "object" && _verticalSpacing[breakpoint] !== void 0 && (acc[breakpoint]["--sg-spacing-y"] = getSpacing(_verticalSpacing[breakpoint])), typeof cols == "object" && cols[breakpoint] !== void 0 && (acc[breakpoint]["--sg-cols"] = cols[breakpoint]), acc),
    {}
  ), media = getSortedBreakpoints(keys(queries), theme.breakpoints).filter(
    (breakpoint) => keys(queries[breakpoint.value]).length > 0
  ).map((breakpoint) => ({
    query: `(min-width: ${theme.breakpoints[breakpoint.value]})`,
    styles: queries[breakpoint.value]
  }));
  return /* @__PURE__ */ jsx(InlineStyles, { styles: baseStyles, media, selector });
}
function getBreakpoints(values2) {
  return typeof values2 == "object" && values2 !== null ? keys(values2) : [];
}
function sortBreakpoints(breakpoints) {
  return breakpoints.sort((a, b) => px(a) - px(b));
}
function getUniqueBreakpoints({
  spacing,
  verticalSpacing,
  cols
}) {
  const breakpoints = Array.from(
    /* @__PURE__ */ new Set([
      ...getBreakpoints(spacing),
      ...getBreakpoints(verticalSpacing),
      ...getBreakpoints(cols)
    ])
  );
  return sortBreakpoints(breakpoints);
}
function SimpleGridContainerVariables({
  spacing,
  verticalSpacing,
  cols,
  selector
}) {
  const _verticalSpacing = verticalSpacing === void 0 ? spacing : verticalSpacing, baseStyles = filterProps({
    "--sg-spacing-x": getSpacing(getBaseValue$1(spacing)),
    "--sg-spacing-y": getSpacing(getBaseValue$1(_verticalSpacing)),
    "--sg-cols": getBaseValue$1(cols)?.toString()
  }), uniqueBreakpoints = getUniqueBreakpoints({ spacing, verticalSpacing, cols }), queries = uniqueBreakpoints.reduce(
    (acc, breakpoint) => (acc[breakpoint] || (acc[breakpoint] = {}), typeof spacing == "object" && spacing[breakpoint] !== void 0 && (acc[breakpoint]["--sg-spacing-x"] = getSpacing(spacing[breakpoint])), typeof _verticalSpacing == "object" && _verticalSpacing[breakpoint] !== void 0 && (acc[breakpoint]["--sg-spacing-y"] = getSpacing(_verticalSpacing[breakpoint])), typeof cols == "object" && cols[breakpoint] !== void 0 && (acc[breakpoint]["--sg-cols"] = cols[breakpoint]), acc),
    {}
  ), media = uniqueBreakpoints.map((breakpoint) => ({
    query: `simple-grid (min-width: ${breakpoint})`,
    styles: queries[breakpoint]
  }));
  return /* @__PURE__ */ jsx(InlineStyles, { styles: baseStyles, container: media, selector });
}
var __default__$8 = { container: "m_925c2d2c", root: "m_2415a157" };
const classes$8 = __default__$8, defaultProps$j = {
  cols: 1,
  spacing: "md",
  type: "media"
}, SimpleGrid = factory((_props, ref) => {
  const props = useProps("SimpleGrid", defaultProps$j, _props), {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    cols,
    verticalSpacing,
    spacing,
    type,
    ...others
  } = props, getStyles2 = useStyles({
    name: "SimpleGrid",
    classes: classes$8,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars
  }), responsiveClassName = useRandomClassName();
  return type === "container" ? /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(SimpleGridContainerVariables, { ...props, selector: `.${responsiveClassName}` }),
    /* @__PURE__ */ jsx("div", { ...getStyles2("container"), children: /* @__PURE__ */ jsx(Box, { ref, ...getStyles2("root", { className: responsiveClassName }), ...others }) })
  ] }) : /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(SimpleGridMediaVariables, { ...props, selector: `.${responsiveClassName}` }),
    /* @__PURE__ */ jsx(Box, { ref, ...getStyles2("root", { className: responsiveClassName }), ...others })
  ] });
});
SimpleGrid.classes = classes$8;
SimpleGrid.displayName = "@mantine/core/SimpleGrid";
const [SliderProvider, useSliderContext] = createSafeContext(
  "SliderProvider was not found in tree"
), SliderRoot = forwardRef(
  ({ size: size2, disabled, variant, color, thumbSize, radius, ...others }, ref) => {
    const { getStyles: getStyles2 } = useSliderContext();
    return /* @__PURE__ */ jsx(
      Box,
      {
        tabIndex: -1,
        variant,
        size: size2,
        ref,
        ...getStyles2("root"),
        ...others
      }
    );
  }
);
SliderRoot.displayName = "@mantine/core/SliderRoot";
const Thumb = forwardRef(
  ({
    max: max2,
    min: min2,
    value,
    position,
    label,
    dragging,
    onMouseDown,
    onKeyDownCapture,
    labelTransitionProps,
    labelAlwaysOn,
    thumbLabel,
    onFocus,
    onBlur,
    showLabelOnHover,
    isHovered,
    children = null,
    disabled
  }, ref) => {
    const { getStyles: getStyles2 } = useSliderContext(), [focused, setFocused] = useState(!1), isVisible = labelAlwaysOn || dragging || focused || showLabelOnHover && isHovered;
    return /* @__PURE__ */ jsxs(
      Box,
      {
        tabIndex: 0,
        role: "slider",
        "aria-label": thumbLabel,
        "aria-valuemax": max2,
        "aria-valuemin": min2,
        "aria-valuenow": value,
        ref,
        __vars: { "--slider-thumb-offset": `${position}%` },
        ...getStyles2("thumb", { focusable: !0 }),
        mod: { dragging, disabled },
        onFocus: () => {
          setFocused(!0), typeof onFocus == "function" && onFocus();
        },
        onBlur: () => {
          setFocused(!1), typeof onBlur == "function" && onBlur();
        },
        onTouchStart: onMouseDown,
        onMouseDown,
        onKeyDownCapture,
        onClick: (event) => event.stopPropagation(),
        children: [
          children,
          /* @__PURE__ */ jsx(
            Transition,
            {
              mounted: label != null && !!isVisible,
              transition: "fade",
              duration: 0,
              ...labelTransitionProps,
              children: (transitionStyles) => /* @__PURE__ */ jsx("div", { ...getStyles2("label", { style: transitionStyles }), children: label })
            }
          )
        ]
      }
    );
  }
);
Thumb.displayName = "@mantine/core/SliderThumb";
function getPosition({ value, min: min2, max: max2 }) {
  const position = (value - min2) / (max2 - min2) * 100;
  return Math.min(Math.max(position, 0), 100);
}
function isMarkFilled({ mark, offset: offset2, value, inverted = !1 }) {
  return inverted ? typeof offset2 == "number" && mark.value <= offset2 || mark.value >= value : typeof offset2 == "number" ? mark.value >= offset2 && mark.value <= value : mark.value <= value;
}
function Marks({ marks, min: min2, max: max2, disabled, value, offset: offset2, inverted }) {
  const { getStyles: getStyles2 } = useSliderContext();
  if (!marks)
    return null;
  const items = marks.map((mark, index2) => /* @__PURE__ */ createElement(
    Box,
    {
      ...getStyles2("markWrapper"),
      __vars: { "--mark-offset": `${getPosition({ value: mark.value, min: min2, max: max2 })}%` },
      key: index2
    },
    /* @__PURE__ */ jsx(
      Box,
      {
        ...getStyles2("mark"),
        mod: { filled: isMarkFilled({ mark, value, offset: offset2, inverted }), disabled }
      }
    ),
    mark.label && /* @__PURE__ */ jsx("div", { ...getStyles2("markLabel"), children: mark.label })
  ));
  return /* @__PURE__ */ jsx("div", { children: items });
}
Marks.displayName = "@mantine/core/SliderMarks";
function Track({
  filled,
  children,
  offset: offset2,
  disabled,
  marksOffset,
  inverted,
  containerProps,
  ...others
}) {
  const { getStyles: getStyles2 } = useSliderContext();
  return /* @__PURE__ */ jsx(Box, { ...getStyles2("trackContainer"), mod: { disabled }, ...containerProps, children: /* @__PURE__ */ jsxs(Box, { ...getStyles2("track"), mod: { inverted, disabled }, children: [
    /* @__PURE__ */ jsx(
      Box,
      {
        mod: { inverted, disabled },
        __vars: {
          "--slider-bar-width": `calc(${filled}% + var(--slider-size))`,
          "--slider-bar-offset": `calc(${offset2}% - var(--slider-size))`
        },
        ...getStyles2("bar")
      }
    ),
    children,
    /* @__PURE__ */ jsx(Marks, { ...others, offset: marksOffset, disabled, inverted })
  ] }) });
}
Track.displayName = "@mantine/core/SliderTrack";
function getChangeValue({
  value,
  containerWidth,
  min: min2,
  max: max2,
  step,
  precision
}) {
  const dx = (containerWidth ? Math.min(Math.max(value, 0), containerWidth) / containerWidth : value) * (max2 - min2), nextValue = (dx !== 0 ? Math.round(dx / step) * step : 0) + min2, nextValueWithinStep = Math.max(nextValue, min2);
  return precision !== void 0 ? Number(nextValueWithinStep.toFixed(precision)) : nextValueWithinStep;
}
function getFloatingValue(value, precision) {
  return parseFloat(value.toFixed(precision));
}
function getPrecision(step) {
  if (!step)
    return 0;
  const split = step.toString().split(".");
  return split.length > 1 ? split[1].length : 0;
}
var __default__$7 = { root: "m_dd36362e", label: "m_c9357328", thumb: "m_c9a9a60a", trackContainer: "m_a8645c2", track: "m_c9ade57f", bar: "m_38aeed47", markWrapper: "m_b7b0423a", mark: "m_dd33bc19", markLabel: "m_68c77a5b" };
const classes$7 = __default__$7, defaultProps$i = {
  radius: "xl",
  min: 0,
  max: 100,
  step: 1,
  marks: [],
  label: (f) => f,
  labelTransitionProps: { transition: "fade", duration: 0 },
  labelAlwaysOn: !1,
  thumbLabel: "",
  showLabelOnHover: !0,
  disabled: !1,
  scale: (v) => v
}, varsResolver$6 = (theme, { size: size2, color, thumbSize, radius }) => ({
  root: {
    "--slider-size": getSize(size2, "slider-size"),
    "--slider-color": color ? getThemeColor(color, theme) : void 0,
    "--slider-radius": radius === void 0 ? void 0 : getRadius(radius),
    "--slider-thumb-size": thumbSize !== void 0 ? rem(thumbSize) : "calc(var(--slider-size) * 2)"
  }
}), Slider = factory((_props, ref) => {
  const props = useProps("Slider", defaultProps$i, _props), {
    classNames,
    styles,
    value,
    onChange,
    onChangeEnd,
    size: size2,
    min: min2,
    max: max2,
    step,
    precision: _precision,
    defaultValue,
    name,
    marks,
    label,
    labelTransitionProps,
    labelAlwaysOn,
    thumbLabel,
    showLabelOnHover,
    thumbChildren,
    disabled,
    unstyled,
    scale,
    inverted,
    className,
    style,
    vars,
    hiddenInputProps,
    restrictToMarks,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Slider",
    props,
    classes: classes$7,
    classNames,
    className,
    styles,
    style,
    vars,
    varsResolver: varsResolver$6,
    unstyled
  }), { dir } = useDirection(), [hovered, setHovered] = useState(!1), [_value, setValue] = useUncontrolled({
    value: typeof value == "number" ? clamp$2(value, min2, max2) : value,
    defaultValue: typeof defaultValue == "number" ? clamp$2(defaultValue, min2, max2) : defaultValue,
    finalValue: clamp$2(0, min2, max2),
    onChange
  }), valueRef = useRef(_value), root = useRef(), thumb = useRef(), position = getPosition({ value: _value, min: min2, max: max2 }), scaledValue = scale(_value), _label = typeof label == "function" ? label(scaledValue) : label, precision = _precision ?? getPrecision(step), handleChange = useCallback(
    ({ x }) => {
      if (!disabled) {
        const nextValue = getChangeValue({
          value: x,
          min: min2,
          max: max2,
          step,
          precision
        });
        setValue(
          restrictToMarks && marks?.length ? findClosestNumber(
            nextValue,
            marks.map((mark) => mark.value)
          ) : nextValue
        ), valueRef.current = nextValue;
      }
    },
    [disabled, min2, max2, step, precision, setValue, marks, restrictToMarks]
  ), { ref: container, active } = useMove(
    handleChange,
    {
      onScrubEnd: () => onChangeEnd?.(
        restrictToMarks && marks?.length ? findClosestNumber(
          valueRef.current,
          marks.map((mark) => mark.value)
        ) : valueRef.current
      )
    },
    dir
  ), handleTrackKeydownCapture = (event) => {
    if (!disabled)
      switch (event.key) {
        case "ArrowUp": {
          event.preventDefault(), thumb.current?.focus();
          const nextValue = getFloatingValue(
            Math.min(Math.max(_value + step, min2), max2),
            precision
          );
          setValue(nextValue), onChangeEnd?.(nextValue);
          break;
        }
        case "ArrowRight": {
          event.preventDefault(), thumb.current?.focus();
          const nextValue = getFloatingValue(
            Math.min(Math.max(dir === "rtl" ? _value - step : _value + step, min2), max2),
            precision
          );
          setValue(nextValue), onChangeEnd?.(nextValue);
          break;
        }
        case "ArrowDown": {
          event.preventDefault(), thumb.current?.focus();
          const nextValue = getFloatingValue(
            Math.min(Math.max(_value - step, min2), max2),
            precision
          );
          setValue(nextValue), onChangeEnd?.(nextValue);
          break;
        }
        case "ArrowLeft": {
          event.preventDefault(), thumb.current?.focus();
          const nextValue = getFloatingValue(
            Math.min(Math.max(dir === "rtl" ? _value + step : _value - step, min2), max2),
            precision
          );
          setValue(nextValue), onChangeEnd?.(nextValue);
          break;
        }
        case "Home": {
          event.preventDefault(), thumb.current?.focus(), setValue(min2), onChangeEnd?.(min2);
          break;
        }
        case "End": {
          event.preventDefault(), thumb.current?.focus(), setValue(max2), onChangeEnd?.(max2);
          break;
        }
      }
  };
  return /* @__PURE__ */ jsx(SliderProvider, { value: { getStyles: getStyles2 }, children: /* @__PURE__ */ jsxs(
    SliderRoot,
    {
      ...others,
      ref: useMergedRef(ref, root),
      onKeyDownCapture: handleTrackKeydownCapture,
      onMouseDownCapture: () => root.current?.focus(),
      size: size2,
      disabled,
      children: [
        /* @__PURE__ */ jsx(
          Track,
          {
            inverted,
            offset: 0,
            filled: position,
            marks,
            min: min2,
            max: max2,
            value: scaledValue,
            disabled,
            containerProps: {
              ref: container,
              onMouseEnter: showLabelOnHover ? () => setHovered(!0) : void 0,
              onMouseLeave: showLabelOnHover ? () => setHovered(!1) : void 0
            },
            children: /* @__PURE__ */ jsx(
              Thumb,
              {
                max: max2,
                min: min2,
                value: scaledValue,
                position,
                dragging: active,
                label: _label,
                ref: thumb,
                labelTransitionProps,
                labelAlwaysOn,
                thumbLabel,
                showLabelOnHover,
                isHovered: hovered,
                disabled,
                children: thumbChildren
              }
            )
          }
        ),
        /* @__PURE__ */ jsx("input", { type: "hidden", name, value: scaledValue, ...hiddenInputProps })
      ]
    }
  ) });
});
Slider.classes = classes$7;
Slider.displayName = "@mantine/core/Slider";
const defaultProps$h = {}, Space = factory((props, ref) => {
  const { w, h, miw, mih, ...others } = useProps("Space", defaultProps$h, props);
  return /* @__PURE__ */ jsx(Box, { ref, ...others, w, miw: miw ?? w, h, mih: mih ?? h });
});
Space.displayName = "@mantine/core/Space";
var __default__$6 = { root: "m_559cce2d", content: "m_b912df4e", control: "m_b9131032" };
const classes$6 = __default__$6, defaultProps$g = {
  maxHeight: 100,
  initialState: !1
}, varsResolver$5 = (_, { transitionDuration }) => ({
  root: {
    "--spoiler-transition-duration": transitionDuration !== void 0 ? `${transitionDuration}ms` : void 0
  }
}), Spoiler = factory((_props, ref) => {
  const props = useProps("Spoiler", defaultProps$g, _props), {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    initialState,
    maxHeight,
    hideLabel,
    showLabel,
    children,
    controlRef,
    transitionDuration,
    id,
    expanded,
    onExpandedChange,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Spoiler",
    classes: classes$6,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$5
  }), _id = useId$1(id), regionId = `${_id}-region`, [show, setShowState] = useUncontrolled({
    value: expanded,
    defaultValue: initialState,
    finalValue: !1,
    onChange: onExpandedChange
  }), { ref: contentRef, height } = useElementSize(), spoilerMoreContent = show ? hideLabel : showLabel, spoiler = spoilerMoreContent !== null && maxHeight < height;
  return /* @__PURE__ */ jsxs(
    Box,
    {
      ...getStyles2("root"),
      id: _id,
      ref,
      "data-has-spoiler": spoiler || void 0,
      ...others,
      children: [
        spoiler && /* @__PURE__ */ jsx(
          Anchor,
          {
            component: "button",
            type: "button",
            ref: controlRef,
            onClick: () => setShowState(!show),
            "aria-expanded": show,
            "aria-controls": regionId,
            ...getStyles2("control"),
            children: spoilerMoreContent
          }
        ),
        /* @__PURE__ */ jsx(
          "div",
          {
            ...getStyles2("content", {
              style: { maxHeight: show ? height ? rem(height) : void 0 : rem(maxHeight) }
            }),
            "data-reduce-motion": !0,
            role: "region",
            id: regionId,
            children: /* @__PURE__ */ jsx("div", { ref: contentRef, children })
          }
        )
      ]
    }
  );
});
Spoiler.classes = classes$6;
Spoiler.displayName = "@mantine/core/Spoiler";
var __default__$5 = { root: "m_6d731127" };
const classes$5 = __default__$5, defaultProps$f = {
  gap: "md",
  align: "stretch",
  justify: "flex-start"
}, varsResolver$4 = (_, { gap, align, justify }) => ({
  root: {
    "--stack-gap": getSpacing(gap),
    "--stack-align": align,
    "--stack-justify": justify
  }
}), Stack = factory((_props, ref) => {
  const props = useProps("Stack", defaultProps$f, _props), {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    align,
    justify,
    gap,
    variant,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Stack",
    props,
    classes: classes$5,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$4
  });
  return /* @__PURE__ */ jsx(Box, { ref, ...getStyles2("root"), variant, ...others });
});
Stack.classes = classes$5;
Stack.displayName = "@mantine/core/Stack";
const [TabsProvider, useTabsContext] = createSafeContext(
  "Tabs component was not found in the tree"
);
var __default__$4 = { root: "m_89d60db1", "list--default": "m_576c9d4", list: "m_89d33d6d", panel: "m_b0c91715", tab: "m_4ec4dce6", tabSection: "m_fc420b1f", "tab--default": "m_539e827b", "list--outline": "m_6772fbd5", "tab--outline": "m_b59ab47c", "tab--pills": "m_c3381914" };
const classes$4 = __default__$4, defaultProps$e = {}, TabsList = factory((_props, ref) => {
  const props = useProps("TabsList", defaultProps$e, _props), { children, className, grow, justify, classNames, styles, style, mod, ...others } = props, ctx = useTabsContext();
  return /* @__PURE__ */ jsx(
    Box,
    {
      ...others,
      ...ctx.getStyles("list", {
        className,
        style,
        classNames,
        styles,
        props,
        variant: ctx.variant
      }),
      ref,
      role: "tablist",
      variant: ctx.variant,
      mod: [
        {
          grow,
          orientation: ctx.orientation,
          placement: ctx.orientation === "vertical" && ctx.placement,
          inverted: ctx.inverted
        },
        mod
      ],
      "aria-orientation": ctx.orientation,
      __vars: { "--tabs-justify": justify },
      children
    }
  );
});
TabsList.classes = classes$4;
TabsList.displayName = "@mantine/core/TabsList";
const defaultProps$d = {}, TabsPanel = factory((_props, ref) => {
  const props = useProps("TabsPanel", defaultProps$d, _props), { children, className, value, classNames, styles, style, mod, keepMounted, ...others } = props, ctx = useTabsContext(), active = ctx.value === value, content = ctx.keepMounted || keepMounted || active ? children : null;
  return /* @__PURE__ */ jsx(
    Box,
    {
      ...others,
      ...ctx.getStyles("panel", {
        className,
        classNames,
        styles,
        style: [style, active ? void 0 : { display: "none" }],
        props
      }),
      ref,
      mod: [{ orientation: ctx.orientation }, mod],
      role: "tabpanel",
      id: ctx.getPanelId(value),
      "aria-labelledby": ctx.getTabId(value),
      children: content
    }
  );
});
TabsPanel.classes = classes$4;
TabsPanel.displayName = "@mantine/core/TabsPanel";
const defaultProps$c = {}, TabsTab = factory((_props, ref) => {
  const props = useProps("TabsTab", defaultProps$c, _props), {
    className,
    children,
    rightSection,
    leftSection,
    value,
    onClick,
    onKeyDown,
    disabled,
    color,
    style,
    classNames,
    styles,
    vars,
    mod,
    tabIndex,
    ...others
  } = props, theme = useMantineTheme(), { dir } = useDirection(), ctx = useTabsContext(), active = value === ctx.value, activateTab = (event) => {
    ctx.onChange(ctx.allowTabDeactivation && value === ctx.value ? null : value), onClick?.(event);
  }, stylesApiProps = { classNames, styles, props };
  return /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      ...others,
      ...ctx.getStyles("tab", { className, style, variant: ctx.variant, ...stylesApiProps }),
      disabled,
      unstyled: ctx.unstyled,
      variant: ctx.variant,
      mod: [
        {
          active,
          disabled,
          orientation: ctx.orientation,
          inverted: ctx.inverted,
          placement: ctx.orientation === "vertical" && ctx.placement
        },
        mod
      ],
      ref,
      role: "tab",
      id: ctx.getTabId(value),
      "aria-selected": active,
      tabIndex: tabIndex || active || ctx.value === null ? 0 : -1,
      "aria-controls": ctx.getPanelId(value),
      onClick: activateTab,
      __vars: { "--tabs-color": color ? getThemeColor(color, theme) : void 0 },
      onKeyDown: createScopedKeydownHandler({
        siblingSelector: '[role="tab"]',
        parentSelector: '[role="tablist"]',
        activateOnFocus: ctx.activateTabWithKeyboard,
        loop: ctx.loop,
        orientation: ctx.orientation || "horizontal",
        dir,
        onKeyDown
      }),
      children: [
        leftSection && /* @__PURE__ */ jsx("span", { ...ctx.getStyles("tabSection", stylesApiProps), "data-position": "left", children: leftSection }),
        children && /* @__PURE__ */ jsx("span", { ...ctx.getStyles("tabLabel", stylesApiProps), children }),
        rightSection && /* @__PURE__ */ jsx("span", { ...ctx.getStyles("tabSection", stylesApiProps), "data-position": "right", children: rightSection })
      ]
    }
  );
});
TabsTab.classes = classes$4;
TabsTab.displayName = "@mantine/core/TabsTab";
const VALUE_ERROR = "Tabs.Tab or Tabs.Panel component was rendered with invalid value or without value", defaultProps$b = {
  keepMounted: !0,
  orientation: "horizontal",
  loop: !0,
  activateTabWithKeyboard: !0,
  allowTabDeactivation: !1,
  unstyled: !1,
  inverted: !1,
  variant: "default",
  placement: "left"
}, varsResolver$3 = (theme, { radius, color, autoContrast }) => ({
  root: {
    "--tabs-radius": getRadius(radius),
    "--tabs-color": getThemeColor(color, theme),
    "--tabs-text-color": getAutoContrastValue(autoContrast, theme) ? getContrastColor({ color, theme, autoContrast }) : void 0
  }
}), Tabs = factory((_props, ref) => {
  const props = useProps("Tabs", defaultProps$b, _props), {
    defaultValue,
    value,
    onChange,
    orientation,
    children,
    loop,
    id,
    activateTabWithKeyboard,
    allowTabDeactivation,
    variant,
    color,
    radius,
    inverted,
    placement,
    keepMounted,
    classNames,
    styles,
    unstyled,
    className,
    style,
    vars,
    autoContrast,
    mod,
    ...others
  } = props, uid = useId$1(id), [currentTab, setCurrentTab] = useUncontrolled({
    value,
    defaultValue,
    finalValue: null,
    onChange
  }), getStyles2 = useStyles({
    name: "Tabs",
    props,
    classes: classes$4,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$3
  });
  return /* @__PURE__ */ jsx(
    TabsProvider,
    {
      value: {
        placement,
        value: currentTab,
        orientation,
        id: uid,
        loop,
        activateTabWithKeyboard,
        getTabId: getSafeId(`${uid}-tab`, VALUE_ERROR),
        getPanelId: getSafeId(`${uid}-panel`, VALUE_ERROR),
        onChange: setCurrentTab,
        allowTabDeactivation,
        variant,
        color,
        radius,
        inverted,
        keepMounted,
        unstyled,
        getStyles: getStyles2
      },
      children: /* @__PURE__ */ jsx(
        Box,
        {
          ref,
          id: uid,
          variant,
          mod: [
            {
              orientation,
              inverted: orientation === "horizontal" && inverted,
              placement: orientation === "vertical" && placement
            },
            mod
          ],
          ...getStyles2("root"),
          ...others,
          children
        }
      )
    }
  );
});
Tabs.classes = classes$4;
Tabs.displayName = "@mantine/core/Tabs";
Tabs.Tab = TabsTab;
Tabs.Panel = TabsPanel;
Tabs.List = TabsList;
var __default__$3 = { root: "m_7341320d" };
const classes$3 = __default__$3, defaultProps$a = {}, varsResolver$2 = (theme, { size: size2, radius, variant, gradient, color, autoContrast }) => {
  const colors = theme.variantColorResolver({
    color: color || theme.primaryColor,
    theme,
    gradient,
    variant: variant || "filled",
    autoContrast
  });
  return {
    root: {
      "--ti-size": getSize(size2, "ti-size"),
      "--ti-radius": radius === void 0 ? void 0 : getRadius(radius),
      "--ti-bg": color || variant ? colors.background : void 0,
      "--ti-color": color || variant ? colors.color : void 0,
      "--ti-bd": color || variant ? colors.border : void 0
    }
  };
}, ThemeIcon = factory((_props, ref) => {
  const props = useProps("ThemeIcon", defaultProps$a, _props), { classNames, className, style, styles, unstyled, vars, autoContrast, ...others } = props, getStyles2 = useStyles({
    name: "ThemeIcon",
    classes: classes$3,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$2
  });
  return /* @__PURE__ */ jsx(Box, { ref, ...getStyles2("root"), ...others });
});
ThemeIcon.classes = classes$3;
ThemeIcon.displayName = "@mantine/core/ThemeIcon";
const headings = ["h1", "h2", "h3", "h4", "h5", "h6"], sizes = ["xs", "sm", "md", "lg", "xl"];
function getTitleSize(order, size2) {
  const titleSize = size2 !== void 0 ? size2 : `h${order}`;
  return headings.includes(titleSize) ? {
    fontSize: `var(--mantine-${titleSize}-font-size)`,
    fontWeight: `var(--mantine-${titleSize}-font-weight)`,
    lineHeight: `var(--mantine-${titleSize}-line-height)`
  } : sizes.includes(titleSize) ? {
    fontSize: `var(--mantine-font-size-${titleSize})`,
    fontWeight: `var(--mantine-h${order}-font-weight)`,
    lineHeight: `var(--mantine-h${order}-line-height)`
  } : {
    fontSize: rem(titleSize),
    fontWeight: `var(--mantine-h${order}-font-weight)`,
    lineHeight: `var(--mantine-h${order}-line-height)`
  };
}
var __default__$2 = { root: "m_8a5d1357" };
const classes$2 = __default__$2, defaultProps$9 = {
  order: 1
}, varsResolver$1 = (_, { order, size: size2, lineClamp, textWrap }) => {
  const sizeVariables = getTitleSize(order, size2);
  return {
    root: {
      "--title-fw": sizeVariables.fontWeight,
      "--title-lh": sizeVariables.lineHeight,
      "--title-fz": sizeVariables.fontSize,
      "--title-line-clamp": typeof lineClamp == "number" ? lineClamp.toString() : void 0,
      "--title-text-wrap": textWrap
    }
  };
}, Title = factory((_props, ref) => {
  const props = useProps("Title", defaultProps$9, _props), {
    classNames,
    className,
    style,
    styles,
    unstyled,
    order,
    vars,
    size: size2,
    variant,
    lineClamp,
    textWrap,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Title",
    props,
    classes: classes$2,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$1
  });
  return [1, 2, 3, 4, 5, 6].includes(order) ? /* @__PURE__ */ jsx(
    Box,
    {
      ...getStyles2("root"),
      component: `h${order}`,
      variant,
      ref,
      mod: [{ order, "data-line-clamp": typeof lineClamp == "number" }, mod],
      size: size2,
      ...others
    }
  ) : null;
});
Title.classes = classes$2;
Title.displayName = "@mantine/core/Title";
function getValuesRange(anchor, value, flatValues) {
  if (!anchor || !value)
    return [];
  const anchorIndex = flatValues.indexOf(anchor), valueIndex = flatValues.indexOf(value), start = Math.min(anchorIndex, valueIndex), end = Math.max(anchorIndex, valueIndex);
  return flatValues.slice(start, end + 1);
}
function TreeNode({
  node,
  getStyles: getStyles2,
  rootIndex,
  controller,
  expandOnClick,
  selectOnClick,
  isSubtree,
  level = 1,
  renderNode,
  flatValues,
  allowRangeSelection,
  expandOnSpace
}) {
  const ref = useRef(null), nested = (node.children || []).map((child) => /* @__PURE__ */ jsx(
    TreeNode,
    {
      node: child,
      flatValues,
      getStyles: getStyles2,
      rootIndex: void 0,
      level: level + 1,
      controller,
      expandOnClick,
      isSubtree: !0,
      renderNode,
      selectOnClick,
      allowRangeSelection,
      expandOnSpace
    },
    child.value
  )), handleKeyDown = (event) => {
    if (event.nativeEvent.code === "ArrowRight" && (event.stopPropagation(), event.preventDefault(), controller.expandedState[node.value] ? event.currentTarget.querySelector("[role=treeitem]")?.focus() : controller.expand(node.value)), event.nativeEvent.code === "ArrowLeft" && (event.stopPropagation(), event.preventDefault(), controller.expandedState[node.value] && (node.children || []).length > 0 ? controller.collapse(node.value) : isSubtree && findElementAncestor(event.currentTarget, "[role=treeitem]")?.focus()), event.nativeEvent.code === "ArrowDown" || event.nativeEvent.code === "ArrowUp") {
      const root = findElementAncestor(event.currentTarget, "[data-tree-root]");
      if (!root)
        return;
      event.stopPropagation(), event.preventDefault();
      const nodes = Array.from(root.querySelectorAll("[role=treeitem]")), index2 = nodes.indexOf(event.currentTarget);
      if (index2 === -1)
        return;
      const nextIndex = event.nativeEvent.code === "ArrowDown" ? index2 + 1 : index2 - 1;
      if (nodes[nextIndex]?.focus(), event.shiftKey) {
        const selectNode = nodes[nextIndex];
        selectNode && controller.setSelectedState(
          getValuesRange(controller.anchorNode, selectNode.dataset.value, flatValues)
        );
      }
    }
    event.nativeEvent.code === "Space" && expandOnSpace && (event.stopPropagation(), event.preventDefault(), controller.toggleExpanded(node.value));
  }, handleNodeClick = (event) => {
    event.stopPropagation(), allowRangeSelection && event.shiftKey && controller.anchorNode ? (controller.setSelectedState(getValuesRange(controller.anchorNode, node.value, flatValues)), ref.current?.focus()) : (expandOnClick && controller.toggleExpanded(node.value), selectOnClick && controller.select(node.value), ref.current?.focus());
  }, selected = controller.selectedState.includes(node.value), elementProps = {
    ...getStyles2("label"),
    onClick: handleNodeClick,
    "data-selected": selected || void 0,
    "data-value": node.value,
    "data-hovered": controller.hoveredNode === node.value || void 0
  };
  return /* @__PURE__ */ jsxs(
    "li",
    {
      ...getStyles2("node", {
        style: { "--label-offset": `calc(var(--level-offset) * ${level - 1})` }
      }),
      role: "treeitem",
      "aria-selected": selected,
      "data-value": node.value,
      "data-selected": selected || void 0,
      "data-hovered": controller.hoveredNode === node.value || void 0,
      "data-level": level,
      tabIndex: rootIndex === 0 ? 0 : -1,
      onKeyDown: handleKeyDown,
      ref,
      onMouseOver: (event) => {
        event.stopPropagation(), controller.setHoveredNode(node.value);
      },
      onMouseLeave: (event) => {
        event.stopPropagation(), controller.setHoveredNode(null);
      },
      children: [
        typeof renderNode == "function" ? renderNode({
          node,
          level,
          selected,
          tree: controller,
          expanded: controller.expandedState[node.value] || !1,
          hasChildren: Array.isArray(node.children) && node.children.length > 0,
          elementProps
        }) : /* @__PURE__ */ jsx("div", { ...elementProps, children: node.label }),
        controller.expandedState[node.value] && nested.length > 0 && /* @__PURE__ */ jsx("ul", { role: "group", ...getStyles2("subtree"), "data-level": level, children: nested })
      ]
    }
  );
}
TreeNode.displayName = "@mantine/core/TreeNode";
function getAllCheckedNodes(data, checkedState, acc = []) {
  const currentTreeChecked = [];
  for (const node of data)
    if (Array.isArray(node.children) && node.children.length > 0) {
      const innerChecked = getAllCheckedNodes(node.children, checkedState, acc);
      if (innerChecked.currentTreeChecked.length === node.children.length) {
        const isChecked = innerChecked.currentTreeChecked.every((item2) => item2.checked), item = {
          checked: isChecked,
          indeterminate: !isChecked,
          value: node.value,
          hasChildren: !0
        };
        currentTreeChecked.push(item), acc.push(item);
      } else if (innerChecked.currentTreeChecked.length > 0) {
        const item = { checked: !1, indeterminate: !0, value: node.value, hasChildren: !0 };
        currentTreeChecked.push(item), acc.push(item);
      }
    } else if (checkedState.includes(node.value)) {
      const item = {
        checked: !0,
        indeterminate: !1,
        value: node.value,
        hasChildren: !1
      };
      currentTreeChecked.push(item), acc.push(item);
    }
  return { result: acc, currentTreeChecked };
}
function findTreeNode(value, data) {
  for (const node of data) {
    if (node.value === value)
      return node;
    if (Array.isArray(node.children)) {
      const childNode = findTreeNode(value, node.children);
      if (childNode)
        return childNode;
    }
  }
  return null;
}
function getChildrenNodesValues(value, data, acc = []) {
  const node = findTreeNode(value, data);
  return node ? !Array.isArray(node.children) || node.children.length === 0 ? [node.value] : (node.children.forEach((child) => {
    Array.isArray(child.children) && child.children.length > 0 ? getChildrenNodesValues(child.value, data, acc) : acc.push(child.value);
  }), acc) : acc;
}
function getAllChildrenNodes(data) {
  return data.reduce((acc, node) => (Array.isArray(node.children) && node.children.length > 0 ? acc.push(...getAllChildrenNodes(node.children)) : acc.push(node.value), acc), []);
}
function isNodeChecked(value, data, checkedState) {
  return checkedState.length === 0 ? !1 : checkedState.includes(value) ? !0 : getAllCheckedNodes(data, checkedState).result.some((node) => node.value === value && node.checked);
}
const memoizedIsNodeChecked = memoize(isNodeChecked);
function isNodeIndeterminate(value, data, checkedState) {
  return checkedState.length === 0 ? !1 : getAllCheckedNodes(data, checkedState).result.some((node) => node.value === value && node.indeterminate);
}
const memoizedIsNodeIndeterminate = memoize(isNodeIndeterminate);
function getInitialTreeExpandedState(initialState, data, value, acc = {}) {
  return data.forEach((node) => {
    acc[node.value] = node.value in initialState ? initialState[node.value] : node.value === value, Array.isArray(node.children) && getInitialTreeExpandedState(initialState, node.children, value, acc);
  }), acc;
}
function getInitialCheckedState(initialState, data) {
  const acc = [];
  return initialState.forEach((node) => acc.push(...getChildrenNodesValues(node, data))), Array.from(new Set(acc));
}
function useTree({
  initialSelectedState = [],
  initialCheckedState = [],
  initialExpandedState = {},
  multiple = !1,
  onNodeCollapse,
  onNodeExpand
} = {}) {
  const [data, setData] = useState([]), [expandedState, setExpandedState] = useState(initialExpandedState), [selectedState, setSelectedState] = useState(initialSelectedState), [checkedState, setCheckedState] = useState(initialCheckedState), [anchorNode, setAnchorNode] = useState(null), [hoveredNode, setHoveredNode] = useState(null), initialize = useCallback(
    (_data) => {
      setExpandedState((current) => getInitialTreeExpandedState(current, _data, selectedState)), setCheckedState((current) => getInitialCheckedState(current, _data)), setData(_data);
    },
    [selectedState, checkedState]
  ), toggleExpanded = useCallback(
    (value) => {
      setExpandedState((current) => {
        const nextState = { ...current, [value]: !current[value] };
        return nextState[value] ? onNodeExpand?.(value) : onNodeCollapse?.(value), nextState;
      });
    },
    [onNodeCollapse, onNodeExpand]
  ), collapse = useCallback(
    (value) => {
      setExpandedState((current) => (current[value] !== !1 && onNodeCollapse?.(value), { ...current, [value]: !1 }));
    },
    [onNodeCollapse]
  ), expand = useCallback(
    (value) => {
      setExpandedState((current) => (current[value] !== !0 && onNodeExpand?.(value), { ...current, [value]: !0 }));
    },
    [onNodeExpand]
  ), expandAllNodes = useCallback(() => {
    setExpandedState((current) => {
      const next = { ...current };
      return Object.keys(next).forEach((key) => {
        next[key] = !0;
      }), next;
    });
  }, []), collapseAllNodes = useCallback(() => {
    setExpandedState((current) => {
      const next = { ...current };
      return Object.keys(next).forEach((key) => {
        next[key] = !1;
      }), next;
    });
  }, []), toggleSelected = useCallback(
    (value) => setSelectedState((current) => multiple ? current.includes(value) ? (setAnchorNode(null), current.filter((item) => item !== value)) : (setAnchorNode(value), [...current, value]) : current.includes(value) ? (setAnchorNode(null), []) : (setAnchorNode(value), [value])),
    []
  ), select = useCallback((value) => {
    setAnchorNode(value), setSelectedState(
      (current) => multiple ? current.includes(value) ? current : [...current, value] : [value]
    );
  }, []), deselect = useCallback((value) => {
    anchorNode === value && setAnchorNode(null), setSelectedState((current) => current.filter((item) => item !== value));
  }, []), clearSelected = useCallback(() => {
    setSelectedState([]), setAnchorNode(null);
  }, []), checkNode = useCallback(
    (value) => {
      const checkedNodes = getChildrenNodesValues(value, data);
      setCheckedState((current) => Array.from(/* @__PURE__ */ new Set([...current, ...checkedNodes])));
    },
    [data]
  ), uncheckNode = useCallback(
    (value) => {
      const checkedNodes = getChildrenNodesValues(value, data);
      setCheckedState((current) => current.filter((item) => !checkedNodes.includes(item)));
    },
    [data]
  ), checkAllNodes = useCallback(() => {
    setCheckedState(() => getAllChildrenNodes(data));
  }, [data]), uncheckAllNodes = useCallback(() => {
    setCheckedState([]);
  }, []);
  return {
    multiple,
    expandedState,
    selectedState,
    checkedState,
    anchorNode,
    initialize,
    toggleExpanded,
    collapse,
    expand,
    expandAllNodes,
    collapseAllNodes,
    setExpandedState,
    checkNode,
    uncheckNode,
    checkAllNodes,
    uncheckAllNodes,
    setCheckedState,
    toggleSelected,
    select,
    deselect,
    clearSelected,
    setSelectedState,
    hoveredNode,
    setHoveredNode,
    getCheckedNodes: () => getAllCheckedNodes(data, checkedState).result,
    isNodeChecked: (value) => memoizedIsNodeChecked(value, data, checkedState),
    isNodeIndeterminate: (value) => memoizedIsNodeIndeterminate(value, data, checkedState)
  };
}
var __default__$1 = { root: "m_f698e191", subtree: "m_75f3ecf", node: "m_f6970eb1", label: "m_dc283425" };
const classes$1 = __default__$1;
function getFlatValues(data) {
  return data.reduce((acc, item) => (acc.push(item.value), item.children && acc.push(...getFlatValues(item.children)), acc), []);
}
const defaultProps$8 = {
  expandOnClick: !0,
  allowRangeSelection: !0,
  expandOnSpace: !0
}, varsResolver = (_theme, { levelOffset }) => ({
  root: {
    "--level-offset": getSpacing(levelOffset)
  }
}), Tree = factory((_props, ref) => {
  const props = useProps("Tree", defaultProps$8, _props), {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    data,
    expandOnClick,
    tree,
    renderNode,
    selectOnClick,
    clearSelectionOnOutsideClick,
    allowRangeSelection,
    expandOnSpace,
    levelOffset,
    ...others
  } = props, defaultController = useTree(), controller = tree || defaultController, getStyles2 = useStyles({
    name: "Tree",
    classes: classes$1,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver
  }), clickOutsideRef = useClickOutside(
    () => clearSelectionOnOutsideClick && controller.clearSelected()
  ), mergedRef = useMergedRef(ref, clickOutsideRef), flatValues = useMemo(() => getFlatValues(data), [data]);
  useEffect(() => {
    controller.initialize(data);
  }, [data]);
  const nodes = data.map((node, index2) => /* @__PURE__ */ jsx(
    TreeNode,
    {
      node,
      getStyles: getStyles2,
      rootIndex: index2,
      expandOnClick,
      selectOnClick,
      controller,
      renderNode,
      flatValues,
      allowRangeSelection,
      expandOnSpace
    },
    node.value
  ));
  return /* @__PURE__ */ jsx(
    Box,
    {
      component: "ul",
      ref: mergedRef,
      ...getStyles2("root"),
      ...others,
      role: "tree",
      "aria-multiselectable": controller.multiple,
      "data-tree-root": !0,
      children: nodes
    }
  );
});
Tree.displayName = "@mantine/core/Tree";
Tree.classes = classes$1;
function getSizesVariables(theme, themeKey, name) {
  return Object.keys(theme[themeKey]).reduce((acc, size2) => (acc[size2] = `var(--mantine-${name}-${size2})`, acc), {});
}
function getBreakpointValue(value, theme) {
  return value in theme.breakpoints ? theme.breakpoints[value] : em(value);
}
function themeToVars(theme) {
  const mergedTheme = mergeMantineTheme(DEFAULT_THEME, theme), fontSizes = getSizesVariables(mergedTheme, "fontSizes", "font-size"), lineHeights = getSizesVariables(mergedTheme, "lineHeights", "line-height"), shadows = getSizesVariables(mergedTheme, "shadows", "shadow"), radius = getSizesVariables(mergedTheme, "radius", "radius"), spacing = getSizesVariables(mergedTheme, "spacing", "spacing"), headings2 = Object.keys(mergedTheme.headings.sizes).reduce(
    (acc, heading) => (acc[heading] = {
      fontSize: `var(--mantine-${heading}-font-size)`,
      lineHeight: `var(--mantine-${heading}-line-height)`,
      fontWeight: `var(--mantine-${heading}-font-weight)`
    }, acc),
    {}
  ), colors = Object.keys(mergedTheme.colors).reduce(
    (acc, color) => (acc[color] = {
      0: `var(--mantine-color-${color}-0)`,
      1: `var(--mantine-color-${color}-1)`,
      2: `var(--mantine-color-${color}-2)`,
      3: `var(--mantine-color-${color}-3)`,
      4: `var(--mantine-color-${color}-4)`,
      5: `var(--mantine-color-${color}-5)`,
      6: `var(--mantine-color-${color}-6)`,
      7: `var(--mantine-color-${color}-7)`,
      8: `var(--mantine-color-${color}-8)`,
      9: `var(--mantine-color-${color}-9)`,
      filled: `var(--mantine-color-${color}-filled)`,
      filledHover: `var(--mantine-color-${color}-filled-hover)`,
      light: `var(--mantine-color-${color}-light)`,
      lightHover: `var(--mantine-color-${color}-light-hover)`,
      lightColor: `var(--mantine-color-${color}-light-color)`,
      outline: `var(--mantine-color-${color}-outline)`,
      outlineHover: `var(--mantine-color-${color}-outline-hover)`
    }, acc),
    {
      primary: "var(--mantine-primary-color-filled)",
      primaryColors: {
        0: "var(--mantine-primary-color-0)",
        1: "var(--mantine-primary-color-1)",
        2: "var(--mantine-primary-color-2)",
        3: "var(--mantine-primary-color-3)",
        4: "var(--mantine-primary-color-4)",
        5: "var(--mantine-primary-color-5)",
        6: "var(--mantine-primary-color-6)",
        7: "var(--mantine-primary-color-7)",
        8: "var(--mantine-primary-color-8)",
        9: "var(--mantine-primary-color-9)",
        filled: "var(--mantine-primary-color-filled)",
        filledHover: "var(--mantine-primary-color-filled-hover)",
        light: "var(--mantine-primary-color-light)",
        lightHover: "var(--mantine-primary-color-light-hover)",
        lightColor: "var(--mantine-primary-color-light-color)",
        outline: "var(--mantine-primary-color-outline)",
        outlineHover: "var(--mantine-primary-color-outline-hover)"
      },
      white: "var(--mantine-color-white)",
      black: "var(--mantine-color-black)",
      text: "var(--mantine-color-text)",
      body: "var(--mantine-color-body)",
      error: "var(--mantine-color-error)",
      placeholder: "var(--mantine-color-placeholder)",
      anchor: "var(--mantine-color-anchor)",
      default: "var(--mantine-color-default)",
      defaultHover: "var(--mantine-color-default-hover)",
      defaultColor: "var(--mantine-color-default-color)",
      defaultBorder: "var(--mantine-color-default-border)",
      dimmed: "var(--mantine-color-dimmed)"
    }
  );
  return {
    scale: "var(--mantine-scale)",
    cursorType: "var(--mantine-cursor-type)",
    webkitFontSmoothing: "var(--mantine-webkit-font-smoothing)",
    mozFontSmoothing: "var(--mantine-moz-font-smoothing)",
    lineHeight: "var(--mantine-line-height)",
    fontFamily: "var(--mantine-font-family)",
    fontFamilyMonospace: "var(--mantine-font-family-monospace)",
    fontFamilyHeadings: "var(--mantine-font-family-headings)",
    headingFontWeight: "var(--mantine-heading-font-weight)",
    radiusDefault: "var(--mantine-radius-default)",
    breakpoints: mergedTheme.breakpoints,
    fontSizes,
    lineHeights,
    shadows,
    radius,
    headings: headings2,
    spacing,
    colors,
    rtlSelector: '[dir="rtl"] &',
    darkSelector: '[data-mantine-color-scheme="dark"] &',
    lightSelector: '[data-mantine-color-scheme="light"] &',
    smallerThan: (breakpoint) => `(max-width: ${getBreakpointValue(breakpoint, mergedTheme)})`,
    largerThan: (breakpoint) => `(min-width: ${getBreakpointValue(breakpoint, mergedTheme)})`
  };
}
function createStore(initialState) {
  let state = initialState, initialized = !1;
  const listeners = /* @__PURE__ */ new Set();
  return {
    getState() {
      return state;
    },
    updateState(value) {
      state = typeof value == "function" ? value(state) : value;
    },
    setState(value) {
      this.updateState(value), listeners.forEach((listener) => listener(state));
    },
    initialize(value) {
      initialized || (state = value, initialized = !0);
    },
    subscribe(callback) {
      return listeners.add(callback), () => listeners.delete(callback);
    }
  };
}
function useStore(store) {
  return useSyncExternalStore(
    store.subscribe,
    () => store.getState(),
    () => store.getState()
  );
}
const createSpotlightStore = () => createStore({
  opened: !1,
  empty: !1,
  selected: -1,
  listId: "",
  query: "",
  registeredActions: /* @__PURE__ */ new Set()
}), useSpotlight = (store) => useStore(store);
function updateSpotlightStateAction(update, store) {
  const state = store.getState();
  store.setState({ ...state, ...update(store.getState()) });
}
function openSpotlightAction(store) {
  updateSpotlightStateAction(() => ({ opened: !0, selected: -1 }), store);
}
function closeSpotlightAction(store) {
  updateSpotlightStateAction(() => ({ opened: !1 }), store);
}
function toggleSpotlightAction(store) {
  updateSpotlightStateAction(
    (state) => ({ opened: !state.opened, selected: state.opened ? state.selected : -1 }),
    store
  );
}
function setSelectedAction(index2, store) {
  store.updateState((state) => ({ ...state, selected: index2 }));
}
function setListId(id, store) {
  store.updateState((state) => ({ ...state, listId: id }));
}
function findElementByQuerySelector(selector, root = document) {
  const element = root.querySelector(selector);
  if (element)
    return element;
  const children = root instanceof ShadowRoot ? root.host.children : root.children;
  for (let i = 0; i < children.length; i += 1) {
    const child = children[i];
    if (child.shadowRoot) {
      const shadowElement = findElementByQuerySelector(selector, child.shadowRoot);
      if (shadowElement)
        return shadowElement;
    }
    const nestedElement = findElementByQuerySelector(selector, child);
    if (nestedElement)
      return nestedElement;
  }
  return null;
}
function selectAction(index2, store) {
  const state = store.getState(), actionsList = state.listId ? findElementByQuerySelector(`#${state.listId}`) : null, selected = actionsList?.querySelector("[data-selected]"), actions = actionsList?.querySelectorAll("[data-action]") ?? [], nextIndex = index2 === -1 ? actions.length - 1 : index2 === actions.length ? 0 : index2, selectedIndex = clamp$2(nextIndex, 0, actions.length - 1);
  return selected?.removeAttribute("data-selected"), actions[selectedIndex]?.scrollIntoView({ block: "nearest" }), actions[selectedIndex]?.setAttribute("data-selected", "true"), setSelectedAction(selectedIndex, store), selectedIndex;
}
function selectNextAction(store) {
  return selectAction(store.getState().selected + 1, store);
}
function selectPreviousAction(store) {
  return selectAction(store.getState().selected - 1, store);
}
function triggerSelectedAction(store) {
  const state = store.getState();
  findElementByQuerySelector(
    `#${state.listId} [data-selected]`
  )?.click();
}
function registerAction(id, store) {
  const state = store.getState();
  return state.registeredActions.add(id), () => {
    state.registeredActions.delete(id);
  };
}
function setQuery(query, store) {
  updateSpotlightStateAction(() => ({ query }), store), Promise.resolve().then(() => {
    selectAction(0, store), updateSpotlightStateAction(
      (state) => ({
        empty: state.query.trim().length > 0 && state.registeredActions.size === 0 || !1
      }),
      store
    );
  });
}
function clearSpotlightState({ clearQuery }, store) {
  store.updateState((state) => ({
    ...state,
    selected: -1,
    query: clearQuery ? "" : state.query,
    empty: clearQuery ? !1 : state.empty
  }));
}
const spotlightActions = {
  open: openSpotlightAction,
  close: closeSpotlightAction,
  toggle: toggleSpotlightAction,
  updateState: updateSpotlightStateAction,
  setSelectedAction,
  setListId,
  selectAction,
  selectNextAction,
  selectPreviousAction,
  triggerSelectedAction,
  registerAction,
  setQuery,
  clearSpotlightState
};
function createSpotlight() {
  const store = createSpotlightStore();
  return [store, {
    open: () => openSpotlightAction(store),
    close: () => closeSpotlightAction(store),
    toggle: () => toggleSpotlightAction(store)
  }];
}
const [spotlightStore, spotlight] = createSpotlight(), { open: openSpotlight, close: closeSpotlight, toggle: toggleSpotlight } = spotlight;
function isActionsGroup(item) {
  const _item = item;
  return _item.group !== void 0 && Array.isArray(_item.actions);
}
function getKeywords(keywords) {
  return Array.isArray(keywords) ? keywords.map((keyword) => keyword.trim()).join(",").toLowerCase().trim() : typeof keywords == "string" ? keywords.toLowerCase().trim() : "";
}
function getFlatActions(data) {
  return data.reduce((acc, item) => "actions" in item ? [...acc, ...item.actions.map((action) => ({ ...action, group: item.group }))] : [...acc, item], []);
}
function flatActionsToGroups(data) {
  const groups = {}, result = [];
  return data.forEach((action) => {
    action.group ? (groups[action.group] || (groups[action.group] = { pushed: !1, data: { group: action.group, actions: [] } }), groups[action.group].data.actions.push(action), groups[action.group].pushed || (groups[action.group].pushed = !0, result.push(groups[action.group].data))) : result.push(action);
  }), result;
}
const defaultSpotlightFilter = (_query, data) => {
  const query = _query.trim().toLowerCase(), priorityMatrix = [[], []];
  return getFlatActions(data).forEach((item) => {
    item.label?.toLowerCase().includes(query) ? priorityMatrix[0].push(item) : (item.description?.toLowerCase().includes(query) || getKeywords(item.keywords).includes(query)) && priorityMatrix[1].push(item);
  }), flatActionsToGroups(priorityMatrix.flat());
};
function limitActions(actions, limit) {
  if (!Array.isArray(actions))
    return [];
  let count2 = 0;
  return actions.reduce((acc, item) => {
    if (count2 >= limit)
      return acc;
    if (isActionsGroup(item)) {
      const groupActions = limitActions(item.actions, limit - count2);
      acc.push({
        group: item.group,
        actions: groupActions
      }), count2 += groupActions.length;
    } else
      acc.push(item), count2 += 1;
    return acc;
  }, []);
}
const [SpotlightProvider, useSpotlightContext] = createSafeContext(
  "Spotlight component was not found in tree"
);
var __default__ = { root: "m_d2b315db", content: "m_3cd250e0", body: "m_d2abce9b", search: "m_f366a061", actionsList: "m_6e463822", action: "m_d49bb8ef", actionBody: "m_3d475731", actionSection: "m_832642f6", actionLabel: "m_6c2a1345", actionDescription: "m_a6d9d78d", empty: "m_82f78f74", footer: "m_ddcaf054", actionsGroup: "m_5a3e5f7b" };
const classes = __default__, defaultProps$7 = {
  dimmedSections: !0,
  highlightQuery: !1
}, SpotlightAction = factory((_props, ref) => {
  const props = useProps("SpotlightAction", defaultProps$7, _props), {
    className,
    style,
    classNames,
    styles,
    id,
    description,
    label,
    leftSection,
    rightSection,
    children,
    dimmedSections,
    highlightQuery,
    highlightColor,
    closeSpotlightOnTrigger,
    onClick,
    onMouseDown,
    keywords,
    vars,
    ...others
  } = props, ctx = useSpotlightContext(), stylesApi = { classNames, styles }, labelNode = highlightQuery && typeof label == "string" ? /* @__PURE__ */ jsx(
    Highlight,
    {
      component: "span",
      highlight: ctx.query,
      color: highlightColor,
      ...ctx.getStyles("actionLabel", stylesApi),
      children: label
    }
  ) : /* @__PURE__ */ jsx("span", { ...ctx.getStyles("actionLabel", stylesApi), children: label });
  return /* @__PURE__ */ jsx(
    UnstyledButton,
    {
      ref,
      "data-action": !0,
      ...ctx.getStyles("action", { className, style, ...stylesApi }),
      ...others,
      onMouseDown: (event) => {
        event.preventDefault(), onMouseDown?.(event);
      },
      onClick: (event) => {
        onClick?.(event), (closeSpotlightOnTrigger ?? ctx.closeOnActionTrigger) && spotlightActions.close(ctx.store);
      },
      tabIndex: -1,
      children: children || /* @__PURE__ */ jsxs(Fragment$1, { children: [
        leftSection && /* @__PURE__ */ jsx(
          Box,
          {
            component: "span",
            mod: { position: "left", dimmed: dimmedSections },
            ...ctx.getStyles("actionSection", stylesApi),
            children: leftSection
          }
        ),
        /* @__PURE__ */ jsxs("span", { ...ctx.getStyles("actionBody", stylesApi), children: [
          labelNode,
          /* @__PURE__ */ jsx("span", { ...ctx.getStyles("actionDescription", stylesApi), children: description })
        ] }),
        rightSection && /* @__PURE__ */ jsx(
          Box,
          {
            component: "span",
            mod: { position: "right", dimmed: dimmedSections },
            ...ctx.getStyles("actionSection", stylesApi),
            children: rightSection
          }
        )
      ] })
    }
  );
});
SpotlightAction.classes = classes;
SpotlightAction.displayName = "@mantine/spotlight/SpotlightAction";
const defaultProps$6 = {}, SpotlightActionsGroup = factory((props, ref) => {
  const { className, style, styles, classNames, label, children, ...others } = useProps(
    "SpotlightActionsGroup",
    defaultProps$6,
    props
  ), ctx = useSpotlightContext();
  return /* @__PURE__ */ jsx(
    Box,
    {
      ...ctx.getStyles("actionsGroup", { className, style, classNames, styles }),
      ref,
      ...others,
      __vars: { "--spotlight-label": `'${label}'` },
      children
    }
  );
});
SpotlightActionsGroup.classes = classes;
SpotlightActionsGroup.displayName = "@mantine/core/SpotlightActionsGroup";
const defaultProps$5 = {}, SpotlightActionsList = factory((props, ref) => {
  const { className, style, id, children, vars, classNames, styles, ...others } = useProps(
    "SpotlightActionsList",
    defaultProps$5,
    props
  ), ctx = useSpotlightContext(), generatedId = `mantine-${useId$2().replace(/:/g, "")}`, listId = id || generatedId;
  return useEffect(() => (spotlightActions.setListId(listId, ctx.store), () => spotlightActions.setListId("", ctx.store)), []), /* @__PURE__ */ jsx(
    ScrollArea.Autosize,
    {
      ...ctx.getStyles("actionsList", { className, style, classNames, styles }),
      ref,
      type: "scroll",
      scrollbarSize: "var(--spotlight-actions-list-padding)",
      offsetScrollbars: "y",
      id: listId,
      ...others,
      children
    }
  );
});
SpotlightActionsList.classes = classes;
SpotlightActionsList.displayName = "@mantine/spotlight/SpotlightActionsList";
const defaultProps$4 = {}, SpotlightEmpty = factory((props, ref) => {
  const { className, style, classNames, styles, ...others } = useProps(
    "SpotlightEmpty",
    defaultProps$4,
    props
  ), ctx = useSpotlightContext();
  return /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      ...ctx.getStyles("empty", { classNames, styles, className, style }),
      ...others
    }
  );
});
SpotlightEmpty.classes = classes;
SpotlightEmpty.displayName = "@mantine/spotlight/SpotlightEmpty";
const defaultProps$3 = {}, SpotlightFooter = factory((props, ref) => {
  const { className, style, classNames, styles, ...others } = useProps(
    "SpotlightFooter",
    defaultProps$3,
    props
  ), ctx = useSpotlightContext();
  return /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      ...ctx.getStyles("footer", { className, classNames, style, styles }),
      ...others
    }
  );
});
SpotlightFooter.classes = classes;
SpotlightFooter.displayName = "@mantine/spotlight/SpotlightFooter";
function getHotkeys(hotkeys, store) {
  if (!hotkeys)
    return [];
  const open = () => spotlightActions.open(store);
  return Array.isArray(hotkeys) ? hotkeys.map((hotkey) => [hotkey, open]) : [[hotkeys, open]];
}
const defaultProps$2 = {
  size: 600,
  yOffset: 80,
  zIndex: getDefaultZIndex("max"),
  overlayProps: { backgroundOpacity: 0.35, blur: 7 },
  transitionProps: { duration: 200, transition: "pop" },
  store: spotlightStore,
  clearQueryOnClose: !0,
  closeOnActionTrigger: !0,
  shortcut: "mod + K",
  maxHeight: 400,
  scrollable: !1
}, SpotlightRoot = factory((_props, ref) => {
  const props = useProps("SpotlightRoot", defaultProps$2, _props), {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    store,
    children,
    query,
    onQueryChange,
    transitionProps,
    clearQueryOnClose,
    shortcut,
    tagsToIgnore,
    triggerOnContentEditable,
    disabled,
    onSpotlightOpen,
    onSpotlightClose,
    forceOpened,
    closeOnActionTrigger,
    maxHeight,
    scrollable,
    ...others
  } = props, theme = useMantineTheme(), { opened, query: storeQuery } = useSpotlight(store), _query = query || storeQuery, setQuery2 = (q) => {
    onQueryChange?.(q), spotlightActions.setQuery(q, store);
  }, getStyles2 = useStyles({
    name: "Spotlight",
    classes,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled
  });
  return useHotkeys(getHotkeys(shortcut, store), tagsToIgnore, triggerOnContentEditable), useDidUpdate(() => {
    opened ? onSpotlightOpen?.() : onSpotlightClose?.();
  }, [opened]), disabled ? null : /* @__PURE__ */ jsx(
    SpotlightProvider,
    {
      value: {
        getStyles: getStyles2,
        query: _query,
        setQuery: setQuery2,
        store,
        closeOnActionTrigger
      },
      children: /* @__PURE__ */ jsx(
        Modal,
        {
          ref,
          ...others,
          withCloseButton: !1,
          opened: opened || !!forceOpened,
          padding: 0,
          onClose: () => spotlightActions.close(store),
          className,
          style,
          classNames: resolveClassNames({
            theme,
            classNames: [classes, classNames],
            props,
            stylesCtx: void 0
          }),
          styles: resolveStyles({ theme, styles, props, stylesCtx: void 0 }),
          transitionProps: {
            ...transitionProps,
            onExited: () => {
              clearQueryOnClose && setQuery2(""), spotlightActions.clearSpotlightState({ clearQuery: clearQueryOnClose }, store), transitionProps?.onExited?.();
            }
          },
          __vars: { "--spotlight-max-height": scrollable ? rem(maxHeight) : void 0 },
          __staticSelector: "Spotlight",
          "data-scrollable": scrollable || void 0,
          children
        }
      )
    }
  );
});
SpotlightRoot.classes = classes;
SpotlightRoot.displayName = "@mantine/spotlight/SpotlightRoot";
const defaultProps$1 = {
  size: "lg"
}, SpotlightSearch = factory((props, ref) => {
  const { classNames, styles, onKeyDown, onChange, vars, value, ...others } = useProps(
    "SpotlightSearch",
    defaultProps$1,
    props
  ), ctx = useSpotlightContext(), inputStyles = ctx.getStyles("search"), [isComposing, setIsComposing] = useState(!1), handleKeyDown = (event) => {
    onKeyDown?.(event), !isComposing && (event.nativeEvent.code === "ArrowDown" && (event.preventDefault(), spotlightActions.selectNextAction(ctx.store)), event.nativeEvent.code === "ArrowUp" && (event.preventDefault(), spotlightActions.selectPreviousAction(ctx.store)), (event.nativeEvent.code === "Enter" || event.nativeEvent.code === "NumpadEnter") && (event.preventDefault(), spotlightActions.triggerSelectedAction(ctx.store)));
  };
  return /* @__PURE__ */ jsx(
    Input,
    {
      ref,
      classNames: [{ input: inputStyles.className }, classNames],
      styles: [{ input: inputStyles.style }, styles],
      ...others,
      value: value ?? ctx.query,
      onChange: (event) => {
        ctx.setQuery(event.currentTarget.value), onChange?.(event);
      },
      onKeyDown: handleKeyDown,
      onCompositionStart: () => setIsComposing(!0),
      onCompositionEnd: () => setIsComposing(!1)
    }
  );
});
SpotlightSearch.classes = classes;
SpotlightSearch.displayName = "@mantine/spotlight/SpotlightSearch";
const defaultProps = {
  size: 600,
  yOffset: 80,
  limit: 1 / 0,
  zIndex: getDefaultZIndex("max"),
  overlayProps: { backgroundOpacity: 0.35, blur: 7 },
  transitionProps: { duration: 200, transition: "pop" },
  store: spotlightStore,
  filter: defaultSpotlightFilter,
  clearQueryOnClose: !0,
  closeOnActionTrigger: !0,
  shortcut: "mod + K",
  highlightQuery: !1
}, Spotlight = factory((_props, ref) => {
  const props = useProps("Spotlight", defaultProps, _props), {
    searchProps,
    filter,
    query,
    onQueryChange,
    actions,
    nothingFound,
    highlightQuery,
    limit,
    ...others
  } = props, [_query, setQuery2] = useUncontrolled({
    value: query,
    defaultValue: "",
    finalValue: "",
    onChange: onQueryChange
  }), filteredActions = limitActions(filter(_query, actions), limit).map((item) => {
    if (isActionsGroup(item)) {
      const items = item.actions.map(({ id, ...actionData }) => /* @__PURE__ */ jsx(SpotlightAction, { highlightQuery, ...actionData }, id));
      return /* @__PURE__ */ jsx(SpotlightActionsGroup, { label: item.group, children: items }, item.group);
    }
    return /* @__PURE__ */ jsx(SpotlightAction, { highlightQuery, ...item }, item.id);
  });
  return /* @__PURE__ */ jsxs(SpotlightRoot, { ...others, query: _query, onQueryChange: setQuery2, ref, children: [
    /* @__PURE__ */ jsx(SpotlightSearch, { ...searchProps }),
    /* @__PURE__ */ jsxs(SpotlightActionsList, { children: [
      filteredActions,
      filteredActions.length === 0 && nothingFound && /* @__PURE__ */ jsx(SpotlightEmpty, { children: nothingFound })
    ] })
  ] });
});
Spotlight.classes = classes;
Spotlight.displayName = "@mantine/spotlight/Spotlight";
Spotlight.Search = SpotlightSearch;
Spotlight.ActionsList = SpotlightActionsList;
Spotlight.Action = SpotlightAction;
Spotlight.Empty = SpotlightEmpty;
Spotlight.ActionsGroup = SpotlightActionsGroup;
Spotlight.Footer = SpotlightFooter;
Spotlight.Root = SpotlightRoot;
Spotlight.open = spotlight.open;
Spotlight.close = spotlight.close;
Spotlight.toggle = spotlight.toggle;
export {
  useLocalStorage as $,
  ActionIcon as A,
  Box as B,
  Card as C,
  Pill as D,
  Divider as E,
  useViewportSize as F,
  Group as G,
  Highlight as H,
  Image as I,
  FocusTrap as J,
  FocusTrapInitialFocus as K,
  CloseButton as L,
  Badge as M,
  Flex as N,
  ActionIconGroup as O,
  Paper as P,
  Tabs as Q,
  RemoveScroll as R,
  Spotlight as S,
  ThemeIcon as T,
  TabsList as U,
  TabsTab as V,
  TabsPanel as W,
  ScrollArea as X,
  UnstyledButton as Y,
  CopyButton as Z,
  Code as _,
  Text as a,
  useStateHistory as a0,
  Space as a1,
  useHotkeys as a2,
  MantineContext as a3,
  Menu as a4,
  MenuTarget as a5,
  MenuDropdown as a6,
  MenuLabel as a7,
  MenuDivider as a8,
  TooltipGroup as a9,
  ModalRoot as aA,
  ModalOverlay as aB,
  ModalContent as aC,
  ModalBody as aD,
  useMantineTheme as aE,
  useMediaQuery as aF,
  useDisclosure as aG,
  LoadingOverlay as aH,
  useCallbackRef as aI,
  Burger as aJ,
  Loader as aK,
  MenuItem as aa,
  keys as ab,
  ColorSwatch as ac,
  CheckIcon as ad,
  rem as ae,
  Slider as af,
  useDebouncedValue as ag,
  Spoiler as ah,
  ButtonGroup as ai,
  useHover$1 as aj,
  FloatingIndicator as ak,
  useUncontrolled as al,
  clampUseMovePosition as am,
  useMove as an,
  openSpotlight as ao,
  HoverCard as ap,
  HoverCardTarget as aq,
  Overlay as ar,
  HoverCardDropdown as as,
  Notification as at,
  createTheme as au,
  MantineProvider as av,
  useInViewport as aw,
  SimpleGrid as ax,
  Drawer as ay,
  Select as az,
  CardSection as b,
  clsx as c,
  Center as d,
  Container as e,
  Title as f,
  Button as g,
  useReducedMotion as h,
  useMergedRef as i,
  useMantineStyleNonce as j,
  SpotlightActionsGroup as k,
  useComputedColorScheme as l,
  Popover as m,
  PopoverTarget as n,
  PopoverDropdown as o,
  ScrollAreaAutosize as p,
  Stack as q,
  useTree as r,
  Tree as s,
  themeToVars as t,
  useMantineColorScheme as u,
  Tooltip as v,
  useId$1 as w,
  SegmentedControl as x,
  Alert as y,
  Anchor as z
};
