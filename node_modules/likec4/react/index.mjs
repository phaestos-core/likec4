var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key != "symbol" ? key + "" : key, value), __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj)), __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value), __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value), __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
import { jsx, jsxs, Fragment } from "react/jsx-runtime";
import * as React from "react";
import React__default, { createContext, memo as memo$1, useState, forwardRef, useCallback, useMemo, useRef, useEffect, useContext, useLayoutEffect, Fragment as Fragment$1, useId as useId$2, cloneElement, Children, createElement, Component, useInsertionEffect as useInsertionEffect$1, isValidElement, useSyncExternalStore } from "react";
import * as ReactDOM from "react-dom";
import ReactDOM__default, { createPortal } from "react-dom";
function cc(names) {
  if (typeof names == "string" || typeof names == "number") return "" + names;
  let out = "";
  if (Array.isArray(names))
    for (let i2 = 0, tmp; i2 < names.length; i2++)
      (tmp = cc(names[i2])) !== "" && (out += (out && " ") + tmp);
  else
    for (let k2 in names)
      names[k2] && (out += (out && " ") + k2);
  return out;
}
var noop$4 = { value: () => {
} };
function dispatch() {
  for (var i2 = 0, n2 = arguments.length, _ = {}, t2; i2 < n2; ++i2) {
    if (!(t2 = arguments[i2] + "") || t2 in _ || /[\s.]/.test(t2)) throw new Error("illegal type: " + t2);
    _[t2] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames$1(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t2) {
    var name = "", i2 = t2.indexOf(".");
    if (i2 >= 0 && (name = t2.slice(i2 + 1), t2 = t2.slice(0, i2)), t2 && !types.hasOwnProperty(t2)) throw new Error("unknown type: " + t2);
    return { type: t2, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._, T2 = parseTypenames$1(typename + "", _), t2, i2 = -1, n2 = T2.length;
    if (arguments.length < 2) {
      for (; ++i2 < n2; ) if ((t2 = (typename = T2[i2]).type) && (t2 = get$1(_[t2], typename.name))) return t2;
      return;
    }
    if (callback != null && typeof callback != "function") throw new Error("invalid callback: " + callback);
    for (; ++i2 < n2; )
      if (t2 = (typename = T2[i2]).type) _[t2] = set$1(_[t2], typename.name, callback);
      else if (callback == null) for (t2 in _) _[t2] = set$1(_[t2], typename.name, null);
    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t2 in _) copy[t2] = _[t2].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n2 = arguments.length - 2) > 0) for (var args = new Array(n2), i2 = 0, n2, t2; i2 < n2; ++i2) args[i2] = arguments[i2 + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t2 = this._[type], i2 = 0, n2 = t2.length; i2 < n2; ++i2) t2[i2].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t2 = this._[type], i2 = 0, n2 = t2.length; i2 < n2; ++i2) t2[i2].value.apply(that, args);
  }
};
function get$1(type, name) {
  for (var i2 = 0, n2 = type.length, c; i2 < n2; ++i2)
    if ((c = type[i2]).name === name)
      return c.value;
}
function set$1(type, name, callback) {
  for (var i2 = 0, n2 = type.length; i2 < n2; ++i2)
    if (type[i2].name === name) {
      type[i2] = noop$4, type = type.slice(0, i2).concat(type.slice(i2 + 1));
      break;
    }
  return callback != null && type.push({ name, value: callback }), type;
}
var xhtml = "http://www.w3.org/1999/xhtml";
const namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function namespace(name) {
  var prefix = name += "", i2 = prefix.indexOf(":");
  return i2 >= 0 && (prefix = name.slice(0, i2)) !== "xmlns" && (name = name.slice(i2 + 1)), namespaces.hasOwnProperty(prefix) ? { space: namespaces[prefix], local: name } : name;
}
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator(name) {
  var fullname = namespace(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}
function none() {
}
function selector$q(selector2) {
  return selector2 == null ? none : function() {
    return this.querySelector(selector2);
  };
}
function selection_select(select2) {
  typeof select2 != "function" && (select2 = selector$q(select2));
  for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j2 = 0; j2 < m2; ++j2)
    for (var group = groups[j2], n2 = group.length, subgroup = subgroups[j2] = new Array(n2), node2, subnode, i2 = 0; i2 < n2; ++i2)
      (node2 = group[i2]) && (subnode = select2.call(node2, node2.__data__, i2, group)) && ("__data__" in node2 && (subnode.__data__ = node2.__data__), subgroup[i2] = subnode);
  return new Selection$1(subgroups, this._parents);
}
function array$1(x2) {
  return x2 == null ? [] : Array.isArray(x2) ? x2 : Array.from(x2);
}
function empty() {
  return [];
}
function selectorAll(selector2) {
  return selector2 == null ? empty : function() {
    return this.querySelectorAll(selector2);
  };
}
function arrayAll(select2) {
  return function() {
    return array$1(select2.apply(this, arguments));
  };
}
function selection_selectAll(select2) {
  typeof select2 == "function" ? select2 = arrayAll(select2) : select2 = selectorAll(select2);
  for (var groups = this._groups, m2 = groups.length, subgroups = [], parents = [], j2 = 0; j2 < m2; ++j2)
    for (var group = groups[j2], n2 = group.length, node2, i2 = 0; i2 < n2; ++i2)
      (node2 = group[i2]) && (subgroups.push(select2.call(node2, node2.__data__, i2, group)), parents.push(node2));
  return new Selection$1(subgroups, parents);
}
function matcher(selector2) {
  return function() {
    return this.matches(selector2);
  };
}
function childMatcher(selector2) {
  return function(node2) {
    return node2.matches(selector2);
  };
}
var find = Array.prototype.find;
function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selection_selectChild(match) {
  return this.select(match == null ? childFirst : childFind(typeof match == "function" ? match : childMatcher(match)));
}
var filter$1 = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter$1.call(this.children, match);
  };
}
function selection_selectChildren(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match == "function" ? match : childMatcher(match)));
}
function selection_filter(match) {
  typeof match != "function" && (match = matcher(match));
  for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j2 = 0; j2 < m2; ++j2)
    for (var group = groups[j2], n2 = group.length, subgroup = subgroups[j2] = [], node2, i2 = 0; i2 < n2; ++i2)
      (node2 = group[i2]) && match.call(node2, node2.__data__, i2, group) && subgroup.push(node2);
  return new Selection$1(subgroups, this._parents);
}
function sparse(update) {
  return new Array(update.length);
}
function selection_enter() {
  return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument, this.namespaceURI = parent.namespaceURI, this._next = null, this._parent = parent, this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector2) {
    return this._parent.querySelector(selector2);
  },
  querySelectorAll: function(selector2) {
    return this._parent.querySelectorAll(selector2);
  }
};
function constant$4(x2) {
  return function() {
    return x2;
  };
}
function bindIndex(parent, group, enter, update, exit, data) {
  for (var i2 = 0, node2, groupLength = group.length, dataLength = data.length; i2 < dataLength; ++i2)
    (node2 = group[i2]) ? (node2.__data__ = data[i2], update[i2] = node2) : enter[i2] = new EnterNode(parent, data[i2]);
  for (; i2 < groupLength; ++i2)
    (node2 = group[i2]) && (exit[i2] = node2);
}
function bindKey(parent, group, enter, update, exit, data, key) {
  var i2, node2, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i2 = 0; i2 < groupLength; ++i2)
    (node2 = group[i2]) && (keyValues[i2] = keyValue = key.call(node2, node2.__data__, i2, group) + "", nodeByKeyValue.has(keyValue) ? exit[i2] = node2 : nodeByKeyValue.set(keyValue, node2));
  for (i2 = 0; i2 < dataLength; ++i2)
    keyValue = key.call(parent, data[i2], i2, data) + "", (node2 = nodeByKeyValue.get(keyValue)) ? (update[i2] = node2, node2.__data__ = data[i2], nodeByKeyValue.delete(keyValue)) : enter[i2] = new EnterNode(parent, data[i2]);
  for (i2 = 0; i2 < groupLength; ++i2)
    (node2 = group[i2]) && nodeByKeyValue.get(keyValues[i2]) === node2 && (exit[i2] = node2);
}
function datum(node2) {
  return node2.__data__;
}
function selection_data(value, key) {
  if (!arguments.length) return Array.from(this, datum);
  var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
  typeof value != "function" && (value = constant$4(value));
  for (var m2 = groups.length, update = new Array(m2), enter = new Array(m2), exit = new Array(m2), j2 = 0; j2 < m2; ++j2) {
    var parent = parents[j2], group = groups[j2], groupLength = group.length, data = arraylike(value.call(parent, parent && parent.__data__, j2, parents)), dataLength = data.length, enterGroup = enter[j2] = new Array(dataLength), updateGroup = update[j2] = new Array(dataLength), exitGroup = exit[j2] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0)
      if (previous = enterGroup[i0]) {
        for (i0 >= i1 && (i1 = i0 + 1); !(next = updateGroup[i1]) && ++i1 < dataLength; ) ;
        previous._next = next || null;
      }
  }
  return update = new Selection$1(update, parents), update._enter = enter, update._exit = exit, update;
}
function arraylike(data) {
  return typeof data == "object" && "length" in data ? data : Array.from(data);
}
function selection_exit() {
  return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
}
function selection_join(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  return typeof onenter == "function" ? (enter = onenter(enter), enter && (enter = enter.selection())) : enter = enter.append(onenter + ""), onupdate != null && (update = onupdate(update), update && (update = update.selection())), onexit == null ? exit.remove() : onexit(exit), enter && update ? enter.merge(update).order() : update;
}
function selection_merge(context) {
  for (var selection2 = context.selection ? context.selection() : context, groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j2 = 0; j2 < m2; ++j2)
    for (var group0 = groups0[j2], group1 = groups1[j2], n2 = group0.length, merge3 = merges[j2] = new Array(n2), node2, i2 = 0; i2 < n2; ++i2)
      (node2 = group0[i2] || group1[i2]) && (merge3[i2] = node2);
  for (; j2 < m0; ++j2)
    merges[j2] = groups0[j2];
  return new Selection$1(merges, this._parents);
}
function selection_order() {
  for (var groups = this._groups, j2 = -1, m2 = groups.length; ++j2 < m2; )
    for (var group = groups[j2], i2 = group.length - 1, next = group[i2], node2; --i2 >= 0; )
      (node2 = group[i2]) && (next && node2.compareDocumentPosition(next) ^ 4 && next.parentNode.insertBefore(node2, next), next = node2);
  return this;
}
function selection_sort(compare2) {
  compare2 || (compare2 = ascending);
  function compareNode(a2, b2) {
    return a2 && b2 ? compare2(a2.__data__, b2.__data__) : !a2 - !b2;
  }
  for (var groups = this._groups, m2 = groups.length, sortgroups = new Array(m2), j2 = 0; j2 < m2; ++j2) {
    for (var group = groups[j2], n2 = group.length, sortgroup = sortgroups[j2] = new Array(n2), node2, i2 = 0; i2 < n2; ++i2)
      (node2 = group[i2]) && (sortgroup[i2] = node2);
    sortgroup.sort(compareNode);
  }
  return new Selection$1(sortgroups, this._parents).order();
}
function ascending(a2, b2) {
  return a2 < b2 ? -1 : a2 > b2 ? 1 : a2 >= b2 ? 0 : NaN;
}
function selection_call() {
  var callback = arguments[0];
  return arguments[0] = this, callback.apply(null, arguments), this;
}
function selection_nodes() {
  return Array.from(this);
}
function selection_node() {
  for (var groups = this._groups, j2 = 0, m2 = groups.length; j2 < m2; ++j2)
    for (var group = groups[j2], i2 = 0, n2 = group.length; i2 < n2; ++i2) {
      var node2 = group[i2];
      if (node2) return node2;
    }
  return null;
}
function selection_size() {
  let size2 = 0;
  for (const node2 of this) ++size2;
  return size2;
}
function selection_empty() {
  return !this.node();
}
function selection_each(callback) {
  for (var groups = this._groups, j2 = 0, m2 = groups.length; j2 < m2; ++j2)
    for (var group = groups[j2], i2 = 0, n2 = group.length, node2; i2 < n2; ++i2)
      (node2 = group[i2]) && callback.call(node2, node2.__data__, i2, group);
  return this;
}
function attrRemove$1(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS$1(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant$1(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}
function attrConstantNS$1(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction$1(name, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    v2 == null ? this.removeAttribute(name) : this.setAttribute(name, v2);
  };
}
function attrFunctionNS$1(fullname, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    v2 == null ? this.removeAttributeNS(fullname.space, fullname.local) : this.setAttributeNS(fullname.space, fullname.local, v2);
  };
}
function selection_attr(name, value) {
  var fullname = namespace(name);
  if (arguments.length < 2) {
    var node2 = this.node();
    return fullname.local ? node2.getAttributeNS(fullname.space, fullname.local) : node2.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS$1 : attrRemove$1 : typeof value == "function" ? fullname.local ? attrFunctionNS$1 : attrFunction$1 : fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, value));
}
function defaultView(node2) {
  return node2.ownerDocument && node2.ownerDocument.defaultView || node2.document && node2 || node2.defaultView;
}
function styleRemove$1(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant$1(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction$1(name, value, priority) {
  return function() {
    var v2 = value.apply(this, arguments);
    v2 == null ? this.style.removeProperty(name) : this.style.setProperty(name, v2, priority);
  };
}
function selection_style(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove$1 : typeof value == "function" ? styleFunction$1 : styleConstant$1)(name, value, priority ?? "")) : styleValue(this.node(), name);
}
function styleValue(node2, name) {
  return node2.style.getPropertyValue(name) || defaultView(node2).getComputedStyle(node2, null).getPropertyValue(name);
}
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}
function propertyFunction(name, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    v2 == null ? delete this[name] : this[name] = v2;
  };
}
function selection_property(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value == "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}
function classArray(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node2) {
  return node2.classList || new ClassList(node2);
}
function ClassList(node2) {
  this._node = node2, this._names = classArray(node2.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i2 = this._names.indexOf(name);
    i2 < 0 && (this._names.push(name), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(name) {
    var i2 = this._names.indexOf(name);
    i2 >= 0 && (this._names.splice(i2, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node2, names) {
  for (var list2 = classList(node2), i2 = -1, n2 = names.length; ++i2 < n2; ) list2.add(names[i2]);
}
function classedRemove(node2, names) {
  for (var list2 = classList(node2), i2 = -1, n2 = names.length; ++i2 < n2; ) list2.remove(names[i2]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function selection_classed(name, value) {
  var names = classArray(name + "");
  if (arguments.length < 2) {
    for (var list2 = classList(this.node()), i2 = -1, n2 = names.length; ++i2 < n2; ) if (!list2.contains(names[i2])) return !1;
    return !0;
  }
  return this.each((typeof value == "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}
function textRemove() {
  this.textContent = "";
}
function textConstant$1(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction$1(value) {
  return function() {
    var v2 = value.apply(this, arguments);
    this.textContent = v2 ?? "";
  };
}
function selection_text(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value == "function" ? textFunction$1 : textConstant$1)(value)) : this.node().textContent;
}
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v2 = value.apply(this, arguments);
    this.innerHTML = v2 ?? "";
  };
}
function selection_html(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value == "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}
function raise() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function selection_raise() {
  return this.each(raise);
}
function lower() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function selection_lower() {
  return this.each(lower);
}
function selection_append(name) {
  var create2 = typeof name == "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}
function constantNull() {
  return null;
}
function selection_insert(name, before) {
  var create2 = typeof name == "function" ? name : creator(name), select2 = before == null ? constantNull : typeof before == "function" ? before : selector$q(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select2.apply(this, arguments) || null);
  });
}
function remove() {
  var parent = this.parentNode;
  parent && parent.removeChild(this);
}
function selection_remove() {
  return this.each(remove);
}
function selection_cloneShallow() {
  var clone = this.cloneNode(!1), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep() {
  var clone = this.cloneNode(!0), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}
function selection_datum(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t2) {
    var name = "", i2 = t2.indexOf(".");
    return i2 >= 0 && (name = t2.slice(i2 + 1), t2 = t2.slice(0, i2)), { type: t2, name };
  });
}
function onRemove(typename) {
  return function() {
    var on2 = this.__on;
    if (on2) {
      for (var j2 = 0, i2 = -1, m2 = on2.length, o2; j2 < m2; ++j2)
        o2 = on2[j2], (!typename.type || o2.type === typename.type) && o2.name === typename.name ? this.removeEventListener(o2.type, o2.listener, o2.options) : on2[++i2] = o2;
      ++i2 ? on2.length = i2 : delete this.__on;
    }
  };
}
function onAdd(typename, value, options) {
  return function() {
    var on2 = this.__on, o2, listener = contextListener(value);
    if (on2) {
      for (var j2 = 0, m2 = on2.length; j2 < m2; ++j2)
        if ((o2 = on2[j2]).type === typename.type && o2.name === typename.name) {
          this.removeEventListener(o2.type, o2.listener, o2.options), this.addEventListener(o2.type, o2.listener = listener, o2.options = options), o2.value = value;
          return;
        }
    }
    this.addEventListener(typename.type, listener, options), o2 = { type: typename.type, name: typename.name, value, listener, options }, on2 ? on2.push(o2) : this.__on = [o2];
  };
}
function selection_on(typename, value, options) {
  var typenames = parseTypenames(typename + ""), i2, n2 = typenames.length, t2;
  if (arguments.length < 2) {
    var on2 = this.node().__on;
    if (on2) {
      for (var j2 = 0, m2 = on2.length, o2; j2 < m2; ++j2)
        for (i2 = 0, o2 = on2[j2]; i2 < n2; ++i2)
          if ((t2 = typenames[i2]).type === o2.type && t2.name === o2.name)
            return o2.value;
    }
    return;
  }
  for (on2 = value ? onAdd : onRemove, i2 = 0; i2 < n2; ++i2) this.each(on2(typenames[i2], value, options));
  return this;
}
function dispatchEvent(node2, type, params) {
  var window2 = defaultView(node2), event = window2.CustomEvent;
  typeof event == "function" ? event = new event(type, params) : (event = window2.document.createEvent("Event"), params ? (event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail) : event.initEvent(type, !1, !1)), node2.dispatchEvent(event);
}
function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}
function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}
function selection_dispatch(type, params) {
  return this.each((typeof params == "function" ? dispatchFunction : dispatchConstant)(type, params));
}
function* selection_iterator() {
  for (var groups = this._groups, j2 = 0, m2 = groups.length; j2 < m2; ++j2)
    for (var group = groups[j2], i2 = 0, n2 = group.length, node2; i2 < n2; ++i2)
      (node2 = group[i2]) && (yield node2);
}
var root$1 = [null];
function Selection$1(groups, parents) {
  this._groups = groups, this._parents = parents;
}
function selection() {
  return new Selection$1([[document.documentElement]], root$1);
}
function selection_selection() {
  return this;
}
Selection$1.prototype = selection.prototype = {
  constructor: Selection$1,
  select: selection_select,
  selectAll: selection_selectAll,
  selectChild: selection_selectChild,
  selectChildren: selection_selectChildren,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  join: selection_join,
  merge: selection_merge,
  selection: selection_selection,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch,
  [Symbol.iterator]: selection_iterator
};
function select(selector2) {
  return typeof selector2 == "string" ? new Selection$1([[document.querySelector(selector2)]], [document.documentElement]) : new Selection$1([[selector2]], root$1);
}
function sourceEvent(event) {
  let sourceEvent2;
  for (; sourceEvent2 = event.sourceEvent; ) event = sourceEvent2;
  return event;
}
function pointer(event, node2) {
  if (event = sourceEvent(event), node2 === void 0 && (node2 = event.currentTarget), node2) {
    var svg = node2.ownerSVGElement || node2;
    if (svg.createSVGPoint) {
      var point2 = svg.createSVGPoint();
      return point2.x = event.clientX, point2.y = event.clientY, point2 = point2.matrixTransform(node2.getScreenCTM().inverse()), [point2.x, point2.y];
    }
    if (node2.getBoundingClientRect) {
      var rect = node2.getBoundingClientRect();
      return [event.clientX - rect.left - node2.clientLeft, event.clientY - rect.top - node2.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}
const nonpassive = { passive: !1 }, nonpassivecapture = { capture: !0, passive: !1 };
function nopropagation$1(event) {
  event.stopImmediatePropagation();
}
function noevent$1(event) {
  event.preventDefault(), event.stopImmediatePropagation();
}
function dragDisable(view) {
  var root2 = view.document.documentElement, selection2 = select(view).on("dragstart.drag", noevent$1, nonpassivecapture);
  "onselectstart" in root2 ? selection2.on("selectstart.drag", noevent$1, nonpassivecapture) : (root2.__noselect = root2.style.MozUserSelect, root2.style.MozUserSelect = "none");
}
function yesdrag(view, noclick) {
  var root2 = view.document.documentElement, selection2 = select(view).on("dragstart.drag", null);
  noclick && (selection2.on("click.drag", noevent$1, nonpassivecapture), setTimeout(function() {
    selection2.on("click.drag", null);
  }, 0)), "onselectstart" in root2 ? selection2.on("selectstart.drag", null) : (root2.style.MozUserSelect = root2.__noselect, delete root2.__noselect);
}
const constant$3 = (x2) => () => x2;
function DragEvent(type, {
  sourceEvent: sourceEvent2,
  subject,
  target,
  identifier,
  active,
  x: x2,
  y: y2,
  dx,
  dy,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type, enumerable: !0, configurable: !0 },
    sourceEvent: { value: sourceEvent2, enumerable: !0, configurable: !0 },
    subject: { value: subject, enumerable: !0, configurable: !0 },
    target: { value: target, enumerable: !0, configurable: !0 },
    identifier: { value: identifier, enumerable: !0, configurable: !0 },
    active: { value: active, enumerable: !0, configurable: !0 },
    x: { value: x2, enumerable: !0, configurable: !0 },
    y: { value: y2, enumerable: !0, configurable: !0 },
    dx: { value: dx, enumerable: !0, configurable: !0 },
    dy: { value: dy, enumerable: !0, configurable: !0 },
    _: { value: dispatch2 }
  });
}
DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};
function defaultFilter$1(event) {
  return !event.ctrlKey && !event.button;
}
function defaultContainer() {
  return this.parentNode;
}
function defaultSubject(event, d2) {
  return d2 ?? { x: event.x, y: event.y };
}
function defaultTouchable$1() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function drag$1() {
  var filter2 = defaultFilter$1, container2 = defaultContainer, subject = defaultSubject, touchable = defaultTouchable$1, gestures = {}, listeners = dispatch("start", "drag", "end"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
  function drag2(selection2) {
    selection2.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved, nonpassive).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function mousedowned(event, d2) {
    if (!(touchending || !filter2.call(this, event, d2))) {
      var gesture = beforestart(this, container2.call(this, event, d2), event, d2, "mouse");
      gesture && (select(event.view).on("mousemove.drag", mousemoved, nonpassivecapture).on("mouseup.drag", mouseupped, nonpassivecapture), dragDisable(event.view), nopropagation$1(event), mousemoving = !1, mousedownx = event.clientX, mousedowny = event.clientY, gesture("start", event));
    }
  }
  function mousemoved(event) {
    if (noevent$1(event), !mousemoving) {
      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag", event);
  }
  function mouseupped(event) {
    select(event.view).on("mousemove.drag mouseup.drag", null), yesdrag(event.view, mousemoving), noevent$1(event), gestures.mouse("end", event);
  }
  function touchstarted(event, d2) {
    if (filter2.call(this, event, d2)) {
      var touches = event.changedTouches, c = container2.call(this, event, d2), n2 = touches.length, i2, gesture;
      for (i2 = 0; i2 < n2; ++i2)
        (gesture = beforestart(this, c, event, d2, touches[i2].identifier, touches[i2])) && (nopropagation$1(event), gesture("start", event, touches[i2]));
    }
  }
  function touchmoved(event) {
    var touches = event.changedTouches, n2 = touches.length, i2, gesture;
    for (i2 = 0; i2 < n2; ++i2)
      (gesture = gestures[touches[i2].identifier]) && (noevent$1(event), gesture("drag", event, touches[i2]));
  }
  function touchended(event) {
    var touches = event.changedTouches, n2 = touches.length, i2, gesture;
    for (touchending && clearTimeout(touchending), touchending = setTimeout(function() {
      touchending = null;
    }, 500), i2 = 0; i2 < n2; ++i2)
      (gesture = gestures[touches[i2].identifier]) && (nopropagation$1(event), gesture("end", event, touches[i2]));
  }
  function beforestart(that, container3, event, d2, identifier, touch) {
    var dispatch2 = listeners.copy(), p2 = pointer(touch || event, container3), dx, dy, s2;
    if ((s2 = subject.call(that, new DragEvent("beforestart", {
      sourceEvent: event,
      target: drag2,
      identifier,
      active,
      x: p2[0],
      y: p2[1],
      dx: 0,
      dy: 0,
      dispatch: dispatch2
    }), d2)) != null)
      return dx = s2.x - p2[0] || 0, dy = s2.y - p2[1] || 0, function gesture(type, event2, touch2) {
        var p0 = p2, n2;
        switch (type) {
          case "start":
            gestures[identifier] = gesture, n2 = active++;
            break;
          case "end":
            delete gestures[identifier], --active;
          case "drag":
            p2 = pointer(touch2 || event2, container3), n2 = active;
            break;
        }
        dispatch2.call(
          type,
          that,
          new DragEvent(type, {
            sourceEvent: event2,
            subject: s2,
            target: drag2,
            identifier,
            active: n2,
            x: p2[0] + dx,
            y: p2[1] + dy,
            dx: p2[0] - p0[0],
            dy: p2[1] - p0[1],
            dispatch: dispatch2
          }),
          d2
        );
      };
  }
  return drag2.filter = function(_) {
    return arguments.length ? (filter2 = typeof _ == "function" ? _ : constant$3(!!_), drag2) : filter2;
  }, drag2.container = function(_) {
    return arguments.length ? (container2 = typeof _ == "function" ? _ : constant$3(_), drag2) : container2;
  }, drag2.subject = function(_) {
    return arguments.length ? (subject = typeof _ == "function" ? _ : constant$3(_), drag2) : subject;
  }, drag2.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ == "function" ? _ : constant$3(!!_), drag2) : touchable;
  }, drag2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag2 : value;
  }, drag2.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag2) : Math.sqrt(clickDistance2);
  }, drag2;
}
function define(constructor, factory2, prototype) {
  constructor.prototype = factory2.prototype = prototype, prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}
function Color() {
}
var darker = 0.7, brighter = 1 / darker, reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`), named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define(Color, color$1, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color$1(format) {
  var m2, l2;
  return format = (format + "").trim().toLowerCase(), (m2 = reHex.exec(format)) ? (l2 = m2[1].length, m2 = parseInt(m2[1], 16), l2 === 6 ? rgbn(m2) : l2 === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l2 === 8 ? rgba$2(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l2 === 4 ? rgba$2(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format)) ? rgba$2(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format)) ? rgba$2(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format)) ? hsla$1(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format)) ? hsla$1(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n2) {
  return new Rgb(n2 >> 16 & 255, n2 >> 8 & 255, n2 & 255, 1);
}
function rgba$2(r2, g2, b2, a2) {
  return a2 <= 0 && (r2 = g2 = b2 = NaN), new Rgb(r2, g2, b2, a2);
}
function rgbConvert(o2) {
  return o2 instanceof Color || (o2 = color$1(o2)), o2 ? (o2 = o2.rgb(), new Rgb(o2.r, o2.g, o2.b, o2.opacity)) : new Rgb();
}
function rgb(r2, g2, b2, opacity) {
  return arguments.length === 1 ? rgbConvert(r2) : new Rgb(r2, g2, b2, opacity ?? 1);
}
function Rgb(r2, g2, b2, opacity) {
  this.r = +r2, this.g = +g2, this.b = +b2, this.opacity = +opacity;
}
define(Rgb, rgb, extend(Color, {
  brighter(k2) {
    return k2 = k2 == null ? brighter : Math.pow(brighter, k2), new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  darker(k2) {
    return k2 = k2 == null ? darker : Math.pow(darker, k2), new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex$1(this.r)}${hex$1(this.g)}${hex$1(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex$1(this.r)}${hex$1(this.g)}${hex$1(this.b)}${hex$1((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a2 = clampa(this.opacity);
  return `${a2 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a2 === 1 ? ")" : `, ${a2})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex$1(value) {
  return value = clampi(value), (value < 16 ? "0" : "") + value.toString(16);
}
function hsla$1(h2, s2, l2, a2) {
  return a2 <= 0 ? h2 = s2 = l2 = NaN : l2 <= 0 || l2 >= 1 ? h2 = s2 = NaN : s2 <= 0 && (h2 = NaN), new Hsl(h2, s2, l2, a2);
}
function hslConvert(o2) {
  if (o2 instanceof Hsl) return new Hsl(o2.h, o2.s, o2.l, o2.opacity);
  if (o2 instanceof Color || (o2 = color$1(o2)), !o2) return new Hsl();
  if (o2 instanceof Hsl) return o2;
  o2 = o2.rgb();
  var r2 = o2.r / 255, g2 = o2.g / 255, b2 = o2.b / 255, min2 = Math.min(r2, g2, b2), max2 = Math.max(r2, g2, b2), h2 = NaN, s2 = max2 - min2, l2 = (max2 + min2) / 2;
  return s2 ? (r2 === max2 ? h2 = (g2 - b2) / s2 + (g2 < b2) * 6 : g2 === max2 ? h2 = (b2 - r2) / s2 + 2 : h2 = (r2 - g2) / s2 + 4, s2 /= l2 < 0.5 ? max2 + min2 : 2 - max2 - min2, h2 *= 60) : s2 = l2 > 0 && l2 < 1 ? 0 : h2, new Hsl(h2, s2, l2, o2.opacity);
}
function hsl(h2, s2, l2, opacity) {
  return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s2, l2, opacity ?? 1);
}
function Hsl(h2, s2, l2, opacity) {
  this.h = +h2, this.s = +s2, this.l = +l2, this.opacity = +opacity;
}
define(Hsl, hsl, extend(Color, {
  brighter(k2) {
    return k2 = k2 == null ? brighter : Math.pow(brighter, k2), new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  darker(k2) {
    return k2 = k2 == null ? darker : Math.pow(darker, k2), new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb() {
    var h2 = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l2 = this.l, m2 = l2 + (l2 < 0.5 ? l2 : 1 - l2) * s2, m1 = 2 * l2 - m2;
    return new Rgb(
      hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2),
      hsl2rgb(h2, m1, m2),
      hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const a2 = clampa(this.opacity);
    return `${a2 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a2 === 1 ? ")" : `, ${a2})`}`;
  }
}));
function clamph(value) {
  return value = (value || 0) % 360, value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h2, m1, m2) {
  return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
}
const constant$2 = (x2) => () => x2;
function linear(a2, d2) {
  return function(t2) {
    return a2 + t2 * d2;
  };
}
function exponential(a2, b2, y2) {
  return a2 = Math.pow(a2, y2), b2 = Math.pow(b2, y2) - a2, y2 = 1 / y2, function(t2) {
    return Math.pow(a2 + t2 * b2, y2);
  };
}
function gamma(y2) {
  return (y2 = +y2) == 1 ? nogamma : function(a2, b2) {
    return b2 - a2 ? exponential(a2, b2, y2) : constant$2(isNaN(a2) ? b2 : a2);
  };
}
function nogamma(a2, b2) {
  var d2 = b2 - a2;
  return d2 ? linear(a2, d2) : constant$2(isNaN(a2) ? b2 : a2);
}
const interpolateRgb = function rgbGamma(y2) {
  var color2 = gamma(y2);
  function rgb$1(start2, end) {
    var r2 = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g2 = color2(start2.g, end.g), b2 = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
    return function(t2) {
      return start2.r = r2(t2), start2.g = g2(t2), start2.b = b2(t2), start2.opacity = opacity(t2), start2 + "";
    };
  }
  return rgb$1.gamma = rgbGamma, rgb$1;
}(1);
function interpolateNumber(a2, b2) {
  return a2 = +a2, b2 = +b2, function(t2) {
    return a2 * (1 - t2) + b2 * t2;
  };
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero(b2) {
  return function() {
    return b2;
  };
}
function one(b2) {
  return function(t2) {
    return b2(t2) + "";
  };
}
function interpolateString(a2, b2) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i2 = -1, s2 = [], q2 = [];
  for (a2 = a2 + "", b2 = b2 + ""; (am = reA.exec(a2)) && (bm = reB.exec(b2)); )
    (bs = bm.index) > bi && (bs = b2.slice(bi, bs), s2[i2] ? s2[i2] += bs : s2[++i2] = bs), (am = am[0]) === (bm = bm[0]) ? s2[i2] ? s2[i2] += bm : s2[++i2] = bm : (s2[++i2] = null, q2.push({ i: i2, x: interpolateNumber(am, bm) })), bi = reB.lastIndex;
  return bi < b2.length && (bs = b2.slice(bi), s2[i2] ? s2[i2] += bs : s2[++i2] = bs), s2.length < 2 ? q2[0] ? one(q2[0].x) : zero(b2) : (b2 = q2.length, function(t2) {
    for (var i3 = 0, o2; i3 < b2; ++i3) s2[(o2 = q2[i3]).i] = o2.x(t2);
    return s2.join("");
  });
}
var degrees$1 = 180 / Math.PI, identity$3 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose(a2, b2, c, d2, e2, f2) {
  var scaleX, scaleY, skewX;
  return (scaleX = Math.sqrt(a2 * a2 + b2 * b2)) && (a2 /= scaleX, b2 /= scaleX), (skewX = a2 * c + b2 * d2) && (c -= a2 * skewX, d2 -= b2 * skewX), (scaleY = Math.sqrt(c * c + d2 * d2)) && (c /= scaleY, d2 /= scaleY, skewX /= scaleY), a2 * d2 < b2 * c && (a2 = -a2, b2 = -b2, skewX = -skewX, scaleX = -scaleX), {
    translateX: e2,
    translateY: f2,
    rotate: Math.atan2(b2, a2) * degrees$1,
    skewX: Math.atan(skewX) * degrees$1,
    scaleX,
    scaleY
  };
}
var svgNode;
function parseCss(value) {
  const m2 = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m2.isIdentity ? identity$3 : decompose(m2.a, m2.b, m2.c, m2.d, m2.e, m2.f);
}
function parseSvg(value) {
  return value == null || (svgNode || (svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g")), svgNode.setAttribute("transform", value), !(value = svgNode.transform.baseVal.consolidate())) ? identity$3 : (value = value.matrix, decompose(value.a, value.b, value.c, value.d, value.e, value.f));
}
function interpolateTransform(parse2, pxComma, pxParen, degParen) {
  function pop(s2) {
    return s2.length ? s2.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s2, q2) {
    if (xa !== xb || ya !== yb) {
      var i2 = s2.push("translate(", null, pxComma, null, pxParen);
      q2.push({ i: i2 - 4, x: interpolateNumber(xa, xb) }, { i: i2 - 2, x: interpolateNumber(ya, yb) });
    } else (xb || yb) && s2.push("translate(" + xb + pxComma + yb + pxParen);
  }
  function rotate(a2, b2, s2, q2) {
    a2 !== b2 ? (a2 - b2 > 180 ? b2 += 360 : b2 - a2 > 180 && (a2 += 360), q2.push({ i: s2.push(pop(s2) + "rotate(", null, degParen) - 2, x: interpolateNumber(a2, b2) })) : b2 && s2.push(pop(s2) + "rotate(" + b2 + degParen);
  }
  function skewX(a2, b2, s2, q2) {
    a2 !== b2 ? q2.push({ i: s2.push(pop(s2) + "skewX(", null, degParen) - 2, x: interpolateNumber(a2, b2) }) : b2 && s2.push(pop(s2) + "skewX(" + b2 + degParen);
  }
  function scale2(xa, ya, xb, yb, s2, q2) {
    if (xa !== xb || ya !== yb) {
      var i2 = s2.push(pop(s2) + "scale(", null, ",", null, ")");
      q2.push({ i: i2 - 4, x: interpolateNumber(xa, xb) }, { i: i2 - 2, x: interpolateNumber(ya, yb) });
    } else (xb !== 1 || yb !== 1) && s2.push(pop(s2) + "scale(" + xb + "," + yb + ")");
  }
  return function(a2, b2) {
    var s2 = [], q2 = [];
    return a2 = parse2(a2), b2 = parse2(b2), translate(a2.translateX, a2.translateY, b2.translateX, b2.translateY, s2, q2), rotate(a2.rotate, b2.rotate, s2, q2), skewX(a2.skewX, b2.skewX, s2, q2), scale2(a2.scaleX, a2.scaleY, b2.scaleX, b2.scaleY, s2, q2), a2 = b2 = null, function(t2) {
      for (var i2 = -1, n2 = q2.length, o2; ++i2 < n2; ) s2[(o2 = q2[i2]).i] = o2.x(t2);
      return s2.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)"), interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")"), epsilon2 = 1e-12;
function cosh(x2) {
  return ((x2 = Math.exp(x2)) + 1 / x2) / 2;
}
function sinh(x2) {
  return ((x2 = Math.exp(x2)) - 1 / x2) / 2;
}
function tanh(x2) {
  return ((x2 = Math.exp(2 * x2)) - 1) / (x2 + 1);
}
const interpolateZoom = function zoomRho(rho, rho2, rho4) {
  function zoom2(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i2, S2;
    if (d2 < epsilon2)
      S2 = Math.log(w1 / w0) / rho, i2 = function(t2) {
        return [
          ux0 + t2 * dx,
          uy0 + t2 * dy,
          w0 * Math.exp(rho * t2 * S2)
        ];
      };
    else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S2 = (r1 - r0) / rho, i2 = function(t2) {
        var s2 = t2 * S2, coshr0 = cosh(r0), u2 = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s2 + r0) - sinh(r0));
        return [
          ux0 + u2 * dx,
          uy0 + u2 * dy,
          w0 * coshr0 / cosh(rho * s2 + r0)
        ];
      };
    }
    return i2.duration = S2 * 1e3 * rho / Math.SQRT2, i2;
  }
  return zoom2.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  }, zoom2;
}(Math.SQRT2, 2, 4);
var frame$1 = 0, timeout$1 = 0, interval = 0, pokeDelay = 1e3, taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance == "object" && performance.now ? performance : Date, setFrame = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f2) {
  setTimeout(f2, 17);
};
function now$1() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay2, time2) {
    if (typeof callback != "function") throw new TypeError("callback is not a function");
    time2 = (time2 == null ? now$1() : +time2) + (delay2 == null ? 0 : +delay2), !this._next && taskTail !== this && (taskTail ? taskTail._next = this : taskHead = this, taskTail = this), this._call = callback, this._time = time2, sleep();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, sleep());
  }
};
function timer(callback, delay2, time2) {
  var t2 = new Timer();
  return t2.restart(callback, delay2, time2), t2;
}
function timerFlush() {
  now$1(), ++frame$1;
  for (var t2 = taskHead, e2; t2; )
    (e2 = clockNow - t2._time) >= 0 && t2._call.call(void 0, e2), t2 = t2._next;
  --frame$1;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew, frame$1 = timeout$1 = 0;
  try {
    timerFlush();
  } finally {
    frame$1 = 0, nap(), clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay2 = now2 - clockLast;
  delay2 > pokeDelay && (clockSkew -= delay2, clockLast = now2);
}
function nap() {
  for (var t0, t1 = taskHead, t2, time2 = 1 / 0; t1; )
    t1._call ? (time2 > t1._time && (time2 = t1._time), t0 = t1, t1 = t1._next) : (t2 = t1._next, t1._next = null, t1 = t0 ? t0._next = t2 : taskHead = t2);
  taskTail = t0, sleep(time2);
}
function sleep(time2) {
  if (!frame$1) {
    timeout$1 && (timeout$1 = clearTimeout(timeout$1));
    var delay2 = time2 - clockNow;
    delay2 > 24 ? (time2 < 1 / 0 && (timeout$1 = setTimeout(wake, time2 - clock.now() - clockSkew)), interval && (interval = clearInterval(interval))) : (interval || (clockLast = clock.now(), interval = setInterval(poke, pokeDelay)), frame$1 = 1, setFrame(wake));
  }
}
function timeout(callback, delay2, time2) {
  var t2 = new Timer();
  return delay2 = delay2 == null ? 0 : +delay2, t2.restart((elapsed) => {
    t2.stop(), callback(elapsed + delay2);
  }, delay2, time2), t2;
}
var emptyOn = dispatch("start", "end", "cancel", "interrupt"), emptyTween = [], CREATED = 0, SCHEDULED = 1, STARTING = 2, STARTED = 3, RUNNING = 4, ENDING = 5, ENDED = 6;
function schedule(node2, name, id2, index2, group, timing) {
  var schedules = node2.__transition;
  if (!schedules) node2.__transition = {};
  else if (id2 in schedules) return;
  create(node2, id2, {
    name,
    index: index2,
    // For context during callback.
    group,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init(node2, id2) {
  var schedule2 = get(node2, id2);
  if (schedule2.state > CREATED) throw new Error("too late; already scheduled");
  return schedule2;
}
function set(node2, id2) {
  var schedule2 = get(node2, id2);
  if (schedule2.state > STARTED) throw new Error("too late; already running");
  return schedule2;
}
function get(node2, id2) {
  var schedule2 = node2.__transition;
  if (!schedule2 || !(schedule2 = schedule2[id2])) throw new Error("transition not found");
  return schedule2;
}
function create(node2, id2, self2) {
  var schedules = node2.__transition, tween;
  schedules[id2] = self2, self2.timer = timer(schedule2, 0, self2.time);
  function schedule2(elapsed) {
    self2.state = SCHEDULED, self2.timer.restart(start2, self2.delay, self2.time), self2.delay <= elapsed && start2(elapsed - self2.delay);
  }
  function start2(elapsed) {
    var i2, j2, n2, o2;
    if (self2.state !== SCHEDULED) return stop();
    for (i2 in schedules)
      if (o2 = schedules[i2], o2.name === self2.name) {
        if (o2.state === STARTED) return timeout(start2);
        o2.state === RUNNING ? (o2.state = ENDED, o2.timer.stop(), o2.on.call("interrupt", node2, node2.__data__, o2.index, o2.group), delete schedules[i2]) : +i2 < id2 && (o2.state = ENDED, o2.timer.stop(), o2.on.call("cancel", node2, node2.__data__, o2.index, o2.group), delete schedules[i2]);
      }
    if (timeout(function() {
      self2.state === STARTED && (self2.state = RUNNING, self2.timer.restart(tick, self2.delay, self2.time), tick(elapsed));
    }), self2.state = STARTING, self2.on.call("start", node2, node2.__data__, self2.index, self2.group), self2.state === STARTING) {
      for (self2.state = STARTED, tween = new Array(n2 = self2.tween.length), i2 = 0, j2 = -1; i2 < n2; ++i2)
        (o2 = self2.tween[i2].value.call(node2, node2.__data__, self2.index, self2.group)) && (tween[++j2] = o2);
      tween.length = j2 + 1;
    }
  }
  function tick(elapsed) {
    for (var t2 = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i2 = -1, n2 = tween.length; ++i2 < n2; )
      tween[i2].call(node2, t2);
    self2.state === ENDING && (self2.on.call("end", node2, node2.__data__, self2.index, self2.group), stop());
  }
  function stop() {
    self2.state = ENDED, self2.timer.stop(), delete schedules[id2];
    for (var i2 in schedules) return;
    delete node2.__transition;
  }
}
function interrupt(node2, name) {
  var schedules = node2.__transition, schedule2, active, empty2 = !0, i2;
  if (schedules) {
    name = name == null ? null : name + "";
    for (i2 in schedules) {
      if ((schedule2 = schedules[i2]).name !== name) {
        empty2 = !1;
        continue;
      }
      active = schedule2.state > STARTING && schedule2.state < ENDING, schedule2.state = ENDED, schedule2.timer.stop(), schedule2.on.call(active ? "interrupt" : "cancel", node2, node2.__data__, schedule2.index, schedule2.group), delete schedules[i2];
    }
    empty2 && delete node2.__transition;
  }
}
function selection_interrupt(name) {
  return this.each(function() {
    interrupt(this, name);
  });
}
function tweenRemove(id2, name) {
  var tween0, tween1;
  return function() {
    var schedule2 = set(this, id2), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i2 = 0, n2 = tween1.length; i2 < n2; ++i2)
        if (tween1[i2].name === name) {
          tween1 = tween1.slice(), tween1.splice(i2, 1);
          break;
        }
    }
    schedule2.tween = tween1;
  };
}
function tweenFunction(id2, name, value) {
  var tween0, tween1;
  if (typeof value != "function") throw new Error();
  return function() {
    var schedule2 = set(this, id2), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t2 = { name, value }, i2 = 0, n2 = tween1.length; i2 < n2; ++i2)
        if (tween1[i2].name === name) {
          tween1[i2] = t2;
          break;
        }
      i2 === n2 && tween1.push(t2);
    }
    schedule2.tween = tween1;
  };
}
function transition_tween(name, value) {
  var id2 = this._id;
  if (name += "", arguments.length < 2) {
    for (var tween = get(this.node(), id2).tween, i2 = 0, n2 = tween.length, t2; i2 < n2; ++i2)
      if ((t2 = tween[i2]).name === name)
        return t2.value;
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
}
function tweenValue(transition, name, value) {
  var id2 = transition._id;
  return transition.each(function() {
    var schedule2 = set(this, id2);
    (schedule2.value || (schedule2.value = {}))[name] = value.apply(this, arguments);
  }), function(node2) {
    return get(node2, id2).value[name];
  };
}
function interpolate$1(a2, b2) {
  var c;
  return (typeof b2 == "number" ? interpolateNumber : b2 instanceof color$1 ? interpolateRgb : (c = color$1(b2)) ? (b2 = c, interpolateRgb) : interpolateString)(a2, b2);
}
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrConstantNS(fullname, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrFunction(name, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    return value1 == null ? void this.removeAttribute(name) : (string0 = this.getAttribute(name), string1 = value1 + "", string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1)));
  };
}
function attrFunctionNS(fullname, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    return value1 == null ? void this.removeAttributeNS(fullname.space, fullname.local) : (string0 = this.getAttributeNS(fullname.space, fullname.local), string1 = value1 + "", string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1)));
  };
}
function transition_attr(name, value) {
  var fullname = namespace(name), i2 = fullname === "transform" ? interpolateTransformSvg : interpolate$1;
  return this.attrTween(name, typeof value == "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i2, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i2, value));
}
function attrInterpolate(name, i2) {
  return function(t2) {
    this.setAttribute(name, i2.call(this, t2));
  };
}
function attrInterpolateNS(fullname, i2) {
  return function(t2) {
    this.setAttributeNS(fullname.space, fullname.local, i2.call(this, t2));
  };
}
function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i2 = value.apply(this, arguments);
    return i2 !== i0 && (t0 = (i0 = i2) && attrInterpolateNS(fullname, i2)), t0;
  }
  return tween._value = value, tween;
}
function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i2 = value.apply(this, arguments);
    return i2 !== i0 && (t0 = (i0 = i2) && attrInterpolate(name, i2)), t0;
  }
  return tween._value = value, tween;
}
function transition_attrTween(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value != "function") throw new Error();
  var fullname = namespace(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}
function delayFunction(id2, value) {
  return function() {
    init(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init(this, id2).delay = value;
  };
}
function transition_delay(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value == "function" ? delayFunction : delayConstant)(id2, value)) : get(this.node(), id2).delay;
}
function durationFunction(id2, value) {
  return function() {
    set(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set(this, id2).duration = value;
  };
}
function transition_duration(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value == "function" ? durationFunction : durationConstant)(id2, value)) : get(this.node(), id2).duration;
}
function easeConstant(id2, value) {
  if (typeof value != "function") throw new Error();
  return function() {
    set(this, id2).ease = value;
  };
}
function transition_ease(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get(this.node(), id2).ease;
}
function easeVarying(id2, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (typeof v2 != "function") throw new Error();
    set(this, id2).ease = v2;
  };
}
function transition_easeVarying(value) {
  if (typeof value != "function") throw new Error();
  return this.each(easeVarying(this._id, value));
}
function transition_filter(match) {
  typeof match != "function" && (match = matcher(match));
  for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j2 = 0; j2 < m2; ++j2)
    for (var group = groups[j2], n2 = group.length, subgroup = subgroups[j2] = [], node2, i2 = 0; i2 < n2; ++i2)
      (node2 = group[i2]) && match.call(node2, node2.__data__, i2, group) && subgroup.push(node2);
  return new Transition$1(subgroups, this._parents, this._name, this._id);
}
function transition_merge(transition) {
  if (transition._id !== this._id) throw new Error();
  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j2 = 0; j2 < m2; ++j2)
    for (var group0 = groups0[j2], group1 = groups1[j2], n2 = group0.length, merge3 = merges[j2] = new Array(n2), node2, i2 = 0; i2 < n2; ++i2)
      (node2 = group0[i2] || group1[i2]) && (merge3[i2] = node2);
  for (; j2 < m0; ++j2)
    merges[j2] = groups0[j2];
  return new Transition$1(merges, this._parents, this._name, this._id);
}
function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t2) {
    var i2 = t2.indexOf(".");
    return i2 >= 0 && (t2 = t2.slice(0, i2)), !t2 || t2 === "start";
  });
}
function onFunction(id2, name, listener) {
  var on0, on1, sit = start(name) ? init : set;
  return function() {
    var schedule2 = sit(this, id2), on2 = schedule2.on;
    on2 !== on0 && (on1 = (on0 = on2).copy()).on(name, listener), schedule2.on = on1;
  };
}
function transition_on(name, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
}
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i2 in this.__transition) if (+i2 !== id2) return;
    parent && parent.removeChild(this);
  };
}
function transition_remove() {
  return this.on("end.remove", removeFunction(this._id));
}
function transition_select(select2) {
  var name = this._name, id2 = this._id;
  typeof select2 != "function" && (select2 = selector$q(select2));
  for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j2 = 0; j2 < m2; ++j2)
    for (var group = groups[j2], n2 = group.length, subgroup = subgroups[j2] = new Array(n2), node2, subnode, i2 = 0; i2 < n2; ++i2)
      (node2 = group[i2]) && (subnode = select2.call(node2, node2.__data__, i2, group)) && ("__data__" in node2 && (subnode.__data__ = node2.__data__), subgroup[i2] = subnode, schedule(subgroup[i2], name, id2, i2, subgroup, get(node2, id2)));
  return new Transition$1(subgroups, this._parents, name, id2);
}
function transition_selectAll(select2) {
  var name = this._name, id2 = this._id;
  typeof select2 != "function" && (select2 = selectorAll(select2));
  for (var groups = this._groups, m2 = groups.length, subgroups = [], parents = [], j2 = 0; j2 < m2; ++j2)
    for (var group = groups[j2], n2 = group.length, node2, i2 = 0; i2 < n2; ++i2)
      if (node2 = group[i2]) {
        for (var children2 = select2.call(node2, node2.__data__, i2, group), child, inherit2 = get(node2, id2), k2 = 0, l2 = children2.length; k2 < l2; ++k2)
          (child = children2[k2]) && schedule(child, name, id2, k2, children2, inherit2);
        subgroups.push(children2), parents.push(node2);
      }
  return new Transition$1(subgroups, parents, name, id2);
}
var Selection = selection.prototype.constructor;
function transition_selection() {
  return new Selection(this._groups, this._parents);
}
function styleNull(name, interpolate2) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, string10 = string1);
  };
}
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function styleFunction(name, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
    return value1 == null && (string1 = value1 = (this.style.removeProperty(name), styleValue(this, name))), string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove2;
  return function() {
    var schedule2 = set(this, id2), on2 = schedule2.on, listener = schedule2.value[key] == null ? remove2 || (remove2 = styleRemove(name)) : void 0;
    (on2 !== on0 || listener0 !== listener) && (on1 = (on0 = on2).copy()).on(event, listener0 = listener), schedule2.on = on1;
  };
}
function transition_style(name, value, priority) {
  var i2 = (name += "") == "transform" ? interpolateTransformCss : interpolate$1;
  return value == null ? this.styleTween(name, styleNull(name, i2)).on("end.style." + name, styleRemove(name)) : typeof value == "function" ? this.styleTween(name, styleFunction(name, i2, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant(name, i2, value), priority).on("end.style." + name, null);
}
function styleInterpolate(name, i2, priority) {
  return function(t2) {
    this.style.setProperty(name, i2.call(this, t2), priority);
  };
}
function styleTween(name, value, priority) {
  var t2, i0;
  function tween() {
    var i2 = value.apply(this, arguments);
    return i2 !== i0 && (t2 = (i0 = i2) && styleInterpolate(name, i2, priority)), t2;
  }
  return tween._value = value, tween;
}
function transition_styleTween(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value != "function") throw new Error();
  return this.tween(key, styleTween(name, value, priority ?? ""));
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 ?? "";
  };
}
function transition_text(value) {
  return this.tween("text", typeof value == "function" ? textFunction(tweenValue(this, "text", value)) : textConstant(value == null ? "" : value + ""));
}
function textInterpolate(i2) {
  return function(t2) {
    this.textContent = i2.call(this, t2);
  };
}
function textTween(value) {
  var t0, i0;
  function tween() {
    var i2 = value.apply(this, arguments);
    return i2 !== i0 && (t0 = (i0 = i2) && textInterpolate(i2)), t0;
  }
  return tween._value = value, tween;
}
function transition_textTween(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value != "function") throw new Error();
  return this.tween(key, textTween(value));
}
function transition_transition() {
  for (var name = this._name, id0 = this._id, id1 = newId(), groups = this._groups, m2 = groups.length, j2 = 0; j2 < m2; ++j2)
    for (var group = groups[j2], n2 = group.length, node2, i2 = 0; i2 < n2; ++i2)
      if (node2 = group[i2]) {
        var inherit2 = get(node2, id0);
        schedule(node2, name, id1, i2, group, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
  return new Transition$1(groups, this._parents, name, id1);
}
function transition_end() {
  var on0, on1, that = this, id2 = that._id, size2 = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = { value: reject }, end = { value: function() {
      --size2 === 0 && resolve();
    } };
    that.each(function() {
      var schedule2 = set(this, id2), on2 = schedule2.on;
      on2 !== on0 && (on1 = (on0 = on2).copy(), on1._.cancel.push(cancel), on1._.interrupt.push(cancel), on1._.end.push(end)), schedule2.on = on1;
    }), size2 === 0 && resolve();
  });
}
var id$2 = 0;
function Transition$1(groups, parents, name, id2) {
  this._groups = groups, this._parents = parents, this._name = name, this._id = id2;
}
function newId() {
  return ++id$2;
}
var selection_prototype = selection.prototype;
Transition$1.prototype = {
  constructor: Transition$1,
  select: transition_select,
  selectAll: transition_selectAll,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  textTween: transition_textTween,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease,
  easeVarying: transition_easeVarying,
  end: transition_end,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};
function cubicInOut(t2) {
  return ((t2 *= 2) <= 1 ? t2 * t2 * t2 : (t2 -= 2) * t2 * t2 + 2) / 2;
}
var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node2, id2) {
  for (var timing; !(timing = node2.__transition) || !(timing = timing[id2]); )
    if (!(node2 = node2.parentNode))
      throw new Error(`transition ${id2} not found`);
  return timing;
}
function selection_transition(name) {
  var id2, timing;
  name instanceof Transition$1 ? (id2 = name._id, name = name._name) : (id2 = newId(), (timing = defaultTiming).time = now$1(), name = name == null ? null : name + "");
  for (var groups = this._groups, m2 = groups.length, j2 = 0; j2 < m2; ++j2)
    for (var group = groups[j2], n2 = group.length, node2, i2 = 0; i2 < n2; ++i2)
      (node2 = group[i2]) && schedule(node2, name, id2, i2, group, timing || inherit(node2, id2));
  return new Transition$1(groups, this._parents, name, id2);
}
selection.prototype.interrupt = selection_interrupt;
selection.prototype.transition = selection_transition;
const constant$1 = (x2) => () => x2;
function ZoomEvent(type, {
  sourceEvent: sourceEvent2,
  target,
  transform: transform2,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type, enumerable: !0, configurable: !0 },
    sourceEvent: { value: sourceEvent2, enumerable: !0, configurable: !0 },
    target: { value: target, enumerable: !0, configurable: !0 },
    transform: { value: transform2, enumerable: !0, configurable: !0 },
    _: { value: dispatch2 }
  });
}
function Transform(k2, x2, y2) {
  this.k = k2, this.x = x2, this.y = y2;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k2) {
    return k2 === 1 ? this : new Transform(this.k * k2, this.x, this.y);
  },
  translate: function(x2, y2) {
    return x2 === 0 & y2 === 0 ? this : new Transform(this.k, this.x + this.k * x2, this.y + this.k * y2);
  },
  apply: function(point2) {
    return [point2[0] * this.k + this.x, point2[1] * this.k + this.y];
  },
  applyX: function(x2) {
    return x2 * this.k + this.x;
  },
  applyY: function(y2) {
    return y2 * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x2) {
    return (x2 - this.x) / this.k;
  },
  invertY: function(y2) {
    return (y2 - this.y) / this.k;
  },
  rescaleX: function(x2) {
    return x2.copy().domain(x2.range().map(this.invertX, this).map(x2.invert, x2));
  },
  rescaleY: function(y2) {
    return y2.copy().domain(y2.range().map(this.invertY, this).map(y2.invert, y2));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity$2 = new Transform(1, 0, 0);
transform.prototype = Transform.prototype;
function transform(node2) {
  for (; !node2.__zoom; ) if (!(node2 = node2.parentNode)) return identity$2;
  return node2.__zoom;
}
function nopropagation(event) {
  event.stopImmediatePropagation();
}
function noevent(event) {
  event.preventDefault(), event.stopImmediatePropagation();
}
function defaultFilter(event) {
  return (!event.ctrlKey || event.type === "wheel") && !event.button;
}
function defaultExtent() {
  var e2 = this;
  return e2 instanceof SVGElement ? (e2 = e2.ownerSVGElement || e2, e2.hasAttribute("viewBox") ? (e2 = e2.viewBox.baseVal, [[e2.x, e2.y], [e2.x + e2.width, e2.y + e2.height]]) : [[0, 0], [e2.width.baseVal.value, e2.height.baseVal.value]]) : [[0, 0], [e2.clientWidth, e2.clientHeight]];
}
function defaultTransform() {
  return this.__zoom || identity$2;
}
function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function defaultConstrain(transform2, extent, translateExtent) {
  var dx0 = transform2.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent[1][1]) - translateExtent[1][1];
  return transform2.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}
function zoom() {
  var filter2 = defaultFilter, extent = defaultExtent, constrain = defaultConstrain, wheelDelta2 = defaultWheelDelta, touchable = defaultTouchable, scaleExtent = [0, 1 / 0], translateExtent = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], duration = 250, interpolate2 = interpolateZoom, listeners = dispatch("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
  function zoom2(selection2) {
    selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, { passive: !1 }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  zoom2.transform = function(collection, transform2, point2, event) {
    var selection2 = collection.selection ? collection.selection() : collection;
    selection2.property("__zoom", defaultTransform), collection !== selection2 ? schedule2(collection, transform2, point2, event) : selection2.interrupt().each(function() {
      gesture(this, arguments).event(event).start().zoom(null, typeof transform2 == "function" ? transform2.apply(this, arguments) : transform2).end();
    });
  }, zoom2.scaleBy = function(selection2, k2, p2, event) {
    zoom2.scaleTo(selection2, function() {
      var k0 = this.__zoom.k, k1 = typeof k2 == "function" ? k2.apply(this, arguments) : k2;
      return k0 * k1;
    }, p2, event);
  }, zoom2.scaleTo = function(selection2, k2, p2, event) {
    zoom2.transform(selection2, function() {
      var e2 = extent.apply(this, arguments), t0 = this.__zoom, p0 = p2 == null ? centroid(e2) : typeof p2 == "function" ? p2.apply(this, arguments) : p2, p1 = t0.invert(p0), k1 = typeof k2 == "function" ? k2.apply(this, arguments) : k2;
      return constrain(translate(scale2(t0, k1), p0, p1), e2, translateExtent);
    }, p2, event);
  }, zoom2.translateBy = function(selection2, x2, y2, event) {
    zoom2.transform(selection2, function() {
      return constrain(this.__zoom.translate(
        typeof x2 == "function" ? x2.apply(this, arguments) : x2,
        typeof y2 == "function" ? y2.apply(this, arguments) : y2
      ), extent.apply(this, arguments), translateExtent);
    }, null, event);
  }, zoom2.translateTo = function(selection2, x2, y2, p2, event) {
    zoom2.transform(selection2, function() {
      var e2 = extent.apply(this, arguments), t2 = this.__zoom, p0 = p2 == null ? centroid(e2) : typeof p2 == "function" ? p2.apply(this, arguments) : p2;
      return constrain(identity$2.translate(p0[0], p0[1]).scale(t2.k).translate(
        typeof x2 == "function" ? -x2.apply(this, arguments) : -x2,
        typeof y2 == "function" ? -y2.apply(this, arguments) : -y2
      ), e2, translateExtent);
    }, p2, event);
  };
  function scale2(transform2, k2) {
    return k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k2)), k2 === transform2.k ? transform2 : new Transform(k2, transform2.x, transform2.y);
  }
  function translate(transform2, p0, p1) {
    var x2 = p0[0] - p1[0] * transform2.k, y2 = p0[1] - p1[1] * transform2.k;
    return x2 === transform2.x && y2 === transform2.y ? transform2 : new Transform(transform2.k, x2, y2);
  }
  function centroid(extent2) {
    return [(+extent2[0][0] + +extent2[1][0]) / 2, (+extent2[0][1] + +extent2[1][1]) / 2];
  }
  function schedule2(transition, transform2, point2, event) {
    transition.on("start.zoom", function() {
      gesture(this, arguments).event(event).start();
    }).on("interrupt.zoom end.zoom", function() {
      gesture(this, arguments).event(event).end();
    }).tween("zoom", function() {
      var that = this, args = arguments, g2 = gesture(that, args).event(event), e2 = extent.apply(that, args), p2 = point2 == null ? centroid(e2) : typeof point2 == "function" ? point2.apply(that, args) : point2, w2 = Math.max(e2[1][0] - e2[0][0], e2[1][1] - e2[0][1]), a2 = that.__zoom, b2 = typeof transform2 == "function" ? transform2.apply(that, args) : transform2, i2 = interpolate2(a2.invert(p2).concat(w2 / a2.k), b2.invert(p2).concat(w2 / b2.k));
      return function(t2) {
        if (t2 === 1) t2 = b2;
        else {
          var l2 = i2(t2), k2 = w2 / l2[2];
          t2 = new Transform(k2, p2[0] - l2[0] * k2, p2[1] - l2[1] * k2);
        }
        g2.zoom(null, t2);
      };
    });
  }
  function gesture(that, args, clean) {
    return !clean && that.__zooming || new Gesture(that, args);
  }
  function Gesture(that, args) {
    this.that = that, this.args = args, this.active = 0, this.sourceEvent = null, this.extent = extent.apply(that, args), this.taps = 0;
  }
  Gesture.prototype = {
    event: function(event) {
      return event && (this.sourceEvent = event), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(key, transform2) {
      return this.mouse && key !== "mouse" && (this.mouse[1] = transform2.invert(this.mouse[0])), this.touch0 && key !== "touch" && (this.touch0[1] = transform2.invert(this.touch0[0])), this.touch1 && key !== "touch" && (this.touch1[1] = transform2.invert(this.touch1[0])), this.that.__zoom = transform2, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(type) {
      var d2 = select(this.that).datum();
      listeners.call(
        type,
        this.that,
        new ZoomEvent(type, {
          sourceEvent: this.sourceEvent,
          target: zoom2,
          type,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d2
      );
    }
  };
  function wheeled(event, ...args) {
    if (!filter2.apply(this, arguments)) return;
    var g2 = gesture(this, args).event(event), t2 = this.__zoom, k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t2.k * Math.pow(2, wheelDelta2.apply(this, arguments)))), p2 = pointer(event);
    if (g2.wheel)
      (g2.mouse[0][0] !== p2[0] || g2.mouse[0][1] !== p2[1]) && (g2.mouse[1] = t2.invert(g2.mouse[0] = p2)), clearTimeout(g2.wheel);
    else {
      if (t2.k === k2) return;
      g2.mouse = [p2, t2.invert(p2)], interrupt(this), g2.start();
    }
    noevent(event), g2.wheel = setTimeout(wheelidled, wheelDelay), g2.zoom("mouse", constrain(translate(scale2(t2, k2), g2.mouse[0], g2.mouse[1]), g2.extent, translateExtent));
    function wheelidled() {
      g2.wheel = null, g2.end();
    }
  }
  function mousedowned(event, ...args) {
    if (touchending || !filter2.apply(this, arguments)) return;
    var currentTarget = event.currentTarget, g2 = gesture(this, args, !0).event(event), v2 = select(event.view).on("mousemove.zoom", mousemoved, !0).on("mouseup.zoom", mouseupped, !0), p2 = pointer(event, currentTarget), x0 = event.clientX, y0 = event.clientY;
    dragDisable(event.view), nopropagation(event), g2.mouse = [p2, this.__zoom.invert(p2)], interrupt(this), g2.start();
    function mousemoved(event2) {
      if (noevent(event2), !g2.moved) {
        var dx = event2.clientX - x0, dy = event2.clientY - y0;
        g2.moved = dx * dx + dy * dy > clickDistance2;
      }
      g2.event(event2).zoom("mouse", constrain(translate(g2.that.__zoom, g2.mouse[0] = pointer(event2, currentTarget), g2.mouse[1]), g2.extent, translateExtent));
    }
    function mouseupped(event2) {
      v2.on("mousemove.zoom mouseup.zoom", null), yesdrag(event2.view, g2.moved), noevent(event2), g2.event(event2).end();
    }
  }
  function dblclicked(event, ...args) {
    if (filter2.apply(this, arguments)) {
      var t0 = this.__zoom, p0 = pointer(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t0.invert(p0), k1 = t0.k * (event.shiftKey ? 0.5 : 2), t1 = constrain(translate(scale2(t0, k1), p0, p1), extent.apply(this, args), translateExtent);
      noevent(event), duration > 0 ? select(this).transition().duration(duration).call(schedule2, t1, p0, event) : select(this).call(zoom2.transform, t1, p0, event);
    }
  }
  function touchstarted(event, ...args) {
    if (filter2.apply(this, arguments)) {
      var touches = event.touches, n2 = touches.length, g2 = gesture(this, args, event.changedTouches.length === n2).event(event), started, i2, t2, p2;
      for (nopropagation(event), i2 = 0; i2 < n2; ++i2)
        t2 = touches[i2], p2 = pointer(t2, this), p2 = [p2, this.__zoom.invert(p2), t2.identifier], g2.touch0 ? !g2.touch1 && g2.touch0[2] !== p2[2] && (g2.touch1 = p2, g2.taps = 0) : (g2.touch0 = p2, started = !0, g2.taps = 1 + !!touchstarting);
      touchstarting && (touchstarting = clearTimeout(touchstarting)), started && (g2.taps < 2 && (touchfirst = p2[0], touchstarting = setTimeout(function() {
        touchstarting = null;
      }, touchDelay)), interrupt(this), g2.start());
    }
  }
  function touchmoved(event, ...args) {
    if (this.__zooming) {
      var g2 = gesture(this, args).event(event), touches = event.changedTouches, n2 = touches.length, i2, t2, p2, l2;
      for (noevent(event), i2 = 0; i2 < n2; ++i2)
        t2 = touches[i2], p2 = pointer(t2, this), g2.touch0 && g2.touch0[2] === t2.identifier ? g2.touch0[0] = p2 : g2.touch1 && g2.touch1[2] === t2.identifier && (g2.touch1[0] = p2);
      if (t2 = g2.that.__zoom, g2.touch1) {
        var p0 = g2.touch0[0], l0 = g2.touch0[1], p1 = g2.touch1[0], l1 = g2.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
        t2 = scale2(t2, Math.sqrt(dp / dl)), p2 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2], l2 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
      } else if (g2.touch0) p2 = g2.touch0[0], l2 = g2.touch0[1];
      else return;
      g2.zoom("touch", constrain(translate(t2, p2, l2), g2.extent, translateExtent));
    }
  }
  function touchended(event, ...args) {
    if (this.__zooming) {
      var g2 = gesture(this, args).event(event), touches = event.changedTouches, n2 = touches.length, i2, t2;
      for (nopropagation(event), touchending && clearTimeout(touchending), touchending = setTimeout(function() {
        touchending = null;
      }, touchDelay), i2 = 0; i2 < n2; ++i2)
        t2 = touches[i2], g2.touch0 && g2.touch0[2] === t2.identifier ? delete g2.touch0 : g2.touch1 && g2.touch1[2] === t2.identifier && delete g2.touch1;
      if (g2.touch1 && !g2.touch0 && (g2.touch0 = g2.touch1, delete g2.touch1), g2.touch0) g2.touch0[1] = this.__zoom.invert(g2.touch0[0]);
      else if (g2.end(), g2.taps === 2 && (t2 = pointer(t2, this), Math.hypot(touchfirst[0] - t2[0], touchfirst[1] - t2[1]) < tapDistance)) {
        var p2 = select(this).on("dblclick.zoom");
        p2 && p2.apply(this, arguments);
      }
    }
  }
  return zoom2.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta2 = typeof _ == "function" ? _ : constant$1(+_), zoom2) : wheelDelta2;
  }, zoom2.filter = function(_) {
    return arguments.length ? (filter2 = typeof _ == "function" ? _ : constant$1(!!_), zoom2) : filter2;
  }, zoom2.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ == "function" ? _ : constant$1(!!_), zoom2) : touchable;
  }, zoom2.extent = function(_) {
    return arguments.length ? (extent = typeof _ == "function" ? _ : constant$1([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom2) : extent;
  }, zoom2.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom2) : [scaleExtent[0], scaleExtent[1]];
  }, zoom2.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom2) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  }, zoom2.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom2) : constrain;
  }, zoom2.duration = function(_) {
    return arguments.length ? (duration = +_, zoom2) : duration;
  }, zoom2.interpolate = function(_) {
    return arguments.length ? (interpolate2 = _, zoom2) : interpolate2;
  }, zoom2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom2 : value;
  }, zoom2.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom2) : Math.sqrt(clickDistance2);
  }, zoom2.tapDistance = function(_) {
    return arguments.length ? (tapDistance = +_, zoom2) : tapDistance;
  }, zoom2;
}
const errorMessages = {
  error001: () => "[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001",
  error002: () => "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.",
  error003: (nodeType) => `Node type "${nodeType}" not found. Using fallback type "default".`,
  error004: () => "The React Flow parent container needs a width and a height to render the graph.",
  error005: () => "Only child nodes can use a parent extent.",
  error006: () => "Can't create edge. An edge needs a source and a target.",
  error007: (id2) => `The old edge with id=${id2} does not exist.`,
  error009: (type) => `Marker type "${type}" doesn't exist.`,
  error008: (handleType, { id: id2, sourceHandle, targetHandle }) => `Couldn't create edge for ${handleType} handle id: "${handleType === "source" ? sourceHandle : targetHandle}", edge id: ${id2}.`,
  error010: () => "Handle: No node id found. Make sure to only use a Handle inside a custom Node.",
  error011: (edgeType) => `Edge type "${edgeType}" not found. Using fallback type "default".`,
  error012: (id2) => `Node with id "${id2}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`,
  error013: (lib2 = "react") => `It seems that you haven't loaded the styles. Please import '@xyflow/${lib2}/dist/style.css' or base.css to make sure everything is working properly.`
}, infiniteExtent = [
  [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
  [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
], elementSelectionKeys = ["Enter", " ", "Escape"];
var ConnectionMode;
(function(ConnectionMode2) {
  ConnectionMode2.Strict = "strict", ConnectionMode2.Loose = "loose";
})(ConnectionMode || (ConnectionMode = {}));
var PanOnScrollMode;
(function(PanOnScrollMode2) {
  PanOnScrollMode2.Free = "free", PanOnScrollMode2.Vertical = "vertical", PanOnScrollMode2.Horizontal = "horizontal";
})(PanOnScrollMode || (PanOnScrollMode = {}));
var SelectionMode;
(function(SelectionMode2) {
  SelectionMode2.Partial = "partial", SelectionMode2.Full = "full";
})(SelectionMode || (SelectionMode = {}));
const initialConnection = {
  inProgress: !1,
  isValid: null,
  from: null,
  fromHandle: null,
  fromPosition: null,
  fromNode: null,
  to: null,
  toHandle: null,
  toPosition: null,
  toNode: null
};
var ConnectionLineType;
(function(ConnectionLineType2) {
  ConnectionLineType2.Bezier = "default", ConnectionLineType2.Straight = "straight", ConnectionLineType2.Step = "step", ConnectionLineType2.SmoothStep = "smoothstep", ConnectionLineType2.SimpleBezier = "simplebezier";
})(ConnectionLineType || (ConnectionLineType = {}));
var MarkerType;
(function(MarkerType2) {
  MarkerType2.Arrow = "arrow", MarkerType2.ArrowClosed = "arrowclosed";
})(MarkerType || (MarkerType = {}));
var Position;
(function(Position2) {
  Position2.Left = "left", Position2.Top = "top", Position2.Right = "right", Position2.Bottom = "bottom";
})(Position || (Position = {}));
const oppositePosition = {
  [Position.Left]: Position.Right,
  [Position.Right]: Position.Left,
  [Position.Top]: Position.Bottom,
  [Position.Bottom]: Position.Top
};
function getConnectionStatus(isValid) {
  return isValid === null ? null : isValid ? "valid" : "invalid";
}
const isEdgeBase = (element) => "id" in element && "source" in element && "target" in element, isNodeBase = (element) => "id" in element && "position" in element && !("source" in element) && !("target" in element), isInternalNodeBase = (element) => "id" in element && "internals" in element && !("source" in element) && !("target" in element), getNodePositionWithOrigin = (node2, nodeOrigin = [0, 0]) => {
  const { width: width2, height } = getNodeDimensions(node2), origin = node2.origin ?? nodeOrigin, offsetX = width2 * origin[0], offsetY = height * origin[1];
  return {
    x: node2.position.x - offsetX,
    y: node2.position.y - offsetY
  };
}, getNodesBounds = (nodes, params = { nodeOrigin: [0, 0], nodeLookup: void 0 }) => {
  if (nodes.length === 0)
    return { x: 0, y: 0, width: 0, height: 0 };
  const box = nodes.reduce((currBox, nodeOrId) => {
    const isId = typeof nodeOrId == "string";
    let currentNode = !params.nodeLookup && !isId ? nodeOrId : void 0;
    params.nodeLookup && (currentNode = isId ? params.nodeLookup.get(nodeOrId) : isInternalNodeBase(nodeOrId) ? nodeOrId : params.nodeLookup.get(nodeOrId.id));
    const nodeBox = currentNode ? nodeToBox(currentNode, params.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 };
    return getBoundsOfBoxes(currBox, nodeBox);
  }, { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 });
  return boxToRect(box);
}, getInternalNodesBounds = (nodeLookup, params = {}) => {
  if (nodeLookup.size === 0)
    return { x: 0, y: 0, width: 0, height: 0 };
  let box = { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 };
  return nodeLookup.forEach((node2) => {
    if (params.filter === void 0 || params.filter(node2)) {
      const nodeBox = nodeToBox(node2);
      box = getBoundsOfBoxes(box, nodeBox);
    }
  }), boxToRect(box);
}, getNodesInside = (nodes, rect, [tx, ty, tScale] = [0, 0, 1], partially = !1, excludeNonSelectableNodes = !1) => {
  const paneRect = {
    ...pointToRendererPoint(rect, [tx, ty, tScale]),
    width: rect.width / tScale,
    height: rect.height / tScale
  }, visibleNodes = [];
  for (const node2 of nodes.values()) {
    const { measured, selectable = !0, hidden: hidden2 = !1 } = node2;
    if (excludeNonSelectableNodes && !selectable || hidden2)
      continue;
    const width2 = measured.width ?? node2.width ?? node2.initialWidth ?? null, height = measured.height ?? node2.height ?? node2.initialHeight ?? null, overlappingArea = getOverlappingArea(paneRect, nodeToRect$1(node2)), area = (width2 ?? 0) * (height ?? 0), partiallyVisible = partially && overlappingArea > 0;
    (!node2.internals.handleBounds || partiallyVisible || overlappingArea >= area || node2.dragging) && visibleNodes.push(node2);
  }
  return visibleNodes;
}, getConnectedEdges = (nodes, edges) => {
  const nodeIds = /* @__PURE__ */ new Set();
  return nodes.forEach((node2) => {
    nodeIds.add(node2.id);
  }), edges.filter((edge) => nodeIds.has(edge.source) || nodeIds.has(edge.target));
};
function getFitViewNodes(nodeLookup, options) {
  const fitViewNodes = /* @__PURE__ */ new Map(), optionNodeIds = options != null && options.nodes ? new Set(options.nodes.map((node2) => node2.id)) : null;
  return nodeLookup.forEach((n2) => {
    n2.measured.width && n2.measured.height && ((options == null ? void 0 : options.includeHiddenNodes) || !n2.hidden) && (!optionNodeIds || optionNodeIds.has(n2.id)) && fitViewNodes.set(n2.id, n2);
  }), fitViewNodes;
}
async function fitView({ nodes, width: width2, height, panZoom, minZoom, maxZoom }, options) {
  if (nodes.size === 0)
    return Promise.resolve(!1);
  const bounds = getInternalNodesBounds(nodes), viewport = getViewportForBounds(bounds, width2, height, (options == null ? void 0 : options.minZoom) ?? minZoom, (options == null ? void 0 : options.maxZoom) ?? maxZoom, (options == null ? void 0 : options.padding) ?? 0.1);
  return await panZoom.setViewport(viewport, { duration: options == null ? void 0 : options.duration }), Promise.resolve(!0);
}
function calculateNodePosition({ nodeId, nextPosition, nodeLookup, nodeOrigin = [0, 0], nodeExtent, onError }) {
  const node2 = nodeLookup.get(nodeId), parentNode = node2.parentId ? nodeLookup.get(node2.parentId) : void 0, { x: parentX, y: parentY } = parentNode ? parentNode.internals.positionAbsolute : { x: 0, y: 0 }, origin = node2.origin ?? nodeOrigin;
  let extent = nodeExtent;
  if (node2.extent === "parent" && !node2.expandParent)
    if (!parentNode)
      onError == null || onError("005", errorMessages.error005());
    else {
      const parentWidth = parentNode.measured.width, parentHeight = parentNode.measured.height;
      parentWidth && parentHeight && (extent = [
        [parentX, parentY],
        [parentX + parentWidth, parentY + parentHeight]
      ]);
    }
  else parentNode && isCoordinateExtent(node2.extent) && (extent = [
    [node2.extent[0][0] + parentX, node2.extent[0][1] + parentY],
    [node2.extent[1][0] + parentX, node2.extent[1][1] + parentY]
  ]);
  const positionAbsolute = isCoordinateExtent(extent) ? clampPosition(nextPosition, extent, node2.measured) : nextPosition;
  return {
    position: {
      x: positionAbsolute.x - parentX + node2.measured.width * origin[0],
      y: positionAbsolute.y - parentY + node2.measured.height * origin[1]
    },
    positionAbsolute
  };
}
async function getElementsToRemove({ nodesToRemove = [], edgesToRemove = [], nodes, edges, onBeforeDelete }) {
  const nodeIds = new Set(nodesToRemove.map((node2) => node2.id)), matchingNodes = [];
  for (const node2 of nodes) {
    if (node2.deletable === !1)
      continue;
    const isIncluded = nodeIds.has(node2.id), parentHit = !isIncluded && node2.parentId && matchingNodes.find((n2) => n2.id === node2.parentId);
    (isIncluded || parentHit) && matchingNodes.push(node2);
  }
  const edgeIds = new Set(edgesToRemove.map((edge) => edge.id)), deletableEdges = edges.filter((edge) => edge.deletable !== !1), matchingEdges = getConnectedEdges(matchingNodes, deletableEdges);
  for (const edge of deletableEdges)
    edgeIds.has(edge.id) && !matchingEdges.find((e2) => e2.id === edge.id) && matchingEdges.push(edge);
  if (!onBeforeDelete)
    return {
      edges: matchingEdges,
      nodes: matchingNodes
    };
  const onBeforeDeleteResult = await onBeforeDelete({
    nodes: matchingNodes,
    edges: matchingEdges
  });
  return typeof onBeforeDeleteResult == "boolean" ? onBeforeDeleteResult ? { edges: matchingEdges, nodes: matchingNodes } : { edges: [], nodes: [] } : onBeforeDeleteResult;
}
const clamp$4 = (val, min2 = 0, max2 = 1) => Math.min(Math.max(val, min2), max2), clampPosition = (position2 = { x: 0, y: 0 }, extent, dimensions) => ({
  x: clamp$4(position2.x, extent[0][0], extent[1][0] - ((dimensions == null ? void 0 : dimensions.width) ?? 0)),
  y: clamp$4(position2.y, extent[0][1], extent[1][1] - ((dimensions == null ? void 0 : dimensions.height) ?? 0))
});
function clampPositionToParent(childPosition, childDimensions, parent) {
  const { width: parentWidth, height: parentHeight } = getNodeDimensions(parent), { x: parentX, y: parentY } = parent.internals.positionAbsolute;
  return clampPosition(childPosition, [
    [parentX, parentY],
    [parentX + parentWidth, parentY + parentHeight]
  ], childDimensions);
}
const calcAutoPanVelocity = (value, min2, max2) => value < min2 ? clamp$4(Math.abs(value - min2), 1, min2) / min2 : value > max2 ? -clamp$4(Math.abs(value - max2), 1, min2) / min2 : 0, calcAutoPan = (pos, bounds, speed = 15, distance2 = 40) => {
  const xMovement = calcAutoPanVelocity(pos.x, distance2, bounds.width - distance2) * speed, yMovement = calcAutoPanVelocity(pos.y, distance2, bounds.height - distance2) * speed;
  return [xMovement, yMovement];
}, getBoundsOfBoxes = (box1, box2) => ({
  x: Math.min(box1.x, box2.x),
  y: Math.min(box1.y, box2.y),
  x2: Math.max(box1.x2, box2.x2),
  y2: Math.max(box1.y2, box2.y2)
}), rectToBox = ({ x: x2, y: y2, width: width2, height }) => ({
  x: x2,
  y: y2,
  x2: x2 + width2,
  y2: y2 + height
}), boxToRect = ({ x: x2, y: y2, x2: x22, y2: y22 }) => ({
  x: x2,
  y: y2,
  width: x22 - x2,
  height: y22 - y2
}), nodeToRect$1 = (node2, nodeOrigin = [0, 0]) => {
  var _a4, _b2;
  const { x: x2, y: y2 } = isInternalNodeBase(node2) ? node2.internals.positionAbsolute : getNodePositionWithOrigin(node2, nodeOrigin);
  return {
    x: x2,
    y: y2,
    width: ((_a4 = node2.measured) == null ? void 0 : _a4.width) ?? node2.width ?? node2.initialWidth ?? 0,
    height: ((_b2 = node2.measured) == null ? void 0 : _b2.height) ?? node2.height ?? node2.initialHeight ?? 0
  };
}, nodeToBox = (node2, nodeOrigin = [0, 0]) => {
  var _a4, _b2;
  const { x: x2, y: y2 } = isInternalNodeBase(node2) ? node2.internals.positionAbsolute : getNodePositionWithOrigin(node2, nodeOrigin);
  return {
    x: x2,
    y: y2,
    x2: x2 + (((_a4 = node2.measured) == null ? void 0 : _a4.width) ?? node2.width ?? node2.initialWidth ?? 0),
    y2: y2 + (((_b2 = node2.measured) == null ? void 0 : _b2.height) ?? node2.height ?? node2.initialHeight ?? 0)
  };
}, getBoundsOfRects = (rect1, rect2) => boxToRect(getBoundsOfBoxes(rectToBox(rect1), rectToBox(rect2))), getOverlappingArea = (rectA, rectB) => {
  const xOverlap = Math.max(0, Math.min(rectA.x + rectA.width, rectB.x + rectB.width) - Math.max(rectA.x, rectB.x)), yOverlap = Math.max(0, Math.min(rectA.y + rectA.height, rectB.y + rectB.height) - Math.max(rectA.y, rectB.y));
  return Math.ceil(xOverlap * yOverlap);
}, isRectObject = (obj) => isNumeric(obj.width) && isNumeric(obj.height) && isNumeric(obj.x) && isNumeric(obj.y), isNumeric = (n2) => !isNaN(n2) && isFinite(n2), devWarn = (id2, message) => {
}, snapPosition = (position2, snapGrid = [1, 1]) => ({
  x: snapGrid[0] * Math.round(position2.x / snapGrid[0]),
  y: snapGrid[1] * Math.round(position2.y / snapGrid[1])
}), pointToRendererPoint = ({ x: x2, y: y2 }, [tx, ty, tScale], snapToGrid = !1, snapGrid = [1, 1]) => {
  const position2 = {
    x: (x2 - tx) / tScale,
    y: (y2 - ty) / tScale
  };
  return snapToGrid ? snapPosition(position2, snapGrid) : position2;
}, rendererPointToPoint = ({ x: x2, y: y2 }, [tx, ty, tScale]) => ({
  x: x2 * tScale + tx,
  y: y2 * tScale + ty
}), getViewportForBounds = (bounds, width2, height, minZoom, maxZoom, padding) => {
  const xZoom = width2 / (bounds.width * (1 + padding)), yZoom = height / (bounds.height * (1 + padding)), zoom2 = Math.min(xZoom, yZoom), clampedZoom = clamp$4(zoom2, minZoom, maxZoom), boundsCenterX = bounds.x + bounds.width / 2, boundsCenterY = bounds.y + bounds.height / 2, x2 = width2 / 2 - boundsCenterX * clampedZoom, y2 = height / 2 - boundsCenterY * clampedZoom;
  return { x: x2, y: y2, zoom: clampedZoom };
}, isMacOs = () => {
  var _a4;
  return typeof navigator < "u" && ((_a4 = navigator == null ? void 0 : navigator.userAgent) == null ? void 0 : _a4.indexOf("Mac")) >= 0;
};
function isCoordinateExtent(extent) {
  return extent !== void 0 && extent !== "parent";
}
function getNodeDimensions(node2) {
  var _a4, _b2;
  return {
    width: ((_a4 = node2.measured) == null ? void 0 : _a4.width) ?? node2.width ?? node2.initialWidth ?? 0,
    height: ((_b2 = node2.measured) == null ? void 0 : _b2.height) ?? node2.height ?? node2.initialHeight ?? 0
  };
}
function nodeHasDimensions(node2) {
  var _a4, _b2;
  return (((_a4 = node2.measured) == null ? void 0 : _a4.width) ?? node2.width ?? node2.initialWidth) !== void 0 && (((_b2 = node2.measured) == null ? void 0 : _b2.height) ?? node2.height ?? node2.initialHeight) !== void 0;
}
function evaluateAbsolutePosition(position2, dimensions = { width: 0, height: 0 }, parentId, nodeLookup, nodeOrigin) {
  const positionAbsolute = { ...position2 }, parent = nodeLookup.get(parentId);
  if (parent) {
    const origin = parent.origin || nodeOrigin;
    positionAbsolute.x += parent.internals.positionAbsolute.x - (dimensions.width ?? 0) * origin[0], positionAbsolute.y += parent.internals.positionAbsolute.y - (dimensions.height ?? 0) * origin[1];
  }
  return positionAbsolute;
}
function getPointerPosition(event, { snapGrid = [0, 0], snapToGrid = !1, transform: transform2, containerBounds }) {
  const { x: x2, y: y2 } = getEventPosition(event), pointerPos = pointToRendererPoint({ x: x2 - ((containerBounds == null ? void 0 : containerBounds.left) ?? 0), y: y2 - ((containerBounds == null ? void 0 : containerBounds.top) ?? 0) }, transform2), { x: xSnapped, y: ySnapped } = snapToGrid ? snapPosition(pointerPos, snapGrid) : pointerPos;
  return {
    xSnapped,
    ySnapped,
    ...pointerPos
  };
}
const getDimensions$1 = (node2) => ({
  width: node2.offsetWidth,
  height: node2.offsetHeight
}), getHostForElement = (element) => {
  var _a4;
  return ((_a4 = element.getRootNode) == null ? void 0 : _a4.call(element)) || (window == null ? void 0 : window.document);
}, inputTags = ["INPUT", "SELECT", "TEXTAREA"];
function isInputDOMNode(event) {
  var _a4, _b2;
  const target = ((_b2 = (_a4 = event.composedPath) == null ? void 0 : _a4.call(event)) == null ? void 0 : _b2[0]) || event.target;
  return inputTags.includes(target == null ? void 0 : target.nodeName) || (target == null ? void 0 : target.hasAttribute("contenteditable")) || !!(target != null && target.closest(".nokey"));
}
const isMouseEvent = (event) => "clientX" in event, getEventPosition = (event, bounds) => {
  var _a4, _b2;
  const isMouse = isMouseEvent(event), evtX = isMouse ? event.clientX : (_a4 = event.touches) == null ? void 0 : _a4[0].clientX, evtY = isMouse ? event.clientY : (_b2 = event.touches) == null ? void 0 : _b2[0].clientY;
  return {
    x: evtX - ((bounds == null ? void 0 : bounds.left) ?? 0),
    y: evtY - ((bounds == null ? void 0 : bounds.top) ?? 0)
  };
}, getHandleBounds = (type, nodeElement, nodeBounds, zoom2, nodeId) => {
  const handles = nodeElement.querySelectorAll(`.${type}`);
  return !handles || !handles.length ? null : Array.from(handles).map((handle) => {
    const handleBounds = handle.getBoundingClientRect();
    return {
      id: handle.getAttribute("data-handleid"),
      type,
      nodeId,
      position: handle.getAttribute("data-handlepos"),
      x: (handleBounds.left - nodeBounds.left) / zoom2,
      y: (handleBounds.top - nodeBounds.top) / zoom2,
      ...getDimensions$1(handle)
    };
  });
};
function getBezierEdgeCenter({ sourceX, sourceY, targetX, targetY, sourceControlX, sourceControlY, targetControlX, targetControlY }) {
  const centerX = sourceX * 0.125 + sourceControlX * 0.375 + targetControlX * 0.375 + targetX * 0.125, centerY = sourceY * 0.125 + sourceControlY * 0.375 + targetControlY * 0.375 + targetY * 0.125, offsetX = Math.abs(centerX - sourceX), offsetY = Math.abs(centerY - sourceY);
  return [centerX, centerY, offsetX, offsetY];
}
function calculateControlOffset(distance2, curvature) {
  return distance2 >= 0 ? 0.5 * distance2 : curvature * 25 * Math.sqrt(-distance2);
}
function getControlWithCurvature({ pos, x1, y1, x2, y2, c }) {
  switch (pos) {
    case Position.Left:
      return [x1 - calculateControlOffset(x1 - x2, c), y1];
    case Position.Right:
      return [x1 + calculateControlOffset(x2 - x1, c), y1];
    case Position.Top:
      return [x1, y1 - calculateControlOffset(y1 - y2, c)];
    case Position.Bottom:
      return [x1, y1 + calculateControlOffset(y2 - y1, c)];
  }
}
function getBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, curvature = 0.25 }) {
  const [sourceControlX, sourceControlY] = getControlWithCurvature({
    pos: sourcePosition,
    x1: sourceX,
    y1: sourceY,
    x2: targetX,
    y2: targetY,
    c: curvature
  }), [targetControlX, targetControlY] = getControlWithCurvature({
    pos: targetPosition,
    x1: targetX,
    y1: targetY,
    x2: sourceX,
    y2: sourceY,
    c: curvature
  }), [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourceControlX,
    sourceControlY,
    targetControlX,
    targetControlY
  });
  return [
    `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,
    labelX,
    labelY,
    offsetX,
    offsetY
  ];
}
function getEdgeCenter({ sourceX, sourceY, targetX, targetY }) {
  const xOffset = Math.abs(targetX - sourceX) / 2, centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset, yOffset = Math.abs(targetY - sourceY) / 2, centerY = targetY < sourceY ? targetY + yOffset : targetY - yOffset;
  return [centerX, centerY, xOffset, yOffset];
}
function getElevatedEdgeZIndex({ sourceNode, targetNode, selected: selected2 = !1, zIndex = 0, elevateOnSelect = !1 }) {
  if (!elevateOnSelect)
    return zIndex;
  const edgeOrConnectedNodeSelected = selected2 || targetNode.selected || sourceNode.selected, selectedZIndex = Math.max(sourceNode.internals.z || 0, targetNode.internals.z || 0, 1e3);
  return zIndex + (edgeOrConnectedNodeSelected ? selectedZIndex : 0);
}
function isEdgeVisible({ sourceNode, targetNode, width: width2, height, transform: transform2 }) {
  const edgeBox = getBoundsOfBoxes(nodeToBox(sourceNode), nodeToBox(targetNode));
  edgeBox.x === edgeBox.x2 && (edgeBox.x2 += 1), edgeBox.y === edgeBox.y2 && (edgeBox.y2 += 1);
  const viewRect = {
    x: -transform2[0] / transform2[2],
    y: -transform2[1] / transform2[2],
    width: width2 / transform2[2],
    height: height / transform2[2]
  };
  return getOverlappingArea(viewRect, boxToRect(edgeBox)) > 0;
}
const getEdgeId = ({ source, sourceHandle, target, targetHandle }) => `xy-edge__${source}${sourceHandle || ""}-${target}${targetHandle || ""}`, connectionExists = (edge, edges) => edges.some((el) => el.source === edge.source && el.target === edge.target && (el.sourceHandle === edge.sourceHandle || !el.sourceHandle && !edge.sourceHandle) && (el.targetHandle === edge.targetHandle || !el.targetHandle && !edge.targetHandle)), addEdge$1 = (edgeParams, edges) => {
  if (!edgeParams.source || !edgeParams.target)
    return edges;
  let edge;
  return isEdgeBase(edgeParams) ? edge = { ...edgeParams } : edge = {
    ...edgeParams,
    id: getEdgeId(edgeParams)
  }, connectionExists(edge, edges) ? edges : (edge.sourceHandle === null && delete edge.sourceHandle, edge.targetHandle === null && delete edge.targetHandle, edges.concat(edge));
};
function getStraightPath({ sourceX, sourceY, targetX, targetY }) {
  const [labelX, labelY, offsetX, offsetY] = getEdgeCenter({
    sourceX,
    sourceY,
    targetX,
    targetY
  });
  return [`M ${sourceX},${sourceY}L ${targetX},${targetY}`, labelX, labelY, offsetX, offsetY];
}
const handleDirections = {
  [Position.Left]: { x: -1, y: 0 },
  [Position.Right]: { x: 1, y: 0 },
  [Position.Top]: { x: 0, y: -1 },
  [Position.Bottom]: { x: 0, y: 1 }
}, getDirection = ({ source, sourcePosition = Position.Bottom, target }) => sourcePosition === Position.Left || sourcePosition === Position.Right ? source.x < target.x ? { x: 1, y: 0 } : { x: -1, y: 0 } : source.y < target.y ? { x: 0, y: 1 } : { x: 0, y: -1 }, distance$1 = (a2, b2) => Math.sqrt(Math.pow(b2.x - a2.x, 2) + Math.pow(b2.y - a2.y, 2));
function getPoints({ source, sourcePosition = Position.Bottom, target, targetPosition = Position.Top, center, offset: offset2 }) {
  const sourceDir = handleDirections[sourcePosition], targetDir = handleDirections[targetPosition], sourceGapped = { x: source.x + sourceDir.x * offset2, y: source.y + sourceDir.y * offset2 }, targetGapped = { x: target.x + targetDir.x * offset2, y: target.y + targetDir.y * offset2 }, dir = getDirection({
    source: sourceGapped,
    sourcePosition,
    target: targetGapped
  }), dirAccessor = dir.x !== 0 ? "x" : "y", currDir = dir[dirAccessor];
  let points = [], centerX, centerY;
  const sourceGapOffset = { x: 0, y: 0 }, targetGapOffset = { x: 0, y: 0 }, [defaultCenterX, defaultCenterY, defaultOffsetX, defaultOffsetY] = getEdgeCenter({
    sourceX: source.x,
    sourceY: source.y,
    targetX: target.x,
    targetY: target.y
  });
  if (sourceDir[dirAccessor] * targetDir[dirAccessor] === -1) {
    centerX = center.x ?? defaultCenterX, centerY = center.y ?? defaultCenterY;
    const verticalSplit = [
      { x: centerX, y: sourceGapped.y },
      { x: centerX, y: targetGapped.y }
    ], horizontalSplit = [
      { x: sourceGapped.x, y: centerY },
      { x: targetGapped.x, y: centerY }
    ];
    sourceDir[dirAccessor] === currDir ? points = dirAccessor === "x" ? verticalSplit : horizontalSplit : points = dirAccessor === "x" ? horizontalSplit : verticalSplit;
  } else {
    const sourceTarget = [{ x: sourceGapped.x, y: targetGapped.y }], targetSource = [{ x: targetGapped.x, y: sourceGapped.y }];
    if (dirAccessor === "x" ? points = sourceDir.x === currDir ? targetSource : sourceTarget : points = sourceDir.y === currDir ? sourceTarget : targetSource, sourcePosition === targetPosition) {
      const diff = Math.abs(source[dirAccessor] - target[dirAccessor]);
      if (diff <= offset2) {
        const gapOffset = Math.min(offset2 - 1, offset2 - diff);
        sourceDir[dirAccessor] === currDir ? sourceGapOffset[dirAccessor] = (sourceGapped[dirAccessor] > source[dirAccessor] ? -1 : 1) * gapOffset : targetGapOffset[dirAccessor] = (targetGapped[dirAccessor] > target[dirAccessor] ? -1 : 1) * gapOffset;
      }
    }
    if (sourcePosition !== targetPosition) {
      const dirAccessorOpposite = dirAccessor === "x" ? "y" : "x", isSameDir = sourceDir[dirAccessor] === targetDir[dirAccessorOpposite], sourceGtTargetOppo = sourceGapped[dirAccessorOpposite] > targetGapped[dirAccessorOpposite], sourceLtTargetOppo = sourceGapped[dirAccessorOpposite] < targetGapped[dirAccessorOpposite];
      (sourceDir[dirAccessor] === 1 && (!isSameDir && sourceGtTargetOppo || isSameDir && sourceLtTargetOppo) || sourceDir[dirAccessor] !== 1 && (!isSameDir && sourceLtTargetOppo || isSameDir && sourceGtTargetOppo)) && (points = dirAccessor === "x" ? sourceTarget : targetSource);
    }
    const sourceGapPoint = { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y }, targetGapPoint = { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y }, maxXDistance = Math.max(Math.abs(sourceGapPoint.x - points[0].x), Math.abs(targetGapPoint.x - points[0].x)), maxYDistance = Math.max(Math.abs(sourceGapPoint.y - points[0].y), Math.abs(targetGapPoint.y - points[0].y));
    maxXDistance >= maxYDistance ? (centerX = (sourceGapPoint.x + targetGapPoint.x) / 2, centerY = points[0].y) : (centerX = points[0].x, centerY = (sourceGapPoint.y + targetGapPoint.y) / 2);
  }
  return [[
    source,
    { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y },
    ...points,
    { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y },
    target
  ], centerX, centerY, defaultOffsetX, defaultOffsetY];
}
function getBend(a2, b2, c, size2) {
  const bendSize = Math.min(distance$1(a2, b2) / 2, distance$1(b2, c) / 2, size2), { x: x2, y: y2 } = b2;
  if (a2.x === x2 && x2 === c.x || a2.y === y2 && y2 === c.y)
    return `L${x2} ${y2}`;
  if (a2.y === y2) {
    const xDir2 = a2.x < c.x ? -1 : 1, yDir2 = a2.y < c.y ? 1 : -1;
    return `L ${x2 + bendSize * xDir2},${y2}Q ${x2},${y2} ${x2},${y2 + bendSize * yDir2}`;
  }
  const xDir = a2.x < c.x ? 1 : -1, yDir = a2.y < c.y ? -1 : 1;
  return `L ${x2},${y2 + bendSize * yDir}Q ${x2},${y2} ${x2 + bendSize * xDir},${y2}`;
}
function getSmoothStepPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, borderRadius = 5, centerX, centerY, offset: offset2 = 20 }) {
  const [points, labelX, labelY, offsetX, offsetY] = getPoints({
    source: { x: sourceX, y: sourceY },
    sourcePosition,
    target: { x: targetX, y: targetY },
    targetPosition,
    center: { x: centerX, y: centerY },
    offset: offset2
  });
  return [points.reduce((res, p2, i2) => {
    let segment = "";
    return i2 > 0 && i2 < points.length - 1 ? segment = getBend(points[i2 - 1], p2, points[i2 + 1], borderRadius) : segment = `${i2 === 0 ? "M" : "L"}${p2.x} ${p2.y}`, res += segment, res;
  }, ""), labelX, labelY, offsetX, offsetY];
}
function isNodeInitialized(node2) {
  var _a4;
  return node2 && !!(node2.internals.handleBounds || (_a4 = node2.handles) != null && _a4.length) && !!(node2.measured.width || node2.width || node2.initialWidth);
}
function getEdgePosition(params) {
  var _a4;
  const { sourceNode, targetNode } = params;
  if (!isNodeInitialized(sourceNode) || !isNodeInitialized(targetNode))
    return null;
  const sourceHandleBounds = sourceNode.internals.handleBounds || toHandleBounds(sourceNode.handles), targetHandleBounds = targetNode.internals.handleBounds || toHandleBounds(targetNode.handles), sourceHandle = getHandle$1((sourceHandleBounds == null ? void 0 : sourceHandleBounds.source) ?? [], params.sourceHandle), targetHandle = getHandle$1(
    // when connection type is loose we can define all handles as sources and connect source -> source
    params.connectionMode === ConnectionMode.Strict ? (targetHandleBounds == null ? void 0 : targetHandleBounds.target) ?? [] : ((targetHandleBounds == null ? void 0 : targetHandleBounds.target) ?? []).concat((targetHandleBounds == null ? void 0 : targetHandleBounds.source) ?? []),
    params.targetHandle
  );
  if (!sourceHandle || !targetHandle)
    return (_a4 = params.onError) == null || _a4.call(params, "008", errorMessages.error008(sourceHandle ? "target" : "source", {
      id: params.id,
      sourceHandle: params.sourceHandle,
      targetHandle: params.targetHandle
    })), null;
  const sourcePosition = (sourceHandle == null ? void 0 : sourceHandle.position) || Position.Bottom, targetPosition = (targetHandle == null ? void 0 : targetHandle.position) || Position.Top, source = getHandlePosition(sourceNode, sourceHandle, sourcePosition), target = getHandlePosition(targetNode, targetHandle, targetPosition);
  return {
    sourceX: source.x,
    sourceY: source.y,
    targetX: target.x,
    targetY: target.y,
    sourcePosition,
    targetPosition
  };
}
function toHandleBounds(handles) {
  if (!handles)
    return null;
  const source = [], target = [];
  for (const handle of handles)
    handle.width = handle.width ?? 1, handle.height = handle.height ?? 1, handle.type === "source" ? source.push(handle) : handle.type === "target" && target.push(handle);
  return {
    source,
    target
  };
}
function getHandlePosition(node2, handle, fallbackPosition = Position.Left, center = !1) {
  const x2 = ((handle == null ? void 0 : handle.x) ?? 0) + node2.internals.positionAbsolute.x, y2 = ((handle == null ? void 0 : handle.y) ?? 0) + node2.internals.positionAbsolute.y, { width: width2, height } = handle ?? getNodeDimensions(node2);
  if (center)
    return { x: x2 + width2 / 2, y: y2 + height / 2 };
  switch ((handle == null ? void 0 : handle.position) ?? fallbackPosition) {
    case Position.Top:
      return { x: x2 + width2 / 2, y: y2 };
    case Position.Right:
      return { x: x2 + width2, y: y2 + height / 2 };
    case Position.Bottom:
      return { x: x2 + width2 / 2, y: y2 + height };
    case Position.Left:
      return { x: x2, y: y2 + height / 2 };
  }
}
function getHandle$1(bounds, handleId) {
  return bounds && (handleId ? bounds.find((d2) => d2.id === handleId) : bounds[0]) || null;
}
function getMarkerId(marker, id2) {
  return marker ? typeof marker == "string" ? marker : `${id2 ? `${id2}__` : ""}${Object.keys(marker).sort().map((key) => `${key}=${marker[key]}`).join("&")}` : "";
}
function createMarkerIds(edges, { id: id2, defaultColor, defaultMarkerStart, defaultMarkerEnd }) {
  const ids = /* @__PURE__ */ new Set();
  return edges.reduce((markers, edge) => ([edge.markerStart || defaultMarkerStart, edge.markerEnd || defaultMarkerEnd].forEach((marker) => {
    if (marker && typeof marker == "object") {
      const markerId = getMarkerId(marker, id2);
      ids.has(markerId) || (markers.push({ id: markerId, color: marker.color || defaultColor, ...marker }), ids.add(markerId));
    }
  }), markers), []).sort((a2, b2) => a2.id.localeCompare(b2.id));
}
function getNodeToolbarTransform(nodeRect, viewport, position2, offset2, align2) {
  let alignmentOffset = 0.5;
  align2 === "start" ? alignmentOffset = 0 : align2 === "end" && (alignmentOffset = 1);
  let pos = [
    (nodeRect.x + nodeRect.width * alignmentOffset) * viewport.zoom + viewport.x,
    nodeRect.y * viewport.zoom + viewport.y - offset2
  ], shift2 = [-100 * alignmentOffset, -100];
  switch (position2) {
    case Position.Right:
      pos = [
        (nodeRect.x + nodeRect.width) * viewport.zoom + viewport.x + offset2,
        (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y
      ], shift2 = [0, -100 * alignmentOffset];
      break;
    case Position.Bottom:
      pos[1] = (nodeRect.y + nodeRect.height) * viewport.zoom + viewport.y + offset2, shift2[1] = 0;
      break;
    case Position.Left:
      pos = [
        nodeRect.x * viewport.zoom + viewport.x - offset2,
        (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y
      ], shift2 = [-100, -100 * alignmentOffset];
      break;
  }
  return `translate(${pos[0]}px, ${pos[1]}px) translate(${shift2[0]}%, ${shift2[1]}%)`;
}
const defaultOptions = {
  nodeOrigin: [0, 0],
  nodeExtent: infiniteExtent,
  elevateNodesOnSelect: !0,
  defaults: {}
}, adoptUserNodesDefaultOptions = {
  ...defaultOptions,
  checkEquality: !0
};
function mergeObjects(base, incoming) {
  const result = { ...base };
  for (const key in incoming)
    incoming[key] !== void 0 && (result[key] = incoming[key]);
  return result;
}
function updateAbsolutePositions(nodeLookup, parentLookup, options) {
  const _options = mergeObjects(defaultOptions, options);
  for (const node2 of nodeLookup.values())
    if (node2.parentId)
      updateChildNode(node2, nodeLookup, parentLookup, _options);
    else {
      const positionWithOrigin = getNodePositionWithOrigin(node2, _options.nodeOrigin), extent = isCoordinateExtent(node2.extent) ? node2.extent : _options.nodeExtent, clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(node2));
      node2.internals.positionAbsolute = clampedPosition;
    }
}
function adoptUserNodes(nodes, nodeLookup, parentLookup, options) {
  var _a4, _b2;
  const _options = mergeObjects(adoptUserNodesDefaultOptions, options), tmpLookup = new Map(nodeLookup), selectedNodeZ = _options != null && _options.elevateNodesOnSelect ? 1e3 : 0;
  nodeLookup.clear(), parentLookup.clear();
  for (const userNode of nodes) {
    let internalNode = tmpLookup.get(userNode.id);
    if (_options.checkEquality && userNode === (internalNode == null ? void 0 : internalNode.internals.userNode))
      nodeLookup.set(userNode.id, internalNode);
    else {
      const positionWithOrigin = getNodePositionWithOrigin(userNode, _options.nodeOrigin), extent = isCoordinateExtent(userNode.extent) ? userNode.extent : _options.nodeExtent, clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(userNode));
      internalNode = {
        ..._options.defaults,
        ...userNode,
        measured: {
          width: (_a4 = userNode.measured) == null ? void 0 : _a4.width,
          height: (_b2 = userNode.measured) == null ? void 0 : _b2.height
        },
        internals: {
          positionAbsolute: clampedPosition,
          // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured
          handleBounds: userNode.measured ? internalNode == null ? void 0 : internalNode.internals.handleBounds : void 0,
          z: calculateZ(userNode, selectedNodeZ),
          userNode
        }
      }, nodeLookup.set(userNode.id, internalNode);
    }
    userNode.parentId && updateChildNode(internalNode, nodeLookup, parentLookup, options);
  }
}
function updateParentLookup(node2, parentLookup) {
  if (!node2.parentId)
    return;
  const childNodes = parentLookup.get(node2.parentId);
  childNodes ? childNodes.set(node2.id, node2) : parentLookup.set(node2.parentId, /* @__PURE__ */ new Map([[node2.id, node2]]));
}
function updateChildNode(node2, nodeLookup, parentLookup, options) {
  const { elevateNodesOnSelect, nodeOrigin, nodeExtent } = mergeObjects(defaultOptions, options), parentId = node2.parentId, parentNode = nodeLookup.get(parentId);
  if (!parentNode) {
    console.warn(`Parent node ${parentId} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);
    return;
  }
  updateParentLookup(node2, parentLookup);
  const selectedNodeZ = elevateNodesOnSelect ? 1e3 : 0, { x: x2, y: y2, z: z2 } = calculateChildXYZ(node2, parentNode, nodeOrigin, nodeExtent, selectedNodeZ), { positionAbsolute } = node2.internals, positionChanged = x2 !== positionAbsolute.x || y2 !== positionAbsolute.y;
  (positionChanged || z2 !== node2.internals.z) && (node2.internals = {
    ...node2.internals,
    positionAbsolute: positionChanged ? { x: x2, y: y2 } : positionAbsolute,
    z: z2
  });
}
function calculateZ(node2, selectedNodeZ) {
  return (isNumeric(node2.zIndex) ? node2.zIndex : 0) + (node2.selected ? selectedNodeZ : 0);
}
function calculateChildXYZ(childNode, parentNode, nodeOrigin, nodeExtent, selectedNodeZ) {
  const { x: parentX, y: parentY } = parentNode.internals.positionAbsolute, childDimensions = getNodeDimensions(childNode), positionWithOrigin = getNodePositionWithOrigin(childNode, nodeOrigin), clampedPosition = isCoordinateExtent(childNode.extent) ? clampPosition(positionWithOrigin, childNode.extent, childDimensions) : positionWithOrigin;
  let absolutePosition = clampPosition({ x: parentX + clampedPosition.x, y: parentY + clampedPosition.y }, nodeExtent, childDimensions);
  childNode.extent === "parent" && (absolutePosition = clampPositionToParent(absolutePosition, childDimensions, parentNode));
  const childZ = calculateZ(childNode, selectedNodeZ), parentZ = parentNode.internals.z ?? 0;
  return {
    x: absolutePosition.x,
    y: absolutePosition.y,
    z: parentZ > childZ ? parentZ : childZ
  };
}
function handleExpandParent(children2, nodeLookup, parentLookup, nodeOrigin = [0, 0]) {
  var _a4;
  const changes = [], parentExpansions = /* @__PURE__ */ new Map();
  for (const child of children2) {
    const parent = nodeLookup.get(child.parentId);
    if (!parent)
      continue;
    const parentRect = ((_a4 = parentExpansions.get(child.parentId)) == null ? void 0 : _a4.expandedRect) ?? nodeToRect$1(parent), expandedRect = getBoundsOfRects(parentRect, child.rect);
    parentExpansions.set(child.parentId, { expandedRect, parent });
  }
  return parentExpansions.size > 0 && parentExpansions.forEach(({ expandedRect, parent }, parentId) => {
    var _a5;
    const positionAbsolute = parent.internals.positionAbsolute, dimensions = getNodeDimensions(parent), origin = parent.origin ?? nodeOrigin, xChange = expandedRect.x < positionAbsolute.x ? Math.round(Math.abs(positionAbsolute.x - expandedRect.x)) : 0, yChange = expandedRect.y < positionAbsolute.y ? Math.round(Math.abs(positionAbsolute.y - expandedRect.y)) : 0, newWidth = Math.max(dimensions.width, Math.round(expandedRect.width)), newHeight = Math.max(dimensions.height, Math.round(expandedRect.height)), widthChange = (newWidth - dimensions.width) * origin[0], heightChange = (newHeight - dimensions.height) * origin[1];
    (xChange > 0 || yChange > 0 || widthChange || heightChange) && (changes.push({
      id: parentId,
      type: "position",
      position: {
        x: parent.position.x - xChange + widthChange,
        y: parent.position.y - yChange + heightChange
      }
    }), (_a5 = parentLookup.get(parentId)) == null || _a5.forEach((childNode) => {
      children2.some((child) => child.id === childNode.id) || changes.push({
        id: childNode.id,
        type: "position",
        position: {
          x: childNode.position.x + xChange,
          y: childNode.position.y + yChange
        }
      });
    })), (dimensions.width < expandedRect.width || dimensions.height < expandedRect.height || xChange || yChange) && changes.push({
      id: parentId,
      type: "dimensions",
      setAttributes: !0,
      dimensions: {
        width: newWidth + (xChange ? origin[0] * xChange - widthChange : 0),
        height: newHeight + (yChange ? origin[1] * yChange - heightChange : 0)
      }
    });
  }), changes;
}
function updateNodeInternals(updates, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent) {
  const viewportNode = domNode == null ? void 0 : domNode.querySelector(".xyflow__viewport");
  let updatedInternals = !1;
  if (!viewportNode)
    return { changes: [], updatedInternals };
  const changes = [], style2 = window.getComputedStyle(viewportNode), { m22: zoom2 } = new window.DOMMatrixReadOnly(style2.transform), parentExpandChildren = [];
  for (const update of updates.values()) {
    const node2 = nodeLookup.get(update.id);
    if (node2)
      if (node2.hidden)
        node2.internals = {
          ...node2.internals,
          handleBounds: void 0
        }, updatedInternals = !0;
      else {
        const dimensions = getDimensions$1(update.nodeElement), dimensionChanged = node2.measured.width !== dimensions.width || node2.measured.height !== dimensions.height;
        if (!!(dimensions.width && dimensions.height && (dimensionChanged || !node2.internals.handleBounds || update.force))) {
          const nodeBounds = update.nodeElement.getBoundingClientRect(), extent = isCoordinateExtent(node2.extent) ? node2.extent : nodeExtent;
          let { positionAbsolute } = node2.internals;
          node2.parentId && node2.extent === "parent" ? positionAbsolute = clampPositionToParent(positionAbsolute, dimensions, nodeLookup.get(node2.parentId)) : extent && (positionAbsolute = clampPosition(positionAbsolute, extent, dimensions)), node2.measured = dimensions, node2.internals = {
            ...node2.internals,
            positionAbsolute,
            handleBounds: {
              source: getHandleBounds("source", update.nodeElement, nodeBounds, zoom2, node2.id),
              target: getHandleBounds("target", update.nodeElement, nodeBounds, zoom2, node2.id)
            }
          }, node2.parentId && updateChildNode(node2, nodeLookup, parentLookup, { nodeOrigin }), updatedInternals = !0, dimensionChanged && (changes.push({
            id: node2.id,
            type: "dimensions",
            dimensions
          }), node2.expandParent && node2.parentId && parentExpandChildren.push({
            id: node2.id,
            parentId: node2.parentId,
            rect: nodeToRect$1(node2, nodeOrigin)
          }));
        }
      }
  }
  if (parentExpandChildren.length > 0) {
    const parentExpandChanges = handleExpandParent(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin);
    changes.push(...parentExpandChanges);
  }
  return { changes, updatedInternals };
}
async function panBy({ delta, panZoom, transform: transform2, translateExtent, width: width2, height }) {
  if (!panZoom || !delta.x && !delta.y)
    return Promise.resolve(!1);
  const nextViewport = await panZoom.setViewportConstrained({
    x: transform2[0] + delta.x,
    y: transform2[1] + delta.y,
    zoom: transform2[2]
  }, [
    [0, 0],
    [width2, height]
  ], translateExtent), transformChanged = !!nextViewport && (nextViewport.x !== transform2[0] || nextViewport.y !== transform2[1] || nextViewport.k !== transform2[2]);
  return Promise.resolve(transformChanged);
}
function updateConnectionLookup(connectionLookup, edgeLookup, edges) {
  connectionLookup.clear(), edgeLookup.clear();
  for (const edge of edges) {
    const { source, target, sourceHandle = null, targetHandle = null } = edge, sourceKey = `${source}-source-${sourceHandle}`, targetKey = `${target}-target-${targetHandle}`, prevSource = connectionLookup.get(sourceKey) || /* @__PURE__ */ new Map(), prevTarget = connectionLookup.get(targetKey) || /* @__PURE__ */ new Map(), connection = { edgeId: edge.id, source, target, sourceHandle, targetHandle };
    edgeLookup.set(edge.id, edge), connectionLookup.set(sourceKey, prevSource.set(`${target}-${targetHandle}`, connection)), connectionLookup.set(targetKey, prevTarget.set(`${source}-${sourceHandle}`, connection));
  }
}
function shallowNodeData(a2, b2) {
  if (a2 === null || b2 === null)
    return !1;
  const _a4 = Array.isArray(a2) ? a2 : [a2], _b2 = Array.isArray(b2) ? b2 : [b2];
  if (_a4.length !== _b2.length)
    return !1;
  for (let i2 = 0; i2 < _a4.length; i2++)
    if (_a4[i2].id !== _b2[i2].id || _a4[i2].type !== _b2[i2].type || !Object.is(_a4[i2].data, _b2[i2].data))
      return !1;
  return !0;
}
function isParentSelected(node2, nodeLookup) {
  if (!node2.parentId)
    return !1;
  const parentNode = nodeLookup.get(node2.parentId);
  return parentNode ? parentNode.selected ? !0 : isParentSelected(parentNode, nodeLookup) : !1;
}
function hasSelector(target, selector2, domNode) {
  let current = target;
  do {
    if (current != null && current.matches(selector2))
      return !0;
    if (current === domNode)
      return !1;
    current = current.parentElement;
  } while (current);
  return !1;
}
function getDragItems(nodeLookup, nodesDraggable, mousePos, nodeId) {
  const dragItems = /* @__PURE__ */ new Map();
  for (const [id2, node2] of nodeLookup)
    if ((node2.selected || node2.id === nodeId) && (!node2.parentId || !isParentSelected(node2, nodeLookup)) && (node2.draggable || nodesDraggable && typeof node2.draggable > "u")) {
      const internalNode = nodeLookup.get(id2);
      internalNode && dragItems.set(id2, {
        id: id2,
        position: internalNode.position || { x: 0, y: 0 },
        distance: {
          x: mousePos.x - internalNode.internals.positionAbsolute.x,
          y: mousePos.y - internalNode.internals.positionAbsolute.y
        },
        extent: internalNode.extent,
        parentId: internalNode.parentId,
        origin: internalNode.origin,
        expandParent: internalNode.expandParent,
        internals: {
          positionAbsolute: internalNode.internals.positionAbsolute || { x: 0, y: 0 }
        },
        measured: {
          width: internalNode.measured.width ?? 0,
          height: internalNode.measured.height ?? 0
        }
      });
    }
  return dragItems;
}
function getEventHandlerParams({ nodeId, dragItems, nodeLookup, dragging = !0 }) {
  var _a4, _b2, _c;
  const nodesFromDragItems = [];
  for (const [id2, dragItem] of dragItems) {
    const node22 = (_a4 = nodeLookup.get(id2)) == null ? void 0 : _a4.internals.userNode;
    node22 && nodesFromDragItems.push({
      ...node22,
      position: dragItem.position,
      dragging
    });
  }
  if (!nodeId)
    return [nodesFromDragItems[0], nodesFromDragItems];
  const node2 = (_b2 = nodeLookup.get(nodeId)) == null ? void 0 : _b2.internals.userNode;
  return [
    node2 ? {
      ...node2,
      position: ((_c = dragItems.get(nodeId)) == null ? void 0 : _c.position) || node2.position,
      dragging
    } : nodesFromDragItems[0],
    nodesFromDragItems
  ];
}
function XYDrag({ onNodeMouseDown, getStoreItems, onDragStart, onDrag, onDragStop }) {
  let lastPos = { x: null, y: null }, autoPanId = 0, dragItems = /* @__PURE__ */ new Map(), autoPanStarted = !1, mousePosition = { x: 0, y: 0 }, containerBounds = null, dragStarted = !1, d3Selection = null, abortDrag = !1;
  function update({ noDragClassName, handleSelector, domNode, isSelectable, nodeId, nodeClickDistance = 0 }) {
    d3Selection = select(domNode);
    function updateNodes({ x: x2, y: y2 }, dragEvent) {
      const { nodeLookup, nodeExtent, snapGrid, snapToGrid, nodeOrigin, onNodeDrag, onSelectionDrag, onError, updateNodePositions } = getStoreItems();
      lastPos = { x: x2, y: y2 };
      let hasChange = !1, nodesBox = { x: 0, y: 0, x2: 0, y2: 0 };
      if (dragItems.size > 1 && nodeExtent) {
        const rect = getInternalNodesBounds(dragItems);
        nodesBox = rectToBox(rect);
      }
      for (const [id2, dragItem] of dragItems) {
        if (!nodeLookup.has(id2))
          continue;
        let nextPosition = { x: x2 - dragItem.distance.x, y: y2 - dragItem.distance.y };
        snapToGrid && (nextPosition = snapPosition(nextPosition, snapGrid));
        let adjustedNodeExtent = [
          [nodeExtent[0][0], nodeExtent[0][1]],
          [nodeExtent[1][0], nodeExtent[1][1]]
        ];
        if (dragItems.size > 1 && nodeExtent && !dragItem.extent) {
          const { positionAbsolute: positionAbsolute2 } = dragItem.internals, x1 = positionAbsolute2.x - nodesBox.x + nodeExtent[0][0], x22 = positionAbsolute2.x + dragItem.measured.width - nodesBox.x2 + nodeExtent[1][0], y1 = positionAbsolute2.y - nodesBox.y + nodeExtent[0][1], y22 = positionAbsolute2.y + dragItem.measured.height - nodesBox.y2 + nodeExtent[1][1];
          adjustedNodeExtent = [
            [x1, y1],
            [x22, y22]
          ];
        }
        const { position: position2, positionAbsolute } = calculateNodePosition({
          nodeId: id2,
          nextPosition,
          nodeLookup,
          nodeExtent: adjustedNodeExtent,
          nodeOrigin,
          onError
        });
        hasChange = hasChange || dragItem.position.x !== position2.x || dragItem.position.y !== position2.y, dragItem.position = position2, dragItem.internals.positionAbsolute = positionAbsolute;
      }
      if (hasChange && (updateNodePositions(dragItems, !0), dragEvent && (onDrag || onNodeDrag || !nodeId && onSelectionDrag))) {
        const [currentNode, currentNodes] = getEventHandlerParams({
          nodeId,
          dragItems,
          nodeLookup
        });
        onDrag == null || onDrag(dragEvent, dragItems, currentNode, currentNodes), onNodeDrag == null || onNodeDrag(dragEvent, currentNode, currentNodes), nodeId || onSelectionDrag == null || onSelectionDrag(dragEvent, currentNodes);
      }
    }
    async function autoPan() {
      if (!containerBounds)
        return;
      const { transform: transform2, panBy: panBy2, autoPanSpeed } = getStoreItems(), [xMovement, yMovement] = calcAutoPan(mousePosition, containerBounds, autoPanSpeed);
      (xMovement !== 0 || yMovement !== 0) && (lastPos.x = (lastPos.x ?? 0) - xMovement / transform2[2], lastPos.y = (lastPos.y ?? 0) - yMovement / transform2[2], await panBy2({ x: xMovement, y: yMovement }) && updateNodes(lastPos, null)), autoPanId = requestAnimationFrame(autoPan);
    }
    function startDrag(event) {
      var _a4;
      const { nodeLookup, multiSelectionActive, nodesDraggable, transform: transform2, snapGrid, snapToGrid, selectNodesOnDrag, onNodeDragStart, onSelectionDragStart, unselectNodesAndEdges } = getStoreItems();
      dragStarted = !0, (!selectNodesOnDrag || !isSelectable) && !multiSelectionActive && nodeId && ((_a4 = nodeLookup.get(nodeId)) != null && _a4.selected || unselectNodesAndEdges()), isSelectable && selectNodesOnDrag && nodeId && (onNodeMouseDown == null || onNodeMouseDown(nodeId));
      const pointerPos = getPointerPosition(event.sourceEvent, { transform: transform2, snapGrid, snapToGrid, containerBounds });
      if (lastPos = pointerPos, dragItems = getDragItems(nodeLookup, nodesDraggable, pointerPos, nodeId), dragItems.size > 0 && (onDragStart || onNodeDragStart || !nodeId && onSelectionDragStart)) {
        const [currentNode, currentNodes] = getEventHandlerParams({
          nodeId,
          dragItems,
          nodeLookup
        });
        onDragStart == null || onDragStart(event.sourceEvent, dragItems, currentNode, currentNodes), onNodeDragStart == null || onNodeDragStart(event.sourceEvent, currentNode, currentNodes), nodeId || onSelectionDragStart == null || onSelectionDragStart(event.sourceEvent, currentNodes);
      }
    }
    const d3DragInstance = drag$1().clickDistance(nodeClickDistance).on("start", (event) => {
      const { domNode: domNode2, nodeDragThreshold, transform: transform2, snapGrid, snapToGrid } = getStoreItems();
      containerBounds = (domNode2 == null ? void 0 : domNode2.getBoundingClientRect()) || null, abortDrag = !1, nodeDragThreshold === 0 && startDrag(event), lastPos = getPointerPosition(event.sourceEvent, { transform: transform2, snapGrid, snapToGrid, containerBounds }), mousePosition = getEventPosition(event.sourceEvent, containerBounds);
    }).on("drag", (event) => {
      const { autoPanOnNodeDrag, transform: transform2, snapGrid, snapToGrid, nodeDragThreshold, nodeLookup } = getStoreItems(), pointerPos = getPointerPosition(event.sourceEvent, { transform: transform2, snapGrid, snapToGrid, containerBounds });
      if ((event.sourceEvent.type === "touchmove" && event.sourceEvent.touches.length > 1 || // if user deletes a node while dragging, we need to abort the drag to prevent errors
      nodeId && !nodeLookup.has(nodeId)) && (abortDrag = !0), !abortDrag) {
        if (!autoPanStarted && autoPanOnNodeDrag && dragStarted && (autoPanStarted = !0, autoPan()), !dragStarted) {
          const x2 = pointerPos.xSnapped - (lastPos.x ?? 0), y2 = pointerPos.ySnapped - (lastPos.y ?? 0);
          Math.sqrt(x2 * x2 + y2 * y2) > nodeDragThreshold && startDrag(event);
        }
        (lastPos.x !== pointerPos.xSnapped || lastPos.y !== pointerPos.ySnapped) && dragItems && dragStarted && (mousePosition = getEventPosition(event.sourceEvent, containerBounds), updateNodes(pointerPos, event.sourceEvent));
      }
    }).on("end", (event) => {
      if (!(!dragStarted || abortDrag) && (autoPanStarted = !1, dragStarted = !1, cancelAnimationFrame(autoPanId), dragItems.size > 0)) {
        const { nodeLookup, updateNodePositions, onNodeDragStop, onSelectionDragStop } = getStoreItems();
        if (updateNodePositions(dragItems, !1), onDragStop || onNodeDragStop || !nodeId && onSelectionDragStop) {
          const [currentNode, currentNodes] = getEventHandlerParams({
            nodeId,
            dragItems,
            nodeLookup,
            dragging: !1
          });
          onDragStop == null || onDragStop(event.sourceEvent, dragItems, currentNode, currentNodes), onNodeDragStop == null || onNodeDragStop(event.sourceEvent, currentNode, currentNodes), nodeId || onSelectionDragStop == null || onSelectionDragStop(event.sourceEvent, currentNodes);
        }
      }
    }).filter((event) => {
      const target = event.target;
      return !event.button && (!noDragClassName || !hasSelector(target, `.${noDragClassName}`, domNode)) && (!handleSelector || hasSelector(target, handleSelector, domNode));
    });
    d3Selection.call(d3DragInstance);
  }
  function destroy() {
    d3Selection == null || d3Selection.on(".drag", null);
  }
  return {
    update,
    destroy
  };
}
function getNodesWithinDistance(position2, nodeLookup, distance2) {
  const nodes = [], rect = {
    x: position2.x - distance2,
    y: position2.y - distance2,
    width: distance2 * 2,
    height: distance2 * 2
  };
  for (const node2 of nodeLookup.values())
    getOverlappingArea(rect, nodeToRect$1(node2)) > 0 && nodes.push(node2);
  return nodes;
}
const ADDITIONAL_DISTANCE = 250;
function getClosestHandle(position2, connectionRadius, nodeLookup, fromHandle) {
  var _a4, _b2;
  let closestHandles = [], minDistance = 1 / 0;
  const closeNodes = getNodesWithinDistance(position2, nodeLookup, connectionRadius + ADDITIONAL_DISTANCE);
  for (const node2 of closeNodes) {
    const allHandles = [...((_a4 = node2.internals.handleBounds) == null ? void 0 : _a4.source) ?? [], ...((_b2 = node2.internals.handleBounds) == null ? void 0 : _b2.target) ?? []];
    for (const handle of allHandles) {
      if (fromHandle.nodeId === handle.nodeId && fromHandle.type === handle.type && fromHandle.id === handle.id)
        continue;
      const { x: x2, y: y2 } = getHandlePosition(node2, handle, handle.position, !0), distance2 = Math.sqrt(Math.pow(x2 - position2.x, 2) + Math.pow(y2 - position2.y, 2));
      distance2 > connectionRadius || (distance2 < minDistance ? (closestHandles = [{ ...handle, x: x2, y: y2 }], minDistance = distance2) : distance2 === minDistance && closestHandles.push({ ...handle, x: x2, y: y2 }));
    }
  }
  if (!closestHandles.length)
    return null;
  if (closestHandles.length > 1) {
    const oppositeHandleType = fromHandle.type === "source" ? "target" : "source";
    return closestHandles.find((handle) => handle.type === oppositeHandleType) ?? closestHandles[0];
  }
  return closestHandles[0];
}
function getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode, withAbsolutePosition = !1) {
  var _a4, _b2, _c;
  const node2 = nodeLookup.get(nodeId);
  if (!node2)
    return null;
  const handles = connectionMode === "strict" ? (_a4 = node2.internals.handleBounds) == null ? void 0 : _a4[handleType] : [...((_b2 = node2.internals.handleBounds) == null ? void 0 : _b2.source) ?? [], ...((_c = node2.internals.handleBounds) == null ? void 0 : _c.target) ?? []], handle = (handleId ? handles == null ? void 0 : handles.find((h2) => h2.id === handleId) : handles == null ? void 0 : handles[0]) ?? null;
  return handle && withAbsolutePosition ? { ...handle, ...getHandlePosition(node2, handle, handle.position, !0) } : handle;
}
function getHandleType(edgeUpdaterType, handleDomNode) {
  return edgeUpdaterType || (handleDomNode != null && handleDomNode.classList.contains("target") ? "target" : handleDomNode != null && handleDomNode.classList.contains("source") ? "source" : null);
}
function isConnectionValid(isInsideConnectionRadius, isHandleValid) {
  let isValid = null;
  return isHandleValid ? isValid = !0 : isInsideConnectionRadius && !isHandleValid && (isValid = !1), isValid;
}
const alwaysValid = () => !0;
function onPointerDown(event, { connectionMode, connectionRadius, handleId, nodeId, edgeUpdaterType, isTarget, domNode, nodeLookup, lib: lib2, autoPanOnConnect, flowId, panBy: panBy2, cancelConnection, onConnectStart, onConnect, onConnectEnd, isValidConnection = alwaysValid, onReconnectEnd, updateConnection, getTransform, getFromHandle, autoPanSpeed }) {
  const doc = getHostForElement(event.target);
  let autoPanId = 0, closestHandle;
  const { x: x2, y: y2 } = getEventPosition(event), clickedHandle = doc == null ? void 0 : doc.elementFromPoint(x2, y2), handleType = getHandleType(edgeUpdaterType, clickedHandle), containerBounds = domNode == null ? void 0 : domNode.getBoundingClientRect();
  if (!containerBounds || !handleType)
    return;
  const fromHandleInternal = getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode);
  if (!fromHandleInternal)
    return;
  let position2 = getEventPosition(event, containerBounds), autoPanStarted = !1, connection = null, isValid = !1, handleDomNode = null;
  function autoPan() {
    if (!autoPanOnConnect || !containerBounds)
      return;
    const [x22, y22] = calcAutoPan(position2, containerBounds, autoPanSpeed);
    panBy2({ x: x22, y: y22 }), autoPanId = requestAnimationFrame(autoPan);
  }
  const fromHandle = {
    ...fromHandleInternal,
    nodeId,
    type: handleType,
    position: fromHandleInternal.position
  }, fromNodeInternal = nodeLookup.get(nodeId), newConnection = {
    inProgress: !0,
    isValid: null,
    from: getHandlePosition(fromNodeInternal, fromHandle, Position.Left, !0),
    fromHandle,
    fromPosition: fromHandle.position,
    fromNode: fromNodeInternal,
    to: position2,
    toHandle: null,
    toPosition: oppositePosition[fromHandle.position],
    toNode: null
  };
  updateConnection(newConnection);
  let previousConnection = newConnection;
  onConnectStart == null || onConnectStart(event, { nodeId, handleId, handleType });
  function onPointerMove(event2) {
    if (!getFromHandle() || !fromHandle) {
      onPointerUp(event2);
      return;
    }
    const transform2 = getTransform();
    position2 = getEventPosition(event2, containerBounds), closestHandle = getClosestHandle(pointToRendererPoint(position2, transform2, !1, [1, 1]), connectionRadius, nodeLookup, fromHandle), autoPanStarted || (autoPan(), autoPanStarted = !0);
    const result = isValidHandle(event2, {
      handle: closestHandle,
      connectionMode,
      fromNodeId: nodeId,
      fromHandleId: handleId,
      fromType: isTarget ? "target" : "source",
      isValidConnection,
      doc,
      lib: lib2,
      flowId,
      nodeLookup
    });
    handleDomNode = result.handleDomNode, connection = result.connection, isValid = isConnectionValid(!!closestHandle, result.isValid);
    const newConnection2 = {
      // from stays the same
      ...previousConnection,
      isValid,
      to: closestHandle && isValid ? rendererPointToPoint({ x: closestHandle.x, y: closestHandle.y }, transform2) : position2,
      toHandle: result.toHandle,
      toPosition: isValid && result.toHandle ? result.toHandle.position : oppositePosition[fromHandle.position],
      toNode: result.toHandle ? nodeLookup.get(result.toHandle.nodeId) : null
    };
    isValid && closestHandle && previousConnection.toHandle && newConnection2.toHandle && previousConnection.toHandle.type === newConnection2.toHandle.type && previousConnection.toHandle.nodeId === newConnection2.toHandle.nodeId && previousConnection.toHandle.id === newConnection2.toHandle.id && previousConnection.to.x === newConnection2.to.x && previousConnection.to.y === newConnection2.to.y || (updateConnection(newConnection2), previousConnection = newConnection2);
  }
  function onPointerUp(event2) {
    (closestHandle || handleDomNode) && connection && isValid && (onConnect == null || onConnect(connection));
    const { inProgress, ...connectionState } = previousConnection, finalConnectionState = {
      ...connectionState,
      toPosition: previousConnection.toHandle ? previousConnection.toPosition : null
    };
    onConnectEnd == null || onConnectEnd(event2, finalConnectionState), edgeUpdaterType && (onReconnectEnd == null || onReconnectEnd(event2, finalConnectionState)), cancelConnection(), cancelAnimationFrame(autoPanId), autoPanStarted = !1, isValid = !1, connection = null, handleDomNode = null, doc.removeEventListener("mousemove", onPointerMove), doc.removeEventListener("mouseup", onPointerUp), doc.removeEventListener("touchmove", onPointerMove), doc.removeEventListener("touchend", onPointerUp);
  }
  doc.addEventListener("mousemove", onPointerMove), doc.addEventListener("mouseup", onPointerUp), doc.addEventListener("touchmove", onPointerMove), doc.addEventListener("touchend", onPointerUp);
}
function isValidHandle(event, { handle, connectionMode, fromNodeId, fromHandleId, fromType, doc, lib: lib2, flowId, isValidConnection = alwaysValid, nodeLookup }) {
  const isTarget = fromType === "target", handleDomNode = handle ? doc.querySelector(`.${lib2}-flow__handle[data-id="${flowId}-${handle == null ? void 0 : handle.nodeId}-${handle == null ? void 0 : handle.id}-${handle == null ? void 0 : handle.type}"]`) : null, { x: x2, y: y2 } = getEventPosition(event), handleBelow = doc.elementFromPoint(x2, y2), handleToCheck = handleBelow != null && handleBelow.classList.contains(`${lib2}-flow__handle`) ? handleBelow : handleDomNode, result = {
    handleDomNode: handleToCheck,
    isValid: !1,
    connection: null,
    toHandle: null
  };
  if (handleToCheck) {
    const handleType = getHandleType(void 0, handleToCheck), handleNodeId = handleToCheck.getAttribute("data-nodeid"), handleId = handleToCheck.getAttribute("data-handleid"), connectable = handleToCheck.classList.contains("connectable"), connectableEnd = handleToCheck.classList.contains("connectableend");
    if (!handleNodeId || !handleType)
      return result;
    const connection = {
      source: isTarget ? handleNodeId : fromNodeId,
      sourceHandle: isTarget ? handleId : fromHandleId,
      target: isTarget ? fromNodeId : handleNodeId,
      targetHandle: isTarget ? fromHandleId : handleId
    };
    result.connection = connection;
    const isValid = connectable && connectableEnd && (connectionMode === ConnectionMode.Strict ? isTarget && handleType === "source" || !isTarget && handleType === "target" : handleNodeId !== fromNodeId || handleId !== fromHandleId);
    result.isValid = isValid && isValidConnection(connection), result.toHandle = getHandle(handleNodeId, handleType, handleId, nodeLookup, connectionMode, !1);
  }
  return result;
}
const XYHandle = {
  onPointerDown,
  isValid: isValidHandle
};
function XYMinimap({ domNode, panZoom, getTransform, getViewScale }) {
  const selection2 = select(domNode);
  function update({ translateExtent, width: width2, height, zoomStep = 10, pannable = !0, zoomable = !0, inversePan = !1 }) {
    const zoomHandler = (event) => {
      const transform2 = getTransform();
      if (event.sourceEvent.type !== "wheel" || !panZoom)
        return;
      const pinchDelta = -event.sourceEvent.deltaY * (event.sourceEvent.deltaMode === 1 ? 0.05 : event.sourceEvent.deltaMode ? 1 : 2e-3) * zoomStep, nextZoom = transform2[2] * Math.pow(2, pinchDelta);
      panZoom.scaleTo(nextZoom);
    };
    let panStart = [0, 0];
    const panStartHandler = (event) => {
      (event.sourceEvent.type === "mousedown" || event.sourceEvent.type === "touchstart") && (panStart = [
        event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,
        event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY
      ]);
    }, panHandler = (event) => {
      const transform2 = getTransform();
      if (event.sourceEvent.type !== "mousemove" && event.sourceEvent.type !== "touchmove" || !panZoom)
        return;
      const panCurrent = [
        event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,
        event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY
      ], panDelta = [panCurrent[0] - panStart[0], panCurrent[1] - panStart[1]];
      panStart = panCurrent;
      const moveScale = getViewScale() * Math.max(transform2[2], Math.log(transform2[2])) * (inversePan ? -1 : 1), position2 = {
        x: transform2[0] - panDelta[0] * moveScale,
        y: transform2[1] - panDelta[1] * moveScale
      }, extent = [
        [0, 0],
        [width2, height]
      ];
      panZoom.setViewportConstrained({
        x: position2.x,
        y: position2.y,
        zoom: transform2[2]
      }, extent, translateExtent);
    }, zoomAndPanHandler = zoom().on("start", panStartHandler).on("zoom", pannable ? panHandler : null).on("zoom.wheel", zoomable ? zoomHandler : null);
    selection2.call(zoomAndPanHandler, {});
  }
  function destroy() {
    selection2.on("zoom", null);
  }
  return {
    update,
    destroy,
    pointer
  };
}
const viewChanged = (prevViewport, eventViewport) => prevViewport.x !== eventViewport.x || prevViewport.y !== eventViewport.y || prevViewport.zoom !== eventViewport.k, transformToViewport = (transform2) => ({
  x: transform2.x,
  y: transform2.y,
  zoom: transform2.k
}), viewportToTransform = ({ x: x2, y: y2, zoom: zoom2 }) => identity$2.translate(x2, y2).scale(zoom2), isWrappedWithClass = (event, className) => event.target.closest(`.${className}`), isRightClickPan = (panOnDrag, usedButton) => usedButton === 2 && Array.isArray(panOnDrag) && panOnDrag.includes(2), getD3Transition = (selection2, duration = 0, onEnd = () => {
}) => {
  const hasDuration = typeof duration == "number" && duration > 0;
  return hasDuration || onEnd(), hasDuration ? selection2.transition().duration(duration).on("end", onEnd) : selection2;
}, wheelDelta = (event) => {
  const factor = event.ctrlKey && isMacOs() ? 10 : 1;
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * factor;
};
function createPanOnScrollHandler({ zoomPanValues, noWheelClassName, d3Selection, d3Zoom, panOnScrollMode, panOnScrollSpeed, zoomOnPinch, onPanZoomStart, onPanZoom, onPanZoomEnd }) {
  return (event) => {
    if (isWrappedWithClass(event, noWheelClassName))
      return !1;
    event.preventDefault(), event.stopImmediatePropagation();
    const currentZoom = d3Selection.property("__zoom").k || 1;
    if (event.ctrlKey && zoomOnPinch) {
      const point2 = pointer(event), pinchDelta = wheelDelta(event), zoom2 = currentZoom * Math.pow(2, pinchDelta);
      d3Zoom.scaleTo(d3Selection, zoom2, point2, event);
      return;
    }
    const deltaNormalize = event.deltaMode === 1 ? 20 : 1;
    let deltaX = panOnScrollMode === PanOnScrollMode.Vertical ? 0 : event.deltaX * deltaNormalize, deltaY = panOnScrollMode === PanOnScrollMode.Horizontal ? 0 : event.deltaY * deltaNormalize;
    !isMacOs() && event.shiftKey && panOnScrollMode !== PanOnScrollMode.Vertical && (deltaX = event.deltaY * deltaNormalize, deltaY = 0), d3Zoom.translateBy(
      d3Selection,
      -(deltaX / currentZoom) * panOnScrollSpeed,
      -(deltaY / currentZoom) * panOnScrollSpeed,
      // @ts-ignore
      { internal: !0 }
    );
    const nextViewport = transformToViewport(d3Selection.property("__zoom"));
    clearTimeout(zoomPanValues.panScrollTimeout), zoomPanValues.isPanScrolling || (zoomPanValues.isPanScrolling = !0, onPanZoomStart == null || onPanZoomStart(event, nextViewport)), zoomPanValues.isPanScrolling && (onPanZoom == null || onPanZoom(event, nextViewport), zoomPanValues.panScrollTimeout = setTimeout(() => {
      onPanZoomEnd == null || onPanZoomEnd(event, nextViewport), zoomPanValues.isPanScrolling = !1;
    }, 150));
  };
}
function createZoomOnScrollHandler({ noWheelClassName, preventScrolling, d3ZoomHandler }) {
  return function(event, d2) {
    if (!preventScrolling && event.type === "wheel" && !event.ctrlKey || isWrappedWithClass(event, noWheelClassName))
      return null;
    event.preventDefault(), d3ZoomHandler.call(this, event, d2);
  };
}
function createPanZoomStartHandler({ zoomPanValues, onDraggingChange, onPanZoomStart }) {
  return (event) => {
    var _a4, _b2, _c;
    if ((_a4 = event.sourceEvent) != null && _a4.internal)
      return;
    const viewport = transformToViewport(event.transform);
    zoomPanValues.mouseButton = ((_b2 = event.sourceEvent) == null ? void 0 : _b2.button) || 0, zoomPanValues.isZoomingOrPanning = !0, zoomPanValues.prevViewport = viewport, ((_c = event.sourceEvent) == null ? void 0 : _c.type) === "mousedown" && onDraggingChange(!0), onPanZoomStart && (onPanZoomStart == null || onPanZoomStart(event.sourceEvent, viewport));
  };
}
function createPanZoomHandler({ zoomPanValues, panOnDrag, onPaneContextMenu, onTransformChange, onPanZoom }) {
  return (event) => {
    var _a4, _b2;
    zoomPanValues.usedRightMouseButton = !!(onPaneContextMenu && isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0)), (_a4 = event.sourceEvent) != null && _a4.sync || onTransformChange([event.transform.x, event.transform.y, event.transform.k]), onPanZoom && !((_b2 = event.sourceEvent) != null && _b2.internal) && (onPanZoom == null || onPanZoom(event.sourceEvent, transformToViewport(event.transform)));
  };
}
function createPanZoomEndHandler({ zoomPanValues, panOnDrag, panOnScroll, onDraggingChange, onPanZoomEnd, onPaneContextMenu }) {
  return (event) => {
    var _a4;
    if (!((_a4 = event.sourceEvent) != null && _a4.internal) && (zoomPanValues.isZoomingOrPanning = !1, onPaneContextMenu && isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0) && !zoomPanValues.usedRightMouseButton && event.sourceEvent && onPaneContextMenu(event.sourceEvent), zoomPanValues.usedRightMouseButton = !1, onDraggingChange(!1), onPanZoomEnd && viewChanged(zoomPanValues.prevViewport, event.transform))) {
      const viewport = transformToViewport(event.transform);
      zoomPanValues.prevViewport = viewport, clearTimeout(zoomPanValues.timerId), zoomPanValues.timerId = setTimeout(
        () => {
          onPanZoomEnd == null || onPanZoomEnd(event.sourceEvent, viewport);
        },
        // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll
        panOnScroll ? 150 : 0
      );
    }
  };
}
function createFilter({ zoomActivationKeyPressed, zoomOnScroll, zoomOnPinch, panOnDrag, panOnScroll, zoomOnDoubleClick, userSelectionActive, noWheelClassName, noPanClassName, lib: lib2 }) {
  return (event) => {
    var _a4;
    const zoomScroll = zoomActivationKeyPressed || zoomOnScroll, pinchZoom = zoomOnPinch && event.ctrlKey;
    if (event.button === 1 && event.type === "mousedown" && (isWrappedWithClass(event, `${lib2}-flow__node`) || isWrappedWithClass(event, `${lib2}-flow__edge`)))
      return !0;
    if (!panOnDrag && !zoomScroll && !panOnScroll && !zoomOnDoubleClick && !zoomOnPinch || userSelectionActive || isWrappedWithClass(event, noWheelClassName) && event.type === "wheel" || isWrappedWithClass(event, noPanClassName) && (event.type !== "wheel" || panOnScroll && event.type === "wheel" && !zoomActivationKeyPressed) || !zoomOnPinch && event.ctrlKey && event.type === "wheel")
      return !1;
    if (!zoomOnPinch && event.type === "touchstart" && ((_a4 = event.touches) == null ? void 0 : _a4.length) > 1)
      return event.preventDefault(), !1;
    if (!zoomScroll && !panOnScroll && !pinchZoom && event.type === "wheel" || !panOnDrag && (event.type === "mousedown" || event.type === "touchstart") || Array.isArray(panOnDrag) && !panOnDrag.includes(event.button) && event.type === "mousedown")
      return !1;
    const buttonAllowed = Array.isArray(panOnDrag) && panOnDrag.includes(event.button) || !event.button || event.button <= 1;
    return (!event.ctrlKey || event.type === "wheel") && buttonAllowed;
  };
}
function XYPanZoom({ domNode, minZoom, maxZoom, paneClickDistance, translateExtent, viewport, onPanZoom, onPanZoomStart, onPanZoomEnd, onDraggingChange }) {
  const zoomPanValues = {
    isZoomingOrPanning: !1,
    usedRightMouseButton: !1,
    prevViewport: { x: 0, y: 0, zoom: 0 },
    mouseButton: 0,
    timerId: void 0,
    panScrollTimeout: void 0,
    isPanScrolling: !1
  }, bbox = domNode.getBoundingClientRect(), d3ZoomInstance = zoom().clickDistance(!isNumeric(paneClickDistance) || paneClickDistance < 0 ? 0 : paneClickDistance).scaleExtent([minZoom, maxZoom]).translateExtent(translateExtent), d3Selection = select(domNode).call(d3ZoomInstance);
  setViewportConstrained({
    x: viewport.x,
    y: viewport.y,
    zoom: clamp$4(viewport.zoom, minZoom, maxZoom)
  }, [
    [0, 0],
    [bbox.width, bbox.height]
  ], translateExtent);
  const d3ZoomHandler = d3Selection.on("wheel.zoom"), d3DblClickZoomHandler = d3Selection.on("dblclick.zoom");
  d3ZoomInstance.wheelDelta(wheelDelta);
  function setTransform(transform2, options) {
    return d3Selection ? new Promise((resolve) => {
      d3ZoomInstance == null || d3ZoomInstance.transform(getD3Transition(d3Selection, options == null ? void 0 : options.duration, () => resolve(!0)), transform2);
    }) : Promise.resolve(!1);
  }
  function update({ noWheelClassName, noPanClassName, onPaneContextMenu, userSelectionActive, panOnScroll, panOnDrag, panOnScrollMode, panOnScrollSpeed, preventScrolling, zoomOnPinch, zoomOnScroll, zoomOnDoubleClick, zoomActivationKeyPressed, lib: lib2, onTransformChange }) {
    userSelectionActive && !zoomPanValues.isZoomingOrPanning && destroy();
    const wheelHandler = panOnScroll && !zoomActivationKeyPressed && !userSelectionActive ? createPanOnScrollHandler({
      zoomPanValues,
      noWheelClassName,
      d3Selection,
      d3Zoom: d3ZoomInstance,
      panOnScrollMode,
      panOnScrollSpeed,
      zoomOnPinch,
      onPanZoomStart,
      onPanZoom,
      onPanZoomEnd
    }) : createZoomOnScrollHandler({
      noWheelClassName,
      preventScrolling,
      d3ZoomHandler
    });
    if (d3Selection.on("wheel.zoom", wheelHandler, { passive: !1 }), !userSelectionActive) {
      const startHandler = createPanZoomStartHandler({
        zoomPanValues,
        onDraggingChange,
        onPanZoomStart
      });
      d3ZoomInstance.on("start", startHandler);
      const panZoomHandler = createPanZoomHandler({
        zoomPanValues,
        panOnDrag,
        onPaneContextMenu: !!onPaneContextMenu,
        onPanZoom,
        onTransformChange
      });
      d3ZoomInstance.on("zoom", panZoomHandler);
      const panZoomEndHandler = createPanZoomEndHandler({
        zoomPanValues,
        panOnDrag,
        panOnScroll,
        onPaneContextMenu,
        onPanZoomEnd,
        onDraggingChange
      });
      d3ZoomInstance.on("end", panZoomEndHandler);
    }
    const filter2 = createFilter({
      zoomActivationKeyPressed,
      panOnDrag,
      zoomOnScroll,
      panOnScroll,
      zoomOnDoubleClick,
      zoomOnPinch,
      userSelectionActive,
      noPanClassName,
      noWheelClassName,
      lib: lib2
    });
    d3ZoomInstance.filter(filter2), zoomOnDoubleClick ? d3Selection.on("dblclick.zoom", d3DblClickZoomHandler) : d3Selection.on("dblclick.zoom", null);
  }
  function destroy() {
    d3ZoomInstance.on("zoom", null);
  }
  async function setViewportConstrained(viewport2, extent, translateExtent2) {
    const nextTransform = viewportToTransform(viewport2), contrainedTransform = d3ZoomInstance == null ? void 0 : d3ZoomInstance.constrain()(nextTransform, extent, translateExtent2);
    return contrainedTransform && await setTransform(contrainedTransform), new Promise((resolve) => resolve(contrainedTransform));
  }
  async function setViewport(viewport2, options) {
    const nextTransform = viewportToTransform(viewport2);
    return await setTransform(nextTransform, options), new Promise((resolve) => resolve(nextTransform));
  }
  function syncViewport(viewport2) {
    if (d3Selection) {
      const nextTransform = viewportToTransform(viewport2), currentTransform = d3Selection.property("__zoom");
      (currentTransform.k !== viewport2.zoom || currentTransform.x !== viewport2.x || currentTransform.y !== viewport2.y) && (d3ZoomInstance == null || d3ZoomInstance.transform(d3Selection, nextTransform, null, { sync: !0 }));
    }
  }
  function getViewport() {
    const transform$1 = d3Selection ? transform(d3Selection.node()) : { x: 0, y: 0, k: 1 };
    return { x: transform$1.x, y: transform$1.y, zoom: transform$1.k };
  }
  function scaleTo(zoom2, options) {
    return d3Selection ? new Promise((resolve) => {
      d3ZoomInstance == null || d3ZoomInstance.scaleTo(getD3Transition(d3Selection, options == null ? void 0 : options.duration, () => resolve(!0)), zoom2);
    }) : Promise.resolve(!1);
  }
  function scaleBy(factor, options) {
    return d3Selection ? new Promise((resolve) => {
      d3ZoomInstance == null || d3ZoomInstance.scaleBy(getD3Transition(d3Selection, options == null ? void 0 : options.duration, () => resolve(!0)), factor);
    }) : Promise.resolve(!1);
  }
  function setScaleExtent(scaleExtent) {
    d3ZoomInstance == null || d3ZoomInstance.scaleExtent(scaleExtent);
  }
  function setTranslateExtent(translateExtent2) {
    d3ZoomInstance == null || d3ZoomInstance.translateExtent(translateExtent2);
  }
  function setClickDistance(distance2) {
    const validDistance = !isNumeric(distance2) || distance2 < 0 ? 0 : distance2;
    d3ZoomInstance == null || d3ZoomInstance.clickDistance(validDistance);
  }
  return {
    update,
    destroy,
    setViewport,
    setViewportConstrained,
    getViewport,
    scaleTo,
    scaleBy,
    setScaleExtent,
    setTranslateExtent,
    syncViewport,
    setClickDistance
  };
}
var ResizeControlVariant;
(function(ResizeControlVariant2) {
  ResizeControlVariant2.Line = "line", ResizeControlVariant2.Handle = "handle";
})(ResizeControlVariant || (ResizeControlVariant = {}));
function getResizeDirection({ width: width2, prevWidth, height, prevHeight, affectsX, affectsY }) {
  const deltaWidth = width2 - prevWidth, deltaHeight = height - prevHeight, direction = [deltaWidth > 0 ? 1 : deltaWidth < 0 ? -1 : 0, deltaHeight > 0 ? 1 : deltaHeight < 0 ? -1 : 0];
  return deltaWidth && affectsX && (direction[0] = direction[0] * -1), deltaHeight && affectsY && (direction[1] = direction[1] * -1), direction;
}
function getControlDirection(controlPosition) {
  const isHorizontal = controlPosition.includes("right") || controlPosition.includes("left"), isVertical = controlPosition.includes("bottom") || controlPosition.includes("top"), affectsX = controlPosition.includes("left"), affectsY = controlPosition.includes("top");
  return {
    isHorizontal,
    isVertical,
    affectsX,
    affectsY
  };
}
function getLowerExtentClamp(lowerExtent, lowerBound) {
  return Math.max(0, lowerBound - lowerExtent);
}
function getUpperExtentClamp(upperExtent, upperBound) {
  return Math.max(0, upperExtent - upperBound);
}
function getSizeClamp(size2, minSize, maxSize) {
  return Math.max(0, minSize - size2, size2 - maxSize);
}
function xor(a2, b2) {
  return a2 ? !b2 : b2;
}
function getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, extent, childExtent) {
  let { affectsX, affectsY } = controlDirection;
  const { isHorizontal, isVertical } = controlDirection, isDiagonal = isHorizontal && isVertical, { xSnapped, ySnapped } = pointerPosition, { minWidth, maxWidth, minHeight, maxHeight } = boundaries, { x: startX, y: startY, width: startWidth, height: startHeight, aspectRatio: aspectRatio2 } = startValues;
  let distX = Math.floor(isHorizontal ? xSnapped - startValues.pointerX : 0), distY = Math.floor(isVertical ? ySnapped - startValues.pointerY : 0);
  const newWidth = startWidth + (affectsX ? -distX : distX), newHeight = startHeight + (affectsY ? -distY : distY), originOffsetX = -nodeOrigin[0] * startWidth, originOffsetY = -nodeOrigin[1] * startHeight;
  let clampX = getSizeClamp(newWidth, minWidth, maxWidth), clampY = getSizeClamp(newHeight, minHeight, maxHeight);
  if (extent) {
    let xExtentClamp = 0, yExtentClamp = 0;
    affectsX && distX < 0 ? xExtentClamp = getLowerExtentClamp(startX + distX + originOffsetX, extent[0][0]) : !affectsX && distX > 0 && (xExtentClamp = getUpperExtentClamp(startX + newWidth + originOffsetX, extent[1][0])), affectsY && distY < 0 ? yExtentClamp = getLowerExtentClamp(startY + distY + originOffsetY, extent[0][1]) : !affectsY && distY > 0 && (yExtentClamp = getUpperExtentClamp(startY + newHeight + originOffsetY, extent[1][1])), clampX = Math.max(clampX, xExtentClamp), clampY = Math.max(clampY, yExtentClamp);
  }
  if (childExtent) {
    let xExtentClamp = 0, yExtentClamp = 0;
    affectsX && distX > 0 ? xExtentClamp = getUpperExtentClamp(startX + distX, childExtent[0][0]) : !affectsX && distX < 0 && (xExtentClamp = getLowerExtentClamp(startX + newWidth, childExtent[1][0])), affectsY && distY > 0 ? yExtentClamp = getUpperExtentClamp(startY + distY, childExtent[0][1]) : !affectsY && distY < 0 && (yExtentClamp = getLowerExtentClamp(startY + newHeight, childExtent[1][1])), clampX = Math.max(clampX, xExtentClamp), clampY = Math.max(clampY, yExtentClamp);
  }
  if (keepAspectRatio) {
    if (isHorizontal) {
      const aspectHeightClamp = getSizeClamp(newWidth / aspectRatio2, minHeight, maxHeight) * aspectRatio2;
      if (clampX = Math.max(clampX, aspectHeightClamp), extent) {
        let aspectExtentClamp = 0;
        !affectsX && !affectsY || affectsX && !affectsY && isDiagonal ? aspectExtentClamp = getUpperExtentClamp(startY + originOffsetY + newWidth / aspectRatio2, extent[1][1]) * aspectRatio2 : aspectExtentClamp = getLowerExtentClamp(startY + originOffsetY + (affectsX ? distX : -distX) / aspectRatio2, extent[0][1]) * aspectRatio2, clampX = Math.max(clampX, aspectExtentClamp);
      }
      if (childExtent) {
        let aspectExtentClamp = 0;
        !affectsX && !affectsY || affectsX && !affectsY && isDiagonal ? aspectExtentClamp = getLowerExtentClamp(startY + newWidth / aspectRatio2, childExtent[1][1]) * aspectRatio2 : aspectExtentClamp = getUpperExtentClamp(startY + (affectsX ? distX : -distX) / aspectRatio2, childExtent[0][1]) * aspectRatio2, clampX = Math.max(clampX, aspectExtentClamp);
      }
    }
    if (isVertical) {
      const aspectWidthClamp = getSizeClamp(newHeight * aspectRatio2, minWidth, maxWidth) / aspectRatio2;
      if (clampY = Math.max(clampY, aspectWidthClamp), extent) {
        let aspectExtentClamp = 0;
        !affectsX && !affectsY || affectsY && !affectsX && isDiagonal ? aspectExtentClamp = getUpperExtentClamp(startX + newHeight * aspectRatio2 + originOffsetX, extent[1][0]) / aspectRatio2 : aspectExtentClamp = getLowerExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio2 + originOffsetX, extent[0][0]) / aspectRatio2, clampY = Math.max(clampY, aspectExtentClamp);
      }
      if (childExtent) {
        let aspectExtentClamp = 0;
        !affectsX && !affectsY || affectsY && !affectsX && isDiagonal ? aspectExtentClamp = getLowerExtentClamp(startX + newHeight * aspectRatio2, childExtent[1][0]) / aspectRatio2 : aspectExtentClamp = getUpperExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio2, childExtent[0][0]) / aspectRatio2, clampY = Math.max(clampY, aspectExtentClamp);
      }
    }
  }
  distY = distY + (distY < 0 ? clampY : -clampY), distX = distX + (distX < 0 ? clampX : -clampX), keepAspectRatio && (isDiagonal ? newWidth > newHeight * aspectRatio2 ? distY = (xor(affectsX, affectsY) ? -distX : distX) / aspectRatio2 : distX = (xor(affectsX, affectsY) ? -distY : distY) * aspectRatio2 : isHorizontal ? (distY = distX / aspectRatio2, affectsY = affectsX) : (distX = distY * aspectRatio2, affectsX = affectsY));
  const x2 = affectsX ? startX + distX : startX, y2 = affectsY ? startY + distY : startY;
  return {
    width: startWidth + (affectsX ? -distX : distX),
    height: startHeight + (affectsY ? -distY : distY),
    x: nodeOrigin[0] * distX * (affectsX ? -1 : 1) + x2,
    y: nodeOrigin[1] * distY * (affectsY ? -1 : 1) + y2
  };
}
const initPrevValues$1 = { width: 0, height: 0, x: 0, y: 0 }, initStartValues = {
  ...initPrevValues$1,
  pointerX: 0,
  pointerY: 0,
  aspectRatio: 1
};
function nodeToParentExtent(node2) {
  return [
    [0, 0],
    [node2.measured.width, node2.measured.height]
  ];
}
function nodeToChildExtent(child, parent, nodeOrigin) {
  const x2 = parent.position.x + child.position.x, y2 = parent.position.y + child.position.y, width2 = child.measured.width ?? 0, height = child.measured.height ?? 0, originOffsetX = nodeOrigin[0] * width2, originOffsetY = nodeOrigin[1] * height;
  return [
    [x2 - originOffsetX, y2 - originOffsetY],
    [x2 + width2 - originOffsetX, y2 + height - originOffsetY]
  ];
}
function XYResizer({ domNode, nodeId, getStoreItems, onChange, onEnd }) {
  const selection2 = select(domNode);
  function update({ controlPosition, boundaries, keepAspectRatio, onResizeStart, onResize, onResizeEnd, shouldResize }) {
    let prevValues = { ...initPrevValues$1 }, startValues = { ...initStartValues };
    const controlDirection = getControlDirection(controlPosition);
    let node2, containerBounds = null, childNodes = [], parentNode, parentExtent, childExtent;
    const dragHandler = drag$1().on("start", (event) => {
      const { nodeLookup, transform: transform2, snapGrid, snapToGrid, nodeOrigin, paneDomNode } = getStoreItems();
      if (node2 = nodeLookup.get(nodeId), !node2)
        return;
      containerBounds = (paneDomNode == null ? void 0 : paneDomNode.getBoundingClientRect()) ?? null;
      const { xSnapped, ySnapped } = getPointerPosition(event.sourceEvent, {
        transform: transform2,
        snapGrid,
        snapToGrid,
        containerBounds
      });
      prevValues = {
        width: node2.measured.width ?? 0,
        height: node2.measured.height ?? 0,
        x: node2.position.x ?? 0,
        y: node2.position.y ?? 0
      }, startValues = {
        ...prevValues,
        pointerX: xSnapped,
        pointerY: ySnapped,
        aspectRatio: prevValues.width / prevValues.height
      }, parentNode = void 0, node2.parentId && (node2.extent === "parent" || node2.expandParent) && (parentNode = nodeLookup.get(node2.parentId), parentExtent = parentNode && node2.extent === "parent" ? nodeToParentExtent(parentNode) : void 0), childNodes = [], childExtent = void 0;
      for (const [childId, child] of nodeLookup)
        if (child.parentId === nodeId && (childNodes.push({
          id: childId,
          position: { ...child.position },
          extent: child.extent
        }), child.extent === "parent" || child.expandParent)) {
          const extent = nodeToChildExtent(child, node2, child.origin ?? nodeOrigin);
          childExtent ? childExtent = [
            [Math.min(extent[0][0], childExtent[0][0]), Math.min(extent[0][1], childExtent[0][1])],
            [Math.max(extent[1][0], childExtent[1][0]), Math.max(extent[1][1], childExtent[1][1])]
          ] : childExtent = extent;
        }
      onResizeStart == null || onResizeStart(event, { ...prevValues });
    }).on("drag", (event) => {
      const { transform: transform2, snapGrid, snapToGrid, nodeOrigin: storeNodeOrigin } = getStoreItems(), pointerPosition = getPointerPosition(event.sourceEvent, {
        transform: transform2,
        snapGrid,
        snapToGrid,
        containerBounds
      }), childChanges = [];
      if (!node2)
        return;
      const { x: prevX, y: prevY, width: prevWidth, height: prevHeight } = prevValues, change = {}, nodeOrigin = node2.origin ?? storeNodeOrigin, { width: width2, height, x: x2, y: y2 } = getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, parentExtent, childExtent), isWidthChange = width2 !== prevWidth, isHeightChange = height !== prevHeight, isXPosChange = x2 !== prevX && isWidthChange, isYPosChange = y2 !== prevY && isHeightChange;
      if (!isXPosChange && !isYPosChange && !isWidthChange && !isHeightChange)
        return;
      if ((isXPosChange || isYPosChange || nodeOrigin[0] === 1 || nodeOrigin[1] === 1) && (change.x = isXPosChange ? x2 : prevValues.x, change.y = isYPosChange ? y2 : prevValues.y, prevValues.x = change.x, prevValues.y = change.y, childNodes.length > 0)) {
        const xChange = x2 - prevX, yChange = y2 - prevY;
        for (const childNode of childNodes)
          childNode.position = {
            x: childNode.position.x - xChange + nodeOrigin[0] * (width2 - prevWidth),
            y: childNode.position.y - yChange + nodeOrigin[1] * (height - prevHeight)
          }, childChanges.push(childNode);
      }
      if ((isWidthChange || isHeightChange) && (change.width = isWidthChange ? width2 : prevValues.width, change.height = isHeightChange ? height : prevValues.height, prevValues.width = change.width, prevValues.height = change.height), parentNode && node2.expandParent) {
        const xLimit = nodeOrigin[0] * (change.width ?? 0);
        change.x && change.x < xLimit && (prevValues.x = xLimit, startValues.x = startValues.x - (change.x - xLimit));
        const yLimit = nodeOrigin[1] * (change.height ?? 0);
        change.y && change.y < yLimit && (prevValues.y = yLimit, startValues.y = startValues.y - (change.y - yLimit));
      }
      const direction = getResizeDirection({
        width: prevValues.width,
        prevWidth,
        height: prevValues.height,
        prevHeight,
        affectsX: controlDirection.affectsX,
        affectsY: controlDirection.affectsY
      }), nextValues = { ...prevValues, direction };
      (shouldResize == null ? void 0 : shouldResize(event, nextValues)) !== !1 && (onResize == null || onResize(event, nextValues), onChange(change, childChanges));
    }).on("end", (event) => {
      onResizeEnd == null || onResizeEnd(event, { ...prevValues }), onEnd == null || onEnd();
    });
    selection2.call(dragHandler);
  }
  function destroy() {
    selection2.on(".drag", null);
  }
  return {
    update,
    destroy
  };
}
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2.default : x2;
}
var withSelector = { exports: {} }, withSelector_production_min = {}, shim = { exports: {} }, useSyncExternalStoreShim_production_min = {};
var e$4 = React__default;
function h$2(a2, b2) {
  return a2 === b2 && (a2 !== 0 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var k = typeof Object.is == "function" ? Object.is : h$2, l$5 = e$4.useState, m$5 = e$4.useEffect, n$8 = e$4.useLayoutEffect, p$6 = e$4.useDebugValue;
function q$1(a2, b2) {
  var d2 = b2(), f2 = l$5({ inst: { value: d2, getSnapshot: b2 } }), c = f2[0].inst, g2 = f2[1];
  return n$8(function() {
    c.value = d2, c.getSnapshot = b2, r$9(c) && g2({ inst: c });
  }, [a2, d2, b2]), m$5(function() {
    return r$9(c) && g2({ inst: c }), a2(function() {
      r$9(c) && g2({ inst: c });
    });
  }, [a2]), p$6(d2), d2;
}
function r$9(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var d2 = b2();
    return !k(a2, d2);
  } catch {
    return !0;
  }
}
function t$9(a2, b2) {
  return b2();
}
var u$c = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? t$9 : q$1;
useSyncExternalStoreShim_production_min.useSyncExternalStore = e$4.useSyncExternalStore !== void 0 ? e$4.useSyncExternalStore : u$c;
shim.exports;
shim.exports = useSyncExternalStoreShim_production_min;
var shimExports = shim.exports;
var h$1 = React__default, n$7 = shimExports;
function p$5(a2, b2) {
  return a2 === b2 && (a2 !== 0 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var q = typeof Object.is == "function" ? Object.is : p$5, r$8 = n$7.useSyncExternalStore, t$8 = h$1.useRef, u$b = h$1.useEffect, v$1 = h$1.useMemo, w$1 = h$1.useDebugValue;
withSelector_production_min.useSyncExternalStoreWithSelector = function(a2, b2, e2, l2, g2) {
  var c = t$8(null);
  if (c.current === null) {
    var f2 = { hasValue: !1, value: null };
    c.current = f2;
  } else f2 = c.current;
  c = v$1(function() {
    function a3(a4) {
      if (!c2) {
        if (c2 = !0, d3 = a4, a4 = l2(a4), g2 !== void 0 && f2.hasValue) {
          var b3 = f2.value;
          if (g2(b3, a4)) return k2 = b3;
        }
        return k2 = a4;
      }
      if (b3 = k2, q(d3, a4)) return b3;
      var e3 = l2(a4);
      return g2 !== void 0 && g2(b3, e3) ? b3 : (d3 = a4, k2 = e3);
    }
    var c2 = !1, d3, k2, m2 = e2 === void 0 ? null : e2;
    return [function() {
      return a3(b2());
    }, m2 === null ? void 0 : function() {
      return a3(m2());
    }];
  }, [b2, e2, l2, g2]);
  var d2 = r$8(a2, c[0], c[1]);
  return u$b(function() {
    f2.hasValue = !0, f2.value = d2;
  }, [d2]), w$1(d2), d2;
};
withSelector.exports;
withSelector.exports = withSelector_production_min;
var withSelectorExports = withSelector.exports;
const useSyncExternalStoreExports = /* @__PURE__ */ getDefaultExportFromCjs(withSelectorExports), __vite_import_meta_env__$1 = { BASE_URL: "/", DEV: !1, MODE: "production", PROD: !0, SSR: !1 }, createStoreImpl = (createState2) => {
  let state;
  const listeners = /* @__PURE__ */ new Set(), setState = (partial, replace) => {
    const nextState = typeof partial == "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = replace ?? (typeof nextState != "object" || nextState === null) ? nextState : Object.assign({}, state, nextState), listeners.forEach((listener) => listener(state, previousState));
    }
  }, getState = () => state, api = { setState, getState, getInitialState: () => initialState, subscribe: (listener) => (listeners.add(listener), () => listeners.delete(listener)), destroy: () => {
    (__vite_import_meta_env__$1 ? "production" : void 0) !== "production" && console.warn(
      "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
    ), listeners.clear();
  } }, initialState = state = createState2(setState, getState, api);
  return api;
}, createStore$2 = (createState2) => createState2 ? createStoreImpl(createState2) : createStoreImpl, { useDebugValue } = React__default, { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports, identity$1 = (arg) => arg;
function useStoreWithEqualityFn(api, selector2 = identity$1, equalityFn) {
  const slice = useSyncExternalStoreWithSelector(
    api.subscribe,
    api.getState,
    api.getServerState || api.getInitialState,
    selector2,
    equalityFn
  );
  return useDebugValue(slice), slice;
}
const createWithEqualityFnImpl = (createState2, defaultEqualityFn) => {
  const api = createStore$2(createState2), useBoundStoreWithEqualityFn = (selector2, equalityFn = defaultEqualityFn) => useStoreWithEqualityFn(api, selector2, equalityFn);
  return Object.assign(useBoundStoreWithEqualityFn, api), useBoundStoreWithEqualityFn;
}, createWithEqualityFn = (createState2, defaultEqualityFn) => createState2 ? createWithEqualityFnImpl(createState2, defaultEqualityFn) : createWithEqualityFnImpl;
function shallow$1(objA, objB) {
  if (Object.is(objA, objB))
    return !0;
  if (typeof objA != "object" || objA === null || typeof objB != "object" || objB === null)
    return !1;
  if (objA instanceof Map && objB instanceof Map) {
    if (objA.size !== objB.size) return !1;
    for (const [key, value] of objA)
      if (!Object.is(value, objB.get(key)))
        return !1;
    return !0;
  }
  if (objA instanceof Set && objB instanceof Set) {
    if (objA.size !== objB.size) return !1;
    for (const value of objA)
      if (!objB.has(value))
        return !1;
    return !0;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length)
    return !1;
  for (const keyA of keysA)
    if (!Object.prototype.hasOwnProperty.call(objB, keyA) || !Object.is(objA[keyA], objB[keyA]))
      return !1;
  return !0;
}
const StoreContext = createContext(null), Provider$1 = StoreContext.Provider, zustandErrorMessage = errorMessages.error001();
function useStore$2(selector2, equalityFn) {
  const store = useContext(StoreContext);
  if (store === null)
    throw new Error(zustandErrorMessage);
  return useStoreWithEqualityFn(store, selector2, equalityFn);
}
function useStoreApi() {
  const store = useContext(StoreContext);
  if (store === null)
    throw new Error(zustandErrorMessage);
  return useMemo(() => ({
    getState: store.getState,
    setState: store.setState,
    subscribe: store.subscribe
  }), [store]);
}
const style = { display: "none" }, ariaLiveStyle = {
  position: "absolute",
  width: 1,
  height: 1,
  margin: -1,
  border: 0,
  padding: 0,
  overflow: "hidden",
  clip: "rect(0px, 0px, 0px, 0px)",
  clipPath: "inset(100%)"
}, ARIA_NODE_DESC_KEY = "react-flow__node-desc", ARIA_EDGE_DESC_KEY = "react-flow__edge-desc", ARIA_LIVE_MESSAGE = "react-flow__aria-live", selector$o = (s2) => s2.ariaLiveMessage;
function AriaLiveMessage({ rfId }) {
  const ariaLiveMessage = useStore$2(selector$o);
  return jsx("div", { id: `${ARIA_LIVE_MESSAGE}-${rfId}`, "aria-live": "assertive", "aria-atomic": "true", style: ariaLiveStyle, children: ariaLiveMessage });
}
function A11yDescriptions({ rfId, disableKeyboardA11y }) {
  return jsxs(Fragment, { children: [jsxs("div", { id: `${ARIA_NODE_DESC_KEY}-${rfId}`, style, children: ["Press enter or space to select a node.", !disableKeyboardA11y && "You can then use the arrow keys to move the node around.", " Press delete to remove it and escape to cancel.", " "] }), jsx("div", { id: `${ARIA_EDGE_DESC_KEY}-${rfId}`, style, children: "Press enter or space to select an edge. You can then press delete to remove it or escape to cancel." }), !disableKeyboardA11y && jsx(AriaLiveMessage, { rfId })] });
}
const selector$n = (s2) => s2.userSelectionActive ? "none" : "all";
function Panel({ position: position2 = "top-left", children: children2, className, style: style2, ...rest }) {
  const pointerEvents = useStore$2(selector$n), positionClasses = `${position2}`.split("-");
  return jsx("div", { className: cc(["react-flow__panel", className, ...positionClasses]), style: { ...style2, pointerEvents }, ...rest, children: children2 });
}
function Attribution({ proOptions, position: position2 = "bottom-right" }) {
  return proOptions != null && proOptions.hideAttribution ? null : jsx(Panel, { position: position2, className: "react-flow__attribution", "data-message": "Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev", children: jsx("a", { href: "https://reactflow.dev", target: "_blank", rel: "noopener noreferrer", "aria-label": "React Flow attribution", children: "React Flow" }) });
}
const selector$m = (s2) => {
  const selectedNodes = [], selectedEdges = [];
  for (const [, node2] of s2.nodeLookup)
    node2.selected && selectedNodes.push(node2.internals.userNode);
  for (const [, edge] of s2.edgeLookup)
    edge.selected && selectedEdges.push(edge);
  return { selectedNodes, selectedEdges };
}, selectId = (obj) => obj.id;
function areEqual(a2, b2) {
  return shallow$1(a2.selectedNodes.map(selectId), b2.selectedNodes.map(selectId)) && shallow$1(a2.selectedEdges.map(selectId), b2.selectedEdges.map(selectId));
}
function SelectionListenerInner({ onSelectionChange }) {
  const store = useStoreApi(), { selectedNodes, selectedEdges } = useStore$2(selector$m, areEqual);
  return useEffect(() => {
    const params = { nodes: selectedNodes, edges: selectedEdges };
    onSelectionChange == null || onSelectionChange(params), store.getState().onSelectionChangeHandlers.forEach((fn) => fn(params));
  }, [selectedNodes, selectedEdges, onSelectionChange]), null;
}
const changeSelector = (s2) => !!s2.onSelectionChangeHandlers;
function SelectionListener({ onSelectionChange }) {
  const storeHasSelectionChangeHandlers = useStore$2(changeSelector);
  return onSelectionChange || storeHasSelectionChangeHandlers ? jsx(SelectionListenerInner, { onSelectionChange }) : null;
}
const defaultNodeOrigin = [0, 0], defaultViewport = { x: 0, y: 0, zoom: 1 }, reactFlowFieldsToTrack = [
  "nodes",
  "edges",
  "defaultNodes",
  "defaultEdges",
  "onConnect",
  "onConnectStart",
  "onConnectEnd",
  "onClickConnectStart",
  "onClickConnectEnd",
  "nodesDraggable",
  "nodesConnectable",
  "nodesFocusable",
  "edgesFocusable",
  "edgesReconnectable",
  "elevateNodesOnSelect",
  "elevateEdgesOnSelect",
  "minZoom",
  "maxZoom",
  "nodeExtent",
  "onNodesChange",
  "onEdgesChange",
  "elementsSelectable",
  "connectionMode",
  "snapGrid",
  "snapToGrid",
  "translateExtent",
  "connectOnClick",
  "defaultEdgeOptions",
  "fitView",
  "fitViewOptions",
  "onNodesDelete",
  "onEdgesDelete",
  "onDelete",
  "onNodeDrag",
  "onNodeDragStart",
  "onNodeDragStop",
  "onSelectionDrag",
  "onSelectionDragStart",
  "onSelectionDragStop",
  "onMoveStart",
  "onMove",
  "onMoveEnd",
  "noPanClassName",
  "nodeOrigin",
  "autoPanOnConnect",
  "autoPanOnNodeDrag",
  "onError",
  "connectionRadius",
  "isValidConnection",
  "selectNodesOnDrag",
  "nodeDragThreshold",
  "onBeforeDelete",
  "debug",
  "autoPanSpeed",
  "paneClickDistance"
], fieldsToTrack = [...reactFlowFieldsToTrack, "rfId"], selector$l = (s2) => ({
  setNodes: s2.setNodes,
  setEdges: s2.setEdges,
  setMinZoom: s2.setMinZoom,
  setMaxZoom: s2.setMaxZoom,
  setTranslateExtent: s2.setTranslateExtent,
  setNodeExtent: s2.setNodeExtent,
  reset: s2.reset,
  setDefaultNodesAndEdges: s2.setDefaultNodesAndEdges,
  setPaneClickDistance: s2.setPaneClickDistance
}), initPrevValues = {
  // these are values that are also passed directly to other components
  // than the StoreUpdater. We can reduce the number of setStore calls
  // by setting the same values here as prev fields.
  translateExtent: infiniteExtent,
  nodeOrigin: defaultNodeOrigin,
  minZoom: 0.5,
  maxZoom: 2,
  elementsSelectable: !0,
  noPanClassName: "nopan",
  rfId: "1",
  paneClickDistance: 0
};
function StoreUpdater(props) {
  const { setNodes, setEdges, setMinZoom, setMaxZoom, setTranslateExtent, setNodeExtent, reset, setDefaultNodesAndEdges, setPaneClickDistance } = useStore$2(selector$l, shallow$1), store = useStoreApi();
  useEffect(() => (setDefaultNodesAndEdges(props.defaultNodes, props.defaultEdges), () => {
    previousFields.current = initPrevValues, reset();
  }), []);
  const previousFields = useRef(initPrevValues);
  return useEffect(
    () => {
      for (const fieldName of fieldsToTrack) {
        const fieldValue = props[fieldName], previousFieldValue = previousFields.current[fieldName];
        fieldValue !== previousFieldValue && (typeof props[fieldName] > "u" || (fieldName === "nodes" ? setNodes(fieldValue) : fieldName === "edges" ? setEdges(fieldValue) : fieldName === "minZoom" ? setMinZoom(fieldValue) : fieldName === "maxZoom" ? setMaxZoom(fieldValue) : fieldName === "translateExtent" ? setTranslateExtent(fieldValue) : fieldName === "nodeExtent" ? setNodeExtent(fieldValue) : fieldName === "paneClickDistance" ? setPaneClickDistance(fieldValue) : fieldName === "fitView" ? store.setState({ fitViewOnInit: fieldValue }) : fieldName === "fitViewOptions" ? store.setState({ fitViewOnInitOptions: fieldValue }) : store.setState({ [fieldName]: fieldValue })));
      }
      previousFields.current = props;
    },
    // Only re-run the effect if one of the fields we track changes
    fieldsToTrack.map((fieldName) => props[fieldName])
  ), null;
}
function getMediaQuery() {
  return typeof window > "u" || !window.matchMedia ? null : window.matchMedia("(prefers-color-scheme: dark)");
}
function useColorModeClass(colorMode) {
  var _a4;
  const [colorModeClass, setColorModeClass] = useState(colorMode === "system" ? null : colorMode);
  return useEffect(() => {
    if (colorMode !== "system") {
      setColorModeClass(colorMode);
      return;
    }
    const mediaQuery = getMediaQuery(), updateColorModeClass = () => setColorModeClass(mediaQuery != null && mediaQuery.matches ? "dark" : "light");
    return updateColorModeClass(), mediaQuery == null || mediaQuery.addEventListener("change", updateColorModeClass), () => {
      mediaQuery == null || mediaQuery.removeEventListener("change", updateColorModeClass);
    };
  }, [colorMode]), colorModeClass !== null ? colorModeClass : (_a4 = getMediaQuery()) != null && _a4.matches ? "dark" : "light";
}
const defaultDoc = typeof document < "u" ? document : null;
function useKeyPress(keyCode = null, options = { target: defaultDoc, actInsideInputWithModifier: !0 }) {
  const [keyPressed, setKeyPressed] = useState(!1), modifierPressed = useRef(!1), pressedKeys = useRef(/* @__PURE__ */ new Set([])), [keyCodes, keysToWatch] = useMemo(() => {
    if (keyCode !== null) {
      const keys2 = (Array.isArray(keyCode) ? keyCode : [keyCode]).filter((kc) => typeof kc == "string").map((kc) => kc.replace("+", `
`).replace(`

`, `
+`).split(`
`)), keysFlat = keys2.reduce((res, item) => res.concat(...item), []);
      return [keys2, keysFlat];
    }
    return [[], []];
  }, [keyCode]);
  return useEffect(() => {
    const target = (options == null ? void 0 : options.target) || defaultDoc;
    if (keyCode !== null) {
      const downHandler = (event) => {
        if (modifierPressed.current = event.ctrlKey || event.metaKey || event.shiftKey, (!modifierPressed.current || modifierPressed.current && !options.actInsideInputWithModifier) && isInputDOMNode(event))
          return !1;
        const keyOrCode = useKeyOrCode(event.code, keysToWatch);
        pressedKeys.current.add(event[keyOrCode]), isMatchingKey(keyCodes, pressedKeys.current, !1) && (event.preventDefault(), setKeyPressed(!0));
      }, upHandler = (event) => {
        if ((!modifierPressed.current || modifierPressed.current && !options.actInsideInputWithModifier) && isInputDOMNode(event))
          return !1;
        const keyOrCode = useKeyOrCode(event.code, keysToWatch);
        isMatchingKey(keyCodes, pressedKeys.current, !0) ? (setKeyPressed(!1), pressedKeys.current.clear()) : pressedKeys.current.delete(event[keyOrCode]), event.key === "Meta" && pressedKeys.current.clear(), modifierPressed.current = !1;
      }, resetHandler = () => {
        pressedKeys.current.clear(), setKeyPressed(!1);
      };
      return target == null || target.addEventListener("keydown", downHandler), target == null || target.addEventListener("keyup", upHandler), window.addEventListener("blur", resetHandler), window.addEventListener("contextmenu", resetHandler), () => {
        target == null || target.removeEventListener("keydown", downHandler), target == null || target.removeEventListener("keyup", upHandler), window.removeEventListener("blur", resetHandler), window.removeEventListener("contextmenu", resetHandler);
      };
    }
  }, [keyCode, setKeyPressed]), keyPressed;
}
function isMatchingKey(keyCodes, pressedKeys, isUp) {
  return keyCodes.filter((keys2) => isUp || keys2.length === pressedKeys.size).some((keys2) => keys2.every((k2) => pressedKeys.has(k2)));
}
function useKeyOrCode(eventCode, keysToWatch) {
  return keysToWatch.includes(eventCode) ? "code" : "key";
}
const useViewportHelper = () => {
  const store = useStoreApi();
  return useMemo(() => ({
    zoomIn: (options) => {
      const { panZoom } = store.getState();
      return panZoom ? panZoom.scaleBy(1.2, { duration: options == null ? void 0 : options.duration }) : Promise.resolve(!1);
    },
    zoomOut: (options) => {
      const { panZoom } = store.getState();
      return panZoom ? panZoom.scaleBy(1 / 1.2, { duration: options == null ? void 0 : options.duration }) : Promise.resolve(!1);
    },
    zoomTo: (zoomLevel, options) => {
      const { panZoom } = store.getState();
      return panZoom ? panZoom.scaleTo(zoomLevel, { duration: options == null ? void 0 : options.duration }) : Promise.resolve(!1);
    },
    getZoom: () => store.getState().transform[2],
    setViewport: async (viewport, options) => {
      const { transform: [tX, tY, tZoom], panZoom } = store.getState();
      return panZoom ? (await panZoom.setViewport({
        x: viewport.x ?? tX,
        y: viewport.y ?? tY,
        zoom: viewport.zoom ?? tZoom
      }, { duration: options == null ? void 0 : options.duration }), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    getViewport: () => {
      const [x2, y2, zoom2] = store.getState().transform;
      return { x: x2, y: y2, zoom: zoom2 };
    },
    fitView: (options) => {
      const { nodeLookup, minZoom, maxZoom, panZoom, domNode } = store.getState();
      if (!panZoom || !domNode)
        return Promise.resolve(!1);
      const fitViewNodes = getFitViewNodes(nodeLookup, options), { width: width2, height } = getDimensions$1(domNode);
      return fitView({
        nodes: fitViewNodes,
        width: width2,
        height,
        minZoom,
        maxZoom,
        panZoom
      }, options);
    },
    setCenter: async (x2, y2, options) => {
      const { width: width2, height, maxZoom, panZoom } = store.getState(), nextZoom = typeof (options == null ? void 0 : options.zoom) < "u" ? options.zoom : maxZoom, centerX = width2 / 2 - x2 * nextZoom, centerY = height / 2 - y2 * nextZoom;
      return panZoom ? (await panZoom.setViewport({
        x: centerX,
        y: centerY,
        zoom: nextZoom
      }, { duration: options == null ? void 0 : options.duration }), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    fitBounds: async (bounds, options) => {
      const { width: width2, height, minZoom, maxZoom, panZoom } = store.getState(), viewport = getViewportForBounds(bounds, width2, height, minZoom, maxZoom, (options == null ? void 0 : options.padding) ?? 0.1);
      return panZoom ? (await panZoom.setViewport(viewport, { duration: options == null ? void 0 : options.duration }), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    screenToFlowPosition: (clientPosition, options = { snapToGrid: !0 }) => {
      const { transform: transform2, snapGrid, domNode } = store.getState();
      if (!domNode)
        return clientPosition;
      const { x: domX, y: domY } = domNode.getBoundingClientRect(), correctedPosition = {
        x: clientPosition.x - domX,
        y: clientPosition.y - domY
      };
      return pointToRendererPoint(correctedPosition, transform2, options.snapToGrid, snapGrid);
    },
    flowToScreenPosition: (flowPosition) => {
      const { transform: transform2, domNode } = store.getState();
      if (!domNode)
        return flowPosition;
      const { x: domX, y: domY } = domNode.getBoundingClientRect(), rendererPosition = rendererPointToPoint(flowPosition, transform2);
      return {
        x: rendererPosition.x + domX,
        y: rendererPosition.y + domY
      };
    }
  }), []);
};
function applyChanges(changes, elements) {
  const updatedElements = [], changesMap = /* @__PURE__ */ new Map(), addItemChanges = [];
  for (const change of changes)
    if (change.type === "add") {
      addItemChanges.push(change);
      continue;
    } else if (change.type === "remove" || change.type === "replace")
      changesMap.set(change.id, [change]);
    else {
      const elementChanges = changesMap.get(change.id);
      elementChanges ? elementChanges.push(change) : changesMap.set(change.id, [change]);
    }
  for (const element of elements) {
    const changes2 = changesMap.get(element.id);
    if (!changes2) {
      updatedElements.push(element);
      continue;
    }
    if (changes2[0].type === "remove")
      continue;
    if (changes2[0].type === "replace") {
      updatedElements.push({ ...changes2[0].item });
      continue;
    }
    const updatedElement = { ...element };
    for (const change of changes2)
      applyChange(change, updatedElement);
    updatedElements.push(updatedElement);
  }
  return addItemChanges.length && addItemChanges.forEach((change) => {
    change.index !== void 0 ? updatedElements.splice(change.index, 0, { ...change.item }) : updatedElements.push({ ...change.item });
  }), updatedElements;
}
function applyChange(change, element) {
  switch (change.type) {
    case "select": {
      element.selected = change.selected;
      break;
    }
    case "position": {
      typeof change.position < "u" && (element.position = change.position), typeof change.dragging < "u" && (element.dragging = change.dragging);
      break;
    }
    case "dimensions": {
      typeof change.dimensions < "u" && (element.measured ?? (element.measured = {}), element.measured.width = change.dimensions.width, element.measured.height = change.dimensions.height, change.setAttributes && (element.width = change.dimensions.width, element.height = change.dimensions.height)), typeof change.resizing == "boolean" && (element.resizing = change.resizing);
      break;
    }
  }
}
function applyNodeChanges(changes, nodes) {
  return applyChanges(changes, nodes);
}
function applyEdgeChanges(changes, edges) {
  return applyChanges(changes, edges);
}
function createSelectionChange(id2, selected2) {
  return {
    id: id2,
    type: "select",
    selected: selected2
  };
}
function getSelectionChanges(items, selectedIds = /* @__PURE__ */ new Set(), mutateItem = !1) {
  const changes = [];
  for (const [id2, item] of items) {
    const willBeSelected = selectedIds.has(id2);
    !(item.selected === void 0 && !willBeSelected) && item.selected !== willBeSelected && (mutateItem && (item.selected = willBeSelected), changes.push(createSelectionChange(item.id, willBeSelected)));
  }
  return changes;
}
function getElementsDiffChanges({ items = [], lookup }) {
  var _a4;
  const changes = [], itemsLookup = new Map(items.map((item) => [item.id, item]));
  for (const [index2, item] of items.entries()) {
    const lookupItem = lookup.get(item.id), storeItem = ((_a4 = lookupItem == null ? void 0 : lookupItem.internals) == null ? void 0 : _a4.userNode) ?? lookupItem;
    storeItem !== void 0 && storeItem !== item && changes.push({ id: item.id, item, type: "replace" }), storeItem === void 0 && changes.push({ item, type: "add", index: index2 });
  }
  for (const [id2] of lookup)
    itemsLookup.get(id2) === void 0 && changes.push({ id: id2, type: "remove" });
  return changes;
}
function elementToRemoveChange(item) {
  return {
    id: item.id,
    type: "remove"
  };
}
const isNode$1 = (element) => isNodeBase(element), isEdge = (element) => isEdgeBase(element);
function fixedForwardRef(render) {
  return forwardRef(render);
}
const useIsomorphicLayoutEffect$3 = typeof window < "u" ? useLayoutEffect : useEffect;
function useQueue(runQueue) {
  const [serial, setSerial] = useState(BigInt(0)), [queue] = useState(() => createQueue(() => setSerial((n2) => n2 + BigInt(1))));
  return useIsomorphicLayoutEffect$3(() => {
    const queueItems = queue.get();
    queueItems.length && (runQueue(queueItems), queue.reset());
  }, [serial]), queue;
}
function createQueue(cb) {
  let queue = [];
  return {
    get: () => queue,
    reset: () => {
      queue = [];
    },
    push: (item) => {
      queue.push(item), cb();
    }
  };
}
const BatchContext = createContext(null);
function BatchProvider({ children: children2 }) {
  const store = useStoreApi(), nodeQueueHandler = useCallback((queueItems) => {
    const { nodes = [], setNodes, hasDefaultNodes, onNodesChange, nodeLookup } = store.getState();
    let next = nodes;
    for (const payload of queueItems)
      next = typeof payload == "function" ? payload(next) : payload;
    hasDefaultNodes ? setNodes(next) : onNodesChange && onNodesChange(getElementsDiffChanges({
      items: next,
      lookup: nodeLookup
    }));
  }, []), nodeQueue = useQueue(nodeQueueHandler), edgeQueueHandler = useCallback((queueItems) => {
    const { edges = [], setEdges, hasDefaultEdges, onEdgesChange, edgeLookup } = store.getState();
    let next = edges;
    for (const payload of queueItems)
      next = typeof payload == "function" ? payload(next) : payload;
    hasDefaultEdges ? setEdges(next) : onEdgesChange && onEdgesChange(getElementsDiffChanges({
      items: next,
      lookup: edgeLookup
    }));
  }, []), edgeQueue = useQueue(edgeQueueHandler), value = useMemo(() => ({ nodeQueue, edgeQueue }), []);
  return jsx(BatchContext.Provider, { value, children: children2 });
}
function useBatchContext() {
  const batchContext = useContext(BatchContext);
  if (!batchContext)
    throw new Error("useBatchContext must be used within a BatchProvider");
  return batchContext;
}
const selector$k = (s2) => !!s2.panZoom;
function useReactFlow() {
  const viewportHelper = useViewportHelper(), store = useStoreApi(), batchContext = useBatchContext(), viewportInitialized = useStore$2(selector$k), generalHelper = useMemo(() => {
    const getInternalNode = (id2) => store.getState().nodeLookup.get(id2), setNodes = (payload) => {
      batchContext.nodeQueue.push(payload);
    }, setEdges = (payload) => {
      batchContext.edgeQueue.push(payload);
    }, getNodeRect = (node2) => {
      var _a4, _b2;
      const { nodeLookup, nodeOrigin } = store.getState(), nodeToUse = isNode$1(node2) ? node2 : nodeLookup.get(node2.id), position2 = nodeToUse.parentId ? evaluateAbsolutePosition(nodeToUse.position, nodeToUse.measured, nodeToUse.parentId, nodeLookup, nodeOrigin) : nodeToUse.position, nodeWithPosition = {
        id: nodeToUse.id,
        position: position2,
        width: ((_a4 = nodeToUse.measured) == null ? void 0 : _a4.width) ?? nodeToUse.width,
        height: ((_b2 = nodeToUse.measured) == null ? void 0 : _b2.height) ?? nodeToUse.height,
        data: nodeToUse.data
      };
      return nodeToRect$1(nodeWithPosition);
    }, updateNode = (id2, nodeUpdate, options = { replace: !1 }) => {
      setNodes((prevNodes) => prevNodes.map((node2) => {
        if (node2.id === id2) {
          const nextNode = typeof nodeUpdate == "function" ? nodeUpdate(node2) : nodeUpdate;
          return options.replace && isNode$1(nextNode) ? nextNode : { ...node2, ...nextNode };
        }
        return node2;
      }));
    }, updateEdge = (id2, edgeUpdate, options = { replace: !1 }) => {
      setEdges((prevEdges) => prevEdges.map((edge) => {
        if (edge.id === id2) {
          const nextEdge = typeof edgeUpdate == "function" ? edgeUpdate(edge) : edgeUpdate;
          return options.replace && isEdge(nextEdge) ? nextEdge : { ...edge, ...nextEdge };
        }
        return edge;
      }));
    };
    return {
      getNodes: () => store.getState().nodes.map((n2) => ({ ...n2 })),
      getNode: (id2) => {
        var _a4;
        return (_a4 = getInternalNode(id2)) == null ? void 0 : _a4.internals.userNode;
      },
      getInternalNode,
      getEdges: () => {
        const { edges = [] } = store.getState();
        return edges.map((e2) => ({ ...e2 }));
      },
      getEdge: (id2) => store.getState().edgeLookup.get(id2),
      setNodes,
      setEdges,
      addNodes: (payload) => {
        const newNodes = Array.isArray(payload) ? payload : [payload];
        batchContext.nodeQueue.push((nodes) => [...nodes, ...newNodes]);
      },
      addEdges: (payload) => {
        const newEdges = Array.isArray(payload) ? payload : [payload];
        batchContext.edgeQueue.push((edges) => [...edges, ...newEdges]);
      },
      toObject: () => {
        const { nodes = [], edges = [], transform: transform2 } = store.getState(), [x2, y2, zoom2] = transform2;
        return {
          nodes: nodes.map((n2) => ({ ...n2 })),
          edges: edges.map((e2) => ({ ...e2 })),
          viewport: {
            x: x2,
            y: y2,
            zoom: zoom2
          }
        };
      },
      deleteElements: async ({ nodes: nodesToRemove = [], edges: edgesToRemove = [] }) => {
        const { nodes, edges, onNodesDelete, onEdgesDelete, triggerNodeChanges, triggerEdgeChanges, onDelete, onBeforeDelete } = store.getState(), { nodes: matchingNodes, edges: matchingEdges } = await getElementsToRemove({
          nodesToRemove,
          edgesToRemove,
          nodes,
          edges,
          onBeforeDelete
        }), hasMatchingEdges = matchingEdges.length > 0, hasMatchingNodes = matchingNodes.length > 0;
        if (hasMatchingEdges) {
          const edgeChanges = matchingEdges.map(elementToRemoveChange);
          onEdgesDelete == null || onEdgesDelete(matchingEdges), triggerEdgeChanges(edgeChanges);
        }
        if (hasMatchingNodes) {
          const nodeChanges = matchingNodes.map(elementToRemoveChange);
          onNodesDelete == null || onNodesDelete(matchingNodes), triggerNodeChanges(nodeChanges);
        }
        return (hasMatchingNodes || hasMatchingEdges) && (onDelete == null || onDelete({ nodes: matchingNodes, edges: matchingEdges })), { deletedNodes: matchingNodes, deletedEdges: matchingEdges };
      },
      getIntersectingNodes: (nodeOrRect, partially = !0, nodes) => {
        const isRect = isRectObject(nodeOrRect), nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect), hasNodesOption = nodes !== void 0;
        return nodeRect ? (nodes || store.getState().nodes).filter((n2) => {
          const internalNode = store.getState().nodeLookup.get(n2.id);
          if (internalNode && !isRect && (n2.id === nodeOrRect.id || !internalNode.internals.positionAbsolute))
            return !1;
          const currNodeRect = nodeToRect$1(hasNodesOption ? n2 : internalNode), overlappingArea = getOverlappingArea(currNodeRect, nodeRect);
          return partially && overlappingArea > 0 || overlappingArea >= nodeRect.width * nodeRect.height;
        }) : [];
      },
      isNodeIntersecting: (nodeOrRect, area, partially = !0) => {
        const nodeRect = isRectObject(nodeOrRect) ? nodeOrRect : getNodeRect(nodeOrRect);
        if (!nodeRect)
          return !1;
        const overlappingArea = getOverlappingArea(nodeRect, area);
        return partially && overlappingArea > 0 || overlappingArea >= nodeRect.width * nodeRect.height;
      },
      updateNode,
      updateNodeData: (id2, dataUpdate, options = { replace: !1 }) => {
        updateNode(id2, (node2) => {
          const nextData = typeof dataUpdate == "function" ? dataUpdate(node2) : dataUpdate;
          return options.replace ? { ...node2, data: nextData } : { ...node2, data: { ...node2.data, ...nextData } };
        }, options);
      },
      updateEdge,
      updateEdgeData: (id2, dataUpdate, options = { replace: !1 }) => {
        updateEdge(id2, (edge) => {
          const nextData = typeof dataUpdate == "function" ? dataUpdate(edge) : dataUpdate;
          return options.replace ? { ...edge, data: nextData } : { ...edge, data: { ...edge.data, ...nextData } };
        }, options);
      },
      getNodesBounds: (nodes) => {
        const { nodeLookup, nodeOrigin } = store.getState();
        return getNodesBounds(nodes, { nodeLookup, nodeOrigin });
      },
      getHandleConnections: ({ type, id: id2, nodeId }) => {
        var _a4;
        return Array.from(((_a4 = store.getState().connectionLookup.get(`${nodeId}-${type}-${id2 ?? null}`)) == null ? void 0 : _a4.values()) ?? []);
      }
    };
  }, []);
  return useMemo(() => ({
    ...generalHelper,
    ...viewportHelper,
    viewportInitialized
  }), [viewportInitialized]);
}
const selected = (item) => item.selected, deleteKeyOptions = { actInsideInputWithModifier: !1 }, win$1 = typeof window < "u" ? window : void 0;
function useGlobalKeyHandler({ deleteKeyCode, multiSelectionKeyCode }) {
  const store = useStoreApi(), { deleteElements } = useReactFlow(), deleteKeyPressed = useKeyPress(deleteKeyCode, deleteKeyOptions), multiSelectionKeyPressed = useKeyPress(multiSelectionKeyCode, { target: win$1 });
  useEffect(() => {
    if (deleteKeyPressed) {
      const { edges, nodes } = store.getState();
      deleteElements({ nodes: nodes.filter(selected), edges: edges.filter(selected) }), store.setState({ nodesSelectionActive: !1 });
    }
  }, [deleteKeyPressed]), useEffect(() => {
    store.setState({ multiSelectionActive: multiSelectionKeyPressed });
  }, [multiSelectionKeyPressed]);
}
function useResizeHandler(domNode) {
  const store = useStoreApi();
  useEffect(() => {
    const updateDimensions = () => {
      var _a4, _b2;
      if (!domNode.current)
        return !1;
      const size2 = getDimensions$1(domNode.current);
      (size2.height === 0 || size2.width === 0) && ((_b2 = (_a4 = store.getState()).onError) == null || _b2.call(_a4, "004", errorMessages.error004())), store.setState({ width: size2.width || 500, height: size2.height || 500 });
    };
    if (domNode.current) {
      updateDimensions(), window.addEventListener("resize", updateDimensions);
      const resizeObserver = new ResizeObserver(() => updateDimensions());
      return resizeObserver.observe(domNode.current), () => {
        window.removeEventListener("resize", updateDimensions), resizeObserver && domNode.current && resizeObserver.unobserve(domNode.current);
      };
    }
  }, []);
}
const containerStyle = {
  position: "absolute",
  width: "100%",
  height: "100%",
  top: 0,
  left: 0
}, selector$j = (s2) => ({
  userSelectionActive: s2.userSelectionActive,
  lib: s2.lib
});
function ZoomPane({ onPaneContextMenu, zoomOnScroll = !0, zoomOnPinch = !0, panOnScroll = !1, panOnScrollSpeed = 0.5, panOnScrollMode = PanOnScrollMode.Free, zoomOnDoubleClick = !0, panOnDrag = !0, defaultViewport: defaultViewport2, translateExtent, minZoom, maxZoom, zoomActivationKeyCode, preventScrolling = !0, children: children2, noWheelClassName, noPanClassName, onViewportChange, isControlledViewport, paneClickDistance }) {
  const store = useStoreApi(), zoomPane = useRef(null), { userSelectionActive, lib: lib2 } = useStore$2(selector$j, shallow$1), zoomActivationKeyPressed = useKeyPress(zoomActivationKeyCode), panZoom = useRef();
  useResizeHandler(zoomPane);
  const onTransformChange = useCallback((transform2) => {
    onViewportChange == null || onViewportChange({ x: transform2[0], y: transform2[1], zoom: transform2[2] }), isControlledViewport || store.setState({ transform: transform2 });
  }, [onViewportChange, isControlledViewport]);
  return useEffect(() => {
    if (zoomPane.current) {
      panZoom.current = XYPanZoom({
        domNode: zoomPane.current,
        minZoom,
        maxZoom,
        translateExtent,
        viewport: defaultViewport2,
        paneClickDistance,
        onDraggingChange: (paneDragging) => store.setState({ paneDragging }),
        onPanZoomStart: (event, vp) => {
          const { onViewportChangeStart, onMoveStart } = store.getState();
          onMoveStart == null || onMoveStart(event, vp), onViewportChangeStart == null || onViewportChangeStart(vp);
        },
        onPanZoom: (event, vp) => {
          const { onViewportChange: onViewportChange2, onMove } = store.getState();
          onMove == null || onMove(event, vp), onViewportChange2 == null || onViewportChange2(vp);
        },
        onPanZoomEnd: (event, vp) => {
          const { onViewportChangeEnd, onMoveEnd } = store.getState();
          onMoveEnd == null || onMoveEnd(event, vp), onViewportChangeEnd == null || onViewportChangeEnd(vp);
        }
      });
      const { x: x2, y: y2, zoom: zoom2 } = panZoom.current.getViewport();
      return store.setState({
        panZoom: panZoom.current,
        transform: [x2, y2, zoom2],
        domNode: zoomPane.current.closest(".react-flow")
      }), () => {
        var _a4;
        (_a4 = panZoom.current) == null || _a4.destroy();
      };
    }
  }, []), useEffect(() => {
    var _a4;
    (_a4 = panZoom.current) == null || _a4.update({
      onPaneContextMenu,
      zoomOnScroll,
      zoomOnPinch,
      panOnScroll,
      panOnScrollSpeed,
      panOnScrollMode,
      zoomOnDoubleClick,
      panOnDrag,
      zoomActivationKeyPressed,
      preventScrolling,
      noPanClassName,
      userSelectionActive,
      noWheelClassName,
      lib: lib2,
      onTransformChange
    });
  }, [
    onPaneContextMenu,
    zoomOnScroll,
    zoomOnPinch,
    panOnScroll,
    panOnScrollSpeed,
    panOnScrollMode,
    zoomOnDoubleClick,
    panOnDrag,
    zoomActivationKeyPressed,
    preventScrolling,
    noPanClassName,
    userSelectionActive,
    noWheelClassName,
    lib2,
    onTransformChange
  ]), jsx("div", { className: "react-flow__renderer", ref: zoomPane, style: containerStyle, children: children2 });
}
const selector$i = (s2) => ({
  userSelectionActive: s2.userSelectionActive,
  userSelectionRect: s2.userSelectionRect
});
function UserSelection() {
  const { userSelectionActive, userSelectionRect } = useStore$2(selector$i, shallow$1);
  return userSelectionActive && userSelectionRect ? jsx("div", { className: "react-flow__selection react-flow__container", style: {
    width: userSelectionRect.width,
    height: userSelectionRect.height,
    transform: `translate(${userSelectionRect.x}px, ${userSelectionRect.y}px)`
  } }) : null;
}
const wrapHandler = (handler, containerRef) => (event) => {
  event.target === containerRef.current && (handler == null || handler(event));
}, selector$h = (s2) => ({
  userSelectionActive: s2.userSelectionActive,
  elementsSelectable: s2.elementsSelectable,
  dragging: s2.paneDragging
});
function Pane({ isSelecting, selectionKeyPressed, selectionMode = SelectionMode.Full, panOnDrag, selectionOnDrag, onSelectionStart, onSelectionEnd, onPaneClick, onPaneContextMenu, onPaneScroll, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, children: children2 }) {
  const container2 = useRef(null), store = useStoreApi(), prevSelectedNodesCount = useRef(0), prevSelectedEdgesCount = useRef(0), containerBounds = useRef(), edgeIdLookup = useRef(/* @__PURE__ */ new Map()), { userSelectionActive, elementsSelectable, dragging } = useStore$2(selector$h, shallow$1), hasActiveSelection = elementsSelectable && (isSelecting || userSelectionActive), selectionInProgress = useRef(!1), selectionStarted = useRef(!1), resetUserSelection = () => {
    store.setState({ userSelectionActive: !1, userSelectionRect: null }), prevSelectedNodesCount.current = 0, prevSelectedEdgesCount.current = 0;
  }, onClick = (event) => {
    if (selectionInProgress.current) {
      selectionInProgress.current = !1;
      return;
    }
    onPaneClick == null || onPaneClick(event), store.getState().resetSelectedElements(), store.setState({ nodesSelectionActive: !1 });
  }, onContextMenu = (event) => {
    if (Array.isArray(panOnDrag) && (panOnDrag != null && panOnDrag.includes(2))) {
      event.preventDefault();
      return;
    }
    onPaneContextMenu == null || onPaneContextMenu(event);
  }, onWheel = onPaneScroll ? (event) => onPaneScroll(event) : void 0, onPointerDown2 = (event) => {
    var _a4, _b2, _c, _d;
    const { resetSelectedElements, domNode, edgeLookup } = store.getState();
    if (containerBounds.current = domNode == null ? void 0 : domNode.getBoundingClientRect(), !elementsSelectable || !isSelecting || event.button !== 0 || event.target !== container2.current || !containerBounds.current)
      return;
    (_b2 = (_a4 = event.target) == null ? void 0 : _a4.setPointerCapture) == null || _b2.call(_a4, event.pointerId), selectionStarted.current = !0, selectionInProgress.current = !1, edgeIdLookup.current = /* @__PURE__ */ new Map();
    for (const [id2, edge] of edgeLookup)
      edgeIdLookup.current.set(edge.source, ((_c = edgeIdLookup.current.get(edge.source)) == null ? void 0 : _c.add(id2)) || /* @__PURE__ */ new Set([id2])), edgeIdLookup.current.set(edge.target, ((_d = edgeIdLookup.current.get(edge.target)) == null ? void 0 : _d.add(id2)) || /* @__PURE__ */ new Set([id2]));
    const { x: x2, y: y2 } = getEventPosition(event.nativeEvent, containerBounds.current);
    resetSelectedElements(), store.setState({
      userSelectionRect: {
        width: 0,
        height: 0,
        startX: x2,
        startY: y2,
        x: x2,
        y: y2
      }
    }), onSelectionStart == null || onSelectionStart(event);
  }, onPointerMove = (event) => {
    const { userSelectionRect, edgeLookup, transform: transform2, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = store.getState();
    if (!containerBounds.current || !userSelectionRect)
      return;
    selectionInProgress.current = !0;
    const { x: mouseX, y: mouseY } = getEventPosition(event.nativeEvent, containerBounds.current), { startX, startY } = userSelectionRect, nextUserSelectRect = {
      startX,
      startY,
      x: mouseX < startX ? mouseX : startX,
      y: mouseY < startY ? mouseY : startY,
      width: Math.abs(mouseX - startX),
      height: Math.abs(mouseY - startY)
    }, selectedNodes = getNodesInside(nodeLookup, nextUserSelectRect, transform2, selectionMode === SelectionMode.Partial, !0), selectedEdgeIds = /* @__PURE__ */ new Set(), selectedNodeIds = /* @__PURE__ */ new Set();
    for (const selectedNode of selectedNodes) {
      selectedNodeIds.add(selectedNode.id);
      const edgeIds = edgeIdLookup.current.get(selectedNode.id);
      if (edgeIds)
        for (const edgeId of edgeIds)
          selectedEdgeIds.add(edgeId);
    }
    if (prevSelectedNodesCount.current !== selectedNodeIds.size) {
      prevSelectedNodesCount.current = selectedNodeIds.size;
      const changes = getSelectionChanges(nodeLookup, selectedNodeIds, !0);
      triggerNodeChanges(changes);
    }
    if (prevSelectedEdgesCount.current !== selectedEdgeIds.size) {
      prevSelectedEdgesCount.current = selectedEdgeIds.size;
      const changes = getSelectionChanges(edgeLookup, selectedEdgeIds);
      triggerEdgeChanges(changes);
    }
    store.setState({
      userSelectionRect: nextUserSelectRect,
      userSelectionActive: !0,
      nodesSelectionActive: !1
    });
  }, onPointerUp = (event) => {
    var _a4, _b2;
    if (event.button !== 0 || !selectionStarted.current)
      return;
    (_b2 = (_a4 = event.target) == null ? void 0 : _a4.releasePointerCapture) == null || _b2.call(_a4, event.pointerId);
    const { userSelectionRect } = store.getState();
    !userSelectionActive && userSelectionRect && event.target === container2.current && (onClick == null || onClick(event)), prevSelectedNodesCount.current > 0 && store.setState({ nodesSelectionActive: !0 }), resetUserSelection(), onSelectionEnd == null || onSelectionEnd(event), (selectionKeyPressed || selectionOnDrag) && (selectionInProgress.current = !1), selectionStarted.current = !1;
  }, draggable = panOnDrag === !0 || Array.isArray(panOnDrag) && panOnDrag.includes(0);
  return jsxs("div", { className: cc(["react-flow__pane", { draggable, dragging, selection: isSelecting }]), onClick: hasActiveSelection ? void 0 : wrapHandler(onClick, container2), onContextMenu: wrapHandler(onContextMenu, container2), onWheel: wrapHandler(onWheel, container2), onPointerEnter: hasActiveSelection ? void 0 : onPaneMouseEnter, onPointerDown: hasActiveSelection ? onPointerDown2 : onPaneMouseMove, onPointerMove: hasActiveSelection ? onPointerMove : onPaneMouseMove, onPointerUp: hasActiveSelection ? onPointerUp : void 0, onPointerLeave: onPaneMouseLeave, ref: container2, style: containerStyle, children: [children2, jsx(UserSelection, {})] });
}
function handleNodeClick({ id: id2, store, unselect = !1, nodeRef }) {
  const { addSelectedNodes, unselectNodesAndEdges, multiSelectionActive, nodeLookup, onError } = store.getState(), node2 = nodeLookup.get(id2);
  if (!node2) {
    onError == null || onError("012", errorMessages.error012(id2));
    return;
  }
  store.setState({ nodesSelectionActive: !1 }), node2.selected ? (unselect || node2.selected && multiSelectionActive) && (unselectNodesAndEdges({ nodes: [node2], edges: [] }), requestAnimationFrame(() => {
    var _a4;
    return (_a4 = nodeRef == null ? void 0 : nodeRef.current) == null ? void 0 : _a4.blur();
  })) : addSelectedNodes([id2]);
}
function useDrag({ nodeRef, disabled = !1, noDragClassName, handleSelector, nodeId, isSelectable, nodeClickDistance }) {
  const store = useStoreApi(), [dragging, setDragging] = useState(!1), xyDrag = useRef();
  return useEffect(() => {
    xyDrag.current = XYDrag({
      getStoreItems: () => store.getState(),
      onNodeMouseDown: (id2) => {
        handleNodeClick({
          id: id2,
          store,
          nodeRef
        });
      },
      onDragStart: () => {
        setDragging(!0);
      },
      onDragStop: () => {
        setDragging(!1);
      }
    });
  }, []), useEffect(() => {
    var _a4, _b2;
    if (disabled)
      (_a4 = xyDrag.current) == null || _a4.destroy();
    else if (nodeRef.current)
      return (_b2 = xyDrag.current) == null || _b2.update({
        noDragClassName,
        handleSelector,
        domNode: nodeRef.current,
        isSelectable,
        nodeId,
        nodeClickDistance
      }), () => {
        var _a5;
        (_a5 = xyDrag.current) == null || _a5.destroy();
      };
  }, [noDragClassName, handleSelector, disabled, isSelectable, nodeRef, nodeId]), dragging;
}
const selectedAndDraggable = (nodesDraggable) => (n2) => n2.selected && (n2.draggable || nodesDraggable && typeof n2.draggable > "u");
function useMoveSelectedNodes() {
  const store = useStoreApi();
  return useCallback((params) => {
    const { nodeExtent, snapToGrid, snapGrid, nodesDraggable, onError, updateNodePositions, nodeLookup, nodeOrigin } = store.getState(), nodeUpdates = /* @__PURE__ */ new Map(), isSelected = selectedAndDraggable(nodesDraggable), xVelo = snapToGrid ? snapGrid[0] : 5, yVelo = snapToGrid ? snapGrid[1] : 5, xDiff = params.direction.x * xVelo * params.factor, yDiff = params.direction.y * yVelo * params.factor;
    for (const [, node2] of nodeLookup) {
      if (!isSelected(node2))
        continue;
      let nextPosition = {
        x: node2.internals.positionAbsolute.x + xDiff,
        y: node2.internals.positionAbsolute.y + yDiff
      };
      snapToGrid && (nextPosition = snapPosition(nextPosition, snapGrid));
      const { position: position2, positionAbsolute } = calculateNodePosition({
        nodeId: node2.id,
        nextPosition,
        nodeLookup,
        nodeExtent,
        nodeOrigin,
        onError
      });
      node2.position = position2, node2.internals.positionAbsolute = positionAbsolute, nodeUpdates.set(node2.id, node2);
    }
    updateNodePositions(nodeUpdates);
  }, []);
}
const NodeIdContext = createContext(null), Provider = NodeIdContext.Provider;
NodeIdContext.Consumer;
const useNodeId = () => useContext(NodeIdContext), selector$g = (s2) => ({
  connectOnClick: s2.connectOnClick,
  noPanClassName: s2.noPanClassName,
  rfId: s2.rfId
}), connectingSelector = (nodeId, handleId, type) => (state) => {
  const { connectionClickStartHandle: clickHandle, connectionMode, connection } = state, { fromHandle, toHandle, isValid } = connection, connectingTo = (toHandle == null ? void 0 : toHandle.nodeId) === nodeId && (toHandle == null ? void 0 : toHandle.id) === handleId && (toHandle == null ? void 0 : toHandle.type) === type;
  return {
    connectingFrom: (fromHandle == null ? void 0 : fromHandle.nodeId) === nodeId && (fromHandle == null ? void 0 : fromHandle.id) === handleId && (fromHandle == null ? void 0 : fromHandle.type) === type,
    connectingTo,
    clickConnecting: (clickHandle == null ? void 0 : clickHandle.nodeId) === nodeId && (clickHandle == null ? void 0 : clickHandle.id) === handleId && (clickHandle == null ? void 0 : clickHandle.type) === type,
    isPossibleEndHandle: connectionMode === ConnectionMode.Strict ? (fromHandle == null ? void 0 : fromHandle.type) !== type : nodeId !== (fromHandle == null ? void 0 : fromHandle.nodeId) || handleId !== (fromHandle == null ? void 0 : fromHandle.id),
    connectionInProcess: !!fromHandle,
    valid: connectingTo && isValid
  };
};
function HandleComponent({ type = "source", position: position2 = Position.Top, isValidConnection, isConnectable = !0, isConnectableStart = !0, isConnectableEnd = !0, id: id2, onConnect, children: children2, className, onMouseDown, onTouchStart, ...rest }, ref) {
  var _a4, _b2;
  const handleId = id2 || null, isTarget = type === "target", store = useStoreApi(), nodeId = useNodeId(), { connectOnClick, noPanClassName, rfId } = useStore$2(selector$g, shallow$1), { connectingFrom, connectingTo, clickConnecting, isPossibleEndHandle, connectionInProcess, valid } = useStore$2(connectingSelector(nodeId, handleId, type), shallow$1);
  nodeId || (_b2 = (_a4 = store.getState()).onError) == null || _b2.call(_a4, "010", errorMessages.error010());
  const onConnectExtended = (params) => {
    const { defaultEdgeOptions, onConnect: onConnectAction, hasDefaultEdges } = store.getState(), edgeParams = {
      ...defaultEdgeOptions,
      ...params
    };
    if (hasDefaultEdges) {
      const { edges, setEdges } = store.getState();
      setEdges(addEdge$1(edgeParams, edges));
    }
    onConnectAction == null || onConnectAction(edgeParams), onConnect == null || onConnect(edgeParams);
  }, onPointerDown2 = (event) => {
    if (!nodeId)
      return;
    const isMouseTriggered = isMouseEvent(event.nativeEvent);
    if (isConnectableStart && (isMouseTriggered && event.button === 0 || !isMouseTriggered)) {
      const currentStore = store.getState();
      XYHandle.onPointerDown(event.nativeEvent, {
        autoPanOnConnect: currentStore.autoPanOnConnect,
        connectionMode: currentStore.connectionMode,
        connectionRadius: currentStore.connectionRadius,
        domNode: currentStore.domNode,
        nodeLookup: currentStore.nodeLookup,
        lib: currentStore.lib,
        isTarget,
        handleId,
        nodeId,
        flowId: currentStore.rfId,
        panBy: currentStore.panBy,
        cancelConnection: currentStore.cancelConnection,
        onConnectStart: currentStore.onConnectStart,
        onConnectEnd: currentStore.onConnectEnd,
        updateConnection: currentStore.updateConnection,
        onConnect: onConnectExtended,
        isValidConnection: isValidConnection || currentStore.isValidConnection,
        getTransform: () => store.getState().transform,
        getFromHandle: () => store.getState().connection.fromHandle,
        autoPanSpeed: currentStore.autoPanSpeed
      });
    }
    isMouseTriggered ? onMouseDown == null || onMouseDown(event) : onTouchStart == null || onTouchStart(event);
  }, onClick = (event) => {
    const { onClickConnectStart, onClickConnectEnd, connectionClickStartHandle, connectionMode, isValidConnection: isValidConnectionStore, lib: lib2, rfId: flowId, nodeLookup, connection: connectionState } = store.getState();
    if (!nodeId || !connectionClickStartHandle && !isConnectableStart)
      return;
    if (!connectionClickStartHandle) {
      onClickConnectStart == null || onClickConnectStart(event.nativeEvent, { nodeId, handleId, handleType: type }), store.setState({ connectionClickStartHandle: { nodeId, type, id: handleId } });
      return;
    }
    const doc = getHostForElement(event.target), isValidConnectionHandler = isValidConnection || isValidConnectionStore, { connection, isValid } = XYHandle.isValid(event.nativeEvent, {
      handle: {
        nodeId,
        id: handleId,
        type
      },
      connectionMode,
      fromNodeId: connectionClickStartHandle.nodeId,
      fromHandleId: connectionClickStartHandle.id || null,
      fromType: connectionClickStartHandle.type,
      isValidConnection: isValidConnectionHandler,
      flowId,
      doc,
      lib: lib2,
      nodeLookup
    });
    isValid && connection && onConnectExtended(connection);
    const connectionClone = structuredClone(connectionState);
    delete connectionClone.inProgress, connectionClone.toPosition = connectionClone.toHandle ? connectionClone.toHandle.position : null, onClickConnectEnd == null || onClickConnectEnd(event, connectionClone), store.setState({ connectionClickStartHandle: null });
  };
  return jsx("div", { "data-handleid": handleId, "data-nodeid": nodeId, "data-handlepos": position2, "data-id": `${rfId}-${nodeId}-${handleId}-${type}`, className: cc([
    "react-flow__handle",
    `react-flow__handle-${position2}`,
    "nodrag",
    noPanClassName,
    className,
    {
      source: !isTarget,
      target: isTarget,
      connectable: isConnectable,
      connectablestart: isConnectableStart,
      connectableend: isConnectableEnd,
      clickconnecting: clickConnecting,
      connectingfrom: connectingFrom,
      connectingto: connectingTo,
      valid,
      // shows where you can start a connection from
      // and where you can end it while connecting
      connectionindicator: isConnectable && (!connectionInProcess || isPossibleEndHandle) && (connectionInProcess ? isConnectableEnd : isConnectableStart)
    }
  ]), onMouseDown: onPointerDown2, onTouchStart: onPointerDown2, onClick: connectOnClick ? onClick : void 0, ref, ...rest, children: children2 });
}
const Handle = memo$1(fixedForwardRef(HandleComponent));
function InputNode({ data, isConnectable, sourcePosition = Position.Bottom }) {
  return jsxs(Fragment, { children: [data == null ? void 0 : data.label, jsx(Handle, { type: "source", position: sourcePosition, isConnectable })] });
}
function DefaultNode({ data, isConnectable, targetPosition = Position.Top, sourcePosition = Position.Bottom }) {
  return jsxs(Fragment, { children: [jsx(Handle, { type: "target", position: targetPosition, isConnectable }), data == null ? void 0 : data.label, jsx(Handle, { type: "source", position: sourcePosition, isConnectable })] });
}
function GroupNode() {
  return null;
}
function OutputNode({ data, isConnectable, targetPosition = Position.Top }) {
  return jsxs(Fragment, { children: [jsx(Handle, { type: "target", position: targetPosition, isConnectable }), data == null ? void 0 : data.label] });
}
const arrowKeyDiffs = {
  ArrowUp: { x: 0, y: -1 },
  ArrowDown: { x: 0, y: 1 },
  ArrowLeft: { x: -1, y: 0 },
  ArrowRight: { x: 1, y: 0 }
}, builtinNodeTypes = {
  input: InputNode,
  default: DefaultNode,
  output: OutputNode,
  group: GroupNode
};
function getNodeInlineStyleDimensions(node2) {
  var _a4, _b2, _c, _d;
  return node2.internals.handleBounds === void 0 ? {
    width: node2.width ?? node2.initialWidth ?? ((_a4 = node2.style) == null ? void 0 : _a4.width),
    height: node2.height ?? node2.initialHeight ?? ((_b2 = node2.style) == null ? void 0 : _b2.height)
  } : {
    width: node2.width ?? ((_c = node2.style) == null ? void 0 : _c.width),
    height: node2.height ?? ((_d = node2.style) == null ? void 0 : _d.height)
  };
}
const selector$f = (s2) => {
  const { width: width2, height, x: x2, y: y2 } = getInternalNodesBounds(s2.nodeLookup, {
    filter: (node2) => !!node2.selected
  });
  return {
    width: isNumeric(width2) ? width2 : null,
    height: isNumeric(height) ? height : null,
    userSelectionActive: s2.userSelectionActive,
    transformString: `translate(${s2.transform[0]}px,${s2.transform[1]}px) scale(${s2.transform[2]}) translate(${x2}px,${y2}px)`
  };
};
function NodesSelection({ onSelectionContextMenu, noPanClassName, disableKeyboardA11y }) {
  const store = useStoreApi(), { width: width2, height, transformString, userSelectionActive } = useStore$2(selector$f, shallow$1), moveSelectedNodes = useMoveSelectedNodes(), nodeRef = useRef(null);
  if (useEffect(() => {
    var _a4;
    disableKeyboardA11y || (_a4 = nodeRef.current) == null || _a4.focus({
      preventScroll: !0
    });
  }, [disableKeyboardA11y]), useDrag({
    nodeRef
  }), userSelectionActive || !width2 || !height)
    return null;
  const onContextMenu = onSelectionContextMenu ? (event) => {
    const selectedNodes = store.getState().nodes.filter((n2) => n2.selected);
    onSelectionContextMenu(event, selectedNodes);
  } : void 0, onKeyDown = (event) => {
    Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key) && moveSelectedNodes({
      direction: arrowKeyDiffs[event.key],
      factor: event.shiftKey ? 4 : 1
    });
  };
  return jsx("div", { className: cc(["react-flow__nodesselection", "react-flow__container", noPanClassName]), style: {
    transform: transformString
  }, children: jsx("div", { ref: nodeRef, className: "react-flow__nodesselection-rect", onContextMenu, tabIndex: disableKeyboardA11y ? void 0 : -1, onKeyDown: disableKeyboardA11y ? void 0 : onKeyDown, style: {
    width: width2,
    height
  } }) });
}
const win = typeof window < "u" ? window : void 0, selector$e = (s2) => ({ nodesSelectionActive: s2.nodesSelectionActive, userSelectionActive: s2.userSelectionActive });
function FlowRendererComponent({ children: children2, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, paneClickDistance, deleteKeyCode, selectionKeyCode, selectionOnDrag, selectionMode, onSelectionStart, onSelectionEnd, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, elementsSelectable, zoomOnScroll, zoomOnPinch, panOnScroll: _panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag: _panOnDrag, defaultViewport: defaultViewport2, translateExtent, minZoom, maxZoom, preventScrolling, onSelectionContextMenu, noWheelClassName, noPanClassName, disableKeyboardA11y, onViewportChange, isControlledViewport }) {
  const { nodesSelectionActive, userSelectionActive } = useStore$2(selector$e), selectionKeyPressed = useKeyPress(selectionKeyCode, { target: win }), panActivationKeyPressed = useKeyPress(panActivationKeyCode, { target: win }), panOnDrag = panActivationKeyPressed || _panOnDrag, panOnScroll = panActivationKeyPressed || _panOnScroll, _selectionOnDrag = selectionOnDrag && panOnDrag !== !0, isSelecting = selectionKeyPressed || userSelectionActive || _selectionOnDrag;
  return useGlobalKeyHandler({ deleteKeyCode, multiSelectionKeyCode }), jsx(ZoomPane, { onPaneContextMenu, elementsSelectable, zoomOnScroll, zoomOnPinch, panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag: !selectionKeyPressed && panOnDrag, defaultViewport: defaultViewport2, translateExtent, minZoom, maxZoom, zoomActivationKeyCode, preventScrolling, noWheelClassName, noPanClassName, onViewportChange, isControlledViewport, paneClickDistance, children: jsxs(Pane, { onSelectionStart, onSelectionEnd, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, panOnDrag, isSelecting: !!isSelecting, selectionMode, selectionKeyPressed, selectionOnDrag: _selectionOnDrag, children: [children2, nodesSelectionActive && jsx(NodesSelection, { onSelectionContextMenu, noPanClassName, disableKeyboardA11y })] }) });
}
FlowRendererComponent.displayName = "FlowRenderer";
const FlowRenderer = memo$1(FlowRendererComponent), selector$d = (onlyRenderVisible) => (s2) => onlyRenderVisible ? getNodesInside(s2.nodeLookup, { x: 0, y: 0, width: s2.width, height: s2.height }, s2.transform, !0).map((node2) => node2.id) : Array.from(s2.nodeLookup.keys());
function useVisibleNodeIds(onlyRenderVisible) {
  return useStore$2(useCallback(selector$d(onlyRenderVisible), [onlyRenderVisible]), shallow$1);
}
const selector$c = (s2) => s2.updateNodeInternals;
function useResizeObserver$2() {
  const updateNodeInternals2 = useStore$2(selector$c), [resizeObserver] = useState(() => typeof ResizeObserver > "u" ? null : new ResizeObserver((entries) => {
    const updates = /* @__PURE__ */ new Map();
    entries.forEach((entry) => {
      const id2 = entry.target.getAttribute("data-id");
      updates.set(id2, {
        id: id2,
        nodeElement: entry.target,
        force: !0
      });
    }), updateNodeInternals2(updates);
  }));
  return useEffect(() => () => {
    resizeObserver == null || resizeObserver.disconnect();
  }, [resizeObserver]), resizeObserver;
}
function useNodeObserver({ node: node2, nodeType, hasDimensions, resizeObserver }) {
  const store = useStoreApi(), nodeRef = useRef(null), observedNode = useRef(null), prevSourcePosition = useRef(node2.sourcePosition), prevTargetPosition = useRef(node2.targetPosition), prevType = useRef(nodeType), isInitialized = hasDimensions && !!node2.internals.handleBounds;
  return useEffect(() => {
    nodeRef.current && !node2.hidden && (!isInitialized || observedNode.current !== nodeRef.current) && (observedNode.current && (resizeObserver == null || resizeObserver.unobserve(observedNode.current)), resizeObserver == null || resizeObserver.observe(nodeRef.current), observedNode.current = nodeRef.current);
  }, [isInitialized, node2.hidden]), useEffect(() => () => {
    observedNode.current && (resizeObserver == null || resizeObserver.unobserve(observedNode.current), observedNode.current = null);
  }, []), useEffect(() => {
    if (nodeRef.current) {
      const typeChanged = prevType.current !== nodeType, sourcePosChanged = prevSourcePosition.current !== node2.sourcePosition, targetPosChanged = prevTargetPosition.current !== node2.targetPosition;
      (typeChanged || sourcePosChanged || targetPosChanged) && (prevType.current = nodeType, prevSourcePosition.current = node2.sourcePosition, prevTargetPosition.current = node2.targetPosition, store.getState().updateNodeInternals(/* @__PURE__ */ new Map([[node2.id, { id: node2.id, nodeElement: nodeRef.current, force: !0 }]])));
    }
  }, [node2.id, nodeType, node2.sourcePosition, node2.targetPosition]), nodeRef;
}
function NodeWrapper({ id: id2, onClick, onMouseEnter, onMouseMove, onMouseLeave, onContextMenu, onDoubleClick, nodesDraggable, elementsSelectable, nodesConnectable, nodesFocusable, resizeObserver, noDragClassName, noPanClassName, disableKeyboardA11y, rfId, nodeTypes: nodeTypes2, nodeExtent, nodeClickDistance, onError }) {
  const { node: node2, internals, isParent: isParent2 } = useStore$2((s2) => {
    const node22 = s2.nodeLookup.get(id2), isParent22 = s2.parentLookup.has(id2);
    return {
      node: node22,
      internals: node22.internals,
      isParent: isParent22
    };
  }, shallow$1);
  let nodeType = node2.type || "default", NodeComponent = (nodeTypes2 == null ? void 0 : nodeTypes2[nodeType]) || builtinNodeTypes[nodeType];
  NodeComponent === void 0 && (onError == null || onError("003", errorMessages.error003(nodeType)), nodeType = "default", NodeComponent = builtinNodeTypes.default);
  const isDraggable = !!(node2.draggable || nodesDraggable && typeof node2.draggable > "u"), isSelectable = !!(node2.selectable || elementsSelectable && typeof node2.selectable > "u"), isConnectable = !!(node2.connectable || nodesConnectable && typeof node2.connectable > "u"), isFocusable = !!(node2.focusable || nodesFocusable && typeof node2.focusable > "u"), store = useStoreApi(), hasDimensions = nodeHasDimensions(node2), nodeRef = useNodeObserver({ node: node2, nodeType, hasDimensions, resizeObserver }), dragging = useDrag({
    nodeRef,
    disabled: node2.hidden || !isDraggable,
    noDragClassName,
    handleSelector: node2.dragHandle,
    nodeId: id2,
    isSelectable,
    nodeClickDistance
  }), moveSelectedNodes = useMoveSelectedNodes();
  if (node2.hidden)
    return null;
  const nodeDimensions = getNodeDimensions(node2), inlineDimensions = getNodeInlineStyleDimensions(node2), hasPointerEvents = isSelectable || isDraggable || onClick || onMouseEnter || onMouseMove || onMouseLeave, onMouseEnterHandler = onMouseEnter ? (event) => onMouseEnter(event, { ...internals.userNode }) : void 0, onMouseMoveHandler = onMouseMove ? (event) => onMouseMove(event, { ...internals.userNode }) : void 0, onMouseLeaveHandler = onMouseLeave ? (event) => onMouseLeave(event, { ...internals.userNode }) : void 0, onContextMenuHandler = onContextMenu ? (event) => onContextMenu(event, { ...internals.userNode }) : void 0, onDoubleClickHandler = onDoubleClick ? (event) => onDoubleClick(event, { ...internals.userNode }) : void 0, onSelectNodeHandler = (event) => {
    const { selectNodesOnDrag, nodeDragThreshold } = store.getState();
    isSelectable && (!selectNodesOnDrag || !isDraggable || nodeDragThreshold > 0) && handleNodeClick({
      id: id2,
      store,
      nodeRef
    }), onClick && onClick(event, { ...internals.userNode });
  }, onKeyDown = (event) => {
    if (!(isInputDOMNode(event.nativeEvent) || disableKeyboardA11y))
      if (elementSelectionKeys.includes(event.key) && isSelectable) {
        const unselect = event.key === "Escape";
        handleNodeClick({
          id: id2,
          store,
          unselect,
          nodeRef
        });
      } else isDraggable && node2.selected && Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key) && (store.setState({
        ariaLiveMessage: `Moved selected node ${event.key.replace("Arrow", "").toLowerCase()}. New position, x: ${~~internals.positionAbsolute.x}, y: ${~~internals.positionAbsolute.y}`
      }), moveSelectedNodes({
        direction: arrowKeyDiffs[event.key],
        factor: event.shiftKey ? 4 : 1
      }));
  };
  return jsx("div", { className: cc([
    "react-flow__node",
    `react-flow__node-${nodeType}`,
    {
      // this is overwritable by passing `nopan` as a class name
      [noPanClassName]: isDraggable
    },
    node2.className,
    {
      selected: node2.selected,
      selectable: isSelectable,
      parent: isParent2,
      draggable: isDraggable,
      dragging
    }
  ]), ref: nodeRef, style: {
    zIndex: internals.z,
    transform: `translate(${internals.positionAbsolute.x}px,${internals.positionAbsolute.y}px)`,
    pointerEvents: hasPointerEvents ? "all" : "none",
    visibility: hasDimensions ? "visible" : "hidden",
    ...node2.style,
    ...inlineDimensions
  }, "data-id": id2, "data-testid": `rf__node-${id2}`, onMouseEnter: onMouseEnterHandler, onMouseMove: onMouseMoveHandler, onMouseLeave: onMouseLeaveHandler, onContextMenu: onContextMenuHandler, onClick: onSelectNodeHandler, onDoubleClick: onDoubleClickHandler, onKeyDown: isFocusable ? onKeyDown : void 0, tabIndex: isFocusable ? 0 : void 0, role: isFocusable ? "button" : void 0, "aria-describedby": disableKeyboardA11y ? void 0 : `${ARIA_NODE_DESC_KEY}-${rfId}`, "aria-label": node2.ariaLabel, children: jsx(Provider, { value: id2, children: jsx(NodeComponent, { id: id2, data: node2.data, type: nodeType, positionAbsoluteX: internals.positionAbsolute.x, positionAbsoluteY: internals.positionAbsolute.y, selected: node2.selected, selectable: isSelectable, draggable: isDraggable, deletable: node2.deletable ?? !0, isConnectable, sourcePosition: node2.sourcePosition, targetPosition: node2.targetPosition, dragging, dragHandle: node2.dragHandle, zIndex: internals.z, parentId: node2.parentId, ...nodeDimensions }) }) });
}
const selector$b = (s2) => ({
  nodesDraggable: s2.nodesDraggable,
  nodesConnectable: s2.nodesConnectable,
  nodesFocusable: s2.nodesFocusable,
  elementsSelectable: s2.elementsSelectable,
  onError: s2.onError
});
function NodeRendererComponent(props) {
  const { nodesDraggable, nodesConnectable, nodesFocusable, elementsSelectable, onError } = useStore$2(selector$b, shallow$1), nodeIds = useVisibleNodeIds(props.onlyRenderVisibleElements), resizeObserver = useResizeObserver$2();
  return jsx("div", { className: "react-flow__nodes", style: containerStyle, children: nodeIds.map((nodeId) => (
    // The split of responsibilities between NodeRenderer and
    // NodeComponentWrapper may appear weird. However, it’s designed to
    // minimize the cost of updates when individual nodes change.
    //
    // For example, when you’re dragging a single node, that node gets
    // updated multiple times per second. If `NodeRenderer` were to update
    // every time, it would have to re-run the `nodes.map()` loop every
    // time. This gets pricey with hundreds of nodes, especially if every
    // loop cycle does more than just rendering a JSX element!
    //
    // As a result of this choice, we took the following implementation
    // decisions:
    // - NodeRenderer subscribes *only* to node IDs – and therefore
    //   rerender *only* when visible nodes are added or removed.
    // - NodeRenderer performs all operations the result of which can be
    //   shared between nodes (such as creating the `ResizeObserver`
    //   instance, or subscribing to `selector`). This means extra prop
    //   drilling into `NodeComponentWrapper`, but it means we need to run
    //   these operations only once – instead of once per node.
    // - Any operations that you’d normally write inside `nodes.map` are
    //   moved into `NodeComponentWrapper`. This ensures they are
    //   memorized – so if `NodeRenderer` *has* to rerender, it only
    //   needs to regenerate the list of nodes, nothing else.
    jsx(NodeWrapper, { id: nodeId, nodeTypes: props.nodeTypes, nodeExtent: props.nodeExtent, onClick: props.onNodeClick, onMouseEnter: props.onNodeMouseEnter, onMouseMove: props.onNodeMouseMove, onMouseLeave: props.onNodeMouseLeave, onContextMenu: props.onNodeContextMenu, onDoubleClick: props.onNodeDoubleClick, noDragClassName: props.noDragClassName, noPanClassName: props.noPanClassName, rfId: props.rfId, disableKeyboardA11y: props.disableKeyboardA11y, resizeObserver, nodesDraggable, nodesConnectable, nodesFocusable, elementsSelectable, nodeClickDistance: props.nodeClickDistance, onError }, nodeId)
  )) });
}
NodeRendererComponent.displayName = "NodeRenderer";
const NodeRenderer = memo$1(NodeRendererComponent);
function useVisibleEdgeIds(onlyRenderVisible) {
  return useStore$2(useCallback((s2) => {
    if (!onlyRenderVisible)
      return s2.edges.map((edge) => edge.id);
    const visibleEdgeIds = [];
    if (s2.width && s2.height)
      for (const edge of s2.edges) {
        const sourceNode = s2.nodeLookup.get(edge.source), targetNode = s2.nodeLookup.get(edge.target);
        sourceNode && targetNode && isEdgeVisible({
          sourceNode,
          targetNode,
          width: s2.width,
          height: s2.height,
          transform: s2.transform
        }) && visibleEdgeIds.push(edge.id);
      }
    return visibleEdgeIds;
  }, [onlyRenderVisible]), shallow$1);
}
const ArrowSymbol = ({ color: color2 = "none", strokeWidth = 1 }) => jsx("polyline", { style: {
  stroke: color2,
  strokeWidth
}, strokeLinecap: "round", strokeLinejoin: "round", fill: "none", points: "-5,-4 0,0 -5,4" }), ArrowClosedSymbol = ({ color: color2 = "none", strokeWidth = 1 }) => jsx("polyline", { style: {
  stroke: color2,
  fill: color2,
  strokeWidth
}, strokeLinecap: "round", strokeLinejoin: "round", points: "-5,-4 0,0 -5,4 -5,-4" }), MarkerSymbols = {
  [MarkerType.Arrow]: ArrowSymbol,
  [MarkerType.ArrowClosed]: ArrowClosedSymbol
};
function useMarkerSymbol(type) {
  const store = useStoreApi();
  return useMemo(() => {
    var _a4, _b2;
    return Object.prototype.hasOwnProperty.call(MarkerSymbols, type) ? MarkerSymbols[type] : ((_b2 = (_a4 = store.getState()).onError) == null || _b2.call(_a4, "009", errorMessages.error009(type)), null);
  }, [type]);
}
const Marker = ({ id: id2, type, color: color2, width: width2 = 12.5, height = 12.5, markerUnits = "strokeWidth", strokeWidth, orient = "auto-start-reverse" }) => {
  const Symbol2 = useMarkerSymbol(type);
  return Symbol2 ? jsx("marker", { className: "react-flow__arrowhead", id: id2, markerWidth: `${width2}`, markerHeight: `${height}`, viewBox: "-10 -10 20 20", markerUnits, orient, refX: "0", refY: "0", children: jsx(Symbol2, { color: color2, strokeWidth }) }) : null;
}, MarkerDefinitions = ({ defaultColor, rfId }) => {
  const edges = useStore$2((s2) => s2.edges), defaultEdgeOptions = useStore$2((s2) => s2.defaultEdgeOptions), markers = useMemo(() => createMarkerIds(edges, {
    id: rfId,
    defaultColor,
    defaultMarkerStart: defaultEdgeOptions == null ? void 0 : defaultEdgeOptions.markerStart,
    defaultMarkerEnd: defaultEdgeOptions == null ? void 0 : defaultEdgeOptions.markerEnd
  }), [edges, defaultEdgeOptions, rfId, defaultColor]);
  return markers.length ? jsx("svg", { className: "react-flow__marker", children: jsx("defs", { children: markers.map((marker) => jsx(Marker, { id: marker.id, type: marker.type, color: marker.color, width: marker.width, height: marker.height, markerUnits: marker.markerUnits, strokeWidth: marker.strokeWidth, orient: marker.orient }, marker.id)) }) }) : null;
};
MarkerDefinitions.displayName = "MarkerDefinitions";
var MarkerDefinitions$1 = memo$1(MarkerDefinitions);
function EdgeTextComponent({ x: x2, y: y2, label: label2, labelStyle = {}, labelShowBg = !0, labelBgStyle = {}, labelBgPadding = [2, 4], labelBgBorderRadius = 2, children: children2, className, ...rest }) {
  const [edgeTextBbox, setEdgeTextBbox] = useState({ x: 1, y: 0, width: 0, height: 0 }), edgeTextClasses = cc(["react-flow__edge-textwrapper", className]), edgeTextRef = useRef(null);
  return useEffect(() => {
    if (edgeTextRef.current) {
      const textBbox = edgeTextRef.current.getBBox();
      setEdgeTextBbox({
        x: textBbox.x,
        y: textBbox.y,
        width: textBbox.width,
        height: textBbox.height
      });
    }
  }, [label2]), typeof label2 > "u" || !label2 ? null : jsxs("g", { transform: `translate(${x2 - edgeTextBbox.width / 2} ${y2 - edgeTextBbox.height / 2})`, className: edgeTextClasses, visibility: edgeTextBbox.width ? "visible" : "hidden", ...rest, children: [labelShowBg && jsx("rect", { width: edgeTextBbox.width + 2 * labelBgPadding[0], x: -labelBgPadding[0], y: -labelBgPadding[1], height: edgeTextBbox.height + 2 * labelBgPadding[1], className: "react-flow__edge-textbg", style: labelBgStyle, rx: labelBgBorderRadius, ry: labelBgBorderRadius }), jsx("text", { className: "react-flow__edge-text", y: edgeTextBbox.height / 2, dy: "0.3em", ref: edgeTextRef, style: labelStyle, children: label2 }), children2] });
}
EdgeTextComponent.displayName = "EdgeText";
const EdgeText = memo$1(EdgeTextComponent);
function BaseEdge({ id: id2, path, labelX, labelY, label: label2, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, className, interactionWidth = 20 }) {
  return jsxs(Fragment, { children: [jsx("path", { id: id2, style: style2, d: path, fill: "none", className: cc(["react-flow__edge-path", className]), markerEnd, markerStart }), interactionWidth && jsx("path", { d: path, fill: "none", strokeOpacity: 0, strokeWidth: interactionWidth, className: "react-flow__edge-interaction" }), label2 && isNumeric(labelX) && isNumeric(labelY) ? jsx(EdgeText, { x: labelX, y: labelY, label: label2, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius }) : null] });
}
function getControl({ pos, x1, y1, x2, y2 }) {
  return pos === Position.Left || pos === Position.Right ? [0.5 * (x1 + x2), y1] : [x1, 0.5 * (y1 + y2)];
}
function getSimpleBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top }) {
  const [sourceControlX, sourceControlY] = getControl({
    pos: sourcePosition,
    x1: sourceX,
    y1: sourceY,
    x2: targetX,
    y2: targetY
  }), [targetControlX, targetControlY] = getControl({
    pos: targetPosition,
    x1: targetX,
    y1: targetY,
    x2: sourceX,
    y2: sourceY
  }), [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourceControlX,
    sourceControlY,
    targetControlX,
    targetControlY
  });
  return [
    `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,
    labelX,
    labelY,
    offsetX,
    offsetY
  ];
}
function createSimpleBezierEdge(params) {
  return memo$1(({ id: id2, sourceX, sourceY, targetX, targetY, sourcePosition = Position.Bottom, targetPosition = Position.Top, label: label2, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth }) => {
    const [path, labelX, labelY] = getSimpleBezierPath({
      sourceX,
      sourceY,
      sourcePosition,
      targetX,
      targetY,
      targetPosition
    }), _id = params.isInternal ? void 0 : id2;
    return jsx(BaseEdge, { id: _id, path, labelX, labelY, label: label2, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth });
  });
}
const SimpleBezierEdge = createSimpleBezierEdge({ isInternal: !1 }), SimpleBezierEdgeInternal = createSimpleBezierEdge({ isInternal: !0 });
SimpleBezierEdge.displayName = "SimpleBezierEdge";
SimpleBezierEdgeInternal.displayName = "SimpleBezierEdgeInternal";
function createSmoothStepEdge(params) {
  return memo$1(({ id: id2, sourceX, sourceY, targetX, targetY, label: label2, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, sourcePosition = Position.Bottom, targetPosition = Position.Top, markerEnd, markerStart, pathOptions, interactionWidth }) => {
    const [path, labelX, labelY] = getSmoothStepPath({
      sourceX,
      sourceY,
      sourcePosition,
      targetX,
      targetY,
      targetPosition,
      borderRadius: pathOptions == null ? void 0 : pathOptions.borderRadius,
      offset: pathOptions == null ? void 0 : pathOptions.offset
    }), _id = params.isInternal ? void 0 : id2;
    return jsx(BaseEdge, { id: _id, path, labelX, labelY, label: label2, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth });
  });
}
const SmoothStepEdge = createSmoothStepEdge({ isInternal: !1 }), SmoothStepEdgeInternal = createSmoothStepEdge({ isInternal: !0 });
SmoothStepEdge.displayName = "SmoothStepEdge";
SmoothStepEdgeInternal.displayName = "SmoothStepEdgeInternal";
function createStepEdge(params) {
  return memo$1(({ id: id2, ...props }) => {
    var _a4;
    const _id = params.isInternal ? void 0 : id2;
    return jsx(SmoothStepEdge, { ...props, id: _id, pathOptions: useMemo(() => {
      var _a5;
      return { borderRadius: 0, offset: (_a5 = props.pathOptions) == null ? void 0 : _a5.offset };
    }, [(_a4 = props.pathOptions) == null ? void 0 : _a4.offset]) });
  });
}
const StepEdge = createStepEdge({ isInternal: !1 }), StepEdgeInternal = createStepEdge({ isInternal: !0 });
StepEdge.displayName = "StepEdge";
StepEdgeInternal.displayName = "StepEdgeInternal";
function createStraightEdge(params) {
  return memo$1(({ id: id2, sourceX, sourceY, targetX, targetY, label: label2, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth }) => {
    const [path, labelX, labelY] = getStraightPath({ sourceX, sourceY, targetX, targetY }), _id = params.isInternal ? void 0 : id2;
    return jsx(BaseEdge, { id: _id, path, labelX, labelY, label: label2, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth });
  });
}
const StraightEdge = createStraightEdge({ isInternal: !1 }), StraightEdgeInternal = createStraightEdge({ isInternal: !0 });
StraightEdge.displayName = "StraightEdge";
StraightEdgeInternal.displayName = "StraightEdgeInternal";
function createBezierEdge(params) {
  return memo$1(({ id: id2, sourceX, sourceY, targetX, targetY, sourcePosition = Position.Bottom, targetPosition = Position.Top, label: label2, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, pathOptions, interactionWidth }) => {
    const [path, labelX, labelY] = getBezierPath({
      sourceX,
      sourceY,
      sourcePosition,
      targetX,
      targetY,
      targetPosition,
      curvature: pathOptions == null ? void 0 : pathOptions.curvature
    }), _id = params.isInternal ? void 0 : id2;
    return jsx(BaseEdge, { id: _id, path, labelX, labelY, label: label2, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth });
  });
}
const BezierEdge = createBezierEdge({ isInternal: !1 }), BezierEdgeInternal = createBezierEdge({ isInternal: !0 });
BezierEdge.displayName = "BezierEdge";
BezierEdgeInternal.displayName = "BezierEdgeInternal";
const builtinEdgeTypes = {
  default: BezierEdgeInternal,
  straight: StraightEdgeInternal,
  step: StepEdgeInternal,
  smoothstep: SmoothStepEdgeInternal,
  simplebezier: SimpleBezierEdgeInternal
}, nullPosition = {
  sourceX: null,
  sourceY: null,
  targetX: null,
  targetY: null,
  sourcePosition: null,
  targetPosition: null
}, shiftX = (x2, shift2, position2) => position2 === Position.Left ? x2 - shift2 : position2 === Position.Right ? x2 + shift2 : x2, shiftY = (y2, shift2, position2) => position2 === Position.Top ? y2 - shift2 : position2 === Position.Bottom ? y2 + shift2 : y2, EdgeUpdaterClassName = "react-flow__edgeupdater";
function EdgeAnchor({ position: position2, centerX, centerY, radius = 10, onMouseDown, onMouseEnter, onMouseOut, type }) {
  return jsx("circle", { onMouseDown, onMouseEnter, onMouseOut, className: cc([EdgeUpdaterClassName, `${EdgeUpdaterClassName}-${type}`]), cx: shiftX(centerX, radius, position2), cy: shiftY(centerY, radius, position2), r: radius, stroke: "transparent", fill: "transparent" });
}
function EdgeUpdateAnchors({ isReconnectable, reconnectRadius, edge, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, onReconnect, onReconnectStart, onReconnectEnd, setReconnecting, setUpdateHover }) {
  const store = useStoreApi(), handleEdgeUpdater = (event, oppositeHandle) => {
    if (event.button !== 0)
      return;
    const { autoPanOnConnect, domNode, isValidConnection, connectionMode, connectionRadius, lib: lib2, onConnectStart, onConnectEnd, cancelConnection, nodeLookup, rfId: flowId, panBy: panBy2, updateConnection } = store.getState(), isTarget = oppositeHandle.type === "target";
    setReconnecting(!0), onReconnectStart == null || onReconnectStart(event, edge, oppositeHandle.type);
    const _onReconnectEnd = (evt, connectionState) => {
      setReconnecting(!1), onReconnectEnd == null || onReconnectEnd(evt, edge, oppositeHandle.type, connectionState);
    }, onConnectEdge = (connection) => onReconnect == null ? void 0 : onReconnect(edge, connection);
    XYHandle.onPointerDown(event.nativeEvent, {
      autoPanOnConnect,
      connectionMode,
      connectionRadius,
      domNode,
      handleId: oppositeHandle.id,
      nodeId: oppositeHandle.nodeId,
      nodeLookup,
      isTarget,
      edgeUpdaterType: oppositeHandle.type,
      lib: lib2,
      flowId,
      cancelConnection,
      panBy: panBy2,
      isValidConnection,
      onConnect: onConnectEdge,
      onConnectStart,
      onConnectEnd,
      onReconnectEnd: _onReconnectEnd,
      updateConnection,
      getTransform: () => store.getState().transform,
      getFromHandle: () => store.getState().connection.fromHandle
    });
  }, onReconnectSourceMouseDown = (event) => handleEdgeUpdater(event, { nodeId: edge.target, id: edge.targetHandle ?? null, type: "target" }), onReconnectTargetMouseDown = (event) => handleEdgeUpdater(event, { nodeId: edge.source, id: edge.sourceHandle ?? null, type: "source" }), onReconnectMouseEnter = () => setUpdateHover(!0), onReconnectMouseOut = () => setUpdateHover(!1);
  return jsxs(Fragment, { children: [(isReconnectable === !0 || isReconnectable === "source") && jsx(EdgeAnchor, { position: sourcePosition, centerX: sourceX, centerY: sourceY, radius: reconnectRadius, onMouseDown: onReconnectSourceMouseDown, onMouseEnter: onReconnectMouseEnter, onMouseOut: onReconnectMouseOut, type: "source" }), (isReconnectable === !0 || isReconnectable === "target") && jsx(EdgeAnchor, { position: targetPosition, centerX: targetX, centerY: targetY, radius: reconnectRadius, onMouseDown: onReconnectTargetMouseDown, onMouseEnter: onReconnectMouseEnter, onMouseOut: onReconnectMouseOut, type: "target" })] });
}
function EdgeWrapper({ id: id2, edgesFocusable, edgesReconnectable, elementsSelectable, onClick, onDoubleClick, onContextMenu, onMouseEnter, onMouseMove, onMouseLeave, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, rfId, edgeTypes: edgeTypes2, noPanClassName, onError, disableKeyboardA11y }) {
  let edge = useStore$2((s2) => s2.edgeLookup.get(id2));
  const defaultEdgeOptions = useStore$2((s2) => s2.defaultEdgeOptions);
  edge = defaultEdgeOptions ? { ...defaultEdgeOptions, ...edge } : edge;
  let edgeType = edge.type || "default", EdgeComponent = (edgeTypes2 == null ? void 0 : edgeTypes2[edgeType]) || builtinEdgeTypes[edgeType];
  EdgeComponent === void 0 && (onError == null || onError("011", errorMessages.error011(edgeType)), edgeType = "default", EdgeComponent = builtinEdgeTypes.default);
  const isFocusable = !!(edge.focusable || edgesFocusable && typeof edge.focusable > "u"), isReconnectable = typeof onReconnect < "u" && (edge.reconnectable || edgesReconnectable && typeof edge.reconnectable > "u"), isSelectable = !!(edge.selectable || elementsSelectable && typeof edge.selectable > "u"), edgeRef = useRef(null), [updateHover, setUpdateHover] = useState(!1), [reconnecting, setReconnecting] = useState(!1), store = useStoreApi(), { zIndex, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition } = useStore$2(useCallback((store2) => {
    const sourceNode = store2.nodeLookup.get(edge.source), targetNode = store2.nodeLookup.get(edge.target);
    if (!sourceNode || !targetNode)
      return {
        zIndex: edge.zIndex,
        ...nullPosition
      };
    const edgePosition = getEdgePosition({
      id: id2,
      sourceNode,
      targetNode,
      sourceHandle: edge.sourceHandle || null,
      targetHandle: edge.targetHandle || null,
      connectionMode: store2.connectionMode,
      onError
    });
    return {
      zIndex: getElevatedEdgeZIndex({
        selected: edge.selected,
        zIndex: edge.zIndex,
        sourceNode,
        targetNode,
        elevateOnSelect: store2.elevateEdgesOnSelect
      }),
      ...edgePosition || nullPosition
    };
  }, [edge.source, edge.target, edge.sourceHandle, edge.targetHandle, edge.selected, edge.zIndex]), shallow$1), markerStartUrl = useMemo(() => edge.markerStart ? `url('#${getMarkerId(edge.markerStart, rfId)}')` : void 0, [edge.markerStart, rfId]), markerEndUrl = useMemo(() => edge.markerEnd ? `url('#${getMarkerId(edge.markerEnd, rfId)}')` : void 0, [edge.markerEnd, rfId]);
  if (edge.hidden || sourceX === null || sourceY === null || targetX === null || targetY === null)
    return null;
  const onEdgeClick = (event) => {
    var _a4;
    const { addSelectedEdges, unselectNodesAndEdges, multiSelectionActive } = store.getState();
    isSelectable && (store.setState({ nodesSelectionActive: !1 }), edge.selected && multiSelectionActive ? (unselectNodesAndEdges({ nodes: [], edges: [edge] }), (_a4 = edgeRef.current) == null || _a4.blur()) : addSelectedEdges([id2])), onClick && onClick(event, edge);
  }, onEdgeDoubleClick = onDoubleClick ? (event) => {
    onDoubleClick(event, { ...edge });
  } : void 0, onEdgeContextMenu = onContextMenu ? (event) => {
    onContextMenu(event, { ...edge });
  } : void 0, onEdgeMouseEnter = onMouseEnter ? (event) => {
    onMouseEnter(event, { ...edge });
  } : void 0, onEdgeMouseMove = onMouseMove ? (event) => {
    onMouseMove(event, { ...edge });
  } : void 0, onEdgeMouseLeave = onMouseLeave ? (event) => {
    onMouseLeave(event, { ...edge });
  } : void 0, onKeyDown = (event) => {
    var _a4;
    if (!disableKeyboardA11y && elementSelectionKeys.includes(event.key) && isSelectable) {
      const { unselectNodesAndEdges, addSelectedEdges } = store.getState();
      event.key === "Escape" ? ((_a4 = edgeRef.current) == null || _a4.blur(), unselectNodesAndEdges({ edges: [edge] })) : addSelectedEdges([id2]);
    }
  };
  return jsx("svg", { style: { zIndex }, children: jsxs("g", { className: cc([
    "react-flow__edge",
    `react-flow__edge-${edgeType}`,
    edge.className,
    noPanClassName,
    {
      selected: edge.selected,
      animated: edge.animated,
      inactive: !isSelectable && !onClick,
      updating: updateHover,
      selectable: isSelectable
    }
  ]), onClick: onEdgeClick, onDoubleClick: onEdgeDoubleClick, onContextMenu: onEdgeContextMenu, onMouseEnter: onEdgeMouseEnter, onMouseMove: onEdgeMouseMove, onMouseLeave: onEdgeMouseLeave, onKeyDown: isFocusable ? onKeyDown : void 0, tabIndex: isFocusable ? 0 : void 0, role: isFocusable ? "button" : "img", "data-id": id2, "data-testid": `rf__edge-${id2}`, "aria-label": edge.ariaLabel === null ? void 0 : edge.ariaLabel || `Edge from ${edge.source} to ${edge.target}`, "aria-describedby": isFocusable ? `${ARIA_EDGE_DESC_KEY}-${rfId}` : void 0, ref: edgeRef, children: [!reconnecting && jsx(EdgeComponent, { id: id2, source: edge.source, target: edge.target, type: edge.type, selected: edge.selected, animated: edge.animated, selectable: isSelectable, deletable: edge.deletable ?? !0, label: edge.label, labelStyle: edge.labelStyle, labelShowBg: edge.labelShowBg, labelBgStyle: edge.labelBgStyle, labelBgPadding: edge.labelBgPadding, labelBgBorderRadius: edge.labelBgBorderRadius, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, data: edge.data, style: edge.style, sourceHandleId: edge.sourceHandle, targetHandleId: edge.targetHandle, markerStart: markerStartUrl, markerEnd: markerEndUrl, pathOptions: "pathOptions" in edge ? edge.pathOptions : void 0, interactionWidth: edge.interactionWidth }), isReconnectable && jsx(EdgeUpdateAnchors, { edge, isReconnectable, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, setUpdateHover, setReconnecting })] }) });
}
const selector$a = (s2) => ({
  width: s2.width,
  height: s2.height,
  edgesFocusable: s2.edgesFocusable,
  edgesReconnectable: s2.edgesReconnectable,
  elementsSelectable: s2.elementsSelectable,
  connectionMode: s2.connectionMode,
  onError: s2.onError
});
function EdgeRendererComponent({ defaultMarkerColor, onlyRenderVisibleElements, rfId, edgeTypes: edgeTypes2, noPanClassName, onReconnect, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onEdgeClick, reconnectRadius, onEdgeDoubleClick, onReconnectStart, onReconnectEnd, disableKeyboardA11y }) {
  const { edgesFocusable, edgesReconnectable, elementsSelectable, onError } = useStore$2(selector$a, shallow$1), edgeIds = useVisibleEdgeIds(onlyRenderVisibleElements);
  return jsxs("div", { className: "react-flow__edges", children: [jsx(MarkerDefinitions$1, { defaultColor: defaultMarkerColor, rfId }), edgeIds.map((id2) => jsx(EdgeWrapper, { id: id2, edgesFocusable, edgesReconnectable, elementsSelectable, noPanClassName, onReconnect, onContextMenu: onEdgeContextMenu, onMouseEnter: onEdgeMouseEnter, onMouseMove: onEdgeMouseMove, onMouseLeave: onEdgeMouseLeave, onClick: onEdgeClick, reconnectRadius, onDoubleClick: onEdgeDoubleClick, onReconnectStart, onReconnectEnd, rfId, onError, edgeTypes: edgeTypes2, disableKeyboardA11y }, id2))] });
}
EdgeRendererComponent.displayName = "EdgeRenderer";
const EdgeRenderer = memo$1(EdgeRendererComponent), selector$9 = (s2) => `translate(${s2.transform[0]}px,${s2.transform[1]}px) scale(${s2.transform[2]})`;
function Viewport({ children: children2 }) {
  const transform2 = useStore$2(selector$9);
  return jsx("div", { className: "react-flow__viewport xyflow__viewport react-flow__container", style: { transform: transform2 }, children: children2 });
}
function useOnInitHandler(onInit) {
  const rfInstance = useReactFlow(), isInitialized = useRef(!1);
  useEffect(() => {
    !isInitialized.current && rfInstance.viewportInitialized && onInit && (setTimeout(() => onInit(rfInstance), 1), isInitialized.current = !0);
  }, [onInit, rfInstance.viewportInitialized]);
}
const selector$8 = (state) => {
  var _a4;
  return (_a4 = state.panZoom) == null ? void 0 : _a4.syncViewport;
};
function useViewportSync(viewport) {
  const syncViewport = useStore$2(selector$8), store = useStoreApi();
  return useEffect(() => {
    viewport && (syncViewport == null || syncViewport(viewport), store.setState({ transform: [viewport.x, viewport.y, viewport.zoom] }));
  }, [viewport, syncViewport]), null;
}
function storeSelector$1(s2) {
  return s2.connection.inProgress ? { ...s2.connection, to: pointToRendererPoint(s2.connection.to, s2.transform) } : { ...s2.connection };
}
function getSelector(connectionSelector) {
  return storeSelector$1;
}
function useConnection(connectionSelector) {
  const combinedSelector = getSelector();
  return useStore$2(combinedSelector, shallow$1);
}
const selector$7 = (s2) => ({
  nodesConnectable: s2.nodesConnectable,
  isValid: s2.connection.isValid,
  inProgress: s2.connection.inProgress,
  width: s2.width,
  height: s2.height
});
function ConnectionLineWrapper({ containerStyle: containerStyle2, style: style2, type, component }) {
  const { nodesConnectable, width: width2, height, isValid, inProgress } = useStore$2(selector$7, shallow$1);
  return !(width2 && nodesConnectable && inProgress) ? null : jsx("svg", { style: containerStyle2, width: width2, height, className: "react-flow__connectionline react-flow__container", children: jsx("g", { className: cc(["react-flow__connection", getConnectionStatus(isValid)]), children: jsx(ConnectionLine, { style: style2, type, CustomComponent: component, isValid }) }) });
}
const ConnectionLine = ({ style: style2, type = ConnectionLineType.Bezier, CustomComponent, isValid }) => {
  const { inProgress, from, fromNode, fromHandle, fromPosition, to, toNode, toHandle, toPosition } = useConnection();
  if (!inProgress)
    return;
  if (CustomComponent)
    return jsx(CustomComponent, { connectionLineType: type, connectionLineStyle: style2, fromNode, fromHandle, fromX: from.x, fromY: from.y, toX: to.x, toY: to.y, fromPosition, toPosition, connectionStatus: getConnectionStatus(isValid), toNode, toHandle });
  let path = "";
  const pathParams = {
    sourceX: from.x,
    sourceY: from.y,
    sourcePosition: fromPosition,
    targetX: to.x,
    targetY: to.y,
    targetPosition: toPosition
  };
  switch (type) {
    case ConnectionLineType.Bezier:
      [path] = getBezierPath(pathParams);
      break;
    case ConnectionLineType.SimpleBezier:
      [path] = getSimpleBezierPath(pathParams);
      break;
    case ConnectionLineType.Step:
      [path] = getSmoothStepPath({
        ...pathParams,
        borderRadius: 0
      });
      break;
    case ConnectionLineType.SmoothStep:
      [path] = getSmoothStepPath(pathParams);
      break;
    default:
      [path] = getStraightPath(pathParams);
  }
  return jsx("path", { d: path, fill: "none", className: "react-flow__connection-path", style: style2 });
};
ConnectionLine.displayName = "ConnectionLine";
const emptyTypes = {};
function useNodeOrEdgeTypesWarning(nodeOrEdgeTypes = emptyTypes) {
  useRef(nodeOrEdgeTypes), useStoreApi(), useEffect(() => {
  }, [nodeOrEdgeTypes]);
}
function useStylesLoadedWarning() {
  useStoreApi(), useRef(!1), useEffect(() => {
  }, []);
}
function GraphViewComponent({ nodeTypes: nodeTypes2, edgeTypes: edgeTypes2, onInit, onNodeClick, onEdgeClick, onNodeDoubleClick, onEdgeDoubleClick, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onSelectionContextMenu, onSelectionStart, onSelectionEnd, connectionLineType, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, selectionKeyCode, selectionOnDrag, selectionMode, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, deleteKeyCode, onlyRenderVisibleElements, elementsSelectable, defaultViewport: defaultViewport2, translateExtent, minZoom, maxZoom, preventScrolling, defaultMarkerColor, zoomOnScroll, zoomOnPinch, panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance, nodeClickDistance, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, noDragClassName, noWheelClassName, noPanClassName, disableKeyboardA11y, nodeExtent, rfId, viewport, onViewportChange }) {
  return useNodeOrEdgeTypesWarning(nodeTypes2), useNodeOrEdgeTypesWarning(edgeTypes2), useStylesLoadedWarning(), useOnInitHandler(onInit), useViewportSync(viewport), jsx(FlowRenderer, { onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, paneClickDistance, deleteKeyCode, selectionKeyCode, selectionOnDrag, selectionMode, onSelectionStart, onSelectionEnd, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, elementsSelectable, zoomOnScroll, zoomOnPinch, zoomOnDoubleClick, panOnScroll, panOnScrollSpeed, panOnScrollMode, panOnDrag, defaultViewport: defaultViewport2, translateExtent, minZoom, maxZoom, onSelectionContextMenu, preventScrolling, noDragClassName, noWheelClassName, noPanClassName, disableKeyboardA11y, onViewportChange, isControlledViewport: !!viewport, children: jsxs(Viewport, { children: [jsx(EdgeRenderer, { edgeTypes: edgeTypes2, onEdgeClick, onEdgeDoubleClick, onReconnect, onReconnectStart, onReconnectEnd, onlyRenderVisibleElements, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius, defaultMarkerColor, noPanClassName, disableKeyboardA11y, rfId }), jsx(ConnectionLineWrapper, { style: connectionLineStyle, type: connectionLineType, component: connectionLineComponent, containerStyle: connectionLineContainerStyle }), jsx("div", { className: "react-flow__edgelabel-renderer" }), jsx(NodeRenderer, { nodeTypes: nodeTypes2, onNodeClick, onNodeDoubleClick, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, nodeClickDistance, onlyRenderVisibleElements, noPanClassName, noDragClassName, disableKeyboardA11y, nodeExtent, rfId }), jsx("div", { className: "react-flow__viewport-portal" })] }) });
}
GraphViewComponent.displayName = "GraphView";
const GraphView = memo$1(GraphViewComponent), getInitialState = ({ nodes, edges, defaultNodes, defaultEdges, width: width2, height, fitView: fitView2, nodeOrigin, nodeExtent } = {}) => {
  const nodeLookup = /* @__PURE__ */ new Map(), parentLookup = /* @__PURE__ */ new Map(), connectionLookup = /* @__PURE__ */ new Map(), edgeLookup = /* @__PURE__ */ new Map(), storeEdges = defaultEdges ?? edges ?? [], storeNodes = defaultNodes ?? nodes ?? [], storeNodeOrigin = nodeOrigin ?? [0, 0], storeNodeExtent = nodeExtent ?? infiniteExtent;
  updateConnectionLookup(connectionLookup, edgeLookup, storeEdges), adoptUserNodes(storeNodes, nodeLookup, parentLookup, {
    nodeOrigin: storeNodeOrigin,
    nodeExtent: storeNodeExtent,
    elevateNodesOnSelect: !1
  });
  let transform2 = [0, 0, 1];
  if (fitView2 && width2 && height) {
    const bounds = getInternalNodesBounds(nodeLookup, {
      filter: (node2) => !!((node2.width || node2.initialWidth) && (node2.height || node2.initialHeight))
    }), { x: x2, y: y2, zoom: zoom2 } = getViewportForBounds(bounds, width2, height, 0.5, 2, 0.1);
    transform2 = [x2, y2, zoom2];
  }
  return {
    rfId: "1",
    width: 0,
    height: 0,
    transform: transform2,
    nodes: storeNodes,
    nodeLookup,
    parentLookup,
    edges: storeEdges,
    edgeLookup,
    connectionLookup,
    onNodesChange: null,
    onEdgesChange: null,
    hasDefaultNodes: defaultNodes !== void 0,
    hasDefaultEdges: defaultEdges !== void 0,
    panZoom: null,
    minZoom: 0.5,
    maxZoom: 2,
    translateExtent: infiniteExtent,
    nodeExtent: storeNodeExtent,
    nodesSelectionActive: !1,
    userSelectionActive: !1,
    userSelectionRect: null,
    connectionMode: ConnectionMode.Strict,
    domNode: null,
    paneDragging: !1,
    noPanClassName: "nopan",
    nodeOrigin: storeNodeOrigin,
    nodeDragThreshold: 1,
    snapGrid: [15, 15],
    snapToGrid: !1,
    nodesDraggable: !0,
    nodesConnectable: !0,
    nodesFocusable: !0,
    edgesFocusable: !0,
    edgesReconnectable: !0,
    elementsSelectable: !0,
    elevateNodesOnSelect: !0,
    elevateEdgesOnSelect: !1,
    fitViewOnInit: !1,
    fitViewDone: !1,
    fitViewOnInitOptions: void 0,
    selectNodesOnDrag: !0,
    multiSelectionActive: !1,
    connection: { ...initialConnection },
    connectionClickStartHandle: null,
    connectOnClick: !0,
    ariaLiveMessage: "",
    autoPanOnConnect: !0,
    autoPanOnNodeDrag: !0,
    autoPanSpeed: 15,
    connectionRadius: 20,
    onError: devWarn,
    isValidConnection: void 0,
    onSelectionChangeHandlers: [],
    lib: "react",
    debug: !1
  };
}, createStore$1 = ({ nodes, edges, defaultNodes, defaultEdges, width: width2, height, fitView: fitView$1, nodeOrigin, nodeExtent }) => createWithEqualityFn((set2, get2) => ({
  ...getInitialState({ nodes, edges, width: width2, height, fitView: fitView$1, nodeOrigin, nodeExtent, defaultNodes, defaultEdges }),
  setNodes: (nodes2) => {
    const { nodeLookup, parentLookup, nodeOrigin: nodeOrigin2, elevateNodesOnSelect } = get2();
    adoptUserNodes(nodes2, nodeLookup, parentLookup, {
      nodeOrigin: nodeOrigin2,
      nodeExtent,
      elevateNodesOnSelect,
      checkEquality: !0
    }), set2({ nodes: nodes2 });
  },
  setEdges: (edges2) => {
    const { connectionLookup, edgeLookup } = get2();
    updateConnectionLookup(connectionLookup, edgeLookup, edges2), set2({ edges: edges2 });
  },
  setDefaultNodesAndEdges: (nodes2, edges2) => {
    if (nodes2) {
      const { setNodes } = get2();
      setNodes(nodes2), set2({ hasDefaultNodes: !0 });
    }
    if (edges2) {
      const { setEdges } = get2();
      setEdges(edges2), set2({ hasDefaultEdges: !0 });
    }
  },
  // Every node gets registerd at a ResizeObserver. Whenever a node
  // changes its dimensions, this function is called to measure the
  // new dimensions and update the nodes.
  updateNodeInternals: (updates, params = { triggerFitView: !0 }) => {
    const { triggerNodeChanges, nodeLookup, parentLookup, fitViewOnInit, fitViewDone, fitViewOnInitOptions, domNode, nodeOrigin: nodeOrigin2, nodeExtent: nodeExtent2, debug: debug2, fitViewSync } = get2(), { changes, updatedInternals } = updateNodeInternals(updates, nodeLookup, parentLookup, domNode, nodeOrigin2, nodeExtent2);
    if (updatedInternals) {
      if (updateAbsolutePositions(nodeLookup, parentLookup, { nodeOrigin: nodeOrigin2, nodeExtent: nodeExtent2 }), params.triggerFitView) {
        let nextFitViewDone = fitViewDone;
        !fitViewDone && fitViewOnInit && (nextFitViewDone = fitViewSync({
          ...fitViewOnInitOptions,
          nodes: fitViewOnInitOptions == null ? void 0 : fitViewOnInitOptions.nodes
        })), set2({ fitViewDone: nextFitViewDone });
      } else
        set2({});
      (changes == null ? void 0 : changes.length) > 0 && (debug2 && console.log("React Flow: trigger node changes", changes), triggerNodeChanges == null || triggerNodeChanges(changes));
    }
  },
  updateNodePositions: (nodeDragItems, dragging = !1) => {
    const parentExpandChildren = [], changes = [];
    for (const [id2, dragItem] of nodeDragItems) {
      const change = {
        id: id2,
        type: "position",
        position: dragItem.position,
        dragging
      };
      dragItem != null && dragItem.expandParent && (dragItem != null && dragItem.parentId) && change.position && (parentExpandChildren.push({
        id: id2,
        parentId: dragItem.parentId,
        rect: {
          ...dragItem.internals.positionAbsolute,
          width: dragItem.measured.width,
          height: dragItem.measured.height
        }
      }), change.position.x = Math.max(0, change.position.x), change.position.y = Math.max(0, change.position.y)), changes.push(change);
    }
    if (parentExpandChildren.length > 0) {
      const { nodeLookup, parentLookup, nodeOrigin: nodeOrigin2 } = get2(), parentExpandChanges = handleExpandParent(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin2);
      changes.push(...parentExpandChanges);
    }
    get2().triggerNodeChanges(changes);
  },
  triggerNodeChanges: (changes) => {
    const { onNodesChange, setNodes, nodes: nodes2, hasDefaultNodes, debug: debug2 } = get2();
    if (changes != null && changes.length) {
      if (hasDefaultNodes) {
        const updatedNodes = applyNodeChanges(changes, nodes2);
        setNodes(updatedNodes);
      }
      debug2 && console.log("React Flow: trigger node changes", changes), onNodesChange == null || onNodesChange(changes);
    }
  },
  triggerEdgeChanges: (changes) => {
    const { onEdgesChange, setEdges, edges: edges2, hasDefaultEdges, debug: debug2 } = get2();
    if (changes != null && changes.length) {
      if (hasDefaultEdges) {
        const updatedEdges = applyEdgeChanges(changes, edges2);
        setEdges(updatedEdges);
      }
      debug2 && console.log("React Flow: trigger edge changes", changes), onEdgesChange == null || onEdgesChange(changes);
    }
  },
  addSelectedNodes: (selectedNodeIds) => {
    const { multiSelectionActive, edgeLookup, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get2();
    if (multiSelectionActive) {
      const nodeChanges = selectedNodeIds.map((nodeId) => createSelectionChange(nodeId, !0));
      triggerNodeChanges(nodeChanges);
      return;
    }
    triggerNodeChanges(getSelectionChanges(nodeLookup, /* @__PURE__ */ new Set([...selectedNodeIds]), !0)), triggerEdgeChanges(getSelectionChanges(edgeLookup));
  },
  addSelectedEdges: (selectedEdgeIds) => {
    const { multiSelectionActive, edgeLookup, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get2();
    if (multiSelectionActive) {
      const changedEdges = selectedEdgeIds.map((edgeId) => createSelectionChange(edgeId, !0));
      triggerEdgeChanges(changedEdges);
      return;
    }
    triggerEdgeChanges(getSelectionChanges(edgeLookup, /* @__PURE__ */ new Set([...selectedEdgeIds]))), triggerNodeChanges(getSelectionChanges(nodeLookup, /* @__PURE__ */ new Set(), !0));
  },
  unselectNodesAndEdges: ({ nodes: nodes2, edges: edges2 } = {}) => {
    const { edges: storeEdges, nodes: storeNodes, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get2(), nodesToUnselect = nodes2 || storeNodes, edgesToUnselect = edges2 || storeEdges, nodeChanges = nodesToUnselect.map((n2) => {
      const internalNode = nodeLookup.get(n2.id);
      return internalNode && (internalNode.selected = !1), createSelectionChange(n2.id, !1);
    }), edgeChanges = edgesToUnselect.map((edge) => createSelectionChange(edge.id, !1));
    triggerNodeChanges(nodeChanges), triggerEdgeChanges(edgeChanges);
  },
  setMinZoom: (minZoom) => {
    const { panZoom, maxZoom } = get2();
    panZoom == null || panZoom.setScaleExtent([minZoom, maxZoom]), set2({ minZoom });
  },
  setMaxZoom: (maxZoom) => {
    const { panZoom, minZoom } = get2();
    panZoom == null || panZoom.setScaleExtent([minZoom, maxZoom]), set2({ maxZoom });
  },
  setTranslateExtent: (translateExtent) => {
    var _a4;
    (_a4 = get2().panZoom) == null || _a4.setTranslateExtent(translateExtent), set2({ translateExtent });
  },
  setPaneClickDistance: (clickDistance) => {
    var _a4;
    (_a4 = get2().panZoom) == null || _a4.setClickDistance(clickDistance);
  },
  resetSelectedElements: () => {
    const { edges: edges2, nodes: nodes2, triggerNodeChanges, triggerEdgeChanges } = get2(), nodeChanges = nodes2.reduce((res, node2) => node2.selected ? [...res, createSelectionChange(node2.id, !1)] : res, []), edgeChanges = edges2.reduce((res, edge) => edge.selected ? [...res, createSelectionChange(edge.id, !1)] : res, []);
    triggerNodeChanges(nodeChanges), triggerEdgeChanges(edgeChanges);
  },
  setNodeExtent: (nextNodeExtent) => {
    const { nodes: nodes2, nodeLookup, parentLookup, nodeOrigin: nodeOrigin2, elevateNodesOnSelect, nodeExtent: nodeExtent2 } = get2();
    nextNodeExtent[0][0] === nodeExtent2[0][0] && nextNodeExtent[0][1] === nodeExtent2[0][1] && nextNodeExtent[1][0] === nodeExtent2[1][0] && nextNodeExtent[1][1] === nodeExtent2[1][1] || (adoptUserNodes(nodes2, nodeLookup, parentLookup, {
      nodeOrigin: nodeOrigin2,
      nodeExtent: nextNodeExtent,
      elevateNodesOnSelect,
      checkEquality: !1
    }), set2({ nodeExtent: nextNodeExtent }));
  },
  panBy: (delta) => {
    const { transform: transform2, width: width22, height: height2, panZoom, translateExtent } = get2();
    return panBy({ delta, panZoom, transform: transform2, translateExtent, width: width22, height: height2 });
  },
  fitView: (options) => {
    const { panZoom, width: width22, height: height2, minZoom, maxZoom, nodeLookup } = get2();
    if (!panZoom)
      return Promise.resolve(!1);
    const fitViewNodes = getFitViewNodes(nodeLookup, options);
    return fitView({
      nodes: fitViewNodes,
      width: width22,
      height: height2,
      panZoom,
      minZoom,
      maxZoom
    }, options);
  },
  // we can't call an asnychronous function in updateNodeInternals
  // for that we created this sync version of fitView
  fitViewSync: (options) => {
    const { panZoom, width: width22, height: height2, minZoom, maxZoom, nodeLookup } = get2();
    if (!panZoom)
      return !1;
    const fitViewNodes = getFitViewNodes(nodeLookup, options);
    return fitView({
      nodes: fitViewNodes,
      width: width22,
      height: height2,
      panZoom,
      minZoom,
      maxZoom
    }, options), fitViewNodes.size > 0;
  },
  cancelConnection: () => {
    set2({
      connection: { ...initialConnection }
    });
  },
  updateConnection: (connection) => {
    set2({ connection });
  },
  reset: () => set2({ ...getInitialState() })
}), Object.is);
function ReactFlowProvider({ initialNodes: nodes, initialEdges: edges, defaultNodes, defaultEdges, initialWidth: width2, initialHeight: height, fitView: fitView2, nodeOrigin, nodeExtent, children: children2 }) {
  const [store] = useState(() => createStore$1({
    nodes,
    edges,
    defaultNodes,
    defaultEdges,
    width: width2,
    height,
    fitView: fitView2,
    nodeOrigin,
    nodeExtent
  }));
  return jsx(Provider$1, { value: store, children: jsx(BatchProvider, { children: children2 }) });
}
function Wrapper({ children: children2, nodes, edges, defaultNodes, defaultEdges, width: width2, height, fitView: fitView2, nodeOrigin, nodeExtent }) {
  return useContext(StoreContext) ? jsx(Fragment, { children: children2 }) : jsx(ReactFlowProvider, { initialNodes: nodes, initialEdges: edges, defaultNodes, defaultEdges, initialWidth: width2, initialHeight: height, fitView: fitView2, nodeOrigin, nodeExtent, children: children2 });
}
const wrapperStyle = {
  width: "100%",
  height: "100%",
  overflow: "hidden",
  position: "relative",
  zIndex: 0
};
function ReactFlow({ nodes, edges, defaultNodes, defaultEdges, className, nodeTypes: nodeTypes2, edgeTypes: edgeTypes2, onNodeClick, onEdgeClick, onInit, onMove, onMoveStart, onMoveEnd, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onNodeDoubleClick, onNodeDragStart, onNodeDrag, onNodeDragStop, onNodesDelete, onEdgesDelete, onDelete, onSelectionChange, onSelectionDragStart, onSelectionDrag, onSelectionDragStop, onSelectionContextMenu, onSelectionStart, onSelectionEnd, onBeforeDelete, connectionMode, connectionLineType = ConnectionLineType.Bezier, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, deleteKeyCode = "Backspace", selectionKeyCode = "Shift", selectionOnDrag = !1, selectionMode = SelectionMode.Full, panActivationKeyCode = "Space", multiSelectionKeyCode = isMacOs() ? "Meta" : "Control", zoomActivationKeyCode = isMacOs() ? "Meta" : "Control", snapToGrid, snapGrid, onlyRenderVisibleElements = !1, selectNodesOnDrag, nodesDraggable, nodesConnectable, nodesFocusable, nodeOrigin = defaultNodeOrigin, edgesFocusable, edgesReconnectable, elementsSelectable = !0, defaultViewport: defaultViewport$1 = defaultViewport, minZoom = 0.5, maxZoom = 2, translateExtent = infiniteExtent, preventScrolling = !0, nodeExtent, defaultMarkerColor = "#b1b1b7", zoomOnScroll = !0, zoomOnPinch = !0, panOnScroll = !1, panOnScrollSpeed = 0.5, panOnScrollMode = PanOnScrollMode.Free, zoomOnDoubleClick = !0, panOnDrag = !0, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance = 0, nodeClickDistance = 0, children: children2, onReconnect, onReconnectStart, onReconnectEnd, onEdgeContextMenu, onEdgeDoubleClick, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius = 10, onNodesChange, onEdgesChange, noDragClassName = "nodrag", noWheelClassName = "nowheel", noPanClassName = "nopan", fitView: fitView2, fitViewOptions, connectOnClick, attributionPosition, proOptions, defaultEdgeOptions, elevateNodesOnSelect, elevateEdgesOnSelect, disableKeyboardA11y = !1, autoPanOnConnect, autoPanOnNodeDrag, autoPanSpeed, connectionRadius, isValidConnection, onError, style: style2, id: id2, nodeDragThreshold, viewport, onViewportChange, width: width2, height, colorMode = "light", debug: debug2, ...rest }, ref) {
  const rfId = id2 || "1", colorModeClassName = useColorModeClass(colorMode);
  return jsx("div", { ...rest, style: { ...style2, ...wrapperStyle }, ref, className: cc(["react-flow", className, colorModeClassName]), "data-testid": "rf__wrapper", id: id2, children: jsxs(Wrapper, { nodes, edges, width: width2, height, fitView: fitView2, nodeOrigin, nodeExtent, children: [jsx(GraphView, { onInit, onNodeClick, onEdgeClick, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onNodeDoubleClick, nodeTypes: nodeTypes2, edgeTypes: edgeTypes2, connectionLineType, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, selectionKeyCode, selectionOnDrag, selectionMode, deleteKeyCode, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, onlyRenderVisibleElements, defaultViewport: defaultViewport$1, translateExtent, minZoom, maxZoom, preventScrolling, zoomOnScroll, zoomOnPinch, zoomOnDoubleClick, panOnScroll, panOnScrollSpeed, panOnScrollMode, panOnDrag, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance, nodeClickDistance, onSelectionContextMenu, onSelectionStart, onSelectionEnd, onReconnect, onReconnectStart, onReconnectEnd, onEdgeContextMenu, onEdgeDoubleClick, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius, defaultMarkerColor, noDragClassName, noWheelClassName, noPanClassName, rfId, disableKeyboardA11y, nodeExtent, viewport, onViewportChange }), jsx(StoreUpdater, { nodes, edges, defaultNodes, defaultEdges, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, nodesDraggable, nodesConnectable, nodesFocusable, edgesFocusable, edgesReconnectable, elementsSelectable, elevateNodesOnSelect, elevateEdgesOnSelect, minZoom, maxZoom, nodeExtent, onNodesChange, onEdgesChange, snapToGrid, snapGrid, connectionMode, translateExtent, connectOnClick, defaultEdgeOptions, fitView: fitView2, fitViewOptions, onNodesDelete, onEdgesDelete, onDelete, onNodeDragStart, onNodeDrag, onNodeDragStop, onSelectionDrag, onSelectionDragStart, onSelectionDragStop, onMove, onMoveStart, onMoveEnd, noPanClassName, nodeOrigin, rfId, autoPanOnConnect, autoPanOnNodeDrag, autoPanSpeed, onError, connectionRadius, isValidConnection, selectNodesOnDrag, nodeDragThreshold, onBeforeDelete, paneClickDistance, debug: debug2 }), jsx(SelectionListener, { onSelectionChange }), children2, jsx(Attribution, { proOptions, position: attributionPosition }), jsx(A11yDescriptions, { rfId, disableKeyboardA11y })] }) });
}
var index$2 = fixedForwardRef(ReactFlow);
const selector$6$1 = (s2) => {
  var _a4;
  return (_a4 = s2.domNode) == null ? void 0 : _a4.querySelector(".react-flow__edgelabel-renderer");
};
function EdgeLabelRenderer({ children: children2 }) {
  const edgeLabelRenderer = useStore$2(selector$6$1);
  return edgeLabelRenderer ? createPortal(children2, edgeLabelRenderer) : null;
}
const selector$5$1 = (s2) => {
  var _a4;
  return (_a4 = s2.domNode) == null ? void 0 : _a4.querySelector(".react-flow__viewport-portal");
};
function ViewportPortal({ children: children2 }) {
  const viewPortalDiv = useStore$2(selector$5$1);
  return viewPortalDiv ? createPortal(children2, viewPortalDiv) : null;
}
function useOnViewportChange({ onStart, onChange, onEnd }) {
  const store = useStoreApi();
  useEffect(() => {
    store.setState({ onViewportChangeStart: onStart });
  }, [onStart]), useEffect(() => {
    store.setState({ onViewportChange: onChange });
  }, [onChange]), useEffect(() => {
    store.setState({ onViewportChangeEnd: onEnd });
  }, [onEnd]);
}
function useNodesData(nodeIds) {
  return useStore$2(useCallback((s2) => {
    const data = [], isArrayOfIds = Array.isArray(nodeIds), _nodeIds = isArrayOfIds ? nodeIds : [nodeIds];
    for (const nodeId of _nodeIds) {
      const node2 = s2.nodeLookup.get(nodeId);
      node2 && data.push({
        id: node2.id,
        type: node2.type,
        data: node2.data
      });
    }
    return isArrayOfIds ? data : data[0] ?? null;
  }, [nodeIds]), shallowNodeData);
}
function useInternalNode(id2) {
  return useStore$2(useCallback((s2) => s2.nodeLookup.get(id2), [id2]), shallow$1);
}
function LinePattern({ dimensions, lineWidth, variant, className }) {
  return jsx("path", { strokeWidth: lineWidth, d: `M${dimensions[0] / 2} 0 V${dimensions[1]} M0 ${dimensions[1] / 2} H${dimensions[0]}`, className: cc(["react-flow__background-pattern", variant, className]) });
}
function DotPattern({ radius, className }) {
  return jsx("circle", { cx: radius, cy: radius, r: radius, className: cc(["react-flow__background-pattern", "dots", className]) });
}
var BackgroundVariant;
(function(BackgroundVariant2) {
  BackgroundVariant2.Lines = "lines", BackgroundVariant2.Dots = "dots", BackgroundVariant2.Cross = "cross";
})(BackgroundVariant || (BackgroundVariant = {}));
const defaultSize = {
  [BackgroundVariant.Dots]: 1,
  [BackgroundVariant.Lines]: 1,
  [BackgroundVariant.Cross]: 6
}, selector$3$1 = (s2) => ({ transform: s2.transform, patternId: `pattern-${s2.rfId}` });
function BackgroundComponent({
  id: id2,
  variant = BackgroundVariant.Dots,
  // only used for dots and cross
  gap = 20,
  // only used for lines and cross
  size: size2,
  lineWidth = 1,
  offset: offset2 = 0,
  color: color2,
  bgColor,
  style: style2,
  className,
  patternClassName
}) {
  const ref = useRef(null), { transform: transform2, patternId } = useStore$2(selector$3$1, shallow$1), patternSize = size2 || defaultSize[variant], isDots = variant === BackgroundVariant.Dots, isCross = variant === BackgroundVariant.Cross, gapXY = Array.isArray(gap) ? gap : [gap, gap], scaledGap = [gapXY[0] * transform2[2] || 1, gapXY[1] * transform2[2] || 1], scaledSize = patternSize * transform2[2], offsetXY = Array.isArray(offset2) ? offset2 : [offset2, offset2], patternDimensions = isCross ? [scaledSize, scaledSize] : scaledGap, scaledOffset = [
    offsetXY[0] * transform2[2] || 1 + patternDimensions[0] / 2,
    offsetXY[1] * transform2[2] || 1 + patternDimensions[1] / 2
  ], _patternId = `${patternId}${id2 || ""}`;
  return jsxs("svg", { className: cc(["react-flow__background", className]), style: {
    ...style2,
    ...containerStyle,
    "--xy-background-color-props": bgColor,
    "--xy-background-pattern-color-props": color2
  }, ref, "data-testid": "rf__background", children: [jsx("pattern", { id: _patternId, x: transform2[0] % scaledGap[0], y: transform2[1] % scaledGap[1], width: scaledGap[0], height: scaledGap[1], patternUnits: "userSpaceOnUse", patternTransform: `translate(-${scaledOffset[0]},-${scaledOffset[1]})`, children: isDots ? jsx(DotPattern, { radius: scaledSize / 2, className: patternClassName }) : jsx(LinePattern, { dimensions: patternDimensions, lineWidth, variant, className: patternClassName }) }), jsx("rect", { x: "0", y: "0", width: "100%", height: "100%", fill: `url(#${_patternId})` })] });
}
BackgroundComponent.displayName = "Background";
const Background = memo$1(BackgroundComponent);
function PlusIcon() {
  return jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", children: jsx("path", { d: "M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z" }) });
}
function MinusIcon() {
  return jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 5", children: jsx("path", { d: "M0 0h32v4.2H0z" }) });
}
function FitViewIcon() {
  return jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 30", children: jsx("path", { d: "M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z" }) });
}
function LockIcon() {
  return jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: jsx("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z" }) });
}
function UnlockIcon() {
  return jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: jsx("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z" }) });
}
function ControlButton({ children: children2, className, ...rest }) {
  return jsx("button", { type: "button", className: cc(["react-flow__controls-button", className]), ...rest, children: children2 });
}
const selector$2$1 = (s2) => ({
  isInteractive: s2.nodesDraggable || s2.nodesConnectable || s2.elementsSelectable,
  minZoomReached: s2.transform[2] <= s2.minZoom,
  maxZoomReached: s2.transform[2] >= s2.maxZoom
});
function ControlsComponent({ style: style2, showZoom = !0, showFitView = !0, showInteractive = !0, fitViewOptions, onZoomIn, onZoomOut, onFitView, onInteractiveChange, className, children: children2, position: position2 = "bottom-left", orientation = "vertical", "aria-label": ariaLabel = "React Flow controls" }) {
  const store = useStoreApi(), { isInteractive, minZoomReached, maxZoomReached } = useStore$2(selector$2$1, shallow$1), { zoomIn, zoomOut, fitView: fitView2 } = useReactFlow(), onZoomInHandler = () => {
    zoomIn(), onZoomIn == null || onZoomIn();
  }, onZoomOutHandler = () => {
    zoomOut(), onZoomOut == null || onZoomOut();
  }, onFitViewHandler = () => {
    fitView2(fitViewOptions), onFitView == null || onFitView();
  }, onToggleInteractivity = () => {
    store.setState({
      nodesDraggable: !isInteractive,
      nodesConnectable: !isInteractive,
      elementsSelectable: !isInteractive
    }), onInteractiveChange == null || onInteractiveChange(!isInteractive);
  };
  return jsxs(Panel, { className: cc(["react-flow__controls", orientation === "horizontal" ? "horizontal" : "vertical", className]), position: position2, style: style2, "data-testid": "rf__controls", "aria-label": ariaLabel, children: [showZoom && jsxs(Fragment, { children: [jsx(ControlButton, { onClick: onZoomInHandler, className: "react-flow__controls-zoomin", title: "zoom in", "aria-label": "zoom in", disabled: maxZoomReached, children: jsx(PlusIcon, {}) }), jsx(ControlButton, { onClick: onZoomOutHandler, className: "react-flow__controls-zoomout", title: "zoom out", "aria-label": "zoom out", disabled: minZoomReached, children: jsx(MinusIcon, {}) })] }), showFitView && jsx(ControlButton, { className: "react-flow__controls-fitview", onClick: onFitViewHandler, title: "fit view", "aria-label": "fit view", children: jsx(FitViewIcon, {}) }), showInteractive && jsx(ControlButton, { className: "react-flow__controls-interactive", onClick: onToggleInteractivity, title: "toggle interactivity", "aria-label": "toggle interactivity", children: isInteractive ? jsx(UnlockIcon, {}) : jsx(LockIcon, {}) }), children2] });
}
ControlsComponent.displayName = "Controls";
memo$1(ControlsComponent);
function MiniMapNodeComponent({ id: id2, x: x2, y: y2, width: width2, height, style: style2, color: color2, strokeColor, strokeWidth, className, borderRadius, shapeRendering, selected: selected2, onClick }) {
  const { background, backgroundColor } = style2 || {}, fill = color2 || background || backgroundColor;
  return jsx("rect", { className: cc(["react-flow__minimap-node", { selected: selected2 }, className]), x: x2, y: y2, rx: borderRadius, ry: borderRadius, width: width2, height, style: {
    fill,
    stroke: strokeColor,
    strokeWidth
  }, shapeRendering, onClick: onClick ? (event) => onClick(event, id2) : void 0 });
}
const MiniMapNode = memo$1(MiniMapNodeComponent), selectorNodeIds = (s2) => s2.nodes.map((node2) => node2.id), getAttrFunction = (func) => func instanceof Function ? func : () => func;
function MiniMapNodes({
  nodeStrokeColor,
  nodeColor,
  nodeClassName = "",
  nodeBorderRadius = 5,
  nodeStrokeWidth,
  // We need to rename the prop to be `CapitalCase` so that JSX will render it as
  // a component properly.
  nodeComponent: NodeComponent = MiniMapNode,
  onClick
}) {
  const nodeIds = useStore$2(selectorNodeIds, shallow$1), nodeColorFunc = getAttrFunction(nodeColor), nodeStrokeColorFunc = getAttrFunction(nodeStrokeColor), nodeClassNameFunc = getAttrFunction(nodeClassName), shapeRendering = typeof window > "u" || window.chrome ? "crispEdges" : "geometricPrecision";
  return jsx(Fragment, { children: nodeIds.map((nodeId) => (
    // The split of responsibilities between MiniMapNodes and
    // NodeComponentWrapper may appear weird. However, it’s designed to
    // minimize the cost of updates when individual nodes change.
    //
    // For more details, see a similar commit in `NodeRenderer/index.tsx`.
    jsx(NodeComponentWrapper, { id: nodeId, nodeColorFunc, nodeStrokeColorFunc, nodeClassNameFunc, nodeBorderRadius, nodeStrokeWidth, NodeComponent, onClick, shapeRendering }, nodeId)
  )) });
}
function NodeComponentWrapperInner({ id: id2, nodeColorFunc, nodeStrokeColorFunc, nodeClassNameFunc, nodeBorderRadius, nodeStrokeWidth, shapeRendering, NodeComponent, onClick }) {
  const { node: node2, x: x2, y: y2, width: width2, height } = useStore$2((s2) => {
    const node22 = s2.nodeLookup.get(id2), { x: x22, y: y22 } = node22.internals.positionAbsolute, { width: width22, height: height2 } = getNodeDimensions(node22);
    return {
      node: node22,
      x: x22,
      y: y22,
      width: width22,
      height: height2
    };
  }, shallow$1);
  return !node2 || node2.hidden || !nodeHasDimensions(node2) ? null : jsx(NodeComponent, { x: x2, y: y2, width: width2, height, style: node2.style, selected: !!node2.selected, className: nodeClassNameFunc(node2), color: nodeColorFunc(node2), borderRadius: nodeBorderRadius, strokeColor: nodeStrokeColorFunc(node2), strokeWidth: nodeStrokeWidth, shapeRendering, onClick, id: node2.id });
}
const NodeComponentWrapper = memo$1(NodeComponentWrapperInner);
var MiniMapNodes$1 = memo$1(MiniMapNodes);
const defaultWidth = 200, defaultHeight = 150, selector$1$1 = (s2) => {
  const viewBB = {
    x: -s2.transform[0] / s2.transform[2],
    y: -s2.transform[1] / s2.transform[2],
    width: s2.width / s2.transform[2],
    height: s2.height / s2.transform[2]
  };
  return {
    viewBB,
    boundingRect: s2.nodeLookup.size > 0 ? getBoundsOfRects(getInternalNodesBounds(s2.nodeLookup), viewBB) : viewBB,
    rfId: s2.rfId,
    panZoom: s2.panZoom,
    translateExtent: s2.translateExtent,
    flowWidth: s2.width,
    flowHeight: s2.height
  };
}, ARIA_LABEL_KEY = "react-flow__minimap-desc";
function MiniMapComponent({
  style: style2,
  className,
  nodeStrokeColor,
  nodeColor,
  nodeClassName = "",
  nodeBorderRadius = 5,
  nodeStrokeWidth,
  // We need to rename the prop to be `CapitalCase` so that JSX will render it as
  // a component properly.
  nodeComponent,
  bgColor,
  maskColor,
  maskStrokeColor,
  maskStrokeWidth,
  position: position2 = "bottom-right",
  onClick,
  onNodeClick,
  pannable = !1,
  zoomable = !1,
  ariaLabel = "React Flow mini map",
  inversePan,
  zoomStep = 10,
  offsetScale = 5
}) {
  const store = useStoreApi(), svg = useRef(null), { boundingRect, viewBB, rfId, panZoom, translateExtent, flowWidth, flowHeight } = useStore$2(selector$1$1, shallow$1), elementWidth = (style2 == null ? void 0 : style2.width) ?? defaultWidth, elementHeight = (style2 == null ? void 0 : style2.height) ?? defaultHeight, scaledWidth = boundingRect.width / elementWidth, scaledHeight = boundingRect.height / elementHeight, viewScale = Math.max(scaledWidth, scaledHeight), viewWidth = viewScale * elementWidth, viewHeight = viewScale * elementHeight, offset2 = offsetScale * viewScale, x2 = boundingRect.x - (viewWidth - boundingRect.width) / 2 - offset2, y2 = boundingRect.y - (viewHeight - boundingRect.height) / 2 - offset2, width2 = viewWidth + offset2 * 2, height = viewHeight + offset2 * 2, labelledBy = `${ARIA_LABEL_KEY}-${rfId}`, viewScaleRef = useRef(0), minimapInstance = useRef();
  viewScaleRef.current = viewScale, useEffect(() => {
    if (svg.current && panZoom)
      return minimapInstance.current = XYMinimap({
        domNode: svg.current,
        panZoom,
        getTransform: () => store.getState().transform,
        getViewScale: () => viewScaleRef.current
      }), () => {
        var _a4;
        (_a4 = minimapInstance.current) == null || _a4.destroy();
      };
  }, [panZoom]), useEffect(() => {
    var _a4;
    (_a4 = minimapInstance.current) == null || _a4.update({
      translateExtent,
      width: flowWidth,
      height: flowHeight,
      inversePan,
      pannable,
      zoomStep,
      zoomable
    });
  }, [pannable, zoomable, inversePan, zoomStep, translateExtent, flowWidth, flowHeight]);
  const onSvgClick = onClick ? (event) => {
    var _a4;
    const [x22, y22] = ((_a4 = minimapInstance.current) == null ? void 0 : _a4.pointer(event)) || [0, 0];
    onClick(event, { x: x22, y: y22 });
  } : void 0, onSvgNodeClick = onNodeClick ? useCallback((event, nodeId) => {
    const node2 = store.getState().nodeLookup.get(nodeId);
    onNodeClick(event, node2);
  }, []) : void 0;
  return jsx(Panel, { position: position2, style: {
    ...style2,
    "--xy-minimap-background-color-props": typeof bgColor == "string" ? bgColor : void 0,
    "--xy-minimap-mask-background-color-props": typeof maskColor == "string" ? maskColor : void 0,
    "--xy-minimap-mask-stroke-color-props": typeof maskStrokeColor == "string" ? maskStrokeColor : void 0,
    "--xy-minimap-mask-stroke-width-props": typeof maskStrokeWidth == "number" ? maskStrokeWidth * viewScale : void 0,
    "--xy-minimap-node-background-color-props": typeof nodeColor == "string" ? nodeColor : void 0,
    "--xy-minimap-node-stroke-color-props": typeof nodeStrokeColor == "string" ? nodeStrokeColor : void 0,
    "--xy-minimap-node-stroke-width-props": typeof nodeStrokeWidth == "string" ? nodeStrokeWidth : void 0
  }, className: cc(["react-flow__minimap", className]), "data-testid": "rf__minimap", children: jsxs("svg", { width: elementWidth, height: elementHeight, viewBox: `${x2} ${y2} ${width2} ${height}`, className: "react-flow__minimap-svg", role: "img", "aria-labelledby": labelledBy, ref: svg, onClick: onSvgClick, children: [ariaLabel && jsx("title", { id: labelledBy, children: ariaLabel }), jsx(MiniMapNodes$1, { onClick: onSvgNodeClick, nodeColor, nodeStrokeColor, nodeBorderRadius, nodeClassName, nodeStrokeWidth, nodeComponent }), jsx("path", { className: "react-flow__minimap-mask", d: `M${x2 - offset2},${y2 - offset2}h${width2 + offset2 * 2}v${height + offset2 * 2}h${-width2 - offset2 * 2}z
        M${viewBB.x},${viewBB.y}h${viewBB.width}v${viewBB.height}h${-viewBB.width}z`, fillRule: "evenodd", pointerEvents: "none" })] }) });
}
MiniMapComponent.displayName = "MiniMap";
memo$1(MiniMapComponent);
function ResizeControl({ nodeId, position: position2, variant = ResizeControlVariant.Handle, className, style: style2 = {}, children: children2, color: color2, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = !1, shouldResize, onResizeStart, onResize, onResizeEnd }) {
  const contextNodeId = useNodeId(), id2 = typeof nodeId == "string" ? nodeId : contextNodeId, store = useStoreApi(), resizeControlRef = useRef(null), defaultPosition = variant === ResizeControlVariant.Line ? "right" : "bottom-right", controlPosition = position2 ?? defaultPosition, resizer = useRef(null);
  useEffect(() => {
    if (!(!resizeControlRef.current || !id2))
      return resizer.current || (resizer.current = XYResizer({
        domNode: resizeControlRef.current,
        nodeId: id2,
        getStoreItems: () => {
          const { nodeLookup, transform: transform2, snapGrid, snapToGrid, nodeOrigin, domNode } = store.getState();
          return {
            nodeLookup,
            transform: transform2,
            snapGrid,
            snapToGrid,
            nodeOrigin,
            paneDomNode: domNode
          };
        },
        onChange: (change, childChanges) => {
          const { triggerNodeChanges, nodeLookup, parentLookup, nodeOrigin } = store.getState(), changes = [], nextPosition = { x: change.x, y: change.y }, node2 = nodeLookup.get(id2);
          if (node2 && node2.expandParent && node2.parentId) {
            const origin = node2.origin ?? nodeOrigin, width2 = change.width ?? node2.measured.width, height = change.height ?? node2.measured.height, child = {
              id: node2.id,
              parentId: node2.parentId,
              rect: {
                width: width2,
                height,
                ...evaluateAbsolutePosition({
                  x: change.x ?? node2.position.x,
                  y: change.y ?? node2.position.y
                }, { width: width2, height }, node2.parentId, nodeLookup, origin)
              }
            }, parentExpandChanges = handleExpandParent([child], nodeLookup, parentLookup, nodeOrigin);
            changes.push(...parentExpandChanges), nextPosition.x = change.x ? Math.max(origin[0] * width2, change.x) : void 0, nextPosition.y = change.y ? Math.max(origin[1] * height, change.y) : void 0;
          }
          if (nextPosition.x !== void 0 && nextPosition.y !== void 0) {
            const positionChange = {
              id: id2,
              type: "position",
              position: { ...nextPosition }
            };
            changes.push(positionChange);
          }
          if (change.width !== void 0 && change.height !== void 0) {
            const dimensionChange = {
              id: id2,
              type: "dimensions",
              resizing: !0,
              setAttributes: !0,
              dimensions: {
                width: change.width,
                height: change.height
              }
            };
            changes.push(dimensionChange);
          }
          for (const childChange of childChanges) {
            const positionChange = {
              ...childChange,
              type: "position"
            };
            changes.push(positionChange);
          }
          triggerNodeChanges(changes);
        },
        onEnd: () => {
          const dimensionChange = {
            id: id2,
            type: "dimensions",
            resizing: !1
          };
          store.getState().triggerNodeChanges([dimensionChange]);
        }
      })), resizer.current.update({
        controlPosition,
        boundaries: {
          minWidth,
          minHeight,
          maxWidth,
          maxHeight
        },
        keepAspectRatio,
        onResizeStart,
        onResize,
        onResizeEnd,
        shouldResize
      }), () => {
        var _a4;
        (_a4 = resizer.current) == null || _a4.destroy();
      };
  }, [
    controlPosition,
    minWidth,
    minHeight,
    maxWidth,
    maxHeight,
    keepAspectRatio,
    onResizeStart,
    onResize,
    onResizeEnd,
    shouldResize
  ]);
  const positionClassNames = controlPosition.split("-"), colorStyleProp = variant === ResizeControlVariant.Line ? "borderColor" : "backgroundColor", controlStyle = color2 ? { ...style2, [colorStyleProp]: color2 } : style2;
  return jsx("div", { className: cc(["react-flow__resize-control", "nodrag", ...positionClassNames, variant, className]), ref: resizeControlRef, style: controlStyle, children: children2 });
}
memo$1(ResizeControl);
const selector$p = (state) => {
  var _a4;
  return (_a4 = state.domNode) == null ? void 0 : _a4.querySelector(".react-flow__renderer");
};
function NodeToolbarPortal({ children: children2 }) {
  const wrapperRef = useStore$2(selector$p);
  return wrapperRef ? createPortal(children2, wrapperRef) : null;
}
const nodeEqualityFn = (a2, b2) => (a2 == null ? void 0 : a2.internals.positionAbsolute.x) !== (b2 == null ? void 0 : b2.internals.positionAbsolute.x) || (a2 == null ? void 0 : a2.internals.positionAbsolute.y) !== (b2 == null ? void 0 : b2.internals.positionAbsolute.y) || (a2 == null ? void 0 : a2.measured.width) !== (b2 == null ? void 0 : b2.measured.width) || (a2 == null ? void 0 : a2.measured.height) !== (b2 == null ? void 0 : b2.measured.height) || (a2 == null ? void 0 : a2.selected) !== (b2 == null ? void 0 : b2.selected) || (a2 == null ? void 0 : a2.internals.z) !== (b2 == null ? void 0 : b2.internals.z), nodesEqualityFn = (a2, b2) => {
  if (a2.size !== b2.size)
    return !1;
  for (const [key, node2] of a2)
    if (nodeEqualityFn(node2, b2.get(key)))
      return !1;
  return !0;
}, storeSelector = (state) => ({
  x: state.transform[0],
  y: state.transform[1],
  zoom: state.transform[2],
  selectedNodesCount: state.nodes.filter((node2) => node2.selected).length
});
function NodeToolbar({ nodeId, children: children2, className, style: style2, isVisible, position: position2 = Position.Top, offset: offset2 = 10, align: align2 = "center", ...rest }) {
  const contextNodeId = useNodeId(), nodesSelector2 = useCallback((state) => (Array.isArray(nodeId) ? nodeId : [nodeId || contextNodeId || ""]).reduce((res, id2) => {
    const node2 = state.nodeLookup.get(id2);
    return node2 && res.set(node2.id, node2), res;
  }, /* @__PURE__ */ new Map()), [nodeId, contextNodeId]), nodes = useStore$2(nodesSelector2, nodesEqualityFn), { x: x2, y: y2, zoom: zoom2, selectedNodesCount } = useStore$2(storeSelector, shallow$1);
  if (!(typeof isVisible == "boolean" ? isVisible : nodes.size === 1 && nodes.values().next().value.selected && selectedNodesCount === 1) || !nodes.size)
    return null;
  const nodeRect = getInternalNodesBounds(nodes), nodesArray = Array.from(nodes.values()), zIndex = Math.max(...nodesArray.map((node2) => node2.internals.z + 1)), wrapperStyle2 = {
    position: "absolute",
    transform: getNodeToolbarTransform(nodeRect, { x: x2, y: y2, zoom: zoom2 }, position2, offset2, align2),
    zIndex,
    ...style2
  };
  return jsx(NodeToolbarPortal, { children: jsx("div", { style: wrapperStyle2, className: cc(["react-flow__node-toolbar", className]), ...rest, "data-id": nodesArray.reduce((acc, node2) => `${acc}${node2.id} `, "").trim(), children: children2 }) });
}
function r$7(e2) {
  var t2, f2, n2 = "";
  if (typeof e2 == "string" || typeof e2 == "number") n2 += e2;
  else if (typeof e2 == "object") if (Array.isArray(e2)) {
    var o2 = e2.length;
    for (t2 = 0; t2 < o2; t2++) e2[t2] && (f2 = r$7(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
  } else for (f2 in e2) e2[f2] && (n2 && (n2 += " "), n2 += f2);
  return n2;
}
function clsx() {
  for (var e2, t2, f2 = 0, n2 = "", o2 = arguments.length; f2 < o2; f2++) (e2 = arguments[f2]) && (t2 = r$7(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
var getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols, hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function combineComparators(comparatorA, comparatorB) {
  return function(a2, b2, state) {
    return comparatorA(a2, b2, state) && comparatorB(a2, b2, state);
  };
}
function createIsCircular(areItemsEqual) {
  return function(a2, b2, state) {
    if (!a2 || !b2 || typeof a2 != "object" || typeof b2 != "object")
      return areItemsEqual(a2, b2, state);
    var cache = state.cache, cachedA = cache.get(a2), cachedB = cache.get(b2);
    if (cachedA && cachedB)
      return cachedA === b2 && cachedB === a2;
    cache.set(a2, b2), cache.set(b2, a2);
    var result = areItemsEqual(a2, b2, state);
    return cache.delete(a2), cache.delete(b2), result;
  };
}
function getStrictProperties(object2) {
  return getOwnPropertyNames(object2).concat(getOwnPropertySymbols(object2));
}
var hasOwn = Object.hasOwn || function(object2, property) {
  return hasOwnProperty$2.call(object2, property);
};
function sameValueZeroEqual(a2, b2) {
  return a2 || b2 ? a2 === b2 : a2 === b2 || a2 !== a2 && b2 !== b2;
}
var OWNER = "_owner", getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, keys$1 = Object.keys;
function areArraysEqual(a2, b2, state) {
  var index2 = a2.length;
  if (b2.length !== index2)
    return !1;
  for (; index2-- > 0; )
    if (!state.equals(a2[index2], b2[index2], index2, index2, a2, b2, state))
      return !1;
  return !0;
}
function areDatesEqual(a2, b2) {
  return sameValueZeroEqual(a2.getTime(), b2.getTime());
}
function areMapsEqual(a2, b2, state) {
  if (a2.size !== b2.size)
    return !1;
  for (var matchedIndices = {}, aIterable = a2.entries(), index2 = 0, aResult, bResult; (aResult = aIterable.next()) && !aResult.done; ) {
    for (var bIterable = b2.entries(), hasMatch = !1, matchIndex = 0; (bResult = bIterable.next()) && !bResult.done; ) {
      var _a4 = aResult.value, aKey = _a4[0], aValue = _a4[1], _b2 = bResult.value, bKey = _b2[0], bValue = _b2[1];
      !hasMatch && !matchedIndices[matchIndex] && (hasMatch = state.equals(aKey, bKey, index2, matchIndex, a2, b2, state) && state.equals(aValue, bValue, aKey, bKey, a2, b2, state)) && (matchedIndices[matchIndex] = !0), matchIndex++;
    }
    if (!hasMatch)
      return !1;
    index2++;
  }
  return !0;
}
function areObjectsEqual(a2, b2, state) {
  var properties = keys$1(a2), index2 = properties.length;
  if (keys$1(b2).length !== index2)
    return !1;
  for (var property; index2-- > 0; )
    if (property = properties[index2], property === OWNER && (a2.$$typeof || b2.$$typeof) && a2.$$typeof !== b2.$$typeof || !hasOwn(b2, property) || !state.equals(a2[property], b2[property], property, property, a2, b2, state))
      return !1;
  return !0;
}
function areObjectsEqualStrict(a2, b2, state) {
  var properties = getStrictProperties(a2), index2 = properties.length;
  if (getStrictProperties(b2).length !== index2)
    return !1;
  for (var property, descriptorA, descriptorB; index2-- > 0; )
    if (property = properties[index2], property === OWNER && (a2.$$typeof || b2.$$typeof) && a2.$$typeof !== b2.$$typeof || !hasOwn(b2, property) || !state.equals(a2[property], b2[property], property, property, a2, b2, state) || (descriptorA = getOwnPropertyDescriptor(a2, property), descriptorB = getOwnPropertyDescriptor(b2, property), (descriptorA || descriptorB) && (!descriptorA || !descriptorB || descriptorA.configurable !== descriptorB.configurable || descriptorA.enumerable !== descriptorB.enumerable || descriptorA.writable !== descriptorB.writable)))
      return !1;
  return !0;
}
function arePrimitiveWrappersEqual(a2, b2) {
  return sameValueZeroEqual(a2.valueOf(), b2.valueOf());
}
function areRegExpsEqual(a2, b2) {
  return a2.source === b2.source && a2.flags === b2.flags;
}
function areSetsEqual(a2, b2, state) {
  if (a2.size !== b2.size)
    return !1;
  for (var matchedIndices = {}, aIterable = a2.values(), aResult, bResult; (aResult = aIterable.next()) && !aResult.done; ) {
    for (var bIterable = b2.values(), hasMatch = !1, matchIndex = 0; (bResult = bIterable.next()) && !bResult.done; )
      !hasMatch && !matchedIndices[matchIndex] && (hasMatch = state.equals(aResult.value, bResult.value, aResult.value, bResult.value, a2, b2, state)) && (matchedIndices[matchIndex] = !0), matchIndex++;
    if (!hasMatch)
      return !1;
  }
  return !0;
}
function areTypedArraysEqual(a2, b2) {
  var index2 = a2.length;
  if (b2.length !== index2)
    return !1;
  for (; index2-- > 0; )
    if (a2[index2] !== b2[index2])
      return !1;
  return !0;
}
var ARGUMENTS_TAG = "[object Arguments]", BOOLEAN_TAG = "[object Boolean]", DATE_TAG = "[object Date]", MAP_TAG = "[object Map]", NUMBER_TAG = "[object Number]", OBJECT_TAG = "[object Object]", REG_EXP_TAG = "[object RegExp]", SET_TAG = "[object Set]", STRING_TAG = "[object String]", isArray = Array.isArray, isTypedArray = typeof ArrayBuffer == "function" && ArrayBuffer.isView ? ArrayBuffer.isView : null, assign = Object.assign, getTag = Object.prototype.toString.call.bind(Object.prototype.toString);
function createEqualityComparator(_a4) {
  var areArraysEqual2 = _a4.areArraysEqual, areDatesEqual2 = _a4.areDatesEqual, areMapsEqual2 = _a4.areMapsEqual, areObjectsEqual2 = _a4.areObjectsEqual, arePrimitiveWrappersEqual2 = _a4.arePrimitiveWrappersEqual, areRegExpsEqual2 = _a4.areRegExpsEqual, areSetsEqual2 = _a4.areSetsEqual, areTypedArraysEqual2 = _a4.areTypedArraysEqual;
  return function(a2, b2, state) {
    if (a2 === b2)
      return !0;
    if (a2 == null || b2 == null || typeof a2 != "object" || typeof b2 != "object")
      return a2 !== a2 && b2 !== b2;
    var constructor = a2.constructor;
    if (constructor !== b2.constructor)
      return !1;
    if (constructor === Object)
      return areObjectsEqual2(a2, b2, state);
    if (isArray(a2))
      return areArraysEqual2(a2, b2, state);
    if (isTypedArray != null && isTypedArray(a2))
      return areTypedArraysEqual2(a2, b2, state);
    if (constructor === Date)
      return areDatesEqual2(a2, b2, state);
    if (constructor === RegExp)
      return areRegExpsEqual2(a2, b2, state);
    if (constructor === Map)
      return areMapsEqual2(a2, b2, state);
    if (constructor === Set)
      return areSetsEqual2(a2, b2, state);
    var tag = getTag(a2);
    return tag === DATE_TAG ? areDatesEqual2(a2, b2, state) : tag === REG_EXP_TAG ? areRegExpsEqual2(a2, b2, state) : tag === MAP_TAG ? areMapsEqual2(a2, b2, state) : tag === SET_TAG ? areSetsEqual2(a2, b2, state) : tag === OBJECT_TAG ? typeof a2.then != "function" && typeof b2.then != "function" && areObjectsEqual2(a2, b2, state) : tag === ARGUMENTS_TAG ? areObjectsEqual2(a2, b2, state) : tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG ? arePrimitiveWrappersEqual2(a2, b2, state) : !1;
  };
}
function createEqualityComparatorConfig(_a4) {
  var circular = _a4.circular, createCustomConfig = _a4.createCustomConfig, strict = _a4.strict, config = {
    areArraysEqual: strict ? areObjectsEqualStrict : areArraysEqual,
    areDatesEqual,
    areMapsEqual: strict ? combineComparators(areMapsEqual, areObjectsEqualStrict) : areMapsEqual,
    areObjectsEqual: strict ? areObjectsEqualStrict : areObjectsEqual,
    arePrimitiveWrappersEqual,
    areRegExpsEqual,
    areSetsEqual: strict ? combineComparators(areSetsEqual, areObjectsEqualStrict) : areSetsEqual,
    areTypedArraysEqual: strict ? areObjectsEqualStrict : areTypedArraysEqual
  };
  if (createCustomConfig && (config = assign({}, config, createCustomConfig(config))), circular) {
    var areArraysEqual$1 = createIsCircular(config.areArraysEqual), areMapsEqual$1 = createIsCircular(config.areMapsEqual), areObjectsEqual$1 = createIsCircular(config.areObjectsEqual), areSetsEqual$1 = createIsCircular(config.areSetsEqual);
    config = assign({}, config, {
      areArraysEqual: areArraysEqual$1,
      areMapsEqual: areMapsEqual$1,
      areObjectsEqual: areObjectsEqual$1,
      areSetsEqual: areSetsEqual$1
    });
  }
  return config;
}
function createInternalEqualityComparator(compare2) {
  return function(a2, b2, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, state) {
    return compare2(a2, b2, state);
  };
}
function createIsEqual(_a4) {
  var circular = _a4.circular, comparator = _a4.comparator, createState2 = _a4.createState, equals = _a4.equals, strict = _a4.strict;
  if (createState2)
    return function(a2, b2) {
      var _a5 = createState2(), _b2 = _a5.cache, cache = _b2 === void 0 ? circular ? /* @__PURE__ */ new WeakMap() : void 0 : _b2, meta = _a5.meta;
      return comparator(a2, b2, {
        cache,
        equals,
        meta,
        strict
      });
    };
  if (circular)
    return function(a2, b2) {
      return comparator(a2, b2, {
        cache: /* @__PURE__ */ new WeakMap(),
        equals,
        meta: void 0,
        strict
      });
    };
  var state = {
    cache: void 0,
    equals,
    meta: void 0,
    strict
  };
  return function(a2, b2) {
    return comparator(a2, b2, state);
  };
}
var deepEqual$1 = createCustomEqual();
createCustomEqual({ strict: !0 });
createCustomEqual({ circular: !0 });
createCustomEqual({
  circular: !0,
  strict: !0
});
var shallowEqual = createCustomEqual({
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
createCustomEqual({
  strict: !0,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
createCustomEqual({
  circular: !0,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
createCustomEqual({
  circular: !0,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  },
  strict: !0
});
function createCustomEqual(options) {
  options === void 0 && (options = {});
  var _a4 = options.circular, circular = _a4 === void 0 ? !1 : _a4, createCustomInternalComparator = options.createInternalComparator, createState2 = options.createState, _b2 = options.strict, strict = _b2 === void 0 ? !1 : _b2, config = createEqualityComparatorConfig(options), comparator = createEqualityComparator(config), equals = createCustomInternalComparator ? createCustomInternalComparator(comparator) : createInternalEqualityComparator(comparator);
  return createIsEqual({ circular, comparator, createState: createState2, equals, strict });
}
function u$a(t2, n2, a2) {
  let o2 = (r2) => t2(r2, ...n2);
  return a2 === void 0 ? o2 : Object.assign(o2, { lazy: a2, lazyArgs: n2 });
}
function u$9(r2, n2, a2) {
  let o2 = r2.length - n2.length;
  if (o2 === 0) return r2(...n2);
  if (o2 === 1) return u$a(r2, n2, a2);
  throw new Error("Wrong number of arguments");
}
function r$6(...t2) {
  return u$9(Object.values, t2);
}
var s$4 = { done: !1, hasNext: !1 };
function x$2(t2, ...o2) {
  let n2 = t2, u2 = o2.map((e2) => "lazy" in e2 ? f$4(e2) : void 0), p2 = 0;
  for (; p2 < o2.length; ) {
    if (u2[p2] === void 0 || !B(n2)) {
      let i2 = o2[p2];
      n2 = i2(n2), p2 += 1;
      continue;
    }
    let r2 = [];
    for (let i2 = p2; i2 < o2.length; i2++) {
      let l2 = u2[i2];
      if (l2 === void 0 || (r2.push(l2), l2.isSingle)) break;
    }
    let a2 = [];
    for (let i2 of n2) if (A(i2, a2, r2)) break;
    let { isSingle: y2 } = r2.at(-1);
    n2 = y2 ? a2[0] : a2, p2 += r2.length;
  }
  return n2;
}
function A(t2, o2, n2) {
  if (n2.length === 0) return o2.push(t2), !1;
  let u2 = t2, p2 = s$4, e2 = !1;
  for (let [r2, a2] of n2.entries()) {
    let { index: y2, items: i2 } = a2;
    if (i2.push(u2), p2 = a2(u2, y2, i2), a2.index += 1, p2.hasNext) {
      if (p2.hasMany ?? !1) {
        for (let l2 of p2.next) if (A(l2, o2, n2.slice(r2 + 1))) return !0;
        return e2;
      }
      u2 = p2.next;
    }
    if (!p2.hasNext) break;
    p2.done && (e2 = !0);
  }
  return p2.hasNext && o2.push(u2), e2;
}
function f$4(t2) {
  let { lazy: o2, lazyArgs: n2 } = t2, u2 = o2(...n2);
  return Object.assign(u2, { isSingle: o2.single ?? !1, index: 0, items: [] });
}
function B(t2) {
  return typeof t2 == "string" || typeof t2 == "object" && t2 !== null && Symbol.iterator in t2;
}
function f$3(t2, i2) {
  let o2 = i2.length - t2.length;
  if (o2 === 1) {
    let [n2, ...r2] = i2;
    return x$2(n2, { lazy: t2, lazyArgs: r2 });
  }
  if (o2 === 0) {
    let n2 = { lazy: t2, lazyArgs: i2 };
    return Object.assign((e2) => x$2(e2, n2), n2);
  }
  throw new Error("Wrong number of arguments");
}
function i$9(...e2) {
  return f$3(o$a, e2);
}
function o$a() {
  let e2 = /* @__PURE__ */ new Set();
  return (t2) => e2.has(t2) ? s$4 : (e2.add(t2), { done: !1, hasNext: !0, next: t2 });
}
function i$8(...e2) {
  return u$9(r$5, e2);
}
var r$5 = (e2, t2) => e2.length >= t2, T$2 = { asc: (r2, n2) => r2 > n2, desc: (r2, n2) => r2 < n2 };
function s$3(r2, n2) {
  let [e2, ...o2] = n2;
  if (!m$4(e2)) {
    let t2 = u$8(...o2);
    return r2(e2, t2);
  }
  let a2 = u$8(e2, ...o2);
  return (t2) => r2(t2, a2);
}
function u$8(r2, n2, ...e2) {
  let o2 = typeof r2 == "function" ? r2 : r2[0], a2 = typeof r2 == "function" ? "asc" : r2[1], { [a2]: t2 } = T$2, i2 = n2 === void 0 ? void 0 : u$8(n2, ...e2);
  return (y2, c) => {
    let p2 = o2(y2), l2 = o2(c);
    return t2(p2, l2) ? 1 : t2(l2, p2) ? -1 : (i2 == null ? void 0 : i2(y2, c)) ?? 0;
  };
}
function m$4(r2) {
  if (d$4(r2)) return !0;
  if (typeof r2 != "object" || !Array.isArray(r2)) return !1;
  let [n2, e2, ...o2] = r2;
  return d$4(n2) && typeof e2 == "string" && e2 in T$2 && o2.length === 0;
}
var d$4 = (r2) => typeof r2 == "function" && r2.length === 1;
function u$7(...e2) {
  return u$9(i$7, e2);
}
function i$7(e2, a2) {
  let n2 = [];
  for (let [o2, r2] of e2.entries()) {
    if (!a2(r2, o2, e2)) break;
    n2.push(r2);
  }
  return n2;
}
function r$4(...n2) {
  return u$9(e$3, n2);
}
function e$3(n2, o2) {
  return o2(n2), n2;
}
function b$1(t2) {
  return (e2, r2) => {
    if (r2 === 0) return t2(e2);
    if (!Number.isInteger(r2)) throw new TypeError(`precision must be an integer: ${r2.toString()}`);
    if (r2 > 15 || r2 < -15) throw new RangeError("precision must be between -15 and 15");
    if (Number.isNaN(e2) || !Number.isFinite(e2)) return t2(e2);
    let n2 = 10 ** r2;
    return t2(e2 * n2) / n2;
  };
}
function s$2(...e2) {
  return u$9(r$3, e2);
}
function r$3(e2, u2, t2) {
  let [n2, ...a2] = u2;
  if (n2 === void 0) return t2;
  if (Array.isArray(e2)) {
    let o2 = [...e2];
    return o2[n2] = r$3(e2[n2], a2, t2), o2;
  }
  let { [n2]: T2, ...y2 } = e2;
  return { ...y2, [n2]: r$3(T2, a2, t2) };
}
function m$3(...r2) {
  return u$9(o$9, r2);
}
function o$9(r2, t2) {
  let e2 = [...r2];
  return e2.sort(t2), e2;
}
function a$3(...r2) {
  return s$3(n$6, r2);
}
var n$6 = (r2, t2) => [...r2].sort(t2);
function o$8(r2, n2) {
  let e2 = Math.ceil(r2), t2 = Math.floor(n2);
  if (t2 < e2) throw new RangeError(`randomInteger: The range [${r2.toString()},${n2.toString()}] contains no integer`);
  return Math.floor(Math.random() * (t2 - e2 + 1) + e2);
}
function l$4(...e2) {
  return u$9(u$6, e2);
}
var u$6 = (e2, a2, n2) => e2.reduce(a2, n2);
function t$7(...e2) {
  return u$9(r$2, e2);
}
function r$2(e2) {
  return [...e2].reverse();
}
function i$6(...e2) {
  return u$9(o$7, e2);
}
function o$7(e2, n2) {
  let t2 = {};
  for (let r2 of n2) r2 in e2 && (t2[r2] = e2[r2]);
  return t2;
}
function p$4(...n2) {
  return u$9(t$6, n2);
}
var t$6 = (n2, e2) => n2[e2];
function y$5(...t2) {
  return u$9(f$2, t2);
}
function f$2(t2, e2) {
  if (!i$8(e2, 1)) return { ...t2 };
  if (!i$8(e2, 2)) {
    let { [e2[0]]: r2, ...m2 } = t2;
    return m2;
  }
  let o2 = { ...t2 };
  for (let r2 of e2) delete o2[r2];
  return o2;
}
function t$5(...n2) {
  return u$9(o$6, n2);
}
var o$6 = (n2) => n2.length === 1 ? n2[0] : void 0;
function d$3(...r2) {
  return u$9(i$5, r2);
}
var i$5 = (r2, t2) => {
  let a2 = [[], []];
  for (let [o2, e2] of r2.entries()) t2(e2, o2, r2) ? a2[0].push(e2) : a2[1].push(e2);
  return a2;
};
function a$2(...e2) {
  return u$9(n$5, e2);
}
var n$5 = (e2) => e2.at(-1);
function m$2(...a2) {
  return u$9(o$5, a2, p$3);
}
var o$5 = (a2, e2) => a2.map(e2), p$3 = (a2) => (e2, t2, r2) => ({ done: !1, hasNext: !0, next: a2(e2, t2, r2) });
function l$3(...n2) {
  return u$9(d$2, n2);
}
function d$2(n2, o2) {
  let e2 = {};
  for (let [a2, t2] of n2.entries()) {
    let [y2, u2] = o2(t2, a2, n2);
    e2[y2] = u2;
  }
  return e2;
}
function t$4(r2) {
  return typeof r2 == "string";
}
function n$4(e2) {
  return !!e2;
}
function t$3(n2) {
  return typeof n2 == "function";
}
function n$3(l2) {
  return l2 !== null;
}
function l$2(n2) {
  return n2 != null;
}
function o$4(a2) {
  return (t2) => !a2(t2);
}
function n$2(e2) {
  return e2 == null;
}
function e$2(r2) {
  return typeof r2 == "number" && !Number.isNaN(r2);
}
function o$3(r2) {
  return Array.isArray(r2);
}
function n$1(e2) {
  return e2 !== void 0;
}
function n(e2) {
  return e2 === void 0 ? !0 : typeof e2 == "string" || Array.isArray(e2) ? e2.length === 0 : Object.keys(e2).length === 0;
}
function u$5(...a2) {
  return u$9(o$2, a2, l$1);
}
var o$2 = (a2, r2) => a2.flatMap(r2), l$1 = (a2) => (r2, t2, y2) => {
  let n2 = a2(r2, t2, y2);
  return Array.isArray(n2) ? { done: !1, hasNext: !0, hasMany: !0, next: n2 } : { done: !1, hasNext: !0, next: n2 };
};
function u$4(...e2) {
  return u$9(o$1, e2, i$4);
}
function o$1(e2, r2) {
  return e2.forEach(r2), e2;
}
var i$4 = (e2) => (r2, n2, t2) => (e2(r2, n2, t2), { done: !1, hasNext: !0, next: r2 });
function i$3(...e2) {
  return u$9(a$1, e2);
}
function a$1(e2, r2) {
  for (let [t2, o2] of Object.entries(e2)) r2(o2, t2, e2);
  return e2;
}
function i$2(...e2) {
  return u$9(p$2, e2);
}
var p$2 = (e2, a2) => {
  let n2 = {};
  for (let [d2, t2] of e2.entries()) {
    let y2 = a2(t2, d2, e2);
    if (y2 !== void 0) {
      let { [y2]: r2 } = n2;
      r2 === void 0 && (r2 = [], n2[y2] = r2), r2.push(t2);
    }
  }
  return n2;
};
function T$1(...a2) {
  return u$9(l, a2, y$4);
}
var l = (a2, e2) => a2.filter(e2), y$4 = (a2) => (e2, t2, o2) => a2(e2, t2, o2) ? { done: !1, hasNext: !0, next: e2 } : s$4, e$1 = (n2) => Object.assign(n2, { single: !0 });
function f$1(...e2) {
  return u$9(i$1, e2, e$1(u$3));
}
var i$1 = (e2, n2) => e2.find(n2), u$3 = (e2) => (n2, t2, o2) => e2(n2, t2, o2) ? { done: !0, hasNext: !0, next: n2 } : s$4;
function d$1(...e2) {
  return u$9(r$1, e2, e$1(o));
}
var r$1 = ([e2]) => e2, o = () => a, a = (e2) => ({ hasNext: !0, next: e2, done: !0 });
function t$2(...r2) {
  return u$9(Object.entries, r2);
}
function p$1(...n2) {
  return u$9(u$2, n2);
}
function u$2(n2, t2 = [], r2 = []) {
  if (typeof n2 == "function") return n2;
  if (typeof n2 != "object" || n2 === null || n2 instanceof Date || n2 instanceof RegExp) return structuredClone(n2);
  let o2 = t2.indexOf(n2);
  return o2 !== -1 ? r2[o2] : (t2.push(n2), Array.isArray(n2) ? y$3(n2, t2, r2) : s$1(n2, t2, r2));
}
function s$1(n2, t2, r2) {
  let o2 = {};
  r2.push(o2);
  for (let [e2, c] of Object.entries(n2)) o2[e2] = u$2(c, t2, r2);
  return o2;
}
function y$3(n2, t2, r2) {
  let o2 = [];
  r2.push(o2);
  for (let [e2, c] of n2.entries()) o2[e2] = u$2(c, t2, r2);
  return o2;
}
function t$1(...a2) {
  return u$9(e, a2);
}
var e = (a2, o2) => o2.every((l2) => l2(a2));
function y$2(...a2) {
  return u$9(r, a2);
}
var r = (a2, o2) => o2.some((e2) => e2(a2));
function u$1(...e2) {
  return u$9(b$1(Math.ceil), e2);
}
function u(...n2) {
  return u$9(i, n2);
}
var i = (n2, { min: e2, max: r2 }) => e2 !== void 0 && n2 < e2 ? e2 : r2 !== void 0 && n2 > r2 ? r2 : n2, rootClassName = "likec4-diagram-root";
function nonNullable(value, message) {
  if (typeof value > "u" || value == null)
    throw new Error(message ?? `Expected defined value, but received ${value}`);
  return value;
}
function invariant$1(condition, message) {
  if (!condition)
    throw new Error(message ?? "Invariant failed");
}
function nonexhaustive(value) {
  throw new Error(`NonExhaustive value: ${value}`);
}
var ElementKind;
((ElementKind2) => {
  ElementKind2.Group = "@group";
})(ElementKind || (ElementKind = {}));
const ElementShapes = [
  "rectangle",
  "person",
  "browser",
  "mobile",
  "cylinder",
  "storage",
  "queue"
], DefaultThemeColor = "primary", DefaultElementShape = "rectangle", isTagEqual = (operator) => "tag" in operator, isKindEqual = (operator) => "kind" in operator, isNotOperator = (operator) => "not" in operator, isAndOperator = (operator) => "and" in operator, isOrOperator = (operator) => "or" in operator;
function whereOperatorAsPredicate(operator) {
  switch (!0) {
    case isTagEqual(operator): {
      if ("eq" in operator.tag) {
        const tag2 = operator.tag.eq;
        return (value) => Array.isArray(value.tags) && value.tags.includes(tag2);
      }
      const tag = operator.tag.neq;
      return (value) => !Array.isArray(value.tags) || !value.tags.includes(tag);
    }
    case isKindEqual(operator): {
      if ("eq" in operator.kind) {
        const kind2 = operator.kind.eq;
        return (value) => value.kind === kind2;
      }
      const kind = operator.kind.neq;
      return (value) => n$2(value.kind) || value.kind !== kind;
    }
    case isNotOperator(operator): {
      const predicate = whereOperatorAsPredicate(operator.not);
      return o$4(predicate);
    }
    case isAndOperator(operator): {
      const predicates = operator.and.map(whereOperatorAsPredicate);
      return t$1(predicates);
    }
    case isOrOperator(operator): {
      const predicates = operator.or.map(whereOperatorAsPredicate);
      return y$2(predicates);
    }
    default:
      nonexhaustive(operator);
  }
}
const DefaultRelationshipColor = "gray";
function isStepEdgeId(id2) {
  return id2.startsWith("step-");
}
function extractStep(id2) {
  if (!isStepEdgeId(id2))
    throw new Error(`Invalid step edge id: ${id2}`);
  return parseFloat(id2.slice(5));
}
function getParallelStepsPrefix(id2) {
  return isStepEdgeId(id2) && id2.includes(".") ? id2.slice(0, id2.indexOf(".") + 1) : null;
}
var ComputedNode;
((ComputedNode2) => {
  function isNodesGroup(node2) {
    return node2.kind === ElementKind.Group;
  }
  ComputedNode2.isNodesGroup = isNodesGroup;
})(ComputedNode || (ComputedNode = {}));
function getBBoxCenter({
  x: x2,
  y: y2,
  width: width2,
  height
}) {
  return {
    x: x2 + width2 / 2,
    y: y2 + height / 2
  };
}
var DiagramNode;
((DiagramNode2) => {
  function isNodesGroup(node2) {
    return node2.kind === ElementKind.Group;
  }
  DiagramNode2.isNodesGroup = isNodesGroup;
})(DiagramNode || (DiagramNode = {}));
var naturalCompareLite = { exports: {} };
naturalCompareLite.exports;
var naturalCompare = function(a2, b2) {
  var i2, codeA, codeB = 1, posA = 0, posB = 0, alphabet = String.alphabet;
  function getCode(str, pos, code) {
    if (code) {
      for (i2 = pos; code = getCode(str, i2), code < 76 && code > 65; ) ++i2;
      return +str.slice(pos - 1, i2);
    }
    return code = alphabet && alphabet.indexOf(str.charAt(pos)), code > -1 ? code + 76 : (code = str.charCodeAt(pos) || 0, code < 45 || code > 127 ? code : code < 46 ? 65 : code < 48 ? code - 1 : code < 58 ? code + 18 : code < 65 ? code - 11 : code < 91 ? code + 11 : code < 97 ? code - 37 : code < 123 ? code + 5 : code - 63);
  }
  if ((a2 += "") != (b2 += "")) {
    for (; codeB; )
      if (codeA = getCode(a2, posA++), codeB = getCode(b2, posB++), codeA < 76 && codeB < 76 && codeA > 66 && codeB > 66 && (codeA = getCode(a2, posA, posA), codeB = getCode(b2, posB, posA = i2), posB = i2), codeA != codeB) return codeA < codeB ? -1 : 1;
  }
  return 0;
};
try {
  naturalCompareLite.exports = naturalCompare;
} catch {
  String.naturalCompare = naturalCompare;
}
var naturalCompareLiteExports = naturalCompareLite.exports;
const compare = /* @__PURE__ */ getDefaultExportFromCjs(naturalCompareLiteExports);
function compareNatural(a2, b2) {
  return a2 === b2 ? 0 : t$4(a2) ? t$4(b2) ? compare(a2, b2) : 1 : t$4(b2) ? -1 : 0;
}
function isString(value) {
  return value != null && typeof value == "string";
}
function nameFromFqn(fqn2) {
  const lastDot = fqn2.lastIndexOf(".");
  return lastDot > 0 ? fqn2.slice(lastDot + 1) : fqn2;
}
function isAncestor(...args) {
  const ancestor = isString(args[0]) ? args[0] : args[0].id;
  return (isString(args[1]) ? args[1] : args[1].id).startsWith(ancestor + ".");
}
function commonAncestor(first, second) {
  const parentA = parentFqn(first), parentB = parentFqn(second);
  if (parentA === parentB)
    return parentA;
  if (!parentA || !parentB)
    return null;
  const a2 = first.split("."), b2 = second.split(".");
  let ancestor = null;
  for (; a2.length > 1 && b2.length > 1 && a2[0] && a2[0] === b2[0]; )
    ancestor = ancestor ? `${ancestor}.${a2[0]}` : a2[0], a2.shift(), b2.shift();
  return ancestor;
}
function parentFqn(fqn2) {
  const lastDot = fqn2.lastIndexOf(".");
  return lastDot > 0 ? fqn2.slice(0, lastDot) : null;
}
function ancestorsFqn(fqn2) {
  const path = fqn2.split(".");
  return path.pop(), path.length === 0 ? [] : path.reduce((acc, part, idx) => idx === 0 ? (acc.push(part), acc) : (acc.unshift(`${acc[0]}.${part}`), acc), []);
}
function compareFqnHierarchically(a2, b2) {
  const depthA = a2.split(".").length, depthB = b2.split(".").length;
  switch (!0) {
    case depthA > depthB:
      return 1;
    case depthA < depthB:
      return -1;
    default:
      return 0;
  }
}
function compareByFqnHierarchically(a2, b2) {
  return compareFqnHierarchically(a2.id, b2.id);
}
const blue$1 = {
  fill: "#3b82f6",
  stroke: "#2563eb",
  hiContrast: "#eff6ff",
  loContrast: "#bfdbfe"
}, sky$1 = {
  fill: "#0284c7",
  stroke: "#0369a1",
  hiContrast: "#f0f9ff",
  loContrast: "#B6ECF7"
}, slate$1 = {
  fill: "#64748b",
  stroke: "#475569",
  hiContrast: "#f8fafc",
  loContrast: "#cbd5e1"
}, ElementColors = {
  primary: blue$1,
  blue: blue$1,
  secondary: sky$1,
  sky: sky$1,
  muted: slate$1,
  slate: slate$1,
  gray: {
    // fill: colors.neutral[500],
    // stroke: colors.neutral[600],
    // hiContrast: colors.neutral[50],
    // loContrast: colors.neutral[200],
    fill: "#737373",
    stroke: "#525252",
    hiContrast: "#fafafa",
    loContrast: "#d4d4d4"
  },
  red: {
    // fill: colors.red[500],
    // stroke: colors.red[600],
    // hiContrast: colors.red[50],
    // loContrast: colors.red[200],
    fill: "#AC4D39",
    // fill: '#b54548',
    stroke: "#853A2D",
    // hiContrast: '#fef2f2',
    // loContrast: '#fecaca',
    // hiContrast: '#191111', // colors.gray[900],
    // loContrast: '#3b1219' // colors.gray[800],
    hiContrast: "#FBD3CB",
    // hiContrast: '#f8fafc',
    // loContrast: '#fdd8d8' // radix black red 12
    loContrast: "#f5b2a3"
  },
  green: {
    fill: "#428a4f",
    stroke: "#2d5d39",
    hiContrast: "#f8fafc",
    loContrast: "#c2f0c2"
  },
  amber: {
    fill: "#A35829",
    stroke: "#7E451D",
    hiContrast: "#FFE0C2",
    loContrast: "#f9b27c"
  },
  indigo: {
    // fill: colors.indigo[500],
    // stroke: colors.indigo[600],
    // hiContrast: colors.indigo[50],
    // loContrast: colors.indigo[200],
    fill: "#6366f1",
    stroke: "#4f46e5",
    hiContrast: "#eef2ff",
    loContrast: "#c7d2fe"
  }
}, gray = {
  lineColor: "#6E6E6E",
  labelBgColor: "#18191b",
  labelColor: "#C6C6C6"
}, slate = {
  lineColor: "#64748b",
  // 500
  labelBgColor: "#0f172a",
  // 900
  labelColor: "#cbd5e1"
  // 300
}, blue = {
  lineColor: "#3b82f6",
  // 500
  labelBgColor: "#172554",
  // 950
  labelColor: "#60a5fa"
  // 400
}, sky = {
  lineColor: "#0ea5e9",
  // 500
  labelBgColor: "#082f49",
  // 950
  labelColor: "#38bdf8"
  // 400
}, RelationshipColors = {
  amber: {
    lineColor: "#b45309",
    labelBgColor: "#78350f",
    labelColor: "#FFE0C2"
  },
  blue,
  gray,
  green: {
    lineColor: "#15803d",
    // 700
    labelBgColor: "#052e16",
    // 950
    labelColor: "#22c55e"
    // 500
  },
  indigo: {
    lineColor: "#6366f1",
    // 500
    labelBgColor: "#1e1b4b",
    // 950
    labelColor: "#818cf8"
    // 400
  },
  muted: slate,
  primary: blue,
  red: {
    lineColor: "#AC4D39",
    labelBgColor: "#b91c1c",
    labelColor: "#f5b2a3"
  },
  secondary: sky,
  sky,
  slate
}, defaultTheme = {
  elements: ElementColors,
  relationships: RelationshipColors,
  font: "Arial",
  shadow: "#0a0a0a"
};
function getId(element) {
  return t$4(element) ? element : element.id;
}
class LikeC4DiagramModel {
  constructor(view, model) {
    __publicField(this, "_rootElements", /* @__PURE__ */ new Set());
    __publicField(this, "_elements", /* @__PURE__ */ new Map());
    __publicField(this, "_connections");
    this.view = view, this.model = model;
    for (const node2 of view.nodes) {
      const el = new LikeC4DiagramModel.Element(node2, this);
      this._elements.set(node2.id, el), n$2(node2.parent) && this._rootElements.add(el);
    }
    this._connections = new Map(view.edges.map((e2) => [e2.id, new LikeC4DiagramModel.Connection(e2, this)]));
  }
  get isDynamic() {
    return this.view.__ === "dynamic";
  }
  get id() {
    return this.view.id;
  }
  get title() {
    return this.view.title;
  }
  get viewOf() {
    if (n$2(this.view.__) || this.view.__ === "element") {
      const computedView = this.view;
      return computedView.viewOf ? this.model.element(computedView.viewOf) : null;
    }
    return null;
  }
  get tags() {
    return this.view.tags ?? [];
  }
  roots() {
    return [...this._rootElements];
  }
  elements() {
    return [...this._elements.values()];
  }
  element(id2) {
    return nonNullable(this._elements.get(id2), `LikeC4DiagramModel.Element ${id2} in view ${this.view.id} not found`);
  }
  hasElement(id2) {
    return this._elements.has(id2);
  }
  connections() {
    return [...this._connections.values()];
  }
  connection(id2) {
    return nonNullable(this._connections.get(id2), `Connection ${id2} in view ${this.view.id}  not found`);
  }
  findConnections(source, target, direction = "direct") {
    const sourceId = getId(source), targetId = getId(target);
    return this.connections().filter(
      (c) => c.source.id === sourceId && c.target.id === targetId || direction === "both" && c.source.id === targetId && c.target.id === sourceId
    );
  }
  parent(element) {
    const el = this.element(getId(element));
    return el.node.parent ? this.element(el.node.parent) : null;
  }
  children(element) {
    return this.element(getId(element)).node.children.map((c) => this.element(c));
  }
  // Get all sibling (i.e. same parent)
  siblings(element) {
    const id2 = getId(element), parent = this.parent(id2);
    return (parent ? this.children(parent) : this.roots()).filter((e2) => e2.id !== id2);
  }
  /**
   * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
   * (from closest to root)
   */
  ancestors(element) {
    let id2 = getId(element);
    const result = [];
    let parent;
    for (; parent = this.parent(id2); )
      result.push(parent), id2 = parent.id;
    return result;
  }
  descendants(element) {
    return this.children(element).flatMap((c) => [c, ...this.descendants(c.id)]);
  }
  incoming(element, filter2 = "all") {
    const el = this.element(getId(element)), edges = el.node.inEdges.map((e2) => this.connection(e2));
    return filter2 === "all" || edges.length === 0 ? edges : edges.filter((rel) => filter2 === "direct" ? rel.target.id === el.id : rel.target.id !== el.id);
  }
  incomers(element, filter2 = "all") {
    return this.incoming(element, filter2).map((r2) => r2.source);
  }
  /**
   * Outgoing relationships from the element and its descendants
   */
  outgoing(element, filter2 = "all") {
    const el = this.element(getId(element)), edges = el.node.outEdges.map((e2) => this.connection(e2));
    return filter2 === "all" || edges.length === 0 ? edges : edges.filter((rel) => filter2 === "direct" ? rel.source.id === el.id : rel.source.id !== el.id);
  }
  outgoers(element, filter2 = "all") {
    return this.outgoing(element, filter2).map((r2) => r2.target);
  }
}
((LikeC4DiagramModel2) => {
  class Element2 {
    constructor(node2, view) {
      this.node = node2, this.view = view;
    }
    get id() {
      return this.node.id;
    }
    get title() {
      return this.node.title;
    }
    get kind() {
      return this.node.kind;
    }
    get isRoot() {
      return n$2(this.node.parent);
    }
    get hasNested() {
      return this.node.children.length > 0;
    }
    get shape() {
      return this.node.shape;
    }
    get color() {
      return this.node.color;
    }
    get tags() {
      return this.node.tags ?? [];
    }
    get level() {
      return this.node.level;
    }
    get depth() {
      return this.node.depth ?? 0;
    }
    model() {
      return this.view.model.element(this.id);
    }
    parent() {
      return this.node.parent ? this.view.element(this.node.parent) : null;
    }
    metadata(key, defaultValue) {
      return this.model().metadata(key) ?? defaultValue;
    }
    hasMetadata(key) {
      return this.model().hasMetadata(key);
    }
    ancestors() {
      return this.view.ancestors(this);
    }
    siblings() {
      return this.view.siblings(this);
    }
    descendants() {
      return this.view.descendants(this);
    }
    children() {
      return this.view.children(this);
    }
    incoming(filter2 = "all") {
      return this.view.incoming(this, filter2);
    }
    incomers(filter2 = "all") {
      return this.view.incomers(this, filter2);
    }
    outgoing(filter2 = "all") {
      return this.view.outgoing(this, filter2);
    }
    outgoers(filter2 = "all") {
      return this.view.outgoers(this, filter2);
    }
    connectionsTo(target) {
      return this.view.findConnections(this, target);
    }
  }
  LikeC4DiagramModel2.Element = Element2;
  class Connection {
    constructor(edge, view) {
      this.edge = edge, this.view = view;
    }
    get id() {
      return this.edge.id;
    }
    get source() {
      return this.view.element(this.edge.source);
    }
    get target() {
      return this.view.element(this.edge.target);
    }
    get tags() {
      return this.edge.tags ?? [];
    }
    get color() {
      return this.edge.color ?? DefaultRelationshipColor;
    }
    /**
     * Model relationships
     */
    relationships() {
      return this.edge.relations.map((r2) => nonNullable(this.view.model.relationship(r2)));
    }
  }
  LikeC4DiagramModel2.Connection = Connection;
})(LikeC4DiagramModel || (LikeC4DiagramModel = {}));
class LikeC4ViewModel {
  constructor(view, model) {
    __publicField(this, "_rootElements", /* @__PURE__ */ new Set());
    __publicField(this, "_elements", /* @__PURE__ */ new Map());
    __publicField(this, "_connections");
    this.view = view, this.model = model;
    for (const node2 of view.nodes) {
      const el = new LikeC4ViewModel.Element(node2, this);
      this._elements.set(node2.id, el), n$2(node2.parent) && this._rootElements.add(el);
    }
    this._connections = new Map(view.edges.map((e2) => [e2.id, new LikeC4ViewModel.Connection(e2, this)]));
  }
  get id() {
    return this.view.id;
  }
  get title() {
    return this.view.title;
  }
  get viewOf() {
    return this.view.__ !== "dynamic" && this.view.viewOf ? this.model.element(this.view.viewOf) : null;
  }
  get tags() {
    return this.view.tags ?? [];
  }
  roots() {
    return [...this._rootElements];
  }
  elements() {
    return [...this._elements.values()];
  }
  element(id2) {
    return nonNullable(this._elements.get(id2), `LikeC4ViewModel.Element ${id2} in view ${this.id} not found`);
  }
  hasElement(id2) {
    return this._elements.has(id2);
  }
  connections() {
    return [...this._connections.values()];
  }
  connection(id2) {
    return nonNullable(this._connections.get(id2), `Connection ${id2} in view ${this.id}  not found`);
  }
  findConnections(source, target, direction = "direct") {
    const sourceId = getId(source), targetId = getId(target);
    return this.connections().filter(
      (c) => c.source.id === sourceId && c.target.id === targetId || direction === "both" && c.source.id === targetId && c.target.id === sourceId
    );
  }
  parent(element) {
    const el = this.element(getId(element));
    return el.node.parent ? this.element(el.node.parent) : null;
  }
  children(element) {
    return this.element(getId(element)).node.children.map((c) => this.element(c));
  }
  // Get all sibling (i.e. same parent)
  siblings(element) {
    const id2 = getId(element), parent = this.parent(id2);
    return (parent ? this.children(parent) : this.roots()).filter((e2) => e2.id !== id2);
  }
  /**
   * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
   * (from closest to root)
   */
  ancestors(element) {
    let id2 = getId(element);
    const result = [];
    let parent;
    for (; parent = this.parent(id2); )
      result.push(parent), id2 = parent.id;
    return result;
  }
  descendants(element) {
    return this.children(element).flatMap((c) => [c, ...this.descendants(c.id)]);
  }
  incoming(element, filter2 = "all") {
    const el = this.element(getId(element)), edges = el.node.inEdges.map((e2) => nonNullable(this._connections.get(e2), `Edge ${e2} not found`));
    return filter2 === "all" || edges.length === 0 ? edges : edges.filter((rel) => filter2 === "direct" ? rel.target.id === el.id : rel.target.id !== el.id);
  }
  incomers(element, filter2 = "all") {
    return [...new Set(this.incoming(element, filter2).map((r2) => r2.source))];
  }
  /**
   * Outgoing relationships from the element and its descendants
   */
  outgoing(element, filter2 = "all") {
    const el = this.element(getId(element)), edges = el.node.outEdges.map((e2) => nonNullable(this._connections.get(e2), `Edge ${e2} not found`));
    return filter2 === "all" || edges.length === 0 ? edges : edges.filter((rel) => filter2 === "direct" ? rel.source.id === el.id : rel.source.id !== el.id);
  }
  outgoers(element, filter2 = "all") {
    return [...new Set(this.outgoing(element, filter2).map((r2) => r2.target))];
  }
}
((LikeC4ViewModel2) => {
  class Element2 {
    constructor(node2, viewmodel) {
      this.node = node2, this.viewmodel = viewmodel;
    }
    get id() {
      return this.node.id;
    }
    get title() {
      return this.node.title;
    }
    get kind() {
      return this.node.kind;
    }
    get isRoot() {
      return n$2(this.node.parent);
    }
    get hasNested() {
      return this.node.children.length > 0;
    }
    get shape() {
      return this.node.shape;
    }
    get color() {
      return this.node.color;
    }
    get tags() {
      return this.node.tags ?? [];
    }
    model() {
      return this.viewmodel.model.element(this.id);
    }
    parent() {
      return this.node.parent ? this.viewmodel.element(this.node.parent) : null;
    }
    metadata(key, defaultValue) {
      return this.model().metadata(key) ?? defaultValue;
    }
    hasMetadata(key) {
      return this.model().hasMetadata(key);
    }
    ancestors() {
      return this.viewmodel.ancestors(this);
    }
    siblings() {
      return this.viewmodel.siblings(this);
    }
    descendants() {
      return this.viewmodel.descendants(this);
    }
    children() {
      return this.viewmodel.children(this);
    }
    incoming(filter2 = "all") {
      return this.viewmodel.incoming(this, filter2);
    }
    incomers(filter2 = "all") {
      return this.viewmodel.incomers(this, filter2);
    }
    outgoing(filter2 = "all") {
      return this.viewmodel.outgoing(this, filter2);
    }
    outgoers(filter2 = "all") {
      return this.viewmodel.outgoers(this, filter2);
    }
    connectionsTo(target) {
      return this.viewmodel.findConnections(this, target);
    }
  }
  LikeC4ViewModel2.Element = Element2;
  class Connection {
    constructor(edge, viewmodel) {
      this.edge = edge, this.viewmodel = viewmodel;
    }
    get id() {
      return this.edge.id;
    }
    get source() {
      return this.viewmodel.element(this.edge.source);
    }
    get target() {
      return this.viewmodel.element(this.edge.target);
    }
    get tags() {
      return this.edge.tags ?? [];
    }
    /**
     * Model relationships
     */
    relationships() {
      return this.edge.relations.map((r2) => nonNullable(this.viewmodel.model.relationship(r2)));
    }
  }
  LikeC4ViewModel2.Connection = Connection;
})(LikeC4ViewModel || (LikeC4ViewModel = {}));
class LikeC4Model {
  constructor(type, sourcemodel, elements, relations, views, ViewModelClass) {
    __publicField(this, "_elements", /* @__PURE__ */ new Map());
    // Parent element for given FQN
    __publicField(this, "_parents", /* @__PURE__ */ new Map());
    // Children elements for given FQN
    __publicField(this, "_children", /* @__PURE__ */ new Map());
    __publicField(this, "_rootElements", /* @__PURE__ */ new Set());
    __publicField(this, "_relations", /* @__PURE__ */ new Map());
    // Incoming to an element or its descendants
    __publicField(this, "_incoming", /* @__PURE__ */ new Map());
    // Outgoing from an element or its descendants
    __publicField(this, "_outgoing", /* @__PURE__ */ new Map());
    // Relationships inside the element, among descendants
    __publicField(this, "_internal", /* @__PURE__ */ new Map());
    __publicField(this, "_cacheAscendingSiblings", /* @__PURE__ */ new Map());
    __publicField(this, "_views");
    this.type = type, this.sourcemodel = sourcemodel;
    for (const el of elements)
      this.addElement(el);
    for (const rel of relations)
      this.addRelation(rel);
    this._views = new Map(
      x$2(
        r$6(views),
        m$3((a2, b2) => compareNatural(a2.title ?? "untitled", b2.title ?? "untitled")),
        m$2((view) => [view.id, new ViewModelClass(view, this)])
      )
    );
  }
  /**
   * Returns the root elements of the model.
   */
  roots() {
    return [...this._rootElements];
  }
  /**
   * Returns all elements in the model.
   */
  elements() {
    return [...this._elements.values()];
  }
  /**
   * Returns a specific element by its FQN.
   */
  element(id2) {
    return nonNullable(this._elements.get(id2), `Element ${id2} not found`);
  }
  /**
   * Returns all relationships in the model.
   */
  relationships() {
    return [...this._relations.values()];
  }
  /**
   * Returns a specific relationship by its ID.
   */
  relationship(id2) {
    return nonNullable(this._relations.get(id2), `Relation ${id2} not found`);
  }
  /**
   * Returns all views in the model.
   */
  views() {
    return [...this._views.values()];
  }
  /**
   * Returns a specific view by its ID.
   */
  view(viewId) {
    return nonNullable(this._views.get(viewId), `View ${viewId} not found`);
  }
  /**
   * Returns the parent element of given element.
   * @see ancestors
   */
  parent(element) {
    const id2 = getId(element);
    return this._parents.get(id2) || null;
  }
  /**
   * Get all children of the element (only direct children),
   * @see descendants
   */
  children(element) {
    const id2 = getId(element);
    return this._childrenOf(id2);
  }
  /**
   * Get all sibling (i.e. same parent)
   */
  siblings(element) {
    const id2 = getId(element), parent = this._parents.get(id2);
    return (parent ? this._childrenOf(parent.id) : this.roots()).filter((e2) => e2.id !== id2);
  }
  /**
   * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
   * (from closest to root)
   */
  ancestors(element) {
    let id2 = t$4(element) ? element : element.id;
    const result = [];
    let parent;
    for (; parent = this._parents.get(id2); )
      result.push(parent), id2 = parent.id;
    return result;
  }
  /**
   * Get all descendant elements (i.e. children, children’s children, etc.)
   */
  descendants(element) {
    const id2 = getId(element);
    return this._childrenOf(id2).flatMap((c) => [c, ...this.descendants(c.id)]);
  }
  /**
   * Incoming relationships to the element and its descendants
   * @see incomers
   */
  incoming(element, filter2 = "all") {
    const id2 = getId(element), incoming = Array.from(this._incomingTo(id2));
    return filter2 === "all" || incoming.length === 0 ? incoming : incoming.filter((rel) => filter2 === "direct" ? rel.target.id === id2 : rel.target.id !== id2);
  }
  /**
   * Source elements of incoming relationships
   */
  incomers(element, filter2 = "all") {
    return [...new Set(this.incoming(element, filter2).map((r2) => r2.source))];
  }
  /**
   * Outgoing relationships from the element and its descendants
   * @see outgoers
   */
  outgoing(element, filter2 = "all") {
    const id2 = getId(element), outgoing = Array.from(this._outgoingFrom(id2));
    return filter2 === "all" || outgoing.length === 0 ? outgoing : outgoing.filter((rel) => filter2 === "direct" ? rel.source.id === id2 : rel.source.id !== id2);
  }
  /**
   * Target elements of outgoing relationships
   */
  outgoers(element, filter2 = "all") {
    return [...new Set(this.outgoing(element, filter2).map((r2) => r2.target))];
  }
  /**
   * Relationships inside the element, among descendants
   */
  internal(element) {
    const id2 = getId(element);
    return Array.from(this._internalOf(id2));
  }
  /**
   * Resolve siblings of the element and siblings of ancestors
   *  (from closest to root)
   */
  ascendingSiblings(element) {
    const id2 = getId(element);
    let siblings = this._cacheAscendingSiblings.get(id2);
    return siblings || (siblings = [
      ...this.siblings(id2),
      ...this.ancestors(id2).flatMap((a2) => this.siblings(a2.id))
    ], this._cacheAscendingSiblings.set(id2, siblings)), siblings.slice();
  }
  /**
   * Resolve all views that contain the element
   */
  viewsWithElement(element) {
    const id2 = getId(element);
    return [...this._views.values()].filter((v2) => v2.hasElement(id2));
  }
  addElement(parsed) {
    if (this._elements.has(parsed.id))
      throw new Error(`Element ${parsed.id} already exists`);
    const el = new LikeC4Model.ElementModel(parsed, this);
    this._elements.set(el.id, el);
    const parentId = parentFqn(el.id);
    parentId ? (this._parents.set(el.id, this.element(parentId)), this._childrenOf(parentId).push(el)) : this._rootElements.add(el);
  }
  addRelation(relation) {
    if (this._relations.has(relation.id))
      throw new Error(`Relation ${relation.id} already exists`);
    const rel = new LikeC4Model.Relationship(relation, this);
    this._relations.set(rel.id, rel), this._incomingTo(relation.target).add(rel), this._outgoingFrom(relation.source).add(rel);
    const relParent = commonAncestor(relation.source, relation.target);
    if (relParent)
      for (const ancestor of [relParent, ...ancestorsFqn(relParent)])
        this._internalOf(ancestor).add(rel);
    for (const sourceAncestor of ancestorsFqn(relation.source)) {
      if (sourceAncestor === relParent)
        break;
      this._outgoingFrom(sourceAncestor).add(rel);
    }
    for (const targetAncestor of ancestorsFqn(relation.target)) {
      if (targetAncestor === relParent)
        break;
      this._incomingTo(targetAncestor).add(rel);
    }
  }
  _childrenOf(id2) {
    let children2 = this._children.get(id2);
    return children2 || (children2 = [], this._children.set(id2, children2)), children2;
  }
  _incomingTo(id2) {
    let incoming = this._incoming.get(id2);
    return incoming || (incoming = /* @__PURE__ */ new Set(), this._incoming.set(id2, incoming)), incoming;
  }
  _outgoingFrom(id2) {
    let outgoing = this._outgoing.get(id2);
    return outgoing || (outgoing = /* @__PURE__ */ new Set(), this._outgoing.set(id2, outgoing)), outgoing;
  }
  _internalOf(id2) {
    let internal = this._internal.get(id2);
    return internal || (internal = /* @__PURE__ */ new Set(), this._internal.set(id2, internal)), internal;
  }
}
((LikeC4Model2) => {
  function create2(source) {
    return source.__ === "layouted" ? LikeC4Model2.layouted(source) : LikeC4Model2.computed(source);
  }
  LikeC4Model2.create = create2;
  function computed2(source) {
    return new LikeC4Model2(
      "computed",
      source,
      r$6(source.elements),
      r$6(source.relations),
      source.views,
      LikeC4ViewModel
    );
  }
  LikeC4Model2.computed = computed2;
  function layouted(source) {
    return new LikeC4Model2(
      "layouted",
      source,
      r$6(source.elements),
      r$6(source.relations),
      source.views,
      LikeC4DiagramModel
    );
  }
  LikeC4Model2.layouted = layouted;
  function isModel(model) {
    return model instanceof LikeC4Model2;
  }
  LikeC4Model2.isModel = isModel, ((ViewModel2) => {
    function isLayouted2(model) {
      return model instanceof LikeC4DiagramModel;
    }
    ViewModel2.isLayouted = isLayouted2;
  })(LikeC4Model2.ViewModel || (LikeC4Model2.ViewModel = {}));
  function isLayouted(model) {
    return model.type === "layouted";
  }
  LikeC4Model2.isLayouted = isLayouted;
  class Relationship2 {
    constructor(relationship, model) {
      this.relationship = relationship, this.model = model;
    }
    get id() {
      return this.relationship.id;
    }
    get title() {
      return this.relationship.title;
    }
    get kind() {
      return this.relationship.kind ?? null;
    }
    get tags() {
      return this.relationship.tags ?? [];
    }
    get source() {
      return this.model.element(this.relationship.source);
    }
    get target() {
      return this.model.element(this.relationship.target);
    }
    metadata(key, defaultValue) {
      var _a4;
      return ((_a4 = this.relationship.metadata) == null ? void 0 : _a4[key]) ?? defaultValue;
    }
    hasMetadata(key) {
      var _a4;
      return n$4((_a4 = this.relationship.metadata) == null ? void 0 : _a4[key]);
    }
  }
  LikeC4Model2.Relationship = Relationship2;
  class ElementModel {
    constructor(element, model) {
      this.element = element, this.model = model;
    }
    get id() {
      return this.element.id;
    }
    get title() {
      return this.element.title;
    }
    get kind() {
      return this.element.kind;
    }
    get isRoot() {
      return parentFqn(this.element.id) === null;
    }
    get hasNested() {
      return this.model.children(this).length > 0;
    }
    get shape() {
      return this.element.shape ?? DefaultElementShape;
    }
    get color() {
      return this.element.color ?? DefaultThemeColor;
    }
    get tags() {
      return this.element.tags ?? [];
    }
    parent() {
      return this.model.parent(this);
    }
    metadata(key, defaultValue) {
      var _a4;
      return ((_a4 = this.element.metadata) == null ? void 0 : _a4[key]) ?? defaultValue;
    }
    hasMetadata(key) {
      var _a4;
      return n$4((_a4 = this.element.metadata) == null ? void 0 : _a4[key]);
    }
    ancestors() {
      return this.model.ancestors(this);
    }
    siblings() {
      return this.model.siblings(this);
    }
    descendants() {
      return this.model.descendants(this);
    }
    children() {
      return this.model.children(this);
    }
    /**
     * First 'view of' current element
     */
    viewOf() {
      return this.model.views().find((v2) => {
        var _a4;
        return ((_a4 = v2.viewOf) == null ? void 0 : _a4.id) === this.id;
      }) ?? null;
    }
    /**
     * All views 'view of' current element
     */
    viewsOf() {
      return this.model.views().filter((v2) => {
        var _a4;
        return ((_a4 = v2.viewOf) == null ? void 0 : _a4.id) === this.id;
      });
    }
    /**
     * Views that contain this element
     */
    views() {
      return this.model.viewsWithElement(this);
    }
    incoming(filter2) {
      return this.model.incoming(this, filter2);
    }
    incomers(filter2) {
      return this.model.incomers(this, filter2);
    }
    outgoing(filter2) {
      return this.model.outgoing(this, filter2);
    }
    outgoers(filter2) {
      return this.model.outgoers(this, filter2);
    }
    internal() {
      return this.model.internal(this);
    }
    /**
     * Resolve siblings of the element and siblings of ancestors
     *  (from closest to root)
     */
    ascendingSiblings() {
      return this.model.ascendingSiblings(this);
    }
    // public *descendants(): IterableIterator<LikeC4Element> {
    //   return
    // }
  }
  LikeC4Model2.ElementModel = ElementModel;
})(LikeC4Model || (LikeC4Model = {}));
const DELAY = "LIKEC4_DELAY";
function delay$1(...args) {
  let ms = 100;
  return args.length === 2 ? ms = o$8(args[0], args[1]) : args.length === 1 && (ms = args[0]), new Promise((resolve) => {
    setTimeout(() => {
      resolve(DELAY);
    }, ms ?? 100);
  });
}
const compareRelations = (a2, b2) => {
  const parentA = commonAncestor(a2.source, a2.target), parentB = commonAncestor(b2.source, b2.target);
  if (parentA && !parentB)
    return 1;
  if (!parentA && parentB)
    return -1;
  const compareParents = parentA && parentB ? compareFqnHierarchically(parentA, parentB) : 0;
  if (compareParents !== 0)
    return compareParents;
  const compareSource = compareFqnHierarchically(a2.source, b2.source);
  return compareSource !== 0 ? compareSource : compareFqnHierarchically(a2.target, b2.target);
};
var __assign$1 = function() {
  return __assign$1 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && (t2[p2] = s2[p2]);
    }
    return t2;
  }, __assign$1.apply(this, arguments);
};
function __rest$1(s2, e2) {
  var t2 = {};
  for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0 && (t2[p2] = s2[p2]);
  if (s2 != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++)
      e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]) && (t2[p2[i2]] = s2[p2[i2]]);
  return t2;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++)
    (ar || !(i2 in from)) && (ar || (ar = Array.prototype.slice.call(from, 0, i2)), ar[i2] = from[i2]);
  return to.concat(ar || Array.prototype.slice.call(from));
}
var zeroRightClassName = "right-scroll-bar-position", fullWidthClassName = "width-before-scroll-bar", noScrollbarsClassName = "with-scroll-bars-hidden", removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef$1(ref, value) {
  return typeof ref == "function" ? ref(value) : ref && (ref.current = value), ref;
}
function useCallbackRef$1(initialValue, callback) {
  var ref = useState(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          last !== value && (ref.value = value, ref.callback(value, last));
        }
      }
    };
  })[0];
  return ref.callback = callback, ref.facade;
}
var useIsomorphicLayoutEffect$2 = typeof window < "u" ? React.useLayoutEffect : React.useEffect, currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef$1(null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef$1(ref, newValue);
    });
  });
  return useIsomorphicLayoutEffect$2(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue), nextRefs_1 = new Set(refs), current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        nextRefs_1.has(ref) || assignRef$1(ref, null);
      }), nextRefs_1.forEach(function(ref) {
        prevRefs_1.has(ref) || assignRef$1(ref, current_1);
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]), callbackRef;
}
function ItoI(a2) {
  return a2;
}
function innerCreateMedium(defaults, middleware) {
  middleware === void 0 && (middleware = ItoI);
  var buffer = [], assigned = !1, medium = {
    read: function() {
      if (assigned)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return buffer.length ? buffer[buffer.length - 1] : defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      return buffer.push(item), function() {
        buffer = buffer.filter(function(x2) {
          return x2 !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      for (assigned = !0; buffer.length; ) {
        var cbs = buffer;
        buffer = [], cbs.forEach(cb);
      }
      buffer = {
        push: function(x2) {
          return cb(x2);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = !0;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [], cbs.forEach(cb), pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [], cbs2.forEach(cb);
      }, cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle(), buffer = {
        push: function(x2) {
          pendingQueue.push(x2), cycle();
        },
        filter: function(filter2) {
          return pendingQueue = pendingQueue.filter(filter2), buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  options === void 0 && (options = {});
  var medium = innerCreateMedium(null);
  return medium.options = __assign$1({ async: !0, ssr: !1 }, options), medium;
}
var SideCar$1 = function(_a4) {
  var sideCar = _a4.sideCar, rest = __rest$1(_a4, ["sideCar"]);
  if (!sideCar)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var Target = sideCar.read();
  if (!Target)
    throw new Error("Sidecar medium not found");
  return React.createElement(Target, __assign$1({}, rest));
};
SideCar$1.isSideCarExport = !0;
function exportSidecar(medium, exported) {
  return medium.useMedium(exported), SideCar$1;
}
var effectCar = createSidecarMedium(), nothing = function() {
}, RemoveScroll$1 = React.forwardRef(function(props, parentRef) {
  var ref = React.useRef(null), _a4 = React.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a4[0], setCallbacks = _a4[1], forwardProps = props.forwardProps, children2 = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b2 = props.as, Container = _b2 === void 0 ? "div" : _b2, gapMode = props.gapMode, rest = __rest$1(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), SideCar2 = sideCar, containerRef = useMergeRefs([ref, parentRef]), containerProps = __assign$1(__assign$1({}, rest), callbacks);
  return React.createElement(
    React.Fragment,
    null,
    enabled && React.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? React.cloneElement(React.Children.only(children2), __assign$1(__assign$1({}, containerProps), { ref: containerRef })) : React.createElement(Container, __assign$1({}, containerProps, { className, ref: containerRef }), children2)
  );
});
RemoveScroll$1.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
RemoveScroll$1.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var currentNonce, getNonce = function() {
  if (currentNonce)
    return currentNonce;
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  return nonce && tag.setAttribute("nonce", nonce), tag;
}
function injectStyles$1(tag, css) {
  tag.styleSheet ? tag.styleSheet.cssText = css : tag.appendChild(document.createTextNode(css));
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0, stylesheet = null;
  return {
    add: function(style2) {
      counter == 0 && (stylesheet = makeStyleTag()) && (injectStyles$1(stylesheet, style2), insertStyleTag(stylesheet)), counter++;
    },
    remove: function() {
      counter--, !counter && stylesheet && (stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet), stylesheet = null);
    }
  };
}, styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React.useEffect(function() {
      return sheet.add(styles), function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
}, styleSingleton = function() {
  var useStyle2 = styleHookSingleton(), Sheet = function(_a4) {
    var styles = _a4.styles, dynamic = _a4.dynamic;
    return useStyle2(styles, dynamic), null;
  };
  return Sheet;
}, zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, parse$1 = function(x2) {
  return parseInt(x2 || "", 10) || 0;
}, getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body), left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"], top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"], right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse$1(left), parse$1(top), parse$1(right)];
}, getGapWidth = function(gapMode) {
  if (gapMode === void 0 && (gapMode = "margin"), typeof window > "u")
    return zeroGap;
  var offsets = getOffset(gapMode), documentWidth = document.documentElement.clientWidth, windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
}, Style = styleSingleton(), lockAttribute = "data-scroll-locked", getStyles = function(_a4, allowRelative, gapMode, important) {
  var left = _a4.left, top = _a4.top, right = _a4.right, gap = _a4.gap;
  return gapMode === void 0 && (gapMode = "margin"), `
  .`.concat(noScrollbarsClassName, ` {
   overflow: hidden `).concat(important, `;
   padding-right: `).concat(gap, "px ").concat(important, `;
  }
  body[`).concat(lockAttribute, `] {
    overflow: hidden `).concat(important, `;
    overscroll-behavior: contain;
    `).concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && `
    padding-left: `.concat(left, `px;
    padding-top: `).concat(top, `px;
    padding-right: `).concat(right, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(gap, "px ").concat(important, `;
    `),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(zeroRightClassName, ` {
    right: `).concat(gap, "px ").concat(important, `;
  }
  
  .`).concat(fullWidthClassName, ` {
    margin-right: `).concat(gap, "px ").concat(important, `;
  }
  
  .`).concat(zeroRightClassName, " .").concat(zeroRightClassName, ` {
    right: 0 `).concat(important, `;
  }
  
  .`).concat(fullWidthClassName, " .").concat(fullWidthClassName, ` {
    margin-right: 0 `).concat(important, `;
  }
  
  body[`).concat(lockAttribute, `] {
    `).concat(removedBarSizeVariable, ": ").concat(gap, `px;
  }
`);
}, getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
}, useLockAttribute = function() {
  React.useEffect(function() {
    return document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString()), function() {
      var newCounter = getCurrentUseCounter() - 1;
      newCounter <= 0 ? document.body.removeAttribute(lockAttribute) : document.body.setAttribute(lockAttribute, newCounter.toString());
    };
  }, []);
}, RemoveScrollBar = function(_a4) {
  var noRelative = _a4.noRelative, noImportant = _a4.noImportant, _b2 = _a4.gapMode, gapMode = _b2 === void 0 ? "margin" : _b2;
  useLockAttribute();
  var gap = React.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, noImportant ? "" : "!important") });
}, passiveSupported = !1;
if (typeof window < "u")
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function() {
        return passiveSupported = !0, !0;
      }
    });
    window.addEventListener("test", options, options), window.removeEventListener("test", options, options);
  } catch {
    passiveSupported = !1;
  }
var nonPassive = passiveSupported ? { passive: !1 } : !1, alwaysContainsScroll = function(node2) {
  return node2.tagName === "TEXTAREA";
}, elementCanBeScrolled = function(node2, overflow) {
  if (!(node2 instanceof Element))
    return !1;
  var styles = window.getComputedStyle(node2);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node2) && styles[overflow] === "visible")
  );
}, elementCouldBeVScrolled = function(node2) {
  return elementCanBeScrolled(node2, "overflowY");
}, elementCouldBeHScrolled = function(node2) {
  return elementCanBeScrolled(node2, "overflowX");
}, locationCouldBeScrolled = function(axis, node2) {
  var ownerDocument = node2.ownerDocument, current = node2;
  do {
    typeof ShadowRoot < "u" && current instanceof ShadowRoot && (current = current.host);
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a4 = getScrollVariables(axis, current), scrollHeight = _a4[1], clientHeight = _a4[2];
      if (scrollHeight > clientHeight)
        return !0;
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return !1;
}, getVScrollVariables = function(_a4) {
  var scrollTop = _a4.scrollTop, scrollHeight = _a4.scrollHeight, clientHeight = _a4.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
}, getHScrollVariables = function(_a4) {
  var scrollLeft = _a4.scrollLeft, scrollWidth = _a4.scrollWidth, clientWidth = _a4.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
}, elementCouldBeScrolled = function(axis, node2) {
  return axis === "v" ? elementCouldBeVScrolled(node2) : elementCouldBeHScrolled(node2);
}, getScrollVariables = function(axis, node2) {
  return axis === "v" ? getVScrollVariables(node2) : getHScrollVariables(node2);
}, getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
}, handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction), delta = directionFactor * sourceDelta, target = event.target, targetInLock = endTarget.contains(target), shouldCancelScroll = !1, isDeltaPositive = delta > 0, availableScroll = 0, availableScrollTop = 0;
  do {
    var _a4 = getScrollVariables(axis, target), position2 = _a4[0], scroll_1 = _a4[1], capacity = _a4[2], elementScroll = scroll_1 - capacity - directionFactor * position2;
    (position2 || elementScroll) && elementCouldBeScrolled(axis, target) && (availableScroll += elementScroll, availableScrollTop += position2), target instanceof ShadowRoot ? target = target.host : target = target.parentNode;
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  return (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll) || !isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) && (shouldCancelScroll = !0), shouldCancelScroll;
}, getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
}, getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
}, extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
}, deltaCompare = function(x2, y2) {
  return x2[0] === y2[0] && x2[1] === y2[1];
}, generateStyle = function(id2) {
  return `
  .block-interactivity-`.concat(id2, ` {pointer-events: none;}
  .allow-interactivity-`).concat(id2, ` {pointer-events: all;}
`);
}, idCounter$1 = 0, lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React.useRef([]), touchStartRef = React.useRef([0, 0]), activeAxis = React.useRef(), id2 = React.useState(idCounter$1++)[0], Style2 = React.useState(styleSingleton)[0], lastProps = React.useRef(props);
  React.useEffect(function() {
    lastProps.current = props;
  }, [props]), React.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id2));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), !0).filter(Boolean);
      return allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id2));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(id2)), allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id2));
        });
      };
    }
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey)
      return !lastProps.current.allowPinchZoom;
    var touch = getTouchXY(event), touchStart = touchStartRef.current, deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0], deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1], currentAxis, target = event.target, moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range")
      return !1;
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection)
      return !0;
    if (canBeScrolledInMainDirection ? currentAxis = moveDirection : (currentAxis = moveDirection === "v" ? "h" : "v", canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target)), !canBeScrolledInMainDirection)
      return !1;
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY) && (activeAxis.current = currentAxis), !currentAxis)
      return !0;
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, !0);
  }, []), shouldPrevent = React.useCallback(function(_event) {
    var event = _event;
    if (!(!lockStack.length || lockStack[lockStack.length - 1] !== Style2)) {
      var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event), sourceEvent2 = shouldPreventQueue.current.filter(function(e2) {
        return e2.name === event.type && (e2.target === event.target || event.target === e2.shadowParent) && deltaCompare(e2.delta, delta);
      })[0];
      if (sourceEvent2 && sourceEvent2.should) {
        event.cancelable && event.preventDefault();
        return;
      }
      if (!sourceEvent2) {
        var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node2) {
          return node2.contains(event.target);
        }), shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
        shouldStop && event.cancelable && event.preventDefault();
      }
    }
  }, []), shouldCancel = React.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event), setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e2) {
        return e2 !== event;
      });
    }, 1);
  }, []), scrollTouchStart = React.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event), activeAxis.current = void 0;
  }, []), scrollWheel = React.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []), scrollTouchMove = React.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React.useEffect(function() {
    return lockStack.push(Style2), props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    }), document.addEventListener("wheel", shouldPrevent, nonPassive), document.addEventListener("touchmove", shouldPrevent, nonPassive), document.addEventListener("touchstart", scrollTouchStart, nonPassive), function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      }), document.removeEventListener("wheel", shouldPrevent, nonPassive), document.removeEventListener("touchmove", shouldPrevent, nonPassive), document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React.createElement(
    React.Fragment,
    null,
    inert ? React.createElement(Style2, { styles: generateStyle(id2) }) : null,
    removeScrollBar ? React.createElement(RemoveScrollBar, { gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node2) {
  for (var shadowParent = null; node2 !== null; )
    node2 instanceof ShadowRoot && (shadowParent = node2.host, node2 = node2.host), node2 = node2.parentNode;
  return shadowParent;
}
const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = React.forwardRef(function(props, ref) {
  return React.createElement(RemoveScroll$1, __assign$1({}, props, { ref, sideCar: SideCar }));
});
ReactRemoveScroll.classNames = RemoveScroll$1.classNames;
const RemoveScroll = ReactRemoveScroll;
function keys(object2) {
  return Object.keys(object2);
}
function isObject(item) {
  return item && typeof item == "object" && !Array.isArray(item);
}
function deepMerge(target, source) {
  const result = { ...target }, _source = source;
  return isObject(target) && isObject(source) && Object.keys(source).forEach((key) => {
    isObject(_source[key]) && key in target ? result[key] = deepMerge(result[key], _source[key]) : result[key] = _source[key];
  }), result;
}
function camelToKebabCase(value) {
  return value.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`);
}
function getTransformedScaledValue(value) {
  var _a4;
  return typeof value != "string" || !value.includes("var(--mantine-scale)") ? value : (_a4 = value.match(/^calc\((.*?)\)$/)) == null ? void 0 : _a4[1].split("*")[0].trim();
}
function px$1(value) {
  const transformedValue = getTransformedScaledValue(value);
  return typeof transformedValue == "number" ? transformedValue : typeof transformedValue == "string" ? transformedValue.includes("calc") || transformedValue.includes("var") ? transformedValue : transformedValue.includes("px") ? Number(transformedValue.replace("px", "")) : transformedValue.includes("rem") ? Number(transformedValue.replace("rem", "")) * 16 : transformedValue.includes("em") ? Number(transformedValue.replace("em", "")) * 16 : Number(transformedValue) : NaN;
}
function scaleRem(remValue) {
  return remValue === "0rem" ? "0rem" : `calc(${remValue} * var(--mantine-scale))`;
}
function createConverter(units, { shouldScale = !1 } = {}) {
  function converter(value) {
    if (value === 0 || value === "0")
      return `0${units}`;
    if (typeof value == "number") {
      const val = `${value / 16}${units}`;
      return shouldScale ? scaleRem(val) : val;
    }
    if (typeof value == "string") {
      if (value === "" || value.startsWith("calc(") || value.startsWith("clamp(") || value.includes("rgba("))
        return value;
      if (value.includes(","))
        return value.split(",").map((val) => converter(val)).join(",");
      if (value.includes(" "))
        return value.split(" ").map((val) => converter(val)).join(" ");
      if (value.includes(units))
        return shouldScale ? scaleRem(value) : value;
      const replaced = value.replace("px", "");
      if (!Number.isNaN(Number(replaced))) {
        const val = `${Number(replaced) / 16}${units}`;
        return shouldScale ? scaleRem(val) : val;
      }
    }
    return value;
  }
  return converter;
}
const rem = createConverter("rem", { shouldScale: !0 }), em = createConverter("em");
function filterProps$1(props) {
  return Object.keys(props).reduce((acc, key) => (props[key] !== void 0 && (acc[key] = props[key]), acc), {});
}
function isNumberLike(value) {
  if (typeof value == "number")
    return !0;
  if (typeof value == "string") {
    if (value.startsWith("calc(") || value.startsWith("var(") || value.includes(" ") && value.trim() !== "")
      return !0;
    const cssUnitsRegex = /^[+-]?[0-9]+(\.[0-9]+)?(px|em|rem|ex|ch|lh|rlh|vw|vh|vmin|vmax|vb|vi|svw|svh|lvw|lvh|dvw|dvh|cm|mm|in|pt|pc|q|cqw|cqh|cqi|cqb|cqmin|cqmax|%)?$/;
    return value.trim().split(/\s+/).every((val) => cssUnitsRegex.test(val));
  }
  return !1;
}
function isElement$1(value) {
  return Array.isArray(value) || value === null ? !1 : typeof value == "object" ? value.type !== Fragment$1 : !1;
}
function createSafeContext(errorMessage) {
  const Context = createContext(null);
  return [({ children: children2, value }) => /* @__PURE__ */ jsx(Context.Provider, { value, children: children2 }), () => {
    const ctx = useContext(Context);
    if (ctx === null)
      throw new Error(errorMessage);
    return ctx;
  }];
}
function createOptionalContext(initialValue = null) {
  const Context = createContext(initialValue);
  return [({ children: children2, value }) => /* @__PURE__ */ jsx(Context.Provider, { value, children: children2 }), () => useContext(Context)];
}
function getSafeId(uid, errorMessage) {
  return (value) => {
    if (typeof value != "string" || value.trim().length === 0)
      throw new Error(errorMessage);
    return `${uid}-${value}`;
  };
}
function findElementAncestor(element, selector2) {
  let _element = element;
  for (; (_element = _element.parentElement) && !_element.matches(selector2); )
    ;
  return _element;
}
function getPreviousIndex(current, elements, loop) {
  for (let i2 = current - 1; i2 >= 0; i2 -= 1)
    if (!elements[i2].disabled)
      return i2;
  if (loop) {
    for (let i2 = elements.length - 1; i2 > -1; i2 -= 1)
      if (!elements[i2].disabled)
        return i2;
  }
  return current;
}
function getNextIndex(current, elements, loop) {
  for (let i2 = current + 1; i2 < elements.length; i2 += 1)
    if (!elements[i2].disabled)
      return i2;
  if (loop) {
    for (let i2 = 0; i2 < elements.length; i2 += 1)
      if (!elements[i2].disabled)
        return i2;
  }
  return current;
}
function onSameLevel(target, sibling, parentSelector) {
  return findElementAncestor(target, parentSelector) === findElementAncestor(sibling, parentSelector);
}
function createScopedKeydownHandler({
  parentSelector,
  siblingSelector,
  onKeyDown,
  loop = !0,
  activateOnFocus = !1,
  dir = "rtl",
  orientation
}) {
  return (event) => {
    var _a4;
    onKeyDown == null || onKeyDown(event);
    const elements = Array.from(
      ((_a4 = findElementAncestor(event.currentTarget, parentSelector)) == null ? void 0 : _a4.querySelectorAll(
        siblingSelector
      )) || []
    ).filter((node2) => onSameLevel(event.currentTarget, node2, parentSelector)), current = elements.findIndex((el) => event.currentTarget === el), _nextIndex = getNextIndex(current, elements, loop), _previousIndex = getPreviousIndex(current, elements, loop), nextIndex = dir === "rtl" ? _previousIndex : _nextIndex, previousIndex = dir === "rtl" ? _nextIndex : _previousIndex;
    switch (event.key) {
      case "ArrowRight": {
        orientation === "horizontal" && (event.stopPropagation(), event.preventDefault(), elements[nextIndex].focus(), activateOnFocus && elements[nextIndex].click());
        break;
      }
      case "ArrowLeft": {
        orientation === "horizontal" && (event.stopPropagation(), event.preventDefault(), elements[previousIndex].focus(), activateOnFocus && elements[previousIndex].click());
        break;
      }
      case "ArrowUp": {
        orientation === "vertical" && (event.stopPropagation(), event.preventDefault(), elements[_previousIndex].focus(), activateOnFocus && elements[_previousIndex].click());
        break;
      }
      case "ArrowDown": {
        orientation === "vertical" && (event.stopPropagation(), event.preventDefault(), elements[_nextIndex].focus(), activateOnFocus && elements[_nextIndex].click());
        break;
      }
      case "Home": {
        event.stopPropagation(), event.preventDefault(), !elements[0].disabled && elements[0].focus();
        break;
      }
      case "End": {
        event.stopPropagation(), event.preventDefault();
        const last = elements.length - 1;
        !elements[last].disabled && elements[last].focus();
        break;
      }
    }
  };
}
const elevations = {
  app: 100,
  modal: 200,
  popover: 300,
  overlay: 400,
  max: 9999
};
function getDefaultZIndex(level) {
  return elevations[level];
}
const noop$3 = () => {
};
function closeOnEscape(callback, options = { active: !0 }) {
  return typeof callback != "function" || !options.active ? options.onKeyDown || noop$3 : (event) => {
    var _a4;
    event.key === "Escape" && (callback(event), (_a4 = options.onTrigger) == null || _a4.call(options));
  };
}
function getSize(size2, prefix = "size", convertToRem = !0) {
  if (size2 !== void 0)
    return isNumberLike(size2) ? convertToRem ? rem(size2) : size2 : `var(--${prefix}-${size2})`;
}
function getSpacing(size2) {
  return getSize(size2, "mantine-spacing");
}
function getRadius$1(size2) {
  return size2 === void 0 ? "var(--mantine-radius-default)" : getSize(size2, "mantine-radius");
}
function getFontSize(size2) {
  return getSize(size2, "mantine-font-size");
}
function getLineHeight(size2) {
  return getSize(size2, "mantine-line-height", !1);
}
function getShadow(size2) {
  if (size2)
    return getSize(size2, "mantine-shadow", !1);
}
function createEventHandler(parentEventHandler, eventHandler) {
  return (event) => {
    parentEventHandler == null || parentEventHandler(event), eventHandler == null || eventHandler(event);
  };
}
function getContextItemIndex(elementSelector, parentSelector, node2) {
  var _a4;
  return node2 ? Array.from(
    ((_a4 = findElementAncestor(node2, parentSelector)) == null ? void 0 : _a4.querySelectorAll(elementSelector)) || []
  ).findIndex((element) => element === node2) : null;
}
function useHovered() {
  const [hovered, setHovered] = useState(-1);
  return [hovered, { setHovered, resetHovered: () => setHovered(-1) }];
}
function clamp$3(value, min2, max2) {
  return min2 === void 0 && max2 === void 0 ? value : min2 !== void 0 && max2 === void 0 ? Math.max(value, min2) : Math.min(min2 === void 0 && max2 !== void 0 ? value : Math.max(value, min2), max2);
}
function randomId() {
  return `mantine-${Math.random().toString(36).slice(2, 11)}`;
}
function useCallbackRef(callback) {
  const callbackRef = useRef(callback);
  return useEffect(() => {
    callbackRef.current = callback;
  }), useMemo(() => (...args) => {
    var _a4;
    return (_a4 = callbackRef.current) == null ? void 0 : _a4.call(callbackRef, ...args);
  }, []);
}
function useDebouncedCallback$1(callback, delay2) {
  const handleCallback = useCallbackRef(callback), debounceTimerRef = useRef(0);
  return useEffect(() => () => window.clearTimeout(debounceTimerRef.current), []), useCallback(
    (...args) => {
      window.clearTimeout(debounceTimerRef.current), debounceTimerRef.current = window.setTimeout(() => handleCallback(...args), delay2);
    },
    [handleCallback, delay2]
  );
}
const DEFAULT_EVENTS = ["mousedown", "touchstart"];
function useClickOutside(handler, events, nodes) {
  const ref = useRef();
  return useEffect(() => {
    const listener = (event) => {
      const { target } = event ?? {};
      if (Array.isArray(nodes)) {
        const shouldIgnore = (target == null ? void 0 : target.hasAttribute("data-ignore-outside-clicks")) || !document.body.contains(target) && target.tagName !== "HTML";
        nodes.every((node2) => !!node2 && !event.composedPath().includes(node2)) && !shouldIgnore && handler();
      } else ref.current && !ref.current.contains(target) && handler();
    };
    return (events || DEFAULT_EVENTS).forEach((fn) => document.addEventListener(fn, listener)), () => {
      (events || DEFAULT_EVENTS).forEach((fn) => document.removeEventListener(fn, listener));
    };
  }, [ref, handler, nodes]), ref;
}
function useClipboard({ timeout: timeout2 = 2e3 } = {}) {
  const [error, setError] = useState(null), [copied, setCopied] = useState(!1), [copyTimeout, setCopyTimeout] = useState(null), handleCopyResult = (value) => {
    window.clearTimeout(copyTimeout), setCopyTimeout(window.setTimeout(() => setCopied(!1), timeout2)), setCopied(value);
  };
  return { copy: (valueToCopy) => {
    "clipboard" in navigator ? navigator.clipboard.writeText(valueToCopy).then(() => handleCopyResult(!0)).catch((err) => setError(err)) : setError(new Error("useClipboard: navigator.clipboard is not supported"));
  }, reset: () => {
    setCopied(!1), setError(null), window.clearTimeout(copyTimeout);
  }, error, copied };
}
function attachMediaListener(query, callback) {
  try {
    return query.addEventListener("change", callback), () => query.removeEventListener("change", callback);
  } catch {
    return query.addListener(callback), () => query.removeListener(callback);
  }
}
function getInitialValue(query, initialValue) {
  return typeof window < "u" && "matchMedia" in window ? window.matchMedia(query).matches : !1;
}
function useMediaQuery(query, initialValue, { getInitialValueInEffect } = {
  getInitialValueInEffect: !0
}) {
  const [matches, setMatches] = useState(
    getInitialValueInEffect ? initialValue : getInitialValue(query)
  ), queryRef = useRef();
  return useEffect(() => {
    if ("matchMedia" in window)
      return queryRef.current = window.matchMedia(query), setMatches(queryRef.current.matches), attachMediaListener(queryRef.current, (event) => setMatches(event.matches));
  }, [query]), matches;
}
function useColorScheme$1(initialValue, options) {
  return useMediaQuery("(prefers-color-scheme: dark)", initialValue === "dark", options) ? "dark" : "light";
}
function useDebouncedValue(value, wait, options = { leading: !1 }) {
  const [_value, setValue] = useState(value), mountedRef = useRef(!1), timeoutRef = useRef(null), cooldownRef = useRef(!1), cancel = () => window.clearTimeout(timeoutRef.current);
  return useEffect(() => {
    mountedRef.current && (!cooldownRef.current && options.leading ? (cooldownRef.current = !0, setValue(value)) : (cancel(), timeoutRef.current = window.setTimeout(() => {
      cooldownRef.current = !1, setValue(value);
    }, wait)));
  }, [value, options.leading, wait]), useEffect(() => (mountedRef.current = !0, cancel), []), [_value, cancel];
}
const useIsomorphicEffect = typeof document < "u" ? useLayoutEffect : useEffect;
function useDidUpdate(fn, dependencies) {
  const mounted = useRef(!1);
  useEffect(
    () => () => {
      mounted.current = !1;
    },
    []
  ), useEffect(() => {
    if (mounted.current)
      return fn();
    mounted.current = !0;
  }, dependencies);
}
function useFocusReturn({ opened, shouldReturnFocus = !0 }) {
  const lastActiveElement = useRef(), returnFocus = () => {
    var _a4;
    lastActiveElement.current && "focus" in lastActiveElement.current && typeof lastActiveElement.current.focus == "function" && ((_a4 = lastActiveElement.current) == null || _a4.focus({ preventScroll: !0 }));
  };
  return useDidUpdate(() => {
    let timeout2 = -1;
    const clearFocusTimeout = (event) => {
      event.key === "Tab" && window.clearTimeout(timeout2);
    };
    return document.addEventListener("keydown", clearFocusTimeout), opened ? lastActiveElement.current = document.activeElement : shouldReturnFocus && (timeout2 = window.setTimeout(returnFocus, 10)), () => {
      window.clearTimeout(timeout2), document.removeEventListener("keydown", clearFocusTimeout);
    };
  }, [opened, shouldReturnFocus]), returnFocus;
}
const TABBABLE_NODES = /input|select|textarea|button|object/, FOCUS_SELECTOR = "a, input, select, textarea, button, object, [tabindex]";
function hidden(element) {
  return element.style.display === "none";
}
function visible(element) {
  if (element.getAttribute("aria-hidden") || element.getAttribute("hidden") || element.getAttribute("type") === "hidden")
    return !1;
  let parentElement = element;
  for (; parentElement && !(parentElement === document.body || parentElement.nodeType === 11); ) {
    if (hidden(parentElement))
      return !1;
    parentElement = parentElement.parentNode;
  }
  return !0;
}
function getElementTabIndex(element) {
  let tabIndex = element.getAttribute("tabindex");
  return tabIndex === null && (tabIndex = void 0), parseInt(tabIndex, 10);
}
function focusable(element) {
  const nodeName = element.nodeName.toLowerCase(), isTabIndexNotNaN = !Number.isNaN(getElementTabIndex(element));
  return /* @ts-expect-error function accepts any html element but if it is a button, it should not be disabled to trigger the condition */ (TABBABLE_NODES.test(nodeName) && !element.disabled || element instanceof HTMLAnchorElement && element.href || isTabIndexNotNaN) && visible(element);
}
function tabbable(element) {
  const tabIndex = getElementTabIndex(element);
  return (Number.isNaN(tabIndex) || tabIndex >= 0) && focusable(element);
}
function findTabbableDescendants(element) {
  return Array.from(element.querySelectorAll(FOCUS_SELECTOR)).filter(tabbable);
}
function scopeTab(node2, event) {
  const tabbable2 = findTabbableDescendants(node2);
  if (!tabbable2.length) {
    event.preventDefault();
    return;
  }
  const finalTabbable = tabbable2[event.shiftKey ? 0 : tabbable2.length - 1], root2 = node2.getRootNode();
  let leavingFinalTabbable = finalTabbable === root2.activeElement || node2 === root2.activeElement;
  const activeElement2 = root2.activeElement;
  if (activeElement2.tagName === "INPUT" && activeElement2.getAttribute("type") === "radio" && (leavingFinalTabbable = tabbable2.filter(
    (element) => element.getAttribute("type") === "radio" && element.getAttribute("name") === activeElement2.getAttribute("name")
  ).includes(finalTabbable)), !leavingFinalTabbable)
    return;
  event.preventDefault();
  const target = tabbable2[event.shiftKey ? tabbable2.length - 1 : 0];
  target && target.focus();
}
function useFocusTrap(active = !0) {
  const ref = useRef(), focusNode = (node2) => {
    let focusElement = node2.querySelector("[data-autofocus]");
    if (!focusElement) {
      const children2 = Array.from(node2.querySelectorAll(FOCUS_SELECTOR));
      focusElement = children2.find(tabbable) || children2.find(focusable) || null, !focusElement && focusable(node2) && (focusElement = node2);
    }
    focusElement && focusElement.focus({ preventScroll: !0 });
  }, setRef = useCallback(
    (node2) => {
      active && node2 !== null && ref.current !== node2 && (node2 ? (setTimeout(() => {
        node2.getRootNode() && focusNode(node2);
      }), ref.current = node2) : ref.current = null);
    },
    [active]
  );
  return useEffect(() => {
    if (!active)
      return;
    ref.current && setTimeout(() => focusNode(ref.current));
    const handleKeyDown = (event) => {
      event.key === "Tab" && ref.current && scopeTab(ref.current, event);
    };
    return document.addEventListener("keydown", handleKeyDown), () => document.removeEventListener("keydown", handleKeyDown);
  }, [active]), setRef;
}
const __useId = React__default.useId || (() => {
});
function useReactId$1() {
  const id2 = __useId();
  return id2 ? `mantine-${id2.replace(/:/g, "")}` : "";
}
function useId$1(staticId) {
  const reactId = useReactId$1(), [uuid, setUuid] = useState(reactId);
  return useIsomorphicEffect(() => {
    setUuid(randomId());
  }, []), typeof staticId == "string" ? staticId : typeof window > "u" ? reactId : uuid;
}
function useWindowEvent(type, listener, options) {
  useEffect(() => (window.addEventListener(type, listener, options), () => window.removeEventListener(type, listener, options)), [type, listener]);
}
function serializeJSON(value, hookName = "use-local-storage") {
  try {
    return JSON.stringify(value);
  } catch {
    throw new Error(`@mantine/hooks ${hookName}: Failed to serialize the value`);
  }
}
function deserializeJSON(value) {
  try {
    return value && JSON.parse(value);
  } catch {
    return value;
  }
}
function createStorageHandler(type) {
  return { getItem: (key) => {
    try {
      return window[type].getItem(key);
    } catch {
      return console.warn("use-local-storage: Failed to get value from storage, localStorage is blocked"), null;
    }
  }, setItem: (key, value) => {
    try {
      window[type].setItem(key, value);
    } catch {
      console.warn("use-local-storage: Failed to set value to storage, localStorage is blocked");
    }
  }, removeItem: (key) => {
    try {
      window[type].removeItem(key);
    } catch {
      console.warn(
        "use-local-storage: Failed to remove value from storage, localStorage is blocked"
      );
    }
  } };
}
function createStorage(type, hookName) {
  const eventName = "mantine-local-storage", { getItem, setItem, removeItem: removeItem2 } = createStorageHandler(type);
  return function({
    key,
    defaultValue,
    getInitialValueInEffect = !0,
    deserialize = deserializeJSON,
    serialize = (value) => serializeJSON(value, hookName)
  }) {
    const readStorageValue = useCallback(
      (skipStorage) => {
        let storageBlockedOrSkipped;
        try {
          storageBlockedOrSkipped = typeof window > "u" || !(type in window) || window[type] === null || !!skipStorage;
        } catch {
          storageBlockedOrSkipped = !0;
        }
        if (storageBlockedOrSkipped)
          return defaultValue;
        const storageValue = getItem(key);
        return storageValue !== null ? deserialize(storageValue) : defaultValue;
      },
      [key, defaultValue]
    ), [value, setValue] = useState(readStorageValue(getInitialValueInEffect)), setStorageValue = useCallback(
      (val) => {
        val instanceof Function ? setValue((current) => {
          const result = val(current);
          return setItem(key, serialize(result)), window.dispatchEvent(
            new CustomEvent(eventName, { detail: { key, value: val(current) } })
          ), result;
        }) : (setItem(key, serialize(val)), window.dispatchEvent(new CustomEvent(eventName, { detail: { key, value: val } })), setValue(val));
      },
      [key]
    ), removeStorageValue = useCallback(() => {
      removeItem2(key), window.dispatchEvent(new CustomEvent(eventName, { detail: { key, value: defaultValue } }));
    }, []);
    return useWindowEvent("storage", (event) => {
      event.storageArea === window[type] && event.key === key && setValue(deserialize(event.newValue ?? void 0));
    }), useWindowEvent(eventName, (event) => {
      event.detail.key === key && setValue(event.detail.value);
    }), useEffect(() => {
      defaultValue !== void 0 && value === void 0 && setStorageValue(defaultValue);
    }, [defaultValue, value, setStorageValue]), useEffect(() => {
      const val = readStorageValue();
      val !== void 0 && setStorageValue(val);
    }, []), [value === void 0 ? defaultValue : value, setStorageValue, removeStorageValue];
  };
}
function useLocalStorage(props) {
  return createStorage("localStorage", "use-local-storage")(props);
}
function assignRef(ref, value) {
  typeof ref == "function" ? ref(value) : typeof ref == "object" && ref !== null && "current" in ref && (ref.current = value);
}
function mergeRefs(...refs) {
  return (node2) => {
    refs.forEach((ref) => assignRef(ref, node2));
  };
}
function useMergedRef(...refs) {
  return useCallback(mergeRefs(...refs), refs);
}
function clampUseMovePosition(position2) {
  return {
    x: clamp$3(position2.x, 0, 1),
    y: clamp$3(position2.y, 0, 1)
  };
}
function useMove(onChange, handlers, dir = "ltr") {
  const ref = useRef(null), mounted = useRef(!1), isSliding = useRef(!1), frame2 = useRef(0), [active, setActive] = useState(!1);
  return useEffect(() => {
    mounted.current = !0;
  }, []), useEffect(() => {
    var _a4, _b2;
    const onScrub = ({ x: x2, y: y2 }) => {
      cancelAnimationFrame(frame2.current), frame2.current = requestAnimationFrame(() => {
        if (mounted.current && ref.current) {
          ref.current.style.userSelect = "none";
          const rect = ref.current.getBoundingClientRect();
          if (rect.width && rect.height) {
            const _x = clamp$3((x2 - rect.left) / rect.width, 0, 1);
            onChange({
              x: dir === "ltr" ? _x : 1 - _x,
              y: clamp$3((y2 - rect.top) / rect.height, 0, 1)
            });
          }
        }
      });
    }, bindEvents = () => {
      document.addEventListener("mousemove", onMouseMove), document.addEventListener("mouseup", stopScrubbing), document.addEventListener("touchmove", onTouchMove), document.addEventListener("touchend", stopScrubbing);
    }, unbindEvents = () => {
      document.removeEventListener("mousemove", onMouseMove), document.removeEventListener("mouseup", stopScrubbing), document.removeEventListener("touchmove", onTouchMove), document.removeEventListener("touchend", stopScrubbing);
    }, startScrubbing = () => {
      !isSliding.current && mounted.current && (isSliding.current = !0, typeof (handlers == null ? void 0 : handlers.onScrubStart) == "function" && handlers.onScrubStart(), setActive(!0), bindEvents());
    }, stopScrubbing = () => {
      isSliding.current && mounted.current && (isSliding.current = !1, setActive(!1), unbindEvents(), setTimeout(() => {
        typeof (handlers == null ? void 0 : handlers.onScrubEnd) == "function" && handlers.onScrubEnd();
      }, 0));
    }, onMouseDown = (event) => {
      startScrubbing(), event.preventDefault(), onMouseMove(event);
    }, onMouseMove = (event) => onScrub({ x: event.clientX, y: event.clientY }), onTouchStart = (event) => {
      event.cancelable && event.preventDefault(), startScrubbing(), onTouchMove(event);
    }, onTouchMove = (event) => {
      event.cancelable && event.preventDefault(), onScrub({ x: event.changedTouches[0].clientX, y: event.changedTouches[0].clientY });
    };
    return (_a4 = ref.current) == null || _a4.addEventListener("mousedown", onMouseDown), (_b2 = ref.current) == null || _b2.addEventListener("touchstart", onTouchStart, { passive: !1 }), () => {
      ref.current && (ref.current.removeEventListener("mousedown", onMouseDown), ref.current.removeEventListener("touchstart", onTouchStart));
    };
  }, [dir, onChange]), { ref, active };
}
function useUncontrolled({
  value,
  defaultValue,
  finalValue,
  onChange = () => {
  }
}) {
  const [uncontrolledValue, setUncontrolledValue] = useState(
    defaultValue !== void 0 ? defaultValue : finalValue
  ), handleUncontrolledChange = (val, ...payload) => {
    setUncontrolledValue(val), onChange == null || onChange(val, ...payload);
  };
  return value !== void 0 ? [value, onChange, !0] : [uncontrolledValue, handleUncontrolledChange, !1];
}
function useReducedMotion(initialValue, options) {
  return useMediaQuery("(prefers-reduced-motion: reduce)", initialValue, options);
}
const defaultState = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  top: 0,
  left: 0,
  bottom: 0,
  right: 0
};
function useResizeObserver$1(options) {
  const frameID = useRef(0), ref = useRef(null), [rect, setRect] = useState(defaultState), observer = useMemo(
    () => typeof window < "u" ? new ResizeObserver((entries) => {
      const entry = entries[0];
      entry && (cancelAnimationFrame(frameID.current), frameID.current = requestAnimationFrame(() => {
        ref.current && setRect(entry.contentRect);
      }));
    }) : null,
    []
  );
  return useEffect(() => (ref.current && (observer == null || observer.observe(ref.current, options)), () => {
    observer == null || observer.disconnect(), frameID.current && cancelAnimationFrame(frameID.current);
  }), [ref.current]), [ref, rect];
}
function useElementSize(options) {
  const [ref, { width: width2, height }] = useResizeObserver$1(options);
  return { ref, width: width2, height };
}
const eventListerOptions = {
  passive: !0
};
function useViewportSize() {
  const [windowSize, setWindowSize] = useState({
    width: 0,
    height: 0
  }), setSize = useCallback(() => {
    setWindowSize({ width: window.innerWidth || 0, height: window.innerHeight || 0 });
  }, []);
  return useWindowEvent("resize", setSize, eventListerOptions), useWindowEvent("orientationchange", setSize, eventListerOptions), useEffect(setSize, []), windowSize;
}
function parseHotkey(hotkey) {
  const keys2 = hotkey.toLowerCase().split("+").map((part) => part.trim()), modifiers = {
    alt: keys2.includes("alt"),
    ctrl: keys2.includes("ctrl"),
    meta: keys2.includes("meta"),
    mod: keys2.includes("mod"),
    shift: keys2.includes("shift"),
    plus: keys2.includes("[plus]")
  }, reservedKeys = ["alt", "ctrl", "meta", "shift", "mod"], freeKey = keys2.find((key) => !reservedKeys.includes(key));
  return {
    ...modifiers,
    key: freeKey === "[plus]" ? "+" : freeKey
  };
}
function isExactHotkey(hotkey, event) {
  const { alt, ctrl, meta, mod, shift: shift2, key } = hotkey, { altKey, ctrlKey, metaKey, shiftKey, key: pressedKey } = event;
  if (alt !== altKey)
    return !1;
  if (mod) {
    if (!ctrlKey && !metaKey)
      return !1;
  } else if (ctrl !== ctrlKey || meta !== metaKey)
    return !1;
  return shift2 !== shiftKey ? !1 : !!(key && (pressedKey.toLowerCase() === key.toLowerCase() || event.code.replace("Key", "").toLowerCase() === key.toLowerCase()));
}
function getHotkeyMatcher(hotkey) {
  return (event) => isExactHotkey(parseHotkey(hotkey), event);
}
function shouldFireEvent(event, tagsToIgnore, triggerOnContentEditable = !1) {
  return event.target instanceof HTMLElement ? (triggerOnContentEditable || !event.target.isContentEditable) && !tagsToIgnore.includes(event.target.tagName) : !0;
}
function useHotkeys(hotkeys, tagsToIgnore = ["INPUT", "TEXTAREA", "SELECT"], triggerOnContentEditable = !1) {
  useEffect(() => {
    const keydownListener = (event) => {
      hotkeys.forEach(([hotkey, handler, options = { preventDefault: !0 }]) => {
        getHotkeyMatcher(hotkey)(event) && shouldFireEvent(event, tagsToIgnore, triggerOnContentEditable) && (options.preventDefault && event.preventDefault(), handler(event));
      });
    };
    return document.documentElement.addEventListener("keydown", keydownListener), () => document.documentElement.removeEventListener("keydown", keydownListener);
  }, [hotkeys]);
}
function useHover$1() {
  const [hovered, setHovered] = useState(!1), ref = useRef(null), onMouseEnter = useCallback(() => setHovered(!0), []), onMouseLeave = useCallback(() => setHovered(!1), []);
  return useEffect(() => {
    if (ref.current)
      return ref.current.addEventListener("mouseenter", onMouseEnter), ref.current.addEventListener("mouseleave", onMouseLeave), () => {
        var _a4, _b2;
        (_a4 = ref.current) == null || _a4.removeEventListener("mouseenter", onMouseEnter), (_b2 = ref.current) == null || _b2.removeEventListener("mouseleave", onMouseLeave);
      };
  }, [ref.current]), { ref, hovered };
}
function useDisclosure(initialState = !1, callbacks) {
  const { onOpen, onClose } = callbacks || {}, [opened, setOpened] = useState(initialState), open = useCallback(() => {
    setOpened((isOpened) => isOpened || (onOpen == null || onOpen(), !0));
  }, [onOpen]), close = useCallback(() => {
    setOpened((isOpened) => isOpened && (onClose == null || onClose(), !1));
  }, [onClose]), toggle = useCallback(() => {
    opened ? close() : open();
  }, [close, open, opened]);
  return [opened, { open, close, toggle }];
}
function useTimeout(callback, delay2, options = { autoInvoke: !1 }) {
  const timeoutRef = useRef(null), start2 = useCallback(
    (...callbackParams) => {
      timeoutRef.current || (timeoutRef.current = window.setTimeout(() => {
        callback(callbackParams), timeoutRef.current = null;
      }, delay2));
    },
    [delay2]
  ), clear = useCallback(() => {
    timeoutRef.current && (window.clearTimeout(timeoutRef.current), timeoutRef.current = null);
  }, []);
  return useEffect(() => (options.autoInvoke && start2(), clear), [clear, start2]), { start: start2, clear };
}
function useMutationObserver(callback, options, target) {
  const observer = useRef(), ref = useRef(null);
  return useEffect(() => {
    const targetElement = typeof target == "function" ? target() : target;
    return (targetElement || ref.current) && (observer.current = new MutationObserver(callback), observer.current.observe(targetElement || ref.current, options)), () => {
      var _a4;
      (_a4 = observer.current) == null || _a4.disconnect();
    };
  }, [callback, options]), ref;
}
function useMounted() {
  const [mounted, setMounted] = useState(!1);
  return useEffect(() => setMounted(!0), []), mounted;
}
function useStateHistory(initialValue) {
  const [state, setState] = useState({
    history: [initialValue],
    current: 0
  }), set2 = useCallback(
    (val) => setState((currentState) => {
      const nextState = [...currentState.history.slice(0, currentState.current + 1), val];
      return {
        history: nextState,
        current: nextState.length - 1
      };
    }),
    []
  ), back = useCallback(
    (steps = 1) => setState((currentState) => ({
      history: currentState.history,
      current: Math.max(0, currentState.current - steps)
    })),
    []
  ), forward = useCallback(
    (steps = 1) => setState((currentState) => ({
      history: currentState.history,
      current: Math.min(currentState.history.length - 1, currentState.current + steps)
    })),
    []
  ), reset = useCallback(() => {
    setState({ history: [initialValue], current: 0 });
  }, [initialValue]), handlers = useMemo(() => ({ back, forward, reset, set: set2 }), [back, forward, reset, set2]);
  return [state.history[state.current], handlers, state];
}
function getEnv() {
  return typeof process < "u" && process.env ? "production" : "development";
}
function memoize(func) {
  const cache = /* @__PURE__ */ new Map();
  return (...args) => {
    const key = JSON.stringify(args);
    if (cache.has(key))
      return cache.get(key);
    const result = func(...args);
    return cache.set(key, result), result;
  };
}
function findClosestNumber(value, numbers) {
  return numbers.length === 0 ? value : numbers.reduce(
    (prev, curr) => Math.abs(curr - value) < Math.abs(prev - value) ? curr : prev
  );
}
function getRefProp(element) {
  var _a4;
  const version2 = React__default.version;
  return typeof React__default.version != "string" || version2.startsWith("18.") ? element == null ? void 0 : element.ref : (_a4 = element == null ? void 0 : element.props) == null ? void 0 : _a4.ref;
}
const EMPTY_CLASS_NAMES = {};
function mergeClassNames(objects) {
  const merged = {};
  return objects.forEach((obj) => {
    Object.entries(obj).forEach(([key, value]) => {
      merged[key] ? merged[key] = clsx(merged[key], value) : merged[key] = value;
    });
  }), merged;
}
function resolveClassNames({ theme, classNames, props, stylesCtx }) {
  const resolvedClassNames = (Array.isArray(classNames) ? classNames : [classNames]).map(
    (item) => typeof item == "function" ? item(theme, props, stylesCtx) : item || EMPTY_CLASS_NAMES
  );
  return mergeClassNames(resolvedClassNames);
}
function resolveStyles({ theme, styles, props, stylesCtx }) {
  return (Array.isArray(styles) ? styles : [styles]).reduce((acc, style2) => typeof style2 == "function" ? { ...acc, ...style2(theme, props, stylesCtx) } : { ...acc, ...style2 }, {});
}
const MantineContext = createContext(null);
function useMantineContext() {
  const ctx = useContext(MantineContext);
  if (!ctx)
    throw new Error("[@mantine/core] MantineProvider was not found in tree");
  return ctx;
}
function useMantineCssVariablesResolver() {
  return useMantineContext().cssVariablesResolver;
}
function useMantineClassNamesPrefix() {
  return useMantineContext().classNamesPrefix;
}
function useMantineStyleNonce() {
  return useMantineContext().getStyleNonce;
}
function useMantineWithStaticClasses() {
  return useMantineContext().withStaticClasses;
}
function useMantineIsHeadless() {
  return useMantineContext().headless;
}
function useMantineSxTransform() {
  var _a4;
  return (_a4 = useMantineContext().stylesTransform) == null ? void 0 : _a4.sx;
}
function useMantineStylesTransform() {
  var _a4;
  return (_a4 = useMantineContext().stylesTransform) == null ? void 0 : _a4.styles;
}
function isHexColor(hex2) {
  return /^#?([0-9A-F]{3}){1,2}([0-9A-F]{2})?$/i.test(hex2);
}
function hexToRgba(color2) {
  let hexString = color2.replace("#", "");
  if (hexString.length === 3) {
    const shorthandHex = hexString.split("");
    hexString = [
      shorthandHex[0],
      shorthandHex[0],
      shorthandHex[1],
      shorthandHex[1],
      shorthandHex[2],
      shorthandHex[2]
    ].join("");
  }
  if (hexString.length === 8) {
    const alpha2 = parseInt(hexString.slice(6, 8), 16) / 255;
    return {
      r: parseInt(hexString.slice(0, 2), 16),
      g: parseInt(hexString.slice(2, 4), 16),
      b: parseInt(hexString.slice(4, 6), 16),
      a: alpha2
    };
  }
  const parsed = parseInt(hexString, 16), r2 = parsed >> 16 & 255, g2 = parsed >> 8 & 255, b2 = parsed & 255;
  return {
    r: r2,
    g: g2,
    b: b2,
    a: 1
  };
}
function rgbStringToRgba(color2) {
  const [r2, g2, b2, a2] = color2.replace(/[^0-9,./]/g, "").split(/[/,]/).map(Number);
  return { r: r2, g: g2, b: b2, a: a2 || 1 };
}
function hslStringToRgba(hslaString) {
  const hslaRegex = /^hsla?\(\s*(\d+)\s*,\s*(\d+%)\s*,\s*(\d+%)\s*(,\s*(0?\.\d+|\d+(\.\d+)?))?\s*\)$/i, matches = hslaString.match(hslaRegex);
  if (!matches)
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 1
    };
  const h2 = parseInt(matches[1], 10), s2 = parseInt(matches[2], 10) / 100, l2 = parseInt(matches[3], 10) / 100, a2 = matches[5] ? parseFloat(matches[5]) : void 0, chroma = (1 - Math.abs(2 * l2 - 1)) * s2, huePrime = h2 / 60, x2 = chroma * (1 - Math.abs(huePrime % 2 - 1)), m2 = l2 - chroma / 2;
  let r2, g2, b2;
  return huePrime >= 0 && huePrime < 1 ? (r2 = chroma, g2 = x2, b2 = 0) : huePrime >= 1 && huePrime < 2 ? (r2 = x2, g2 = chroma, b2 = 0) : huePrime >= 2 && huePrime < 3 ? (r2 = 0, g2 = chroma, b2 = x2) : huePrime >= 3 && huePrime < 4 ? (r2 = 0, g2 = x2, b2 = chroma) : huePrime >= 4 && huePrime < 5 ? (r2 = x2, g2 = 0, b2 = chroma) : (r2 = chroma, g2 = 0, b2 = x2), {
    r: Math.round((r2 + m2) * 255),
    g: Math.round((g2 + m2) * 255),
    b: Math.round((b2 + m2) * 255),
    a: a2 || 1
  };
}
function toRgba(color2) {
  return isHexColor(color2) ? hexToRgba(color2) : color2.startsWith("rgb") ? rgbStringToRgba(color2) : color2.startsWith("hsl") ? hslStringToRgba(color2) : {
    r: 0,
    g: 0,
    b: 0,
    a: 1
  };
}
function darken(color2, alpha2) {
  if (color2.startsWith("var("))
    return `color-mix(in srgb, ${color2}, black ${alpha2 * 100}%)`;
  const { r: r2, g: g2, b: b2, a: a2 } = toRgba(color2), f2 = 1 - alpha2, dark = (input) => Math.round(input * f2);
  return `rgba(${dark(r2)}, ${dark(g2)}, ${dark(b2)}, ${a2})`;
}
function getPrimaryShade(theme, colorScheme) {
  return typeof theme.primaryShade == "number" ? theme.primaryShade : colorScheme === "dark" ? theme.primaryShade.dark : theme.primaryShade.light;
}
function gammaCorrect(c) {
  return c <= 0.03928 ? c / 12.92 : ((c + 0.055) / 1.055) ** 2.4;
}
function getLightnessFromOklch(oklchColor) {
  const match = oklchColor.match(/oklch\((.*?)%\s/);
  return match ? parseFloat(match[1]) : null;
}
function luminance(color2) {
  if (color2.startsWith("oklch("))
    return (getLightnessFromOklch(color2) || 0) / 100;
  const { r: r2, g: g2, b: b2 } = toRgba(color2), sR = r2 / 255, sG = g2 / 255, sB = b2 / 255, rLinear = gammaCorrect(sR), gLinear = gammaCorrect(sG), bLinear = gammaCorrect(sB);
  return 0.2126 * rLinear + 0.7152 * gLinear + 0.0722 * bLinear;
}
function isLightColor(color2, luminanceThreshold = 0.179) {
  return color2.startsWith("var(") ? !1 : luminance(color2) > luminanceThreshold;
}
function parseThemeColor({
  color: color2,
  theme,
  colorScheme
}) {
  if (typeof color2 != "string")
    throw new Error(
      `[@mantine/core] Failed to parse color. Expected color to be a string, instead got ${typeof color2}`
    );
  if (color2 === "bright")
    return {
      color: color2,
      value: colorScheme === "dark" ? theme.white : theme.black,
      shade: void 0,
      isThemeColor: !1,
      isLight: isLightColor(
        colorScheme === "dark" ? theme.white : theme.black,
        theme.luminanceThreshold
      ),
      variable: "--mantine-color-bright"
    };
  if (color2 === "dimmed")
    return {
      color: color2,
      value: colorScheme === "dark" ? theme.colors.dark[2] : theme.colors.gray[7],
      shade: void 0,
      isThemeColor: !1,
      isLight: isLightColor(
        colorScheme === "dark" ? theme.colors.dark[2] : theme.colors.gray[6],
        theme.luminanceThreshold
      ),
      variable: "--mantine-color-dimmed"
    };
  if (color2 === "white" || color2 === "black")
    return {
      color: color2,
      value: color2 === "white" ? theme.white : theme.black,
      shade: void 0,
      isThemeColor: !1,
      isLight: isLightColor(
        color2 === "white" ? theme.white : theme.black,
        theme.luminanceThreshold
      ),
      variable: `--mantine-color-${color2}`
    };
  const [_color, shade] = color2.split("."), colorShade = shade ? Number(shade) : void 0, isThemeColor = _color in theme.colors;
  if (isThemeColor) {
    const colorValue = colorShade !== void 0 ? theme.colors[_color][colorShade] : theme.colors[_color][getPrimaryShade(theme, colorScheme || "light")];
    return {
      color: _color,
      value: colorValue,
      shade: colorShade,
      isThemeColor,
      isLight: isLightColor(colorValue, theme.luminanceThreshold),
      variable: shade ? `--mantine-color-${_color}-${colorShade}` : `--mantine-color-${_color}-filled`
    };
  }
  return {
    color: color2,
    value: color2,
    isThemeColor,
    isLight: isLightColor(color2, theme.luminanceThreshold),
    shade: colorShade,
    variable: void 0
  };
}
function getThemeColor(color2, theme) {
  const parsed = parseThemeColor({ color: color2 || theme.primaryColor, theme });
  return parsed.variable ? `var(${parsed.variable})` : color2;
}
function getGradient(gradient, theme) {
  const merged = {
    from: (gradient == null ? void 0 : gradient.from) || theme.defaultGradient.from,
    to: (gradient == null ? void 0 : gradient.to) || theme.defaultGradient.to,
    deg: (gradient == null ? void 0 : gradient.deg) || theme.defaultGradient.deg || 0
  }, fromColor = getThemeColor(merged.from, theme), toColor = getThemeColor(merged.to, theme);
  return `linear-gradient(${merged.deg}deg, ${fromColor} 0%, ${toColor} 100%)`;
}
function rgba$1(color2, alpha2) {
  if (typeof color2 != "string" || alpha2 > 1 || alpha2 < 0)
    return "rgba(0, 0, 0, 1)";
  if (color2.startsWith("var(")) {
    const mixPercentage = (1 - alpha2) * 100;
    return `color-mix(in srgb, ${color2}, transparent ${mixPercentage}%)`;
  }
  if (color2.startsWith("oklch"))
    return color2.includes("/") ? color2.replace(/\/\s*[\d.]+\s*\)/, `/ ${alpha2})`) : color2.replace(")", ` / ${alpha2})`);
  const { r: r2, g: g2, b: b2 } = toRgba(color2);
  return `rgba(${r2}, ${g2}, ${b2}, ${alpha2})`;
}
const alpha$1 = rgba$1, defaultVariantColorsResolver = ({
  color: color2,
  theme,
  variant,
  gradient,
  autoContrast
}) => {
  const parsed = parseThemeColor({ color: color2, theme }), _autoContrast = typeof autoContrast == "boolean" ? autoContrast : theme.autoContrast;
  if (variant === "filled") {
    const textColor = _autoContrast && parsed.isLight ? "var(--mantine-color-black)" : "var(--mantine-color-white)";
    return parsed.isThemeColor ? parsed.shade === void 0 ? {
      background: `var(--mantine-color-${color2}-filled)`,
      hover: `var(--mantine-color-${color2}-filled-hover)`,
      color: textColor,
      border: `${rem(1)} solid transparent`
    } : {
      background: `var(--mantine-color-${parsed.color}-${parsed.shade})`,
      hover: `var(--mantine-color-${parsed.color}-${parsed.shade === 9 ? 8 : parsed.shade + 1})`,
      color: textColor,
      border: `${rem(1)} solid transparent`
    } : {
      background: color2,
      hover: darken(color2, 0.1),
      color: textColor,
      border: `${rem(1)} solid transparent`
    };
  }
  if (variant === "light") {
    if (parsed.isThemeColor) {
      if (parsed.shade === void 0)
        return {
          background: `var(--mantine-color-${color2}-light)`,
          hover: `var(--mantine-color-${color2}-light-hover)`,
          color: `var(--mantine-color-${color2}-light-color)`,
          border: `${rem(1)} solid transparent`
        };
      const parsedColor = theme.colors[parsed.color][parsed.shade];
      return {
        background: rgba$1(parsedColor, 0.1),
        hover: rgba$1(parsedColor, 0.12),
        color: `var(--mantine-color-${parsed.color}-${Math.min(parsed.shade, 6)})`,
        border: `${rem(1)} solid transparent`
      };
    }
    return {
      background: rgba$1(color2, 0.1),
      hover: rgba$1(color2, 0.12),
      color: color2,
      border: `${rem(1)} solid transparent`
    };
  }
  if (variant === "outline")
    return parsed.isThemeColor ? parsed.shade === void 0 ? {
      background: "transparent",
      hover: `var(--mantine-color-${color2}-outline-hover)`,
      color: `var(--mantine-color-${color2}-outline)`,
      border: `${rem(1)} solid var(--mantine-color-${color2}-outline)`
    } : {
      background: "transparent",
      hover: rgba$1(theme.colors[parsed.color][parsed.shade], 0.05),
      color: `var(--mantine-color-${parsed.color}-${parsed.shade})`,
      border: `${rem(1)} solid var(--mantine-color-${parsed.color}-${parsed.shade})`
    } : {
      background: "transparent",
      hover: rgba$1(color2, 0.05),
      color: color2,
      border: `${rem(1)} solid ${color2}`
    };
  if (variant === "subtle") {
    if (parsed.isThemeColor) {
      if (parsed.shade === void 0)
        return {
          background: "transparent",
          hover: `var(--mantine-color-${color2}-light-hover)`,
          color: `var(--mantine-color-${color2}-light-color)`,
          border: `${rem(1)} solid transparent`
        };
      const parsedColor = theme.colors[parsed.color][parsed.shade];
      return {
        background: "transparent",
        hover: rgba$1(parsedColor, 0.12),
        color: `var(--mantine-color-${parsed.color}-${Math.min(parsed.shade, 6)})`,
        border: `${rem(1)} solid transparent`
      };
    }
    return {
      background: "transparent",
      hover: rgba$1(color2, 0.12),
      color: color2,
      border: `${rem(1)} solid transparent`
    };
  }
  return variant === "transparent" ? parsed.isThemeColor ? parsed.shade === void 0 ? {
    background: "transparent",
    hover: "transparent",
    color: `var(--mantine-color-${color2}-light-color)`,
    border: `${rem(1)} solid transparent`
  } : {
    background: "transparent",
    hover: "transparent",
    color: `var(--mantine-color-${parsed.color}-${Math.min(parsed.shade, 6)})`,
    border: `${rem(1)} solid transparent`
  } : {
    background: "transparent",
    hover: "transparent",
    color: color2,
    border: `${rem(1)} solid transparent`
  } : variant === "white" ? parsed.isThemeColor ? parsed.shade === void 0 ? {
    background: "var(--mantine-color-white)",
    hover: darken(theme.white, 0.01),
    color: `var(--mantine-color-${color2}-filled)`,
    border: `${rem(1)} solid transparent`
  } : {
    background: "var(--mantine-color-white)",
    hover: darken(theme.white, 0.01),
    color: `var(--mantine-color-${parsed.color}-${parsed.shade})`,
    border: `${rem(1)} solid transparent`
  } : {
    background: "var(--mantine-color-white)",
    hover: darken(theme.white, 0.01),
    color: color2,
    border: `${rem(1)} solid transparent`
  } : variant === "gradient" ? {
    background: getGradient(gradient, theme),
    hover: getGradient(gradient, theme),
    color: "var(--mantine-color-white)",
    border: "none"
  } : variant === "default" ? {
    background: "var(--mantine-color-default)",
    hover: "var(--mantine-color-default-hover)",
    color: "var(--mantine-color-default-color)",
    border: `${rem(1)} solid var(--mantine-color-default-border)`
  } : {};
}, DEFAULT_COLORS = {
  dark: [
    "#C9C9C9",
    "#b8b8b8",
    "#828282",
    "#696969",
    "#424242",
    "#3b3b3b",
    "#2e2e2e",
    "#242424",
    "#1f1f1f",
    "#141414"
  ],
  gray: [
    "#f8f9fa",
    "#f1f3f5",
    "#e9ecef",
    "#dee2e6",
    "#ced4da",
    "#adb5bd",
    "#868e96",
    "#495057",
    "#343a40",
    "#212529"
  ],
  red: [
    "#fff5f5",
    "#ffe3e3",
    "#ffc9c9",
    "#ffa8a8",
    "#ff8787",
    "#ff6b6b",
    "#fa5252",
    "#f03e3e",
    "#e03131",
    "#c92a2a"
  ],
  pink: [
    "#fff0f6",
    "#ffdeeb",
    "#fcc2d7",
    "#faa2c1",
    "#f783ac",
    "#f06595",
    "#e64980",
    "#d6336c",
    "#c2255c",
    "#a61e4d"
  ],
  grape: [
    "#f8f0fc",
    "#f3d9fa",
    "#eebefa",
    "#e599f7",
    "#da77f2",
    "#cc5de8",
    "#be4bdb",
    "#ae3ec9",
    "#9c36b5",
    "#862e9c"
  ],
  violet: [
    "#f3f0ff",
    "#e5dbff",
    "#d0bfff",
    "#b197fc",
    "#9775fa",
    "#845ef7",
    "#7950f2",
    "#7048e8",
    "#6741d9",
    "#5f3dc4"
  ],
  indigo: [
    "#edf2ff",
    "#dbe4ff",
    "#bac8ff",
    "#91a7ff",
    "#748ffc",
    "#5c7cfa",
    "#4c6ef5",
    "#4263eb",
    "#3b5bdb",
    "#364fc7"
  ],
  blue: [
    "#e7f5ff",
    "#d0ebff",
    "#a5d8ff",
    "#74c0fc",
    "#4dabf7",
    "#339af0",
    "#228be6",
    "#1c7ed6",
    "#1971c2",
    "#1864ab"
  ],
  cyan: [
    "#e3fafc",
    "#c5f6fa",
    "#99e9f2",
    "#66d9e8",
    "#3bc9db",
    "#22b8cf",
    "#15aabf",
    "#1098ad",
    "#0c8599",
    "#0b7285"
  ],
  teal: [
    "#e6fcf5",
    "#c3fae8",
    "#96f2d7",
    "#63e6be",
    "#38d9a9",
    "#20c997",
    "#12b886",
    "#0ca678",
    "#099268",
    "#087f5b"
  ],
  green: [
    "#ebfbee",
    "#d3f9d8",
    "#b2f2bb",
    "#8ce99a",
    "#69db7c",
    "#51cf66",
    "#40c057",
    "#37b24d",
    "#2f9e44",
    "#2b8a3e"
  ],
  lime: [
    "#f4fce3",
    "#e9fac8",
    "#d8f5a2",
    "#c0eb75",
    "#a9e34b",
    "#94d82d",
    "#82c91e",
    "#74b816",
    "#66a80f",
    "#5c940d"
  ],
  yellow: [
    "#fff9db",
    "#fff3bf",
    "#ffec99",
    "#ffe066",
    "#ffd43b",
    "#fcc419",
    "#fab005",
    "#f59f00",
    "#f08c00",
    "#e67700"
  ],
  orange: [
    "#fff4e6",
    "#ffe8cc",
    "#ffd8a8",
    "#ffc078",
    "#ffa94d",
    "#ff922b",
    "#fd7e14",
    "#f76707",
    "#e8590c",
    "#d9480f"
  ]
}, DEFAULT_FONT_FAMILY = "-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji", DEFAULT_THEME = {
  scale: 1,
  fontSmoothing: !0,
  focusRing: "auto",
  white: "#fff",
  black: "#000",
  colors: DEFAULT_COLORS,
  primaryShade: { light: 6, dark: 8 },
  primaryColor: "blue",
  variantColorResolver: defaultVariantColorsResolver,
  autoContrast: !1,
  luminanceThreshold: 0.3,
  fontFamily: DEFAULT_FONT_FAMILY,
  fontFamilyMonospace: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace",
  respectReducedMotion: !1,
  cursorType: "default",
  defaultGradient: { from: "blue", to: "cyan", deg: 45 },
  defaultRadius: "sm",
  activeClassName: "mantine-active",
  focusClassName: "",
  headings: {
    fontFamily: DEFAULT_FONT_FAMILY,
    fontWeight: "700",
    textWrap: "wrap",
    sizes: {
      h1: { fontSize: rem(34), lineHeight: "1.3" },
      h2: { fontSize: rem(26), lineHeight: "1.35" },
      h3: { fontSize: rem(22), lineHeight: "1.4" },
      h4: { fontSize: rem(18), lineHeight: "1.45" },
      h5: { fontSize: rem(16), lineHeight: "1.5" },
      h6: { fontSize: rem(14), lineHeight: "1.5" }
    }
  },
  fontSizes: {
    xs: rem(12),
    sm: rem(14),
    md: rem(16),
    lg: rem(18),
    xl: rem(20)
  },
  lineHeights: {
    xs: "1.4",
    sm: "1.45",
    md: "1.55",
    lg: "1.6",
    xl: "1.65"
  },
  radius: {
    xs: rem(2),
    sm: rem(4),
    md: rem(8),
    lg: rem(16),
    xl: rem(32)
  },
  spacing: {
    xs: rem(10),
    sm: rem(12),
    md: rem(16),
    lg: rem(20),
    xl: rem(32)
  },
  breakpoints: {
    xs: "36em",
    sm: "48em",
    md: "62em",
    lg: "75em",
    xl: "88em"
  },
  shadows: {
    xs: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), 0 ${rem(1)} ${rem(2)} rgba(0, 0, 0, 0.1)`,
    sm: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(10)} ${rem(
      15
    )} ${rem(-5)}, rgba(0, 0, 0, 0.04) 0 ${rem(7)} ${rem(7)} ${rem(-5)}`,
    md: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(20)} ${rem(
      25
    )} ${rem(-5)}, rgba(0, 0, 0, 0.04) 0 ${rem(10)} ${rem(10)} ${rem(-5)}`,
    lg: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(28)} ${rem(
      23
    )} ${rem(-7)}, rgba(0, 0, 0, 0.04) 0 ${rem(12)} ${rem(12)} ${rem(-7)}`,
    xl: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(36)} ${rem(
      28
    )} ${rem(-7)}, rgba(0, 0, 0, 0.04) 0 ${rem(17)} ${rem(17)} ${rem(-7)}`
  },
  other: {},
  components: {}
};
function isMantineColorScheme(value) {
  return value === "auto" || value === "dark" || value === "light";
}
function localStorageColorSchemeManager({
  key = "mantine-color-scheme-value"
} = {}) {
  let handleStorageEvent;
  return {
    get: (defaultValue) => {
      if (typeof window > "u")
        return defaultValue;
      try {
        const storedColorScheme = window.localStorage.getItem(key);
        return isMantineColorScheme(storedColorScheme) ? storedColorScheme : defaultValue;
      } catch {
        return defaultValue;
      }
    },
    set: (value) => {
      try {
        window.localStorage.setItem(key, value);
      } catch (error) {
        console.warn(
          "[@mantine/core] Local storage color scheme manager was unable to save color scheme.",
          error
        );
      }
    },
    subscribe: (onUpdate) => {
      handleStorageEvent = (event) => {
        event.storageArea === window.localStorage && event.key === key && isMantineColorScheme(event.newValue) && onUpdate(event.newValue);
      }, window.addEventListener("storage", handleStorageEvent);
    },
    unsubscribe: () => {
      window.removeEventListener("storage", handleStorageEvent);
    },
    clear: () => {
      window.localStorage.removeItem(key);
    }
  };
}
const INVALID_PRIMARY_COLOR_ERROR = "[@mantine/core] MantineProvider: Invalid theme.primaryColor, it accepts only key of theme.colors, learn more – https://mantine.dev/theming/colors/#primary-color", INVALID_PRIMARY_SHADE_ERROR = "[@mantine/core] MantineProvider: Invalid theme.primaryShade, it accepts only 0-9 integers or an object { light: 0-9, dark: 0-9 }";
function isValidPrimaryShade(shade) {
  return shade < 0 || shade > 9 ? !1 : parseInt(shade.toString(), 10) === shade;
}
function validateMantineTheme(theme) {
  if (!(theme.primaryColor in theme.colors))
    throw new Error(INVALID_PRIMARY_COLOR_ERROR);
  if (typeof theme.primaryShade == "object" && (!isValidPrimaryShade(theme.primaryShade.dark) || !isValidPrimaryShade(theme.primaryShade.light)))
    throw new Error(INVALID_PRIMARY_SHADE_ERROR);
  if (typeof theme.primaryShade == "number" && !isValidPrimaryShade(theme.primaryShade))
    throw new Error(INVALID_PRIMARY_SHADE_ERROR);
}
function mergeMantineTheme(currentTheme, themeOverride) {
  var _a4;
  if (!themeOverride)
    return validateMantineTheme(currentTheme), currentTheme;
  const result = deepMerge(currentTheme, themeOverride);
  return themeOverride.fontFamily && !((_a4 = themeOverride.headings) != null && _a4.fontFamily) && (result.headings.fontFamily = themeOverride.fontFamily), validateMantineTheme(result), result;
}
const MantineThemeContext = createContext(null), useSafeMantineTheme = () => useContext(MantineThemeContext) || DEFAULT_THEME;
function useMantineTheme() {
  const ctx = useContext(MantineThemeContext);
  if (!ctx)
    throw new Error(
      "@mantine/core: MantineProvider was not found in component tree, make sure you have it in your app"
    );
  return ctx;
}
function MantineThemeProvider({
  theme,
  children: children2,
  inherit: inherit2 = !0
}) {
  const parentTheme = useSafeMantineTheme(), mergedTheme = useMemo(
    () => mergeMantineTheme(inherit2 ? parentTheme : DEFAULT_THEME, theme),
    [theme, parentTheme, inherit2]
  );
  return /* @__PURE__ */ jsx(MantineThemeContext.Provider, { value: mergedTheme, children: children2 });
}
MantineThemeProvider.displayName = "@mantine/core/MantineThemeProvider";
function MantineClasses() {
  const theme = useMantineTheme(), nonce = useMantineStyleNonce(), classes2 = keys(theme.breakpoints).reduce((acc, breakpoint) => {
    const isPxBreakpoint = theme.breakpoints[breakpoint].includes("px"), pxValue = px$1(theme.breakpoints[breakpoint]), maxWidthBreakpoint = isPxBreakpoint ? `${pxValue - 0.1}px` : em(pxValue - 0.1), minWidthBreakpoint = isPxBreakpoint ? `${pxValue}px` : em(pxValue);
    return `${acc}@media (max-width: ${maxWidthBreakpoint}) {.mantine-visible-from-${breakpoint} {display: none !important;}}@media (min-width: ${minWidthBreakpoint}) {.mantine-hidden-from-${breakpoint} {display: none !important;}}`;
  }, "");
  return /* @__PURE__ */ jsx(
    "style",
    {
      "data-mantine-styles": "classes",
      nonce: nonce == null ? void 0 : nonce(),
      dangerouslySetInnerHTML: { __html: classes2 }
    }
  );
}
function cssVariablesObjectToString(variables) {
  return Object.entries(variables).map(([name, value]) => `${name}: ${value};`).join("");
}
function wrapWithSelector(selectors, code) {
  return (Array.isArray(selectors) ? selectors : [selectors]).reduce((acc, selector2) => `${selector2}{${acc}}`, code);
}
function convertCssVariables(input, selector2) {
  const sharedVariables = cssVariablesObjectToString(input.variables), shared = sharedVariables ? wrapWithSelector(selector2, sharedVariables) : "", dark = cssVariablesObjectToString(input.dark), light = cssVariablesObjectToString(input.light), darkForced = dark ? wrapWithSelector(selector2 === ":host" ? `${selector2}([data-mantine-color-scheme="dark"])` : `${selector2}[data-mantine-color-scheme="dark"]`, dark) : "", lightForced = light ? wrapWithSelector(selector2 === ":host" ? `${selector2}([data-mantine-color-scheme="light"])` : `${selector2}[data-mantine-color-scheme="light"]`, light) : "";
  return `${shared}${darkForced}${lightForced}`;
}
function getContrastColor({ color: color2, theme, autoContrast }) {
  return (typeof autoContrast == "boolean" ? autoContrast : theme.autoContrast) && parseThemeColor({ color: color2 || theme.primaryColor, theme }).isLight ? "var(--mantine-color-black)" : "var(--mantine-color-white)";
}
function getPrimaryContrastColor(theme, colorScheme) {
  return getContrastColor({
    color: theme.colors[theme.primaryColor][getPrimaryShade(theme, colorScheme)],
    theme,
    autoContrast: null
  });
}
function getCSSColorVariables({
  theme,
  color: color2,
  colorScheme,
  name = color2,
  withColorValues = !0
}) {
  if (!theme.colors[color2])
    return {};
  if (colorScheme === "light") {
    const primaryShade2 = getPrimaryShade(theme, "light"), dynamicVariables2 = {
      [`--mantine-color-${name}-text`]: `var(--mantine-color-${name}-filled)`,
      [`--mantine-color-${name}-filled`]: `var(--mantine-color-${name}-${primaryShade2})`,
      [`--mantine-color-${name}-filled-hover`]: `var(--mantine-color-${name}-${primaryShade2 === 9 ? 8 : primaryShade2 + 1})`,
      [`--mantine-color-${name}-light`]: alpha$1(theme.colors[color2][primaryShade2], 0.1),
      [`--mantine-color-${name}-light-hover`]: alpha$1(theme.colors[color2][primaryShade2], 0.12),
      [`--mantine-color-${name}-light-color`]: `var(--mantine-color-${name}-${primaryShade2})`,
      [`--mantine-color-${name}-outline`]: `var(--mantine-color-${name}-${primaryShade2})`,
      [`--mantine-color-${name}-outline-hover`]: alpha$1(theme.colors[color2][primaryShade2], 0.05)
    };
    return withColorValues ? {
      [`--mantine-color-${name}-0`]: theme.colors[color2][0],
      [`--mantine-color-${name}-1`]: theme.colors[color2][1],
      [`--mantine-color-${name}-2`]: theme.colors[color2][2],
      [`--mantine-color-${name}-3`]: theme.colors[color2][3],
      [`--mantine-color-${name}-4`]: theme.colors[color2][4],
      [`--mantine-color-${name}-5`]: theme.colors[color2][5],
      [`--mantine-color-${name}-6`]: theme.colors[color2][6],
      [`--mantine-color-${name}-7`]: theme.colors[color2][7],
      [`--mantine-color-${name}-8`]: theme.colors[color2][8],
      [`--mantine-color-${name}-9`]: theme.colors[color2][9],
      ...dynamicVariables2
    } : dynamicVariables2;
  }
  const primaryShade = getPrimaryShade(theme, "dark"), dynamicVariables = {
    [`--mantine-color-${name}-text`]: `var(--mantine-color-${name}-4)`,
    [`--mantine-color-${name}-filled`]: `var(--mantine-color-${name}-${primaryShade})`,
    [`--mantine-color-${name}-filled-hover`]: `var(--mantine-color-${name}-${primaryShade === 9 ? 8 : primaryShade + 1})`,
    [`--mantine-color-${name}-light`]: alpha$1(
      theme.colors[color2][Math.max(0, primaryShade - 2)],
      0.15
    ),
    [`--mantine-color-${name}-light-hover`]: alpha$1(
      theme.colors[color2][Math.max(0, primaryShade - 2)],
      0.2
    ),
    [`--mantine-color-${name}-light-color`]: `var(--mantine-color-${name}-${Math.max(primaryShade - 5, 0)})`,
    [`--mantine-color-${name}-outline`]: `var(--mantine-color-${name}-${Math.max(primaryShade - 4, 0)})`,
    [`--mantine-color-${name}-outline-hover`]: alpha$1(
      theme.colors[color2][Math.max(primaryShade - 4, 0)],
      0.05
    )
  };
  return withColorValues ? {
    [`--mantine-color-${name}-0`]: theme.colors[color2][0],
    [`--mantine-color-${name}-1`]: theme.colors[color2][1],
    [`--mantine-color-${name}-2`]: theme.colors[color2][2],
    [`--mantine-color-${name}-3`]: theme.colors[color2][3],
    [`--mantine-color-${name}-4`]: theme.colors[color2][4],
    [`--mantine-color-${name}-5`]: theme.colors[color2][5],
    [`--mantine-color-${name}-6`]: theme.colors[color2][6],
    [`--mantine-color-${name}-7`]: theme.colors[color2][7],
    [`--mantine-color-${name}-8`]: theme.colors[color2][8],
    [`--mantine-color-${name}-9`]: theme.colors[color2][9],
    ...dynamicVariables
  } : dynamicVariables;
}
function isVirtualColor(value) {
  return !!value && typeof value == "object" && "mantine-virtual-color" in value;
}
function assignSizeVariables(variables, sizes, name) {
  keys(sizes).forEach(
    (size2) => Object.assign(variables, { [`--mantine-${name}-${size2}`]: sizes[size2] })
  );
}
const defaultCssVariablesResolver = (theme) => {
  const lightPrimaryShade = getPrimaryShade(theme, "light"), defaultRadius = theme.defaultRadius in theme.radius ? theme.radius[theme.defaultRadius] : rem(theme.defaultRadius), result = {
    variables: {
      "--mantine-scale": theme.scale.toString(),
      "--mantine-cursor-type": theme.cursorType,
      "--mantine-color-scheme": "light dark",
      "--mantine-webkit-font-smoothing": theme.fontSmoothing ? "antialiased" : "unset",
      "--mantine-moz-font-smoothing": theme.fontSmoothing ? "grayscale" : "unset",
      "--mantine-color-white": theme.white,
      "--mantine-color-black": theme.black,
      "--mantine-line-height": theme.lineHeights.md,
      "--mantine-font-family": theme.fontFamily,
      "--mantine-font-family-monospace": theme.fontFamilyMonospace,
      "--mantine-font-family-headings": theme.headings.fontFamily,
      "--mantine-heading-font-weight": theme.headings.fontWeight,
      "--mantine-heading-text-wrap": theme.headings.textWrap,
      "--mantine-radius-default": defaultRadius,
      // Primary colors
      "--mantine-primary-color-filled": `var(--mantine-color-${theme.primaryColor}-filled)`,
      "--mantine-primary-color-filled-hover": `var(--mantine-color-${theme.primaryColor}-filled-hover)`,
      "--mantine-primary-color-light": `var(--mantine-color-${theme.primaryColor}-light)`,
      "--mantine-primary-color-light-hover": `var(--mantine-color-${theme.primaryColor}-light-hover)`,
      "--mantine-primary-color-light-color": `var(--mantine-color-${theme.primaryColor}-light-color)`
    },
    light: {
      "--mantine-primary-color-contrast": getPrimaryContrastColor(theme, "light"),
      "--mantine-color-bright": "var(--mantine-color-black)",
      "--mantine-color-text": theme.black,
      "--mantine-color-body": theme.white,
      "--mantine-color-error": "var(--mantine-color-red-6)",
      "--mantine-color-placeholder": "var(--mantine-color-gray-5)",
      "--mantine-color-anchor": `var(--mantine-color-${theme.primaryColor}-${lightPrimaryShade})`,
      "--mantine-color-default": "var(--mantine-color-white)",
      "--mantine-color-default-hover": "var(--mantine-color-gray-0)",
      "--mantine-color-default-color": "var(--mantine-color-black)",
      "--mantine-color-default-border": "var(--mantine-color-gray-4)",
      "--mantine-color-dimmed": "var(--mantine-color-gray-6)"
    },
    dark: {
      "--mantine-primary-color-contrast": getPrimaryContrastColor(theme, "dark"),
      "--mantine-color-bright": "var(--mantine-color-white)",
      "--mantine-color-text": "var(--mantine-color-dark-0)",
      "--mantine-color-body": "var(--mantine-color-dark-7)",
      "--mantine-color-error": "var(--mantine-color-red-8)",
      "--mantine-color-placeholder": "var(--mantine-color-dark-3)",
      "--mantine-color-anchor": `var(--mantine-color-${theme.primaryColor}-4)`,
      "--mantine-color-default": "var(--mantine-color-dark-6)",
      "--mantine-color-default-hover": "var(--mantine-color-dark-5)",
      "--mantine-color-default-color": "var(--mantine-color-white)",
      "--mantine-color-default-border": "var(--mantine-color-dark-4)",
      "--mantine-color-dimmed": "var(--mantine-color-dark-2)"
    }
  };
  assignSizeVariables(result.variables, theme.breakpoints, "breakpoint"), assignSizeVariables(result.variables, theme.spacing, "spacing"), assignSizeVariables(result.variables, theme.fontSizes, "font-size"), assignSizeVariables(result.variables, theme.lineHeights, "line-height"), assignSizeVariables(result.variables, theme.shadows, "shadow"), assignSizeVariables(result.variables, theme.radius, "radius"), theme.colors[theme.primaryColor].forEach((_, index2) => {
    result.variables[`--mantine-primary-color-${index2}`] = `var(--mantine-color-${theme.primaryColor}-${index2})`;
  }), keys(theme.colors).forEach((color2) => {
    const value = theme.colors[color2];
    if (isVirtualColor(value)) {
      Object.assign(
        result.light,
        getCSSColorVariables({
          theme,
          name: value.name,
          color: value.light,
          colorScheme: "light",
          withColorValues: !0
        })
      ), Object.assign(
        result.dark,
        getCSSColorVariables({
          theme,
          name: value.name,
          color: value.dark,
          colorScheme: "dark",
          withColorValues: !0
        })
      );
      return;
    }
    value.forEach((shade, index2) => {
      result.variables[`--mantine-color-${color2}-${index2}`] = shade;
    }), Object.assign(
      result.light,
      getCSSColorVariables({
        theme,
        color: color2,
        colorScheme: "light",
        withColorValues: !1
      })
    ), Object.assign(
      result.dark,
      getCSSColorVariables({
        theme,
        color: color2,
        colorScheme: "dark",
        withColorValues: !1
      })
    );
  });
  const headings2 = theme.headings.sizes;
  return keys(headings2).forEach((heading) => {
    result.variables[`--mantine-${heading}-font-size`] = headings2[heading].fontSize, result.variables[`--mantine-${heading}-line-height`] = headings2[heading].lineHeight, result.variables[`--mantine-${heading}-font-weight`] = headings2[heading].fontWeight || theme.headings.fontWeight;
  }), result;
};
function getMergedVariables({ theme, generator }) {
  const defaultResolver = defaultCssVariablesResolver(theme), providerGenerator = generator == null ? void 0 : generator(theme);
  return providerGenerator ? deepMerge(defaultResolver, providerGenerator) : defaultResolver;
}
const defaultCssVariables = defaultCssVariablesResolver(DEFAULT_THEME);
function removeDefaultVariables(input) {
  const cleaned = {
    variables: {},
    light: {},
    dark: {}
  };
  return keys(input.variables).forEach((key) => {
    defaultCssVariables.variables[key] !== input.variables[key] && (cleaned.variables[key] = input.variables[key]);
  }), keys(input.light).forEach((key) => {
    defaultCssVariables.light[key] !== input.light[key] && (cleaned.light[key] = input.light[key]);
  }), keys(input.dark).forEach((key) => {
    defaultCssVariables.dark[key] !== input.dark[key] && (cleaned.dark[key] = input.dark[key]);
  }), cleaned;
}
function getColorSchemeCssVariables(selector2) {
  return `
  ${selector2}[data-mantine-color-scheme="dark"] { --mantine-color-scheme: dark; }
  ${selector2}[data-mantine-color-scheme="light"] { --mantine-color-scheme: light; }
`;
}
function MantineCssVariables({
  cssVariablesSelector,
  deduplicateCssVariables
}) {
  const theme = useMantineTheme(), nonce = useMantineStyleNonce(), generator = useMantineCssVariablesResolver(), mergedVariables = getMergedVariables({ theme, generator }), shouldCleanVariables = cssVariablesSelector === ":root" && deduplicateCssVariables, cleanedVariables = shouldCleanVariables ? removeDefaultVariables(mergedVariables) : mergedVariables, css = convertCssVariables(cleanedVariables, cssVariablesSelector);
  return css ? /* @__PURE__ */ jsx(
    "style",
    {
      "data-mantine-styles": !0,
      nonce: nonce == null ? void 0 : nonce(),
      dangerouslySetInnerHTML: {
        __html: `${css}${shouldCleanVariables ? "" : getColorSchemeCssVariables(cssVariablesSelector)}`
      }
    }
  ) : null;
}
MantineCssVariables.displayName = "@mantine/CssVariables";
function suppressNextjsWarning() {
  const originalError = console.error;
  console.error = (...args) => {
    args.length > 1 && typeof args[0] == "string" && args[0].toLowerCase().includes("extra attributes from the server") && typeof args[1] == "string" && args[1].toLowerCase().includes("data-mantine-color-scheme") || originalError(...args);
  };
}
function setColorSchemeAttribute(colorScheme, getRootElement) {
  var _a4;
  const computedColorScheme = colorScheme !== "auto" ? colorScheme : window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
  (_a4 = getRootElement()) == null || _a4.setAttribute("data-mantine-color-scheme", computedColorScheme);
}
function useProviderColorScheme({
  manager,
  defaultColorScheme,
  getRootElement,
  forceColorScheme
}) {
  const media = useRef(), [value, setValue] = useState(() => manager.get(defaultColorScheme)), colorSchemeValue = forceColorScheme || value, setColorScheme = useCallback(
    (colorScheme) => {
      forceColorScheme || (setColorSchemeAttribute(colorScheme, getRootElement), setValue(colorScheme), manager.set(colorScheme));
    },
    [manager.set, colorSchemeValue, forceColorScheme]
  ), clearColorScheme = useCallback(() => {
    setValue(defaultColorScheme), setColorSchemeAttribute(defaultColorScheme, getRootElement), manager.clear();
  }, [manager.clear, defaultColorScheme]);
  return useEffect(() => (manager.subscribe(setColorScheme), manager.unsubscribe), [manager.subscribe, manager.unsubscribe]), useIsomorphicEffect(() => {
    setColorSchemeAttribute(manager.get(defaultColorScheme), getRootElement);
  }, []), useEffect(() => {
    var _a4;
    if (forceColorScheme)
      return setColorSchemeAttribute(forceColorScheme, getRootElement), () => {
      };
    forceColorScheme === void 0 && setColorSchemeAttribute(value, getRootElement), media.current = window.matchMedia("(prefers-color-scheme: dark)");
    const listener = (event) => {
      value === "auto" && setColorSchemeAttribute(event.matches ? "dark" : "light", getRootElement);
    };
    return (_a4 = media.current) == null || _a4.addEventListener("change", listener), () => {
      var _a5;
      return (_a5 = media.current) == null ? void 0 : _a5.removeEventListener("change", listener);
    };
  }, [value, forceColorScheme]), { colorScheme: colorSchemeValue, setColorScheme, clearColorScheme };
}
function useRespectReduceMotion({
  respectReducedMotion,
  getRootElement
}) {
  useIsomorphicEffect(() => {
    var _a4;
    respectReducedMotion && ((_a4 = getRootElement()) == null || _a4.setAttribute("data-respect-reduced-motion", "true"));
  }, [respectReducedMotion]);
}
suppressNextjsWarning();
function MantineProvider({
  theme,
  children: children2,
  getStyleNonce,
  withStaticClasses = !0,
  withGlobalClasses = !0,
  deduplicateCssVariables = !0,
  withCssVariables = !0,
  cssVariablesSelector = ":root",
  classNamesPrefix = "mantine",
  colorSchemeManager = localStorageColorSchemeManager(),
  defaultColorScheme = "light",
  getRootElement = () => document.documentElement,
  cssVariablesResolver,
  forceColorScheme,
  stylesTransform
}) {
  const { colorScheme, setColorScheme, clearColorScheme } = useProviderColorScheme({
    defaultColorScheme,
    forceColorScheme,
    manager: colorSchemeManager,
    getRootElement
  });
  return useRespectReduceMotion({
    respectReducedMotion: (theme == null ? void 0 : theme.respectReducedMotion) || !1,
    getRootElement
  }), /* @__PURE__ */ jsx(
    MantineContext.Provider,
    {
      value: {
        colorScheme,
        setColorScheme,
        clearColorScheme,
        getRootElement,
        classNamesPrefix,
        getStyleNonce,
        cssVariablesResolver,
        cssVariablesSelector,
        withStaticClasses,
        stylesTransform
      },
      children: /* @__PURE__ */ jsxs(MantineThemeProvider, { theme, children: [
        withCssVariables && /* @__PURE__ */ jsx(
          MantineCssVariables,
          {
            cssVariablesSelector,
            deduplicateCssVariables
          }
        ),
        withGlobalClasses && /* @__PURE__ */ jsx(MantineClasses, {}),
        children2
      ] })
    }
  );
}
MantineProvider.displayName = "@mantine/core/MantineProvider";
function useResolvedStylesApi({
  classNames,
  styles,
  props,
  stylesCtx
}) {
  const theme = useMantineTheme();
  return {
    resolvedClassNames: resolveClassNames({
      theme,
      classNames,
      props,
      stylesCtx: stylesCtx || void 0
    }),
    resolvedStyles: resolveStyles({
      theme,
      styles,
      props,
      stylesCtx: stylesCtx || void 0
    })
  };
}
const FOCUS_CLASS_NAMES = {
  always: "mantine-focus-always",
  auto: "mantine-focus-auto",
  never: "mantine-focus-never"
};
function getGlobalClassNames({ theme, options, unstyled }) {
  return clsx(
    (options == null ? void 0 : options.focusable) && !unstyled && (theme.focusClassName || FOCUS_CLASS_NAMES[theme.focusRing]),
    (options == null ? void 0 : options.active) && !unstyled && theme.activeClassName
  );
}
function getOptionsClassNames({
  selector: selector2,
  stylesCtx,
  options,
  props,
  theme
}) {
  return resolveClassNames({
    theme,
    classNames: options == null ? void 0 : options.classNames,
    props: (options == null ? void 0 : options.props) || props,
    stylesCtx
  })[selector2];
}
function getResolvedClassNames({
  selector: selector2,
  stylesCtx,
  theme,
  classNames,
  props
}) {
  return resolveClassNames({ theme, classNames, props, stylesCtx })[selector2];
}
function getRootClassName({ rootSelector, selector: selector2, className }) {
  return rootSelector === selector2 ? className : void 0;
}
function getSelectorClassName({ selector: selector2, classes: classes2, unstyled }) {
  return unstyled ? void 0 : classes2[selector2];
}
function getStaticClassNames({
  themeName,
  classNamesPrefix,
  selector: selector2,
  withStaticClass
}) {
  return withStaticClass === !1 ? [] : themeName.map((n2) => `${classNamesPrefix}-${n2}-${selector2}`);
}
function getThemeClassNames({
  themeName,
  theme,
  selector: selector2,
  props,
  stylesCtx
}) {
  return themeName.map(
    (n2) => {
      var _a4, _b2;
      return (_b2 = resolveClassNames({
        theme,
        classNames: (_a4 = theme.components[n2]) == null ? void 0 : _a4.classNames,
        props,
        stylesCtx
      })) == null ? void 0 : _b2[selector2];
    }
  );
}
function getVariantClassName({
  options,
  classes: classes2,
  selector: selector2,
  unstyled
}) {
  return options != null && options.variant && !unstyled ? classes2[`${selector2}--${options.variant}`] : void 0;
}
function getClassName({
  theme,
  options,
  themeName,
  selector: selector2,
  classNamesPrefix,
  classNames,
  classes: classes2,
  unstyled,
  className,
  rootSelector,
  props,
  stylesCtx,
  withStaticClasses,
  headless,
  transformedStyles
}) {
  return clsx(
    getGlobalClassNames({ theme, options, unstyled: unstyled || headless }),
    getThemeClassNames({ theme, themeName, selector: selector2, props, stylesCtx }),
    getVariantClassName({ options, classes: classes2, selector: selector2, unstyled }),
    getResolvedClassNames({ selector: selector2, stylesCtx, theme, classNames, props }),
    getResolvedClassNames({ selector: selector2, stylesCtx, theme, classNames: transformedStyles, props }),
    getOptionsClassNames({ selector: selector2, stylesCtx, options, props, theme }),
    getRootClassName({ rootSelector, selector: selector2, className }),
    getSelectorClassName({ selector: selector2, classes: classes2, unstyled: unstyled || headless }),
    withStaticClasses && !headless && getStaticClassNames({
      themeName,
      classNamesPrefix,
      selector: selector2,
      withStaticClass: options == null ? void 0 : options.withStaticClass
    }),
    options == null ? void 0 : options.className
  );
}
function getThemeStyles({
  theme,
  themeName,
  props,
  stylesCtx,
  selector: selector2
}) {
  return themeName.map(
    (n2) => {
      var _a4;
      return resolveStyles({
        theme,
        styles: (_a4 = theme.components[n2]) == null ? void 0 : _a4.styles,
        props,
        stylesCtx
      })[selector2];
    }
  ).reduce((acc, val) => ({ ...acc, ...val }), {});
}
function resolveStyle({ style: style2, theme }) {
  return Array.isArray(style2) ? [...style2].reduce(
    (acc, item) => ({ ...acc, ...resolveStyle({ style: item, theme }) }),
    {}
  ) : typeof style2 == "function" ? style2(theme) : style2 ?? {};
}
function mergeVars(vars2) {
  return vars2.reduce((acc, current) => (current && Object.keys(current).forEach((key) => {
    acc[key] = { ...acc[key], ...filterProps$1(current[key]) };
  }), acc), {});
}
function resolveVars({
  vars: vars2,
  varsResolver: varsResolver2,
  theme,
  props,
  stylesCtx,
  selector: selector2,
  themeName,
  headless
}) {
  var _a4;
  return (_a4 = mergeVars([
    headless ? {} : varsResolver2 == null ? void 0 : varsResolver2(theme, props, stylesCtx),
    ...themeName.map((name) => {
      var _a5, _b2, _c;
      return (_c = (_b2 = (_a5 = theme.components) == null ? void 0 : _a5[name]) == null ? void 0 : _b2.vars) == null ? void 0 : _c.call(_b2, theme, props, stylesCtx);
    }),
    vars2 == null ? void 0 : vars2(theme, props, stylesCtx)
  ])) == null ? void 0 : _a4[selector2];
}
function getStyle({
  theme,
  themeName,
  selector: selector2,
  options,
  props,
  stylesCtx,
  rootSelector,
  styles,
  style: style2,
  vars: vars2,
  varsResolver: varsResolver2,
  headless,
  withStylesTransform
}) {
  return {
    ...!withStylesTransform && getThemeStyles({ theme, themeName, props, stylesCtx, selector: selector2 }),
    ...!withStylesTransform && resolveStyles({ theme, styles, props, stylesCtx })[selector2],
    ...!withStylesTransform && resolveStyles({ theme, styles: options == null ? void 0 : options.styles, props: (options == null ? void 0 : options.props) || props, stylesCtx })[selector2],
    ...resolveVars({ theme, props, stylesCtx, vars: vars2, varsResolver: varsResolver2, selector: selector2, themeName, headless }),
    ...rootSelector === selector2 ? resolveStyle({ style: style2, theme }) : null,
    ...resolveStyle({ style: options == null ? void 0 : options.style, theme })
  };
}
function useStylesTransform({ props, stylesCtx, themeName }) {
  var _a4;
  const theme = useMantineTheme(), stylesTransform = (_a4 = useMantineStylesTransform()) == null ? void 0 : _a4();
  return {
    getTransformedStyles: (styles) => stylesTransform ? [
      ...styles.map(
        (style2) => stylesTransform(style2, { props, theme, ctx: stylesCtx })
      ),
      ...themeName.map(
        (n2) => {
          var _a5;
          return stylesTransform((_a5 = theme.components[n2]) == null ? void 0 : _a5.styles, { props, theme, ctx: stylesCtx });
        }
      )
    ].filter(Boolean) : [],
    withStylesTransform: !!stylesTransform
  };
}
function useStyles({
  name,
  classes: classes2,
  props,
  stylesCtx,
  className,
  style: style2,
  rootSelector = "root",
  unstyled,
  classNames,
  styles,
  vars: vars2,
  varsResolver: varsResolver2
}) {
  const theme = useMantineTheme(), classNamesPrefix = useMantineClassNamesPrefix(), withStaticClasses = useMantineWithStaticClasses(), headless = useMantineIsHeadless(), themeName = (Array.isArray(name) ? name : [name]).filter((n2) => n2), { withStylesTransform, getTransformedStyles } = useStylesTransform({
    props,
    stylesCtx,
    themeName
  });
  return (selector2, options) => ({
    className: getClassName({
      theme,
      options,
      themeName,
      selector: selector2,
      classNamesPrefix,
      classNames,
      classes: classes2,
      unstyled,
      className,
      rootSelector,
      props,
      stylesCtx,
      withStaticClasses,
      headless,
      transformedStyles: getTransformedStyles([options == null ? void 0 : options.styles, styles])
    }),
    style: getStyle({
      theme,
      themeName,
      selector: selector2,
      options,
      props,
      stylesCtx,
      rootSelector,
      styles,
      style: style2,
      vars: vars2,
      varsResolver: varsResolver2,
      headless,
      withStylesTransform
    })
  });
}
function getAutoContrastValue(autoContrast, theme) {
  return typeof autoContrast == "boolean" ? autoContrast : theme.autoContrast;
}
function disableTransition(nonce) {
  const style2 = document.createElement("style");
  return style2.setAttribute("data-mantine-styles", "inline"), style2.innerHTML = "*, *::before, *::after {transition: none !important;}", style2.setAttribute("data-mantine-disable-transition", "true"), nonce && style2.setAttribute("nonce", nonce), document.head.appendChild(style2), () => document.querySelectorAll("[data-mantine-disable-transition]").forEach((element) => element.remove());
}
function useMantineColorScheme({ keepTransitions } = {}) {
  const clearStylesRef = useRef(), timeoutRef = useRef(), ctx = useContext(MantineContext), nonce = useMantineStyleNonce(), nonceValue = useRef(nonce == null ? void 0 : nonce());
  if (!ctx)
    throw new Error("[@mantine/core] MantineProvider was not found in tree");
  const setColorScheme = (value) => {
    ctx.setColorScheme(value), clearStylesRef.current = keepTransitions ? () => {
    } : disableTransition(nonceValue.current), window.clearTimeout(timeoutRef.current), timeoutRef.current = window.setTimeout(() => {
      var _a4;
      (_a4 = clearStylesRef.current) == null || _a4.call(clearStylesRef);
    }, 10);
  }, clearColorScheme = () => {
    ctx.clearColorScheme(), clearStylesRef.current = keepTransitions ? () => {
    } : disableTransition(nonceValue.current), window.clearTimeout(timeoutRef.current), timeoutRef.current = window.setTimeout(() => {
      var _a4;
      (_a4 = clearStylesRef.current) == null || _a4.call(clearStylesRef);
    }, 10);
  }, osColorScheme = useColorScheme$1("light", { getInitialValueInEffect: !1 }), computedColorScheme = ctx.colorScheme === "auto" ? osColorScheme : ctx.colorScheme, toggleColorScheme = useCallback(
    () => setColorScheme(computedColorScheme === "light" ? "dark" : "light"),
    [setColorScheme, computedColorScheme]
  );
  return useEffect(
    () => () => {
      var _a4;
      (_a4 = clearStylesRef.current) == null || _a4.call(clearStylesRef), window.clearTimeout(timeoutRef.current);
    },
    []
  ), {
    colorScheme: ctx.colorScheme,
    setColorScheme,
    clearColorScheme,
    toggleColorScheme
  };
}
function useComputedColorScheme(defaultValue, options = { getInitialValueInEffect: !0 }) {
  const osColorScheme = useColorScheme$1(defaultValue, options), { colorScheme } = useMantineColorScheme();
  return colorScheme === "auto" ? osColorScheme : colorScheme;
}
function useProps(component, defaultProps2, props) {
  var _a4;
  const theme = useMantineTheme(), contextPropsPayload = (_a4 = theme.components[component]) == null ? void 0 : _a4.defaultProps, contextProps = typeof contextPropsPayload == "function" ? contextPropsPayload(theme) : contextPropsPayload;
  return { ...defaultProps2, ...contextProps, ...filterProps$1(props) };
}
function cssObjectToString(css) {
  return keys(css).reduce(
    (acc, rule) => css[rule] !== void 0 ? `${acc}${camelToKebabCase(rule)}:${css[rule]};` : acc,
    ""
  ).trim();
}
function stylesToString({ selector: selector2, styles, media, container: container2 }) {
  const baseStyles = styles ? cssObjectToString(styles) : "", mediaQueryStyles = Array.isArray(media) ? media.map((item) => `@media${item.query}{${selector2}{${cssObjectToString(item.styles)}}}`) : [], containerStyles = Array.isArray(container2) ? container2.map(
    (item) => `@container ${item.query}{${selector2}{${cssObjectToString(item.styles)}}}`
  ) : [];
  return `${baseStyles ? `${selector2}{${baseStyles}}` : ""}${mediaQueryStyles.join("")}${containerStyles.join("")}`.trim();
}
function InlineStyles(props) {
  const nonce = useMantineStyleNonce();
  return /* @__PURE__ */ jsx(
    "style",
    {
      "data-mantine-styles": "inline",
      nonce: nonce == null ? void 0 : nonce(),
      dangerouslySetInnerHTML: { __html: stylesToString(props) }
    }
  );
}
function extractStyleProps(others) {
  const {
    m: m2,
    mx,
    my,
    mt,
    mb,
    ml,
    mr,
    me,
    ms,
    p: p2,
    px: px2,
    py,
    pt,
    pb,
    pl,
    pr,
    pe,
    ps,
    bd,
    bg,
    c,
    opacity,
    ff,
    fz,
    fw,
    lts,
    ta,
    lh,
    fs,
    tt,
    td,
    w: w2,
    miw,
    maw,
    h: h2,
    mih,
    mah,
    bgsz,
    bgp,
    bgr,
    bga,
    pos,
    top,
    left,
    bottom,
    right,
    inset,
    display,
    flex,
    hiddenFrom,
    visibleFrom,
    lightHidden,
    darkHidden,
    sx,
    ...rest
  } = others;
  return { styleProps: filterProps$1({
    m: m2,
    mx,
    my,
    mt,
    mb,
    ml,
    mr,
    me,
    ms,
    p: p2,
    px: px2,
    py,
    pt,
    pb,
    pl,
    pr,
    pe,
    ps,
    bd,
    bg,
    c,
    opacity,
    ff,
    fz,
    fw,
    lts,
    ta,
    lh,
    fs,
    tt,
    td,
    w: w2,
    miw,
    maw,
    h: h2,
    mih,
    mah,
    bgsz,
    bgp,
    bgr,
    bga,
    pos,
    top,
    left,
    bottom,
    right,
    inset,
    display,
    flex,
    hiddenFrom,
    visibleFrom,
    lightHidden,
    darkHidden,
    sx
  }), rest };
}
const STYlE_PROPS_DATA = {
  m: { type: "spacing", property: "margin" },
  mt: { type: "spacing", property: "marginTop" },
  mb: { type: "spacing", property: "marginBottom" },
  ml: { type: "spacing", property: "marginLeft" },
  mr: { type: "spacing", property: "marginRight" },
  ms: { type: "spacing", property: "marginInlineStart" },
  me: { type: "spacing", property: "marginInlineEnd" },
  mx: { type: "spacing", property: "marginInline" },
  my: { type: "spacing", property: "marginBlock" },
  p: { type: "spacing", property: "padding" },
  pt: { type: "spacing", property: "paddingTop" },
  pb: { type: "spacing", property: "paddingBottom" },
  pl: { type: "spacing", property: "paddingLeft" },
  pr: { type: "spacing", property: "paddingRight" },
  ps: { type: "spacing", property: "paddingInlineStart" },
  pe: { type: "spacing", property: "paddingInlineEnd" },
  px: { type: "spacing", property: "paddingInline" },
  py: { type: "spacing", property: "paddingBlock" },
  bd: { type: "border", property: "border" },
  bg: { type: "color", property: "background" },
  c: { type: "textColor", property: "color" },
  opacity: { type: "identity", property: "opacity" },
  ff: { type: "fontFamily", property: "fontFamily" },
  fz: { type: "fontSize", property: "fontSize" },
  fw: { type: "identity", property: "fontWeight" },
  lts: { type: "size", property: "letterSpacing" },
  ta: { type: "identity", property: "textAlign" },
  lh: { type: "lineHeight", property: "lineHeight" },
  fs: { type: "identity", property: "fontStyle" },
  tt: { type: "identity", property: "textTransform" },
  td: { type: "identity", property: "textDecoration" },
  w: { type: "spacing", property: "width" },
  miw: { type: "spacing", property: "minWidth" },
  maw: { type: "spacing", property: "maxWidth" },
  h: { type: "spacing", property: "height" },
  mih: { type: "spacing", property: "minHeight" },
  mah: { type: "spacing", property: "maxHeight" },
  bgsz: { type: "size", property: "backgroundSize" },
  bgp: { type: "identity", property: "backgroundPosition" },
  bgr: { type: "identity", property: "backgroundRepeat" },
  bga: { type: "identity", property: "backgroundAttachment" },
  pos: { type: "identity", property: "position" },
  top: { type: "size", property: "top" },
  left: { type: "size", property: "left" },
  bottom: { type: "size", property: "bottom" },
  right: { type: "size", property: "right" },
  inset: { type: "size", property: "inset" },
  display: { type: "identity", property: "display" },
  flex: { type: "identity", property: "flex" }
};
function colorResolver(color2, theme) {
  const parsedColor = parseThemeColor({ color: color2, theme });
  return parsedColor.color === "dimmed" ? "var(--mantine-color-dimmed)" : parsedColor.color === "bright" ? "var(--mantine-color-bright)" : parsedColor.variable ? `var(${parsedColor.variable})` : parsedColor.color;
}
function textColorResolver(color2, theme) {
  const parsedColor = parseThemeColor({ color: color2, theme });
  return parsedColor.isThemeColor && parsedColor.shade === void 0 ? `var(--mantine-color-${parsedColor.color}-text)` : colorResolver(color2, theme);
}
function borderResolver(value, theme) {
  if (typeof value == "number")
    return rem(value);
  if (typeof value == "string") {
    const [size2, style2, ...colorTuple] = value.split(" ").filter((val) => val.trim() !== "");
    let result = `${rem(size2)}`;
    return style2 && (result += ` ${style2}`), colorTuple.length > 0 && (result += ` ${colorResolver(colorTuple.join(" "), theme)}`), result.trim();
  }
  return value;
}
const values = {
  text: "var(--mantine-font-family)",
  mono: "var(--mantine-font-family-monospace)",
  monospace: "var(--mantine-font-family-monospace)",
  heading: "var(--mantine-font-family-headings)",
  headings: "var(--mantine-font-family-headings)"
};
function fontFamilyResolver(fontFamily) {
  return typeof fontFamily == "string" && fontFamily in values ? values[fontFamily] : fontFamily;
}
const headings$1 = ["h1", "h2", "h3", "h4", "h5", "h6"];
function fontSizeResolver(value, theme) {
  return typeof value == "string" && value in theme.fontSizes ? `var(--mantine-font-size-${value})` : typeof value == "string" && headings$1.includes(value) ? `var(--mantine-${value}-font-size)` : typeof value == "number" || typeof value == "string" ? rem(value) : value;
}
function identityResolver(value) {
  return value;
}
const headings = ["h1", "h2", "h3", "h4", "h5", "h6"];
function lineHeightResolver(value, theme) {
  return typeof value == "string" && value in theme.lineHeights ? `var(--mantine-line-height-${value})` : typeof value == "string" && headings.includes(value) ? `var(--mantine-${value}-line-height)` : value;
}
function sizeResolver(value) {
  return typeof value == "number" ? rem(value) : value;
}
function spacingResolver(value, theme) {
  if (typeof value == "number")
    return rem(value);
  if (typeof value == "string") {
    const mod = value.replace("-", "");
    if (!(mod in theme.spacing))
      return rem(value);
    const variable = `--mantine-spacing-${mod}`;
    return value.startsWith("-") ? `calc(var(${variable}) * -1)` : `var(${variable})`;
  }
  return value;
}
const resolvers = {
  color: colorResolver,
  textColor: textColorResolver,
  fontSize: fontSizeResolver,
  spacing: spacingResolver,
  identity: identityResolver,
  size: sizeResolver,
  lineHeight: lineHeightResolver,
  fontFamily: fontFamilyResolver,
  border: borderResolver
};
function replaceMediaQuery(query) {
  return query.replace("(min-width: ", "").replace("em)", "");
}
function sortMediaQueries({
  media,
  ...props
}) {
  const sortedMedia = Object.keys(media).sort((a2, b2) => Number(replaceMediaQuery(a2)) - Number(replaceMediaQuery(b2))).map((query) => ({ query, styles: media[query] }));
  return { ...props, media: sortedMedia };
}
function hasResponsiveStyles(styleProp) {
  if (typeof styleProp != "object" || styleProp === null)
    return !1;
  const breakpoints = Object.keys(styleProp);
  return !(breakpoints.length === 1 && breakpoints[0] === "base");
}
function getBaseValue(value) {
  return typeof value == "object" && value !== null ? "base" in value ? value.base : void 0 : value;
}
function getBreakpointKeys(value) {
  return typeof value == "object" && value !== null ? keys(value).filter((key) => key !== "base") : [];
}
function getBreakpointValue$1(value, breakpoint) {
  return typeof value == "object" && value !== null && breakpoint in value ? value[breakpoint] : value;
}
function parseStyleProps({
  styleProps,
  data,
  theme
}) {
  return sortMediaQueries(
    keys(styleProps).reduce(
      (acc, styleProp) => {
        if (styleProp === "hiddenFrom" || styleProp === "visibleFrom" || styleProp === "sx")
          return acc;
        const propertyData = data[styleProp], properties = Array.isArray(propertyData.property) ? propertyData.property : [propertyData.property], baseValue = getBaseValue(styleProps[styleProp]);
        if (!hasResponsiveStyles(styleProps[styleProp]))
          return properties.forEach((property) => {
            acc.inlineStyles[property] = resolvers[propertyData.type](baseValue, theme);
          }), acc;
        acc.hasResponsiveStyles = !0;
        const breakpoints = getBreakpointKeys(styleProps[styleProp]);
        return properties.forEach((property) => {
          baseValue && (acc.styles[property] = resolvers[propertyData.type](baseValue, theme)), breakpoints.forEach((breakpoint) => {
            const bp = `(min-width: ${theme.breakpoints[breakpoint]})`;
            acc.media[bp] = {
              ...acc.media[bp],
              [property]: resolvers[propertyData.type](
                getBreakpointValue$1(styleProps[styleProp], breakpoint),
                theme
              )
            };
          });
        }), acc;
      },
      {
        hasResponsiveStyles: !1,
        styles: {},
        inlineStyles: {},
        media: {}
      }
    )
  );
}
function useRandomClassName() {
  return `__m__-${useId$2().replace(/:/g, "")}`;
}
function getStyleObject(style2, theme) {
  return Array.isArray(style2) ? [...style2].reduce(
    (acc, item) => ({ ...acc, ...getStyleObject(item, theme) }),
    {}
  ) : typeof style2 == "function" ? style2(theme) : style2 ?? {};
}
function transformModKey(key) {
  return key.startsWith("data-") ? key : `data-${key}`;
}
function getMod(props) {
  return Object.keys(props).reduce((acc, key) => {
    const value = props[key];
    return value === void 0 || value === "" || value === !1 || value === null || (acc[transformModKey(key)] = props[key]), acc;
  }, {});
}
function getBoxMod(mod) {
  return mod ? typeof mod == "string" ? { [transformModKey(mod)]: !0 } : Array.isArray(mod) ? [...mod].reduce(
    (acc, value) => ({ ...acc, ...getBoxMod(value) }),
    {}
  ) : getMod(mod) : null;
}
function mergeStyles(styles, theme) {
  return Array.isArray(styles) ? [...styles].reduce(
    (acc, item) => ({ ...acc, ...mergeStyles(item, theme) }),
    {}
  ) : typeof styles == "function" ? styles(theme) : styles ?? {};
}
function getBoxStyle({
  theme,
  style: style2,
  vars: vars2,
  styleProps
}) {
  const _style = mergeStyles(style2, theme), _vars = mergeStyles(vars2, theme);
  return { ..._style, ..._vars, ...styleProps };
}
const _Box = forwardRef(
  ({
    component,
    style: style2,
    __vars,
    className,
    variant,
    mod,
    size: size2,
    hiddenFrom,
    visibleFrom,
    lightHidden,
    darkHidden,
    renderRoot,
    __size,
    ...others
  }, ref) => {
    var _a4;
    const theme = useMantineTheme(), Element2 = component || "div", { styleProps, rest } = extractStyleProps(others), useSxTransform = useMantineSxTransform(), transformedSx = (_a4 = useSxTransform == null ? void 0 : useSxTransform()) == null ? void 0 : _a4(styleProps.sx), responsiveClassName = useRandomClassName(), parsedStyleProps = parseStyleProps({
      styleProps,
      theme,
      data: STYlE_PROPS_DATA
    }), props = {
      ref,
      style: getBoxStyle({
        theme,
        style: style2,
        vars: __vars,
        styleProps: parsedStyleProps.inlineStyles
      }),
      className: clsx(className, transformedSx, {
        [responsiveClassName]: parsedStyleProps.hasResponsiveStyles,
        "mantine-light-hidden": lightHidden,
        "mantine-dark-hidden": darkHidden,
        [`mantine-hidden-from-${hiddenFrom}`]: hiddenFrom,
        [`mantine-visible-from-${visibleFrom}`]: visibleFrom
      }),
      "data-variant": variant,
      "data-size": isNumberLike(size2) ? void 0 : size2 || void 0,
      size: __size,
      ...getBoxMod(mod),
      ...rest
    };
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      parsedStyleProps.hasResponsiveStyles && /* @__PURE__ */ jsx(
        InlineStyles,
        {
          selector: `.${responsiveClassName}`,
          styles: parsedStyleProps.styles,
          media: parsedStyleProps.media
        }
      ),
      typeof renderRoot == "function" ? renderRoot(props) : /* @__PURE__ */ jsx(Element2, { ...props })
    ] });
  }
);
_Box.displayName = "@mantine/core/Box";
const Box = _Box;
function identity(value) {
  return value;
}
function factory(ui) {
  const Component2 = forwardRef(ui);
  return Component2.extend = identity, Component2.withProps = (fixedProps) => {
    const Extended = forwardRef((props, ref) => /* @__PURE__ */ jsx(Component2, { ...fixedProps, ...props, ref }));
    return Extended.extend = Component2.extend, Extended.displayName = `WithProps(${Component2.displayName})`, Extended;
  }, Component2;
}
function polymorphicFactory(ui) {
  const Component2 = forwardRef(ui);
  return Component2.withProps = (fixedProps) => {
    const Extended = forwardRef((props, ref) => /* @__PURE__ */ jsx(Component2, { ...fixedProps, ...props, ref }));
    return Extended.extend = Component2.extend, Extended.displayName = `WithProps(${Component2.displayName})`, Extended;
  }, Component2.extend = identity, Component2;
}
const DirectionContext = createContext({
  dir: "ltr",
  toggleDirection: () => {
  },
  setDirection: () => {
  }
});
function useDirection() {
  return useContext(DirectionContext);
}
const [ScrollAreaProvider, useScrollAreaContext] = createSafeContext(
  "ScrollArea.Root component was not found in tree"
);
function useResizeObserver(element, onResize) {
  const handleResize = useCallbackRef(onResize);
  useIsomorphicEffect(() => {
    let rAF = 0;
    if (element) {
      const resizeObserver = new ResizeObserver(() => {
        cancelAnimationFrame(rAF), rAF = window.requestAnimationFrame(handleResize);
      });
      return resizeObserver.observe(element), () => {
        window.cancelAnimationFrame(rAF), resizeObserver.unobserve(element);
      };
    }
  }, [element, handleResize]);
}
const Corner = forwardRef((props, ref) => {
  const { style: style2, ...others } = props, ctx = useScrollAreaContext(), [width2, setWidth] = useState(0), [height, setHeight] = useState(0), hasSize = !!(width2 && height);
  return useResizeObserver(ctx.scrollbarX, () => {
    var _a4;
    const h2 = ((_a4 = ctx.scrollbarX) == null ? void 0 : _a4.offsetHeight) || 0;
    ctx.onCornerHeightChange(h2), setHeight(h2);
  }), useResizeObserver(ctx.scrollbarY, () => {
    var _a4;
    const w2 = ((_a4 = ctx.scrollbarY) == null ? void 0 : _a4.offsetWidth) || 0;
    ctx.onCornerWidthChange(w2), setWidth(w2);
  }), hasSize ? /* @__PURE__ */ jsx("div", { ...others, ref, style: { ...style2, width: width2, height } }) : null;
}), ScrollAreaCorner = forwardRef((props, ref) => {
  const ctx = useScrollAreaContext(), hasBothScrollbarsVisible = !!(ctx.scrollbarX && ctx.scrollbarY);
  return ctx.type !== "scroll" && hasBothScrollbarsVisible ? /* @__PURE__ */ jsx(Corner, { ...props, ref }) : null;
}), defaultProps$1f = {
  scrollHideDelay: 1e3,
  type: "hover"
}, ScrollAreaRoot = forwardRef((_props, ref) => {
  const props = useProps("ScrollAreaRoot", defaultProps$1f, _props), { type, scrollHideDelay, scrollbars, ...others } = props, [scrollArea, setScrollArea] = useState(null), [viewport, setViewport] = useState(null), [content, setContent] = useState(null), [scrollbarX, setScrollbarX] = useState(null), [scrollbarY, setScrollbarY] = useState(null), [cornerWidth, setCornerWidth] = useState(0), [cornerHeight, setCornerHeight] = useState(0), [scrollbarXEnabled, setScrollbarXEnabled] = useState(!1), [scrollbarYEnabled, setScrollbarYEnabled] = useState(!1), rootRef = useMergedRef(ref, (node2) => setScrollArea(node2));
  return /* @__PURE__ */ jsx(
    ScrollAreaProvider,
    {
      value: {
        type,
        scrollHideDelay,
        scrollArea,
        viewport,
        onViewportChange: setViewport,
        content,
        onContentChange: setContent,
        scrollbarX,
        onScrollbarXChange: setScrollbarX,
        scrollbarXEnabled,
        onScrollbarXEnabledChange: setScrollbarXEnabled,
        scrollbarY,
        onScrollbarYChange: setScrollbarY,
        scrollbarYEnabled,
        onScrollbarYEnabledChange: setScrollbarYEnabled,
        onCornerWidthChange: setCornerWidth,
        onCornerHeightChange: setCornerHeight
      },
      children: /* @__PURE__ */ jsx(
        Box,
        {
          ...others,
          ref: rootRef,
          __vars: {
            "--sa-corner-width": scrollbars !== "xy" ? "0px" : `${cornerWidth}px`,
            "--sa-corner-height": scrollbars !== "xy" ? "0px" : `${cornerHeight}px`
          }
        }
      )
    }
  );
});
ScrollAreaRoot.displayName = "@mantine/core/ScrollAreaRoot";
function getThumbRatio(viewportSize, contentSize) {
  const ratio = viewportSize / contentSize;
  return Number.isNaN(ratio) ? 0 : ratio;
}
function getThumbSize(sizes) {
  const ratio = getThumbRatio(sizes.viewport, sizes.content), scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd, thumbSize = (sizes.scrollbar.size - scrollbarPadding) * ratio;
  return Math.max(thumbSize, 18);
}
function linearScale(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1])
      return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function clamp$2(value, [min2, max2]) {
  return Math.min(max2, Math.max(min2, value));
}
function getThumbOffsetFromScroll(scrollPos, sizes, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes), scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd, scrollbar = sizes.scrollbar.size - scrollbarPadding, maxScrollPos = sizes.content - sizes.viewport, maxThumbPos = scrollbar - thumbSizePx, scrollClampRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0], scrollWithoutMomentum = clamp$2(scrollPos, scrollClampRange);
  return linearScale([0, maxScrollPos], [0, maxThumbPos])(scrollWithoutMomentum);
}
function getScrollPositionFromPointer(pointerPos, pointerOffset, sizes, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes), thumbCenter = thumbSizePx / 2, offset2 = pointerOffset || thumbCenter, thumbOffsetFromEnd = thumbSizePx - offset2, minPointerPos = sizes.scrollbar.paddingStart + offset2, maxPointerPos = sizes.scrollbar.size - sizes.scrollbar.paddingEnd - thumbOffsetFromEnd, maxScrollPos = sizes.content - sizes.viewport, scrollRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  return linearScale([minPointerPos, maxPointerPos], scrollRange)(pointerPos);
}
function isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {
  return scrollPos > 0 && scrollPos < maxScrollPos;
}
function toInt(value) {
  return value ? parseInt(value, 10) : 0;
}
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = !0 } = {}) {
  return (event) => {
    originalEventHandler == null || originalEventHandler(event), (checkForDefaultPrevented === !1 || !event.defaultPrevented) && (ourEventHandler == null || ourEventHandler(event));
  };
}
const [ScrollbarProvider, useScrollbarContext] = createSafeContext(
  "ScrollAreaScrollbar was not found in tree"
), Scrollbar = forwardRef((props, forwardedRef) => {
  const {
    sizes,
    hasThumb,
    onThumbChange,
    onThumbPointerUp,
    onThumbPointerDown,
    onThumbPositionChange,
    onDragScroll,
    onWheelScroll,
    onResize,
    ...scrollbarProps
  } = props, context = useScrollAreaContext(), [scrollbar, setScrollbar] = useState(null), composeRefs = useMergedRef(forwardedRef, (node2) => setScrollbar(node2)), rectRef = useRef(null), prevWebkitUserSelectRef = useRef(""), { viewport } = context, maxScrollPos = sizes.content - sizes.viewport, handleWheelScroll = useCallbackRef(onWheelScroll), handleThumbPositionChange = useCallbackRef(onThumbPositionChange), handleResize = useDebouncedCallback$1(onResize, 10), handleDragScroll = (event) => {
    if (rectRef.current) {
      const x2 = event.clientX - rectRef.current.left, y2 = event.clientY - rectRef.current.top;
      onDragScroll({ x: x2, y: y2 });
    }
  };
  return useEffect(() => {
    const handleWheel = (event) => {
      const element = event.target;
      (scrollbar == null ? void 0 : scrollbar.contains(element)) && handleWheelScroll(event, maxScrollPos);
    };
    return document.addEventListener("wheel", handleWheel, { passive: !1 }), () => document.removeEventListener("wheel", handleWheel, { passive: !1 });
  }, [viewport, scrollbar, maxScrollPos, handleWheelScroll]), useEffect(handleThumbPositionChange, [sizes, handleThumbPositionChange]), useResizeObserver(scrollbar, handleResize), useResizeObserver(context.content, handleResize), /* @__PURE__ */ jsx(
    ScrollbarProvider,
    {
      value: {
        scrollbar,
        hasThumb,
        onThumbChange: useCallbackRef(onThumbChange),
        onThumbPointerUp: useCallbackRef(onThumbPointerUp),
        onThumbPositionChange: handleThumbPositionChange,
        onThumbPointerDown: useCallbackRef(onThumbPointerDown)
      },
      children: /* @__PURE__ */ jsx(
        "div",
        {
          ...scrollbarProps,
          ref: composeRefs,
          "data-mantine-scrollbar": !0,
          style: { position: "absolute", ...scrollbarProps.style },
          onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
            event.preventDefault(), event.button === 0 && (event.target.setPointerCapture(event.pointerId), rectRef.current = scrollbar.getBoundingClientRect(), prevWebkitUserSelectRef.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", handleDragScroll(event));
          }),
          onPointerMove: composeEventHandlers(props.onPointerMove, handleDragScroll),
          onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
            event.preventDefault();
            const element = event.target;
            element.hasPointerCapture(event.pointerId) && element.releasePointerCapture(event.pointerId), document.body.style.webkitUserSelect = prevWebkitUserSelectRef.current, rectRef.current = null;
          })
        }
      )
    }
  );
}), ScrollAreaScrollbarX = forwardRef(
  (props, forwardedRef) => {
    const { sizes, onSizesChange, style: style2, ...others } = props, ctx = useScrollAreaContext(), [computedStyle, setComputedStyle] = useState(), ref = useRef(null), composeRefs = useMergedRef(forwardedRef, ref, ctx.onScrollbarXChange);
    return useEffect(() => {
      ref.current && setComputedStyle(getComputedStyle(ref.current));
    }, [ref]), /* @__PURE__ */ jsx(
      Scrollbar,
      {
        "data-orientation": "horizontal",
        ...others,
        ref: composeRefs,
        sizes,
        style: {
          ...style2,
          "--sa-thumb-width": `${getThumbSize(sizes)}px`
        },
        onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.x),
        onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.x),
        onWheelScroll: (event, maxScrollPos) => {
          if (ctx.viewport) {
            const scrollPos = ctx.viewport.scrollLeft + event.deltaX;
            props.onWheelScroll(scrollPos), isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) && event.preventDefault();
          }
        },
        onResize: () => {
          ref.current && ctx.viewport && computedStyle && onSizesChange({
            content: ctx.viewport.scrollWidth,
            viewport: ctx.viewport.offsetWidth,
            scrollbar: {
              size: ref.current.clientWidth,
              paddingStart: toInt(computedStyle.paddingLeft),
              paddingEnd: toInt(computedStyle.paddingRight)
            }
          });
        }
      }
    );
  }
);
ScrollAreaScrollbarX.displayName = "@mantine/core/ScrollAreaScrollbarX";
const ScrollAreaScrollbarY = forwardRef(
  (props, forwardedRef) => {
    const { sizes, onSizesChange, style: style2, ...others } = props, context = useScrollAreaContext(), [computedStyle, setComputedStyle] = useState(), ref = useRef(null), composeRefs = useMergedRef(forwardedRef, ref, context.onScrollbarYChange);
    return useEffect(() => {
      ref.current && setComputedStyle(window.getComputedStyle(ref.current));
    }, []), /* @__PURE__ */ jsx(
      Scrollbar,
      {
        ...others,
        "data-orientation": "vertical",
        ref: composeRefs,
        sizes,
        style: {
          "--sa-thumb-height": `${getThumbSize(sizes)}px`,
          ...style2
        },
        onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.y),
        onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.y),
        onWheelScroll: (event, maxScrollPos) => {
          if (context.viewport) {
            const scrollPos = context.viewport.scrollTop + event.deltaY;
            props.onWheelScroll(scrollPos), isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) && event.preventDefault();
          }
        },
        onResize: () => {
          ref.current && context.viewport && computedStyle && onSizesChange({
            content: context.viewport.scrollHeight,
            viewport: context.viewport.offsetHeight,
            scrollbar: {
              size: ref.current.clientHeight,
              paddingStart: toInt(computedStyle.paddingTop),
              paddingEnd: toInt(computedStyle.paddingBottom)
            }
          });
        }
      }
    );
  }
);
ScrollAreaScrollbarY.displayName = "@mantine/core/ScrollAreaScrollbarY";
const ScrollAreaScrollbarVisible = forwardRef((props, forwardedRef) => {
  const { orientation = "vertical", ...scrollbarProps } = props, { dir } = useDirection(), context = useScrollAreaContext(), thumbRef = useRef(null), pointerOffsetRef = useRef(0), [sizes, setSizes] = useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  }), thumbRatio = getThumbRatio(sizes.viewport, sizes.content), commonProps = {
    ...scrollbarProps,
    sizes,
    onSizesChange: setSizes,
    hasThumb: thumbRatio > 0 && thumbRatio < 1,
    onThumbChange: (thumb) => {
      thumbRef.current = thumb;
    },
    onThumbPointerUp: () => {
      pointerOffsetRef.current = 0;
    },
    onThumbPointerDown: (pointerPos) => {
      pointerOffsetRef.current = pointerPos;
    }
  }, getScrollPosition = (pointerPos, direction) => getScrollPositionFromPointer(pointerPos, pointerOffsetRef.current, sizes, direction);
  return orientation === "horizontal" ? /* @__PURE__ */ jsx(
    ScrollAreaScrollbarX,
    {
      ...commonProps,
      ref: forwardedRef,
      onThumbPositionChange: () => {
        if (context.viewport && thumbRef.current) {
          const scrollPos = context.viewport.scrollLeft, offset2 = getThumbOffsetFromScroll(scrollPos, sizes, dir);
          thumbRef.current.style.transform = `translate3d(${offset2}px, 0, 0)`;
        }
      },
      onWheelScroll: (scrollPos) => {
        context.viewport && (context.viewport.scrollLeft = scrollPos);
      },
      onDragScroll: (pointerPos) => {
        context.viewport && (context.viewport.scrollLeft = getScrollPosition(pointerPos, dir));
      }
    }
  ) : orientation === "vertical" ? /* @__PURE__ */ jsx(
    ScrollAreaScrollbarY,
    {
      ...commonProps,
      ref: forwardedRef,
      onThumbPositionChange: () => {
        if (context.viewport && thumbRef.current) {
          const scrollPos = context.viewport.scrollTop, offset2 = getThumbOffsetFromScroll(scrollPos, sizes);
          sizes.scrollbar.size === 0 ? thumbRef.current.style.opacity = "0" : thumbRef.current.style.opacity = "1", thumbRef.current.style.transform = `translate3d(0, ${offset2}px, 0)`;
        }
      },
      onWheelScroll: (scrollPos) => {
        context.viewport && (context.viewport.scrollTop = scrollPos);
      },
      onDragScroll: (pointerPos) => {
        context.viewport && (context.viewport.scrollTop = getScrollPosition(pointerPos));
      }
    }
  ) : null;
});
ScrollAreaScrollbarVisible.displayName = "@mantine/core/ScrollAreaScrollbarVisible";
const ScrollAreaScrollbarAuto = forwardRef(
  (props, ref) => {
    const context = useScrollAreaContext(), { forceMount, ...scrollbarProps } = props, [visible2, setVisible] = useState(!1), isHorizontal = props.orientation === "horizontal", handleResize = useDebouncedCallback$1(() => {
      if (context.viewport) {
        const isOverflowX = context.viewport.offsetWidth < context.viewport.scrollWidth, isOverflowY = context.viewport.offsetHeight < context.viewport.scrollHeight;
        setVisible(isHorizontal ? isOverflowX : isOverflowY);
      }
    }, 10);
    return useResizeObserver(context.viewport, handleResize), useResizeObserver(context.content, handleResize), forceMount || visible2 ? /* @__PURE__ */ jsx(
      ScrollAreaScrollbarVisible,
      {
        "data-state": visible2 ? "visible" : "hidden",
        ...scrollbarProps,
        ref
      }
    ) : null;
  }
);
ScrollAreaScrollbarAuto.displayName = "@mantine/core/ScrollAreaScrollbarAuto";
const ScrollAreaScrollbarHover = forwardRef(
  (props, ref) => {
    const { forceMount, ...scrollbarProps } = props, context = useScrollAreaContext(), [visible2, setVisible] = useState(!1);
    return useEffect(() => {
      const { scrollArea } = context;
      let hideTimer = 0;
      if (scrollArea) {
        const handlePointerEnter = () => {
          window.clearTimeout(hideTimer), setVisible(!0);
        }, handlePointerLeave = () => {
          hideTimer = window.setTimeout(() => setVisible(!1), context.scrollHideDelay);
        };
        return scrollArea.addEventListener("pointerenter", handlePointerEnter), scrollArea.addEventListener("pointerleave", handlePointerLeave), () => {
          window.clearTimeout(hideTimer), scrollArea.removeEventListener("pointerenter", handlePointerEnter), scrollArea.removeEventListener("pointerleave", handlePointerLeave);
        };
      }
    }, [context.scrollArea, context.scrollHideDelay]), forceMount || visible2 ? /* @__PURE__ */ jsx(
      ScrollAreaScrollbarAuto,
      {
        "data-state": visible2 ? "visible" : "hidden",
        ...scrollbarProps,
        ref
      }
    ) : null;
  }
);
ScrollAreaScrollbarHover.displayName = "@mantine/core/ScrollAreaScrollbarHover";
const ScrollAreaScrollbarScroll = forwardRef(
  (props, red) => {
    const { forceMount, ...scrollbarProps } = props, context = useScrollAreaContext(), isHorizontal = props.orientation === "horizontal", [state, setState] = useState("hidden"), debounceScrollEnd = useDebouncedCallback$1(() => setState("idle"), 100);
    return useEffect(() => {
      if (state === "idle") {
        const hideTimer = window.setTimeout(() => setState("hidden"), context.scrollHideDelay);
        return () => window.clearTimeout(hideTimer);
      }
    }, [state, context.scrollHideDelay]), useEffect(() => {
      const { viewport } = context, scrollDirection = isHorizontal ? "scrollLeft" : "scrollTop";
      if (viewport) {
        let prevScrollPos = viewport[scrollDirection];
        const handleScroll2 = () => {
          const scrollPos = viewport[scrollDirection];
          prevScrollPos !== scrollPos && (setState("scrolling"), debounceScrollEnd()), prevScrollPos = scrollPos;
        };
        return viewport.addEventListener("scroll", handleScroll2), () => viewport.removeEventListener("scroll", handleScroll2);
      }
    }, [context.viewport, isHorizontal, debounceScrollEnd]), forceMount || state !== "hidden" ? /* @__PURE__ */ jsx(
      ScrollAreaScrollbarVisible,
      {
        "data-state": state === "hidden" ? "hidden" : "visible",
        ...scrollbarProps,
        ref: red,
        onPointerEnter: composeEventHandlers(props.onPointerEnter, () => setState("interacting")),
        onPointerLeave: composeEventHandlers(props.onPointerLeave, () => setState("idle"))
      }
    ) : null;
  }
), ScrollAreaScrollbar = forwardRef(
  (props, forwardedRef) => {
    const { forceMount, ...scrollbarProps } = props, context = useScrollAreaContext(), { onScrollbarXEnabledChange, onScrollbarYEnabledChange } = context, isHorizontal = props.orientation === "horizontal";
    return useEffect(() => (isHorizontal ? onScrollbarXEnabledChange(!0) : onScrollbarYEnabledChange(!0), () => {
      isHorizontal ? onScrollbarXEnabledChange(!1) : onScrollbarYEnabledChange(!1);
    }), [isHorizontal, onScrollbarXEnabledChange, onScrollbarYEnabledChange]), context.type === "hover" ? /* @__PURE__ */ jsx(ScrollAreaScrollbarHover, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "scroll" ? /* @__PURE__ */ jsx(ScrollAreaScrollbarScroll, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "auto" ? /* @__PURE__ */ jsx(ScrollAreaScrollbarAuto, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "always" ? /* @__PURE__ */ jsx(ScrollAreaScrollbarVisible, { ...scrollbarProps, ref: forwardedRef }) : null;
  }
);
ScrollAreaScrollbar.displayName = "@mantine/core/ScrollAreaScrollbar";
function addUnlinkedScrollListener(node2, handler = () => {
}) {
  let prevPosition = { left: node2.scrollLeft, top: node2.scrollTop }, rAF = 0;
  return function loop() {
    const position2 = { left: node2.scrollLeft, top: node2.scrollTop }, isHorizontalScroll = prevPosition.left !== position2.left, isVerticalScroll = prevPosition.top !== position2.top;
    (isHorizontalScroll || isVerticalScroll) && handler(), prevPosition = position2, rAF = window.requestAnimationFrame(loop);
  }(), () => window.cancelAnimationFrame(rAF);
}
const Thumb$1 = forwardRef((props, forwardedRef) => {
  const { style: style2, ...others } = props, scrollAreaContext = useScrollAreaContext(), scrollbarContext = useScrollbarContext(), { onThumbPositionChange } = scrollbarContext, composedRef = useMergedRef(forwardedRef, (node2) => scrollbarContext.onThumbChange(node2)), removeUnlinkedScrollListenerRef = useRef(), debounceScrollEnd = useDebouncedCallback$1(() => {
    removeUnlinkedScrollListenerRef.current && (removeUnlinkedScrollListenerRef.current(), removeUnlinkedScrollListenerRef.current = void 0);
  }, 100);
  return useEffect(() => {
    const { viewport } = scrollAreaContext;
    if (viewport) {
      const handleScroll2 = () => {
        if (debounceScrollEnd(), !removeUnlinkedScrollListenerRef.current) {
          const listener = addUnlinkedScrollListener(viewport, onThumbPositionChange);
          removeUnlinkedScrollListenerRef.current = listener, onThumbPositionChange();
        }
      };
      return onThumbPositionChange(), viewport.addEventListener("scroll", handleScroll2), () => viewport.removeEventListener("scroll", handleScroll2);
    }
  }, [scrollAreaContext.viewport, debounceScrollEnd, onThumbPositionChange]), /* @__PURE__ */ jsx(
    "div",
    {
      "data-state": scrollbarContext.hasThumb ? "visible" : "hidden",
      ...others,
      ref: composedRef,
      style: {
        width: "var(--sa-thumb-width)",
        height: "var(--sa-thumb-height)",
        ...style2
      },
      onPointerDownCapture: composeEventHandlers(props.onPointerDownCapture, (event) => {
        const thumbRect = event.target.getBoundingClientRect(), x2 = event.clientX - thumbRect.left, y2 = event.clientY - thumbRect.top;
        scrollbarContext.onThumbPointerDown({ x: x2, y: y2 });
      }),
      onPointerUp: composeEventHandlers(props.onPointerUp, scrollbarContext.onThumbPointerUp)
    }
  );
});
Thumb$1.displayName = "@mantine/core/ScrollAreaThumb";
const ScrollAreaThumb = forwardRef(
  (props, forwardedRef) => {
    const { forceMount, ...thumbProps } = props, scrollbarContext = useScrollbarContext();
    return forceMount || scrollbarContext.hasThumb ? /* @__PURE__ */ jsx(Thumb$1, { ref: forwardedRef, ...thumbProps }) : null;
  }
);
ScrollAreaThumb.displayName = "@mantine/core/ScrollAreaThumb";
const ScrollAreaViewport = forwardRef(
  ({ children: children2, style: style2, ...others }, ref) => {
    const ctx = useScrollAreaContext(), rootRef = useMergedRef(ref, ctx.onViewportChange);
    return /* @__PURE__ */ jsx(
      Box,
      {
        ...others,
        ref: rootRef,
        style: {
          overflowX: ctx.scrollbarXEnabled ? "scroll" : "hidden",
          overflowY: ctx.scrollbarYEnabled ? "scroll" : "hidden",
          ...style2
        },
        children: /* @__PURE__ */ jsx("div", { style: { minWidth: "100%", display: "table" }, ref: ctx.onContentChange, children: children2 })
      }
    );
  }
);
ScrollAreaViewport.displayName = "@mantine/core/ScrollAreaViewport";
var __default__$B = { root: "m_d57069b5", viewport: "m_c0783ff9", viewportInner: "m_f8f631dd", scrollbar: "m_c44ba933", thumb: "m_d8b5e363", corner: "m_21657268" };
const classes$C = __default__$B, defaultProps$1e = {
  scrollHideDelay: 1e3,
  type: "hover",
  scrollbars: "xy"
}, varsResolver$B = (_, { scrollbarSize }) => ({
  root: {
    "--scrollarea-scrollbar-size": rem(scrollbarSize)
  }
}), ScrollArea = factory((_props, ref) => {
  const props = useProps("ScrollArea", defaultProps$1e, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    scrollbarSize,
    vars: vars2,
    type,
    scrollHideDelay,
    viewportProps,
    viewportRef,
    onScrollPositionChange,
    children: children2,
    offsetScrollbars,
    scrollbars,
    onBottomReached,
    onTopReached,
    ...others
  } = props, [scrollbarHovered, setScrollbarHovered] = useState(!1), getStyles2 = useStyles({
    name: "ScrollArea",
    props,
    classes: classes$C,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars: vars2,
    varsResolver: varsResolver$B
  });
  return /* @__PURE__ */ jsxs(
    ScrollAreaRoot,
    {
      type: type === "never" ? "always" : type,
      scrollHideDelay,
      ref,
      scrollbars,
      ...getStyles2("root"),
      ...others,
      children: [
        /* @__PURE__ */ jsx(
          ScrollAreaViewport,
          {
            ...viewportProps,
            ...getStyles2("viewport", { style: viewportProps == null ? void 0 : viewportProps.style }),
            ref: viewportRef,
            "data-offset-scrollbars": offsetScrollbars === !0 ? "xy" : offsetScrollbars || void 0,
            "data-scrollbars": scrollbars || void 0,
            onScroll: (e2) => {
              var _a4;
              (_a4 = viewportProps == null ? void 0 : viewportProps.onScroll) == null || _a4.call(viewportProps, e2), onScrollPositionChange == null || onScrollPositionChange({ x: e2.currentTarget.scrollLeft, y: e2.currentTarget.scrollTop });
              const { scrollTop, scrollHeight, clientHeight } = e2.currentTarget;
              scrollTop - (scrollHeight - clientHeight) >= 0 && (onBottomReached == null || onBottomReached()), scrollTop === 0 && (onTopReached == null || onTopReached());
            },
            children: children2
          }
        ),
        (scrollbars === "xy" || scrollbars === "x") && /* @__PURE__ */ jsx(
          ScrollAreaScrollbar,
          {
            ...getStyles2("scrollbar"),
            orientation: "horizontal",
            "data-hidden": type === "never" || void 0,
            forceMount: !0,
            onMouseEnter: () => setScrollbarHovered(!0),
            onMouseLeave: () => setScrollbarHovered(!1),
            children: /* @__PURE__ */ jsx(ScrollAreaThumb, { ...getStyles2("thumb") })
          }
        ),
        (scrollbars === "xy" || scrollbars === "y") && /* @__PURE__ */ jsx(
          ScrollAreaScrollbar,
          {
            ...getStyles2("scrollbar"),
            orientation: "vertical",
            "data-hidden": type === "never" || void 0,
            forceMount: !0,
            onMouseEnter: () => setScrollbarHovered(!0),
            onMouseLeave: () => setScrollbarHovered(!1),
            children: /* @__PURE__ */ jsx(ScrollAreaThumb, { ...getStyles2("thumb") })
          }
        ),
        /* @__PURE__ */ jsx(
          ScrollAreaCorner,
          {
            ...getStyles2("corner"),
            "data-hovered": scrollbarHovered || void 0,
            "data-hidden": type === "never" || void 0
          }
        )
      ]
    }
  );
});
ScrollArea.displayName = "@mantine/core/ScrollArea";
const ScrollAreaAutosize = factory((props, ref) => {
  const {
    children: children2,
    classNames,
    styles,
    scrollbarSize,
    scrollHideDelay,
    type,
    dir,
    offsetScrollbars,
    viewportRef,
    onScrollPositionChange,
    unstyled,
    variant,
    viewportProps,
    scrollbars,
    style: style2,
    vars: vars2,
    onBottomReached,
    onTopReached,
    ...others
  } = useProps("ScrollAreaAutosize", defaultProps$1e, props);
  return /* @__PURE__ */ jsx(Box, { ...others, ref, style: [{ display: "flex", overflow: "auto" }, style2], children: /* @__PURE__ */ jsx(Box, { style: { display: "flex", flexDirection: "column", flex: 1 }, children: /* @__PURE__ */ jsx(
    ScrollArea,
    {
      classNames,
      styles,
      scrollHideDelay,
      scrollbarSize,
      type,
      dir,
      offsetScrollbars,
      viewportRef,
      onScrollPositionChange,
      unstyled,
      variant,
      viewportProps,
      vars: vars2,
      scrollbars,
      onBottomReached,
      onTopReached,
      children: children2
    }
  ) }) });
});
ScrollArea.classes = classes$C;
ScrollAreaAutosize.displayName = "@mantine/core/ScrollAreaAutosize";
ScrollAreaAutosize.classes = classes$C;
ScrollArea.Autosize = ScrollAreaAutosize;
var __default__$A = { root: "m_87cf2631" };
const classes$B = __default__$A, defaultProps$1d = {
  __staticSelector: "UnstyledButton"
}, UnstyledButton = polymorphicFactory(
  (_props, ref) => {
    const props = useProps("UnstyledButton", defaultProps$1d, _props), {
      className,
      component = "button",
      __staticSelector,
      unstyled,
      classNames,
      styles,
      style: style2,
      ...others
    } = props, getStyles2 = useStyles({
      name: __staticSelector,
      props,
      classes: classes$B,
      className,
      style: style2,
      classNames,
      styles,
      unstyled
    });
    return /* @__PURE__ */ jsx(
      Box,
      {
        ...getStyles2("root", { focusable: !0 }),
        component,
        ref,
        type: component === "button" ? "button" : void 0,
        ...others
      }
    );
  }
);
UnstyledButton.classes = classes$B;
UnstyledButton.displayName = "@mantine/core/UnstyledButton";
var __default__$z = { root: "m_515a97f8" };
const classes$A = __default__$z, defaultProps$1c = {}, VisuallyHidden = factory((_props, ref) => {
  const props = useProps("VisuallyHidden", defaultProps$1c, _props), { classNames, className, style: style2, styles, unstyled, vars: vars2, ...others } = props, getStyles2 = useStyles({
    name: "VisuallyHidden",
    classes: classes$A,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled
  });
  return /* @__PURE__ */ jsx(Box, { component: "span", ref, ...getStyles2("root"), ...others });
});
VisuallyHidden.classes = classes$A;
VisuallyHidden.displayName = "@mantine/core/VisuallyHidden";
var __default__$y = { root: "m_1b7284a3" };
const classes$z = __default__$y, defaultProps$1b = {}, varsResolver$A = (_, { radius, shadow }) => ({
  root: {
    "--paper-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--paper-shadow": getShadow(shadow)
  }
}), Paper = polymorphicFactory((_props, ref) => {
  const props = useProps("Paper", defaultProps$1b, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    withBorder,
    vars: vars2,
    radius,
    shadow,
    variant,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Paper",
    props,
    classes: classes$z,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars: vars2,
    varsResolver: varsResolver$A
  });
  return /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      mod: [{ "data-with-border": withBorder }, mod],
      ...getStyles2("root"),
      variant,
      ...others
    }
  );
});
Paper.classes = classes$z;
Paper.displayName = "@mantine/core/Paper";
function hasWindow() {
  return typeof window < "u";
}
function getNodeName(node2) {
  return isNode(node2) ? (node2.nodeName || "").toLowerCase() : "#document";
}
function getWindow(node2) {
  var _node$ownerDocument;
  return (node2 == null || (_node$ownerDocument = node2.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node2) {
  var _ref;
  return (_ref = (isNode(node2) ? node2.ownerDocument : node2.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return hasWindow() ? value instanceof Node || value instanceof getWindow(value).Node : !1;
}
function isElement(value) {
  return hasWindow() ? value instanceof Element || value instanceof getWindow(value).Element : !1;
}
function isHTMLElement(value) {
  return hasWindow() ? value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement : !1;
}
function isShadowRoot(value) {
  return !hasWindow() || typeof ShadowRoot > "u" ? !1 : value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector2) => {
    try {
      return element.matches(selector2);
    } catch {
      return !1;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit(), css = isElement(elementOrCss) ? getComputedStyle$2(elementOrCss) : elementOrCss;
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : !1) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : !1) || !webkit && (css.filter ? css.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  for (; isHTMLElement(currentNode) && !isLastTraversableNode(currentNode); ) {
    if (isContainingBlock(currentNode))
      return currentNode;
    if (isTopLayer(currentNode))
      return null;
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node2) {
  return ["html", "body", "#document"].includes(getNodeName(node2));
}
function getComputedStyle$2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  return isElement(element) ? {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  } : {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node2) {
  if (getNodeName(node2) === "html")
    return node2;
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node2.assignedSlot || // DOM Element detected.
    node2.parentNode || // ShadowRoot detected.
    isShadowRoot(node2) && node2.host || // Fallback.
    getDocumentElement(node2)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node2) {
  const parentNode = getParentNode(node2);
  return isLastTraversableNode(parentNode) ? node2.ownerDocument ? node2.ownerDocument.body : node2.body : isHTMLElement(parentNode) && isOverflowElement(parentNode) ? parentNode : getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node2, list2, traverseIframes) {
  var _node$ownerDocument2;
  list2 === void 0 && (list2 = []), traverseIframes === void 0 && (traverseIframes = !0);
  const scrollableAncestor = getNearestOverflowAncestor(node2), isBody = scrollableAncestor === ((_node$ownerDocument2 = node2.ownerDocument) == null ? void 0 : _node$ownerDocument2.body), win2 = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win2);
    return list2.concat(win2, win2.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list2.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win2) {
  return win2.parent && Object.getPrototypeOf(win2.parent) ? win2.frameElement : null;
}
function activeElement(doc) {
  let activeElement2 = doc.activeElement;
  for (; ((_activeElement = activeElement2) == null || (_activeElement = _activeElement.shadowRoot) == null ? void 0 : _activeElement.activeElement) != null; ) {
    var _activeElement;
    activeElement2 = activeElement2.shadowRoot.activeElement;
  }
  return activeElement2;
}
function contains(parent, child) {
  if (!parent || !child)
    return !1;
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
  if (parent.contains(child))
    return !0;
  if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    for (; next; ) {
      if (parent === next)
        return !0;
      next = next.parentNode || next.host;
    }
  }
  return !1;
}
function getPlatform() {
  const uaData = navigator.userAgentData;
  return uaData != null && uaData.platform ? uaData.platform : navigator.platform;
}
function getUserAgent() {
  const uaData = navigator.userAgentData;
  return uaData && Array.isArray(uaData.brands) ? uaData.brands.map((_ref) => {
    let {
      brand,
      version: version2
    } = _ref;
    return brand + "/" + version2;
  }).join(" ") : navigator.userAgent;
}
function isVirtualPointerEvent(event) {
  return isJSDOM() ? !1 : !isAndroid() && event.width === 0 && event.height === 0 || isAndroid() && event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "mouse" || // iOS VoiceOver returns 0.333• for width/height.
  event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "touch";
}
function isSafari() {
  return /apple/i.test(navigator.vendor);
}
function isAndroid() {
  const re = /android/i;
  return re.test(getPlatform()) || re.test(getUserAgent());
}
function isMac() {
  return getPlatform().toLowerCase().startsWith("mac") && !navigator.maxTouchPoints;
}
function isJSDOM() {
  return getUserAgent().includes("jsdom/");
}
function isMouseLikePointerType(pointerType, strict) {
  const values2 = ["mouse", "pen"];
  return values2.push("", void 0), values2.includes(pointerType);
}
function isReactEvent(event) {
  return "nativeEvent" in event;
}
function isRootElement(element) {
  return element.matches("html,body");
}
function getDocument(node2) {
  return (node2 == null ? void 0 : node2.ownerDocument) || document;
}
function isEventTargetWithin(event, node2) {
  if (node2 == null)
    return !1;
  if ("composedPath" in event)
    return event.composedPath().includes(node2);
  const e2 = event;
  return e2.target != null && node2.contains(e2.target);
}
function getTarget(event) {
  return "composedPath" in event ? event.composedPath()[0] : event.target;
}
const TYPEABLE_SELECTOR = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
function isTypeableElement(element) {
  return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);
}
const min$1 = Math.min, max$1 = Math.max, round = Math.round, floor = Math.floor, createCoords = (v2) => ({
  x: v2,
  y: v2
}), oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp$1(start2, value, end) {
  return max$1(start2, min$1(value, end));
}
function evaluate(value, param) {
  return typeof value == "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  rtl === void 0 && (rtl = !1);
  const alignment = getAlignment(placement), alignmentAxis = getAlignmentAxis(placement), length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  return rects.reference[length] > rects.floating[length] && (mainAlignmentSide = getOppositePlacement(mainAlignmentSide)), [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"], rl = ["right", "left"], tb = ["top", "bottom"], bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      return rtl ? isStart ? rl : lr : isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list2 = getSideList(getSide(placement), direction === "start", rtl);
  return alignment && (list2 = list2.map((side) => side + "-" + alignment), flipAlignment && (list2 = list2.concat(list2.map(getOppositeAlignmentPlacement)))), list2;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding != "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x2,
    y: y2,
    width: width2,
    height
  } = rect;
  return {
    width: width2,
    height,
    top: y2,
    left: x2,
    right: x2 + width2,
    bottom: y2 + height,
    x: x2,
    y: y2
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement), alignmentAxis = getAlignmentAxis(placement), alignLength = getAxisLength(alignmentAxis), side = getSide(placement), isVertical = sideAxis === "y", commonX = reference.x + reference.width / 2 - floating.width / 2, commonY = reference.y + reference.height / 2 - floating.height / 2, commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config, validMiddleware = middleware.filter(Boolean), rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  }), {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl), statefulPlacement = placement, middlewareData = {}, resetCount = 0;
  for (let i2 = 0; i2 < validMiddleware.length; i2++) {
    const {
      name,
      fn
    } = validMiddleware[i2], {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX ?? x2, y2 = nextY ?? y2, middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    }, reset && resetCount <= 50 && (resetCount++, typeof reset == "object" && (reset.placement && (statefulPlacement = reset.placement), reset.rects && (rects = reset.rects === !0 ? await platform2.getElementRects({
      reference,
      floating,
      strategy
    }) : reset.rects), {
      x: x2,
      y: y2
    } = computeCoordsFromPlacement(rects, statefulPlacement, rtl)), i2 = -1);
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  options === void 0 && (options = {});
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state, {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = !1,
    padding = 0
  } = evaluate(options, state), paddingObject = getPaddingObject(padding), element = elements[altBoundary ? elementContext === "floating" ? "reference" : "floating" : elementContext], clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: (_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) == null || _await$platform$isEle ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  })), rect = elementContext === "floating" ? {
    x: x2,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference, offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating)), offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$3 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state, {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null)
      return {};
    const paddingObject = getPaddingObject(padding), coords = {
      x: x2,
      y: y2
    }, axis = getAlignmentAxis(placement), length = getAxisLength(axis), arrowDimensions = await platform2.getDimensions(element), isYAxis = axis === "y", minProp = isYAxis ? "top" : "left", maxProp = isYAxis ? "bottom" : "right", clientProp = isYAxis ? "clientHeight" : "clientWidth", endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length], startDiff = coords[axis] - rects.reference[axis], arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) && (clientSize = elements.floating[clientProp] || rects.floating[length]);
    const centerToReference = endDiff / 2 - startDiff / 2, largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1, minPadding = min$1(paddingObject[minProp], largestPossiblePadding), maxPadding = min$1(paddingObject[maxProp], largestPossiblePadding), min$1$1 = minPadding, max2 = clientSize - arrowDimensions[length] - maxPadding, center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference, offset2 = clamp$1(min$1$1, center, max2), shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0, alignmentOffset = shouldAddOffset ? center < min$1$1 ? center - min$1$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
}), flip$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state, {
        mainAxis: checkMainAxis = !0,
        crossAxis: checkCrossAxis = !0,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = !0,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset)
        return {};
      const side = getSide(placement), initialSideAxis = getSideAxis(initialPlacement), isBasePlacement = getSide(initialPlacement) === initialPlacement, rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)), fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement)), hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      !specifiedFallbackPlacements && hasFallbackAxisSideDirection && fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      const placements = [initialPlacement, ...fallbackPlacements], overflow = await detectOverflow(state, detectOverflowOptions), overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis && overflows.push(overflow[side]), checkCrossAxis) {
        const sides = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides[0]], overflow[sides[1]]);
      }
      if (overflowsData = [...overflowsData, {
        placement,
        overflows
      }], !overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1, nextPlacement = placements[nextIndex];
        if (nextPlacement)
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement)
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d2.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return !0;
              }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              placement2 && (resetPlacement = placement2);
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        if (placement !== resetPlacement)
          return {
            reset: {
              placement: resetPlacement
            }
          };
      }
      return {};
    }
  };
};
function getBoundingRect(rects) {
  const minX = min$1(...rects.map((rect) => rect.left)), minY = min$1(...rects.map((rect) => rect.top)), maxX = max$1(...rects.map((rect) => rect.right)), maxY = max$1(...rects.map((rect) => rect.bottom));
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getRectsByLine(rects) {
  const sortedRects = rects.slice().sort((a2, b2) => a2.y - b2.y), groups = [];
  let prevRect = null;
  for (let i2 = 0; i2 < sortedRects.length; i2++) {
    const rect = sortedRects[i2];
    !prevRect || rect.y - prevRect.y > prevRect.height / 2 ? groups.push([rect]) : groups[groups.length - 1].push(rect), prevRect = rect;
  }
  return groups.map((rect) => rectToClientRect(getBoundingRect(rect)));
}
const inline$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "inline",
    options,
    async fn(state) {
      const {
        placement,
        elements,
        rects,
        platform: platform2,
        strategy
      } = state, {
        padding = 2,
        x: x2,
        y: y2
      } = evaluate(options, state), nativeClientRects = Array.from(await (platform2.getClientRects == null ? void 0 : platform2.getClientRects(elements.reference)) || []), clientRects = getRectsByLine(nativeClientRects), fallback = rectToClientRect(getBoundingRect(nativeClientRects)), paddingObject = getPaddingObject(padding);
      function getBoundingClientRect2() {
        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x2 != null && y2 != null)
          return clientRects.find((rect) => x2 > rect.left - paddingObject.left && x2 < rect.right + paddingObject.right && y2 > rect.top - paddingObject.top && y2 < rect.bottom + paddingObject.bottom) || fallback;
        if (clientRects.length >= 2) {
          if (getSideAxis(placement) === "y") {
            const firstRect = clientRects[0], lastRect = clientRects[clientRects.length - 1], isTop = getSide(placement) === "top", top2 = firstRect.top, bottom2 = lastRect.bottom, left2 = isTop ? firstRect.left : lastRect.left, right2 = isTop ? firstRect.right : lastRect.right, width3 = right2 - left2, height2 = bottom2 - top2;
            return {
              top: top2,
              bottom: bottom2,
              left: left2,
              right: right2,
              width: width3,
              height: height2,
              x: left2,
              y: top2
            };
          }
          const isLeftSide = getSide(placement) === "left", maxRight = max$1(...clientRects.map((rect) => rect.right)), minLeft = min$1(...clientRects.map((rect) => rect.left)), measureRects = clientRects.filter((rect) => isLeftSide ? rect.left === minLeft : rect.right === maxRight), top = measureRects[0].top, bottom = measureRects[measureRects.length - 1].bottom, left = minLeft, right = maxRight, width2 = right - left, height = bottom - top;
          return {
            top,
            bottom,
            left,
            right,
            width: width2,
            height,
            x: left,
            y: top
          };
        }
        return fallback;
      }
      const resetRects = await platform2.getElementRects({
        reference: {
          getBoundingClientRect: getBoundingClientRect2
        },
        floating: elements.floating,
        strategy
      });
      return rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height ? {
        reset: {
          rects: resetRects
        }
      } : {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state, rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)), side = getSide(placement), alignment = getAlignment(placement), isVertical = getSideAxis(placement) === "y", mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1, crossAxisMulti = rtl && isVertical ? -1 : 1, rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue == "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  return alignment && typeof alignmentAxis == "number" && (crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis), isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2 = function(options) {
  return options === void 0 && (options = 0), {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y: y2,
        placement,
        middlewareData
      } = state, diffCoords = await convertValueToCoords(state, options);
      return placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset ? {} : {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
}, shift$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y2,
        placement
      } = state, {
        mainAxis: checkMainAxis = !0,
        crossAxis: checkCrossAxis = !1,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y3
            } = _ref;
            return {
              x: x3,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state), coords = {
        x: x2,
        y: y2
      }, overflow = await detectOverflow(state, detectOverflowOptions), crossAxis = getSideAxis(getSide(placement)), mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis], crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left", maxSide = mainAxis === "y" ? "bottom" : "right", min2 = mainAxisCoord + overflow[minSide], max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp$1(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left", maxSide = crossAxis === "y" ? "bottom" : "right", min2 = crossAxisCoord + overflow[minSide], max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp$1(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2
        }
      };
    }
  };
}, limitShift$2 = function(options) {
  return options === void 0 && (options = {}), {
    options,
    fn(state) {
      const {
        x: x2,
        y: y2,
        placement,
        rects,
        middlewareData
      } = state, {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = !0,
        crossAxis: checkCrossAxis = !0
      } = evaluate(options, state), coords = {
        x: x2,
        y: y2
      }, crossAxis = getSideAxis(placement), mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis], crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state), computedOffset = typeof rawOffset == "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width", limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis, limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        mainAxisCoord < limitMin ? mainAxisCoord = limitMin : mainAxisCoord > limitMax && (mainAxisCoord = limitMax);
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height", isOriginSide = ["top", "left"].includes(getSide(placement)), limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide && ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0) + (isOriginSide ? 0 : computedOffset.crossAxis), limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        crossAxisCoord < limitMin ? crossAxisCoord = limitMin : crossAxisCoord > limitMax && (crossAxisCoord = limitMax);
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
}, size$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "size",
    options,
    async fn(state) {
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state, {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state), overflow = await detectOverflow(state, detectOverflowOptions), side = getSide(placement), alignment = getAlignment(placement), isYAxis = getSideAxis(placement) === "y", {
        width: width2,
        height
      } = rects.floating;
      let heightSide, widthSide;
      side === "top" || side === "bottom" ? (heightSide = side, widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right") : (widthSide = side, heightSide = alignment === "end" ? "top" : "bottom");
      const maximumClippingHeight = height - overflow.top - overflow.bottom, maximumClippingWidth = width2 - overflow.left - overflow.right, overflowAvailableHeight = min$1(height - overflow[heightSide], maximumClippingHeight), overflowAvailableWidth = min$1(width2 - overflow[widthSide], maximumClippingWidth), noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight, availableWidth = overflowAvailableWidth;
      if (isYAxis ? availableWidth = alignment || noShift ? min$1(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth : availableHeight = alignment || noShift ? min$1(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight, noShift && !alignment) {
        const xMin = max$1(overflow.left, 0), xMax = max$1(overflow.right, 0), yMin = max$1(overflow.top, 0), yMax = max$1(overflow.bottom, 0);
        isYAxis ? availableWidth = width2 - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max$1(overflow.left, overflow.right)) : availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max$1(overflow.top, overflow.bottom));
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      return width2 !== nextDimensions.width || height !== nextDimensions.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function getCssDimensions(element) {
  const css = getComputedStyle$2(element);
  let width2 = parseFloat(css.width) || 0, height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element), offsetWidth = hasOffset ? element.offsetWidth : width2, offsetHeight = hasOffset ? element.offsetHeight : height, shouldFallback = round(width2) !== offsetWidth || round(height) !== offsetHeight;
  return shouldFallback && (width2 = offsetWidth, height = offsetHeight), {
    width: width2,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return isElement(element) ? element : element.contextElement;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement))
    return createCoords(1);
  const rect = domElement.getBoundingClientRect(), {
    width: width2,
    height,
    $
  } = getCssDimensions(domElement);
  let x2 = ($ ? round(rect.width) : rect.width) / width2, y2 = ($ ? round(rect.height) : rect.height) / height;
  return (!x2 || !Number.isFinite(x2)) && (x2 = 1), (!y2 || !Number.isFinite(y2)) && (y2 = 1), {
    x: x2,
    y: y2
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win2 = getWindow(element);
  return !isWebKit() || !win2.visualViewport ? noOffsets : {
    x: win2.visualViewport.offsetLeft,
    y: win2.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  return isFixed === void 0 && (isFixed = !1), !floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element) ? !1 : isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  includeScale === void 0 && (includeScale = !1), isFixedStrategy === void 0 && (isFixedStrategy = !1);
  const clientRect = element.getBoundingClientRect(), domElement = unwrapElement(element);
  let scale2 = createCoords(1);
  includeScale && (offsetParent ? isElement(offsetParent) && (scale2 = getScale(offsetParent)) : scale2 = getScale(element));
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale2.x, y2 = (clientRect.top + visualOffsets.y) / scale2.y, width2 = clientRect.width / scale2.x, height = clientRect.height / scale2.y;
  if (domElement) {
    const win2 = getWindow(domElement), offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win2, currentIFrame = currentWin.frameElement;
    for (; currentIFrame && offsetParent && offsetWin !== currentWin; ) {
      const iframeScale = getScale(currentIFrame), iframeRect = currentIFrame.getBoundingClientRect(), css = getComputedStyle$2(currentIFrame), left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x, top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x, y2 *= iframeScale.y, width2 *= iframeScale.x, height *= iframeScale.y, x2 += left, y2 += top, currentWin = getWindow(currentIFrame), currentIFrame = currentWin.frameElement;
    }
  }
  return rectToClientRect({
    width: width2,
    height,
    x: x2,
    y: y2
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed", documentElement = getDocumentElement(offsetParent), topLayer = elements ? isTopLayer(elements.floating) : !1;
  if (offsetParent === documentElement || topLayer && isFixed)
    return rect;
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  }, scale2 = createCoords(1);
  const offsets = createCoords(0), isOffsetParentAnElement = isHTMLElement(offsetParent);
  if ((isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) && ((getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) && (scroll = getNodeScroll(offsetParent)), isHTMLElement(offsetParent))) {
    const offsetRect = getBoundingClientRect(offsetParent);
    scale2 = getScale(offsetParent), offsets.x = offsetRect.x + offsetParent.clientLeft, offsets.y = offsetRect.y + offsetParent.clientTop;
  }
  return {
    width: rect.width * scale2.x,
    height: rect.height * scale2.y,
    x: rect.x * scale2.x - scroll.scrollLeft * scale2.x + offsets.x,
    y: rect.y * scale2.y - scroll.scrollTop * scale2.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element), scroll = getNodeScroll(element), body = element.ownerDocument.body, width2 = max$1(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth), height = max$1(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  return getComputedStyle$2(body).direction === "rtl" && (x2 += max$1(html.clientWidth, body.clientWidth) - width2), {
    width: width2,
    height,
    x: x2,
    y: y2
  };
}
function getViewportRect(element, strategy) {
  const win2 = getWindow(element), html = getDocumentElement(element), visualViewport = win2.visualViewport;
  let width2 = html.clientWidth, height = html.clientHeight, x2 = 0, y2 = 0;
  if (visualViewport) {
    width2 = visualViewport.width, height = visualViewport.height;
    const visualViewportBased = isWebKit();
    (!visualViewportBased || visualViewportBased && strategy === "fixed") && (x2 = visualViewport.offsetLeft, y2 = visualViewport.offsetTop);
  }
  return {
    width: width2,
    height,
    x: x2,
    y: y2
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, !0, strategy === "fixed"), top = clientRect.top + element.clientTop, left = clientRect.left + element.clientLeft, scale2 = isHTMLElement(element) ? getScale(element) : createCoords(1), width2 = element.clientWidth * scale2.x, height = element.clientHeight * scale2.y, x2 = left * scale2.x, y2 = top * scale2.y;
  return {
    width: width2,
    height,
    x: x2,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport")
    rect = getViewportRect(element, strategy);
  else if (clippingAncestor === "document")
    rect = getDocumentRect(getDocumentElement(element));
  else if (isElement(clippingAncestor))
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  return parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode) ? !1 : getComputedStyle$2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult)
    return cachedResult;
  let result = getOverflowAncestors(element, [], !1).filter((el) => isElement(el) && getNodeName(el) !== "body"), currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  for (; isElement(currentNode) && !isLastTraversableNode(currentNode); ) {
    const computedStyle = getComputedStyle$2(currentNode), currentNodeIsContaining = isContainingBlock(currentNode);
    !currentNodeIsContaining && computedStyle.position === "fixed" && (currentContainingBlockComputedStyle = null), (elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode)) ? result = result.filter((ancestor) => ancestor !== currentNode) : currentContainingBlockComputedStyle = computedStyle, currentNode = getParentNode(currentNode);
  }
  return cache.set(element, result), result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const clippingAncestors = [...boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary), rootBoundary], firstClippingAncestor = clippingAncestors[0], clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    return accRect.top = max$1(rect.top, accRect.top), accRect.right = min$1(rect.right, accRect.right), accRect.bottom = min$1(rect.bottom, accRect.bottom), accRect.left = max$1(rect.left, accRect.left), accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width: width2,
    height
  } = getCssDimensions(element);
  return {
    width: width2,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent), documentElement = getDocumentElement(offsetParent), isFixed = strategy === "fixed", rect = getBoundingClientRect(element, !0, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed)
    if ((getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) && (scroll = getNodeScroll(offsetParent)), isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, !0, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft, offsets.y = offsetRect.y + offsetParent.clientTop;
    } else documentElement && (offsets.x = getWindowScrollBarX(documentElement));
  const x2 = rect.left + scroll.scrollLeft - offsets.x, y2 = rect.top + scroll.scrollTop - offsets.y;
  return {
    x: x2,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  return !isHTMLElement(element) || getComputedStyle$2(element).position === "fixed" ? null : polyfill ? polyfill(element) : element.offsetParent;
}
function getOffsetParent(element, polyfill) {
  const win2 = getWindow(element);
  if (isTopLayer(element))
    return win2;
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    for (; svgOffsetParent && !isLastTraversableNode(svgOffsetParent); ) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent))
        return svgOffsetParent;
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win2;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  for (; offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent); )
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  return offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent) ? win2 : offsetParent || getContainingBlock(element) || win2;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent, getDimensionsFn = this.getDimensions, floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$2(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element, onMove) {
  let io = null, timeoutId;
  const root2 = getDocumentElement(element);
  function cleanup2() {
    var _io;
    clearTimeout(timeoutId), (_io = io) == null || _io.disconnect(), io = null;
  }
  function refresh(skip, threshold) {
    skip === void 0 && (skip = !1), threshold === void 0 && (threshold = 1), cleanup2();
    const {
      left,
      top,
      width: width2,
      height
    } = element.getBoundingClientRect();
    if (skip || onMove(), !width2 || !height)
      return;
    const insetTop = floor(top), insetRight = floor(root2.clientWidth - (left + width2)), insetBottom = floor(root2.clientHeight - (top + height)), insetLeft = floor(left), options = {
      rootMargin: -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px",
      threshold: max$1(0, min$1(1, threshold)) || 1
    };
    let isFirstUpdate = !0;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate)
          return refresh();
        ratio ? refresh(!1, ratio) : timeoutId = setTimeout(() => {
          refresh(!1, 1e-7);
        }, 1e3);
      }
      isFirstUpdate = !1;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root2.ownerDocument
      });
    } catch {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  return refresh(!0), cleanup2;
}
function autoUpdate(reference, floating, update, options) {
  options === void 0 && (options = {});
  const {
    ancestorScroll = !0,
    ancestorResize = !0,
    elementResize = typeof ResizeObserver == "function",
    layoutShift = typeof IntersectionObserver == "function",
    animationFrame = !1
  } = options, referenceEl = unwrapElement(reference), ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: !0
    }), ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1, resizeObserver = null;
  elementResize && (resizeObserver = new ResizeObserver((_ref) => {
    let [firstEntry] = _ref;
    firstEntry && firstEntry.target === referenceEl && resizeObserver && (resizeObserver.unobserve(floating), cancelAnimationFrame(reobserveFrame), reobserveFrame = requestAnimationFrame(() => {
      var _resizeObserver;
      (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
    })), update();
  }), referenceEl && !animationFrame && resizeObserver.observe(referenceEl), resizeObserver.observe(floating));
  let frameId, prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  animationFrame && frameLoop();
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height) && update(), prevRefRect = nextRefRect, frameId = requestAnimationFrame(frameLoop);
  }
  return update(), () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update), ancestorResize && ancestor.removeEventListener("resize", update);
    }), cleanupIo == null || cleanupIo(), (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect(), resizeObserver = null, animationFrame && cancelAnimationFrame(frameId);
  };
}
const offset$1 = offset$2, shift$1 = shift$2, flip$1 = flip$2, size$1 = size$2, arrow$2 = arrow$3, inline$1 = inline$2, limitShift$1 = limitShift$2, computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map(), mergedOptions = {
    platform,
    ...options
  }, platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var index$1 = typeof document < "u" ? useLayoutEffect : useEffect;
function deepEqual(a2, b2) {
  if (a2 === b2)
    return !0;
  if (typeof a2 != typeof b2)
    return !1;
  if (typeof a2 == "function" && a2.toString() === b2.toString())
    return !0;
  let length, i2, keys2;
  if (a2 && b2 && typeof a2 == "object") {
    if (Array.isArray(a2)) {
      if (length = a2.length, length !== b2.length) return !1;
      for (i2 = length; i2-- !== 0; )
        if (!deepEqual(a2[i2], b2[i2]))
          return !1;
      return !0;
    }
    if (keys2 = Object.keys(a2), length = keys2.length, length !== Object.keys(b2).length)
      return !1;
    for (i2 = length; i2-- !== 0; )
      if (!{}.hasOwnProperty.call(b2, keys2[i2]))
        return !1;
    for (i2 = length; i2-- !== 0; ) {
      const key = keys2[i2];
      if (!(key === "_owner" && a2.$$typeof) && !deepEqual(a2[key], b2[key]))
        return !1;
    }
    return !0;
  }
  return a2 !== a2 && b2 !== b2;
}
function getDPR(element) {
  return typeof window > "u" ? 1 : (element.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef$1(value) {
  const ref = React.useRef(value);
  return index$1(() => {
    ref.current = value;
  }), ref;
}
function useFloating$1(options) {
  options === void 0 && (options = {});
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform: transform2 = !0,
    whileElementsMounted,
    open
  } = options, [data, setData] = React.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: !1
  }), [latestMiddleware, setLatestMiddleware] = React.useState(middleware);
  deepEqual(latestMiddleware, middleware) || setLatestMiddleware(middleware);
  const [_reference, _setReference] = React.useState(null), [_floating, _setFloating] = React.useState(null), setReference = React.useCallback((node2) => {
    node2 !== referenceRef.current && (referenceRef.current = node2, _setReference(node2));
  }, []), setFloating = React.useCallback((node2) => {
    node2 !== floatingRef.current && (floatingRef.current = node2, _setFloating(node2));
  }, []), referenceEl = externalReference || _reference, floatingEl = externalFloating || _floating, referenceRef = React.useRef(null), floatingRef = React.useRef(null), dataRef = React.useRef(data), hasWhileElementsMounted = whileElementsMounted != null, whileElementsMountedRef = useLatestRef$1(whileElementsMounted), platformRef = useLatestRef$1(platform2), openRef = useLatestRef$1(open), update = React.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current)
      return;
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    platformRef.current && (config.platform = platformRef.current), computePosition(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== !1
      };
      isMountedRef.current && !deepEqual(dataRef.current, fullData) && (dataRef.current = fullData, ReactDOM.flushSync(() => {
        setData(fullData);
      }));
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index$1(() => {
    open === !1 && dataRef.current.isPositioned && (dataRef.current.isPositioned = !1, setData((data2) => ({
      ...data2,
      isPositioned: !1
    })));
  }, [open]);
  const isMountedRef = React.useRef(!1);
  index$1(() => (isMountedRef.current = !0, () => {
    isMountedRef.current = !1;
  }), []), index$1(() => {
    if (referenceEl && (referenceRef.current = referenceEl), floatingEl && (floatingRef.current = floatingEl), referenceEl && floatingEl) {
      if (whileElementsMountedRef.current)
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]), elements = React.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]), floatingStyles = React.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating)
      return initialStyles;
    const x2 = roundByDPR(elements.floating, data.x), y2 = roundByDPR(elements.floating, data.y);
    return transform2 ? {
      ...initialStyles,
      transform: "translate(" + x2 + "px, " + y2 + "px)",
      ...getDPR(elements.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: strategy,
      left: x2,
      top: y2
    };
  }, [strategy, transform2, elements.floating, data.x, data.y]);
  return React.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
const arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options == "function" ? options(state) : options;
      return element && isRef(element) ? element.current != null ? arrow$2({
        element: element.current,
        padding
      }).fn(state) : {} : element ? arrow$2({
        element,
        padding
      }).fn(state) : {};
    }
  };
}, offset = (options, deps) => ({
  ...offset$1(options),
  options: [options, deps]
}), shift = (options, deps) => ({
  ...shift$1(options),
  options: [options, deps]
}), limitShift = (options, deps) => ({
  ...limitShift$1(options),
  options: [options, deps]
}), flip = (options, deps) => ({
  ...flip$1(options),
  options: [options, deps]
}), size = (options, deps) => ({
  ...size$1(options),
  options: [options, deps]
}), inline = (options, deps) => ({
  ...inline$1(options),
  options: [options, deps]
}), arrow = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
}), SafeReact = {
  ...React
}, useInsertionEffect = SafeReact.useInsertionEffect, useSafeInsertionEffect = useInsertionEffect || ((fn) => fn());
function useEffectEvent(callback) {
  const ref = React.useRef(() => {
  });
  return useSafeInsertionEffect(() => {
    ref.current = callback;
  }), React.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}
var index = typeof document < "u" ? useLayoutEffect : useEffect;
let serverHandoffComplete = !1, count = 0;
const genId = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++
);
function useFloatingId() {
  const [id2, setId] = React.useState(() => serverHandoffComplete ? genId() : void 0);
  return index(() => {
    id2 == null && setId(genId());
  }, []), React.useEffect(() => {
    serverHandoffComplete = !0;
  }, []), id2;
}
const useReactId = SafeReact.useId, useId = useReactId || useFloatingId;
function createPubSub() {
  const map2 = /* @__PURE__ */ new Map();
  return {
    emit(event, data) {
      var _map$get;
      (_map$get = map2.get(event)) == null || _map$get.forEach((handler) => handler(data));
    },
    on(event, listener) {
      map2.set(event, [...map2.get(event) || [], listener]);
    },
    off(event, listener) {
      var _map$get2;
      map2.set(event, ((_map$get2 = map2.get(event)) == null ? void 0 : _map$get2.filter((l2) => l2 !== listener)) || []);
    }
  };
}
const FloatingNodeContext = /* @__PURE__ */ React.createContext(null), FloatingTreeContext = /* @__PURE__ */ React.createContext(null), useFloatingParentNodeId = () => {
  var _React$useContext;
  return ((_React$useContext = React.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
}, useFloatingTree = () => React.useContext(FloatingTreeContext);
function createAttribute(name) {
  return "data-floating-ui-" + name;
}
function useLatestRef(value) {
  const ref = useRef(value);
  return index(() => {
    ref.current = value;
  }), ref;
}
const safePolygonIdentifier = /* @__PURE__ */ createAttribute("safe-polygon");
function getDelay(value, prop, pointerType) {
  return pointerType && !isMouseLikePointerType(pointerType) ? 0 : typeof value == "number" ? value : value == null ? void 0 : value[prop];
}
function useHover(context, props) {
  props === void 0 && (props = {});
  const {
    open,
    onOpenChange,
    dataRef,
    events,
    elements
  } = context, {
    enabled = !0,
    delay: delay2 = 0,
    handleClose = null,
    mouseOnly = !1,
    restMs = 0,
    move = !0
  } = props, tree = useFloatingTree(), parentId = useFloatingParentNodeId(), handleCloseRef = useLatestRef(handleClose), delayRef = useLatestRef(delay2), openRef = useLatestRef(open), pointerTypeRef = React.useRef(), timeoutRef = React.useRef(-1), handlerRef = React.useRef(), restTimeoutRef = React.useRef(-1), blockMouseMoveRef = React.useRef(!0), performedPointerEventsMutationRef = React.useRef(!1), unbindMouseMoveRef = React.useRef(() => {
  }), restTimeoutPendingRef = React.useRef(!1), isHoverOpen = React.useCallback(() => {
    var _dataRef$current$open;
    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;
    return (type == null ? void 0 : type.includes("mouse")) && type !== "mousedown";
  }, [dataRef]);
  React.useEffect(() => {
    if (!enabled) return;
    function onOpenChange2(_ref) {
      let {
        open: open2
      } = _ref;
      open2 || (clearTimeout(timeoutRef.current), clearTimeout(restTimeoutRef.current), blockMouseMoveRef.current = !0, restTimeoutPendingRef.current = !1);
    }
    return events.on("openchange", onOpenChange2), () => {
      events.off("openchange", onOpenChange2);
    };
  }, [enabled, events]), React.useEffect(() => {
    if (!enabled || !handleCloseRef.current || !open) return;
    function onLeave(event) {
      isHoverOpen() && onOpenChange(!1, event, "hover");
    }
    const html = getDocument(elements.floating).documentElement;
    return html.addEventListener("mouseleave", onLeave), () => {
      html.removeEventListener("mouseleave", onLeave);
    };
  }, [elements.floating, open, onOpenChange, enabled, handleCloseRef, isHoverOpen]);
  const closeWithDelay = React.useCallback(function(event, runElseBranch, reason) {
    runElseBranch === void 0 && (runElseBranch = !0), reason === void 0 && (reason = "hover");
    const closeDelay = getDelay(delayRef.current, "close", pointerTypeRef.current);
    closeDelay && !handlerRef.current ? (clearTimeout(timeoutRef.current), timeoutRef.current = window.setTimeout(() => onOpenChange(!1, event, reason), closeDelay)) : runElseBranch && (clearTimeout(timeoutRef.current), onOpenChange(!1, event, reason));
  }, [delayRef, onOpenChange]), cleanupMouseMoveHandler = useEffectEvent(() => {
    unbindMouseMoveRef.current(), handlerRef.current = void 0;
  }), clearPointerEvents = useEffectEvent(() => {
    if (performedPointerEventsMutationRef.current) {
      const body = getDocument(elements.floating).body;
      body.style.pointerEvents = "", body.removeAttribute(safePolygonIdentifier), performedPointerEventsMutationRef.current = !1;
    }
  }), isClickLikeOpenEvent = useEffectEvent(() => dataRef.current.openEvent ? ["click", "mousedown"].includes(dataRef.current.openEvent.type) : !1);
  React.useEffect(() => {
    if (!enabled) return;
    function onMouseEnter(event) {
      if (clearTimeout(timeoutRef.current), blockMouseMoveRef.current = !1, mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || restMs > 0 && !getDelay(delayRef.current, "open"))
        return;
      const openDelay = getDelay(delayRef.current, "open", pointerTypeRef.current);
      openDelay ? timeoutRef.current = window.setTimeout(() => {
        openRef.current || onOpenChange(!0, event, "hover");
      }, openDelay) : open || onOpenChange(!0, event, "hover");
    }
    function onMouseLeave(event) {
      if (isClickLikeOpenEvent()) return;
      unbindMouseMoveRef.current();
      const doc = getDocument(elements.floating);
      if (clearTimeout(restTimeoutRef.current), restTimeoutPendingRef.current = !1, handleCloseRef.current && dataRef.current.floatingContext) {
        open || clearTimeout(timeoutRef.current), handlerRef.current = handleCloseRef.current({
          ...dataRef.current.floatingContext,
          tree,
          x: event.clientX,
          y: event.clientY,
          onClose() {
            clearPointerEvents(), cleanupMouseMoveHandler(), isClickLikeOpenEvent() || closeWithDelay(event, !0, "safe-polygon");
          }
        });
        const handler = handlerRef.current;
        doc.addEventListener("mousemove", handler), unbindMouseMoveRef.current = () => {
          doc.removeEventListener("mousemove", handler);
        };
        return;
      }
      (pointerTypeRef.current === "touch" ? !contains(elements.floating, event.relatedTarget) : !0) && closeWithDelay(event);
    }
    function onScrollMouseLeave(event) {
      isClickLikeOpenEvent() || dataRef.current.floatingContext && (handleCloseRef.current == null || handleCloseRef.current({
        ...dataRef.current.floatingContext,
        tree,
        x: event.clientX,
        y: event.clientY,
        onClose() {
          clearPointerEvents(), cleanupMouseMoveHandler(), isClickLikeOpenEvent() || closeWithDelay(event);
        }
      })(event));
    }
    if (isElement(elements.domReference)) {
      var _elements$floating;
      const ref = elements.domReference;
      return open && ref.addEventListener("mouseleave", onScrollMouseLeave), (_elements$floating = elements.floating) == null || _elements$floating.addEventListener("mouseleave", onScrollMouseLeave), move && ref.addEventListener("mousemove", onMouseEnter, {
        once: !0
      }), ref.addEventListener("mouseenter", onMouseEnter), ref.addEventListener("mouseleave", onMouseLeave), () => {
        var _elements$floating2;
        open && ref.removeEventListener("mouseleave", onScrollMouseLeave), (_elements$floating2 = elements.floating) == null || _elements$floating2.removeEventListener("mouseleave", onScrollMouseLeave), move && ref.removeEventListener("mousemove", onMouseEnter), ref.removeEventListener("mouseenter", onMouseEnter), ref.removeEventListener("mouseleave", onMouseLeave);
      };
    }
  }, [elements, enabled, context, mouseOnly, restMs, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, openRef, tree, delayRef, handleCloseRef, dataRef, isClickLikeOpenEvent]), index(() => {
    var _handleCloseRef$curre;
    if (enabled && open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {
      performedPointerEventsMutationRef.current = !0;
      const floatingEl = elements.floating;
      if (isElement(elements.domReference) && floatingEl) {
        var _tree$nodesRef$curren;
        const body = getDocument(elements.floating).body;
        body.setAttribute(safePolygonIdentifier, "");
        const ref = elements.domReference, parentFloating = tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find((node2) => node2.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren.elements.floating;
        return parentFloating && (parentFloating.style.pointerEvents = ""), body.style.pointerEvents = "none", ref.style.pointerEvents = "auto", floatingEl.style.pointerEvents = "auto", () => {
          body.style.pointerEvents = "", ref.style.pointerEvents = "", floatingEl.style.pointerEvents = "";
        };
      }
    }
  }, [enabled, open, parentId, elements, tree, handleCloseRef, isHoverOpen]), index(() => {
    open || (pointerTypeRef.current = void 0, restTimeoutPendingRef.current = !1, cleanupMouseMoveHandler(), clearPointerEvents());
  }, [open, cleanupMouseMoveHandler, clearPointerEvents]), React.useEffect(() => () => {
    cleanupMouseMoveHandler(), clearTimeout(timeoutRef.current), clearTimeout(restTimeoutRef.current), clearPointerEvents();
  }, [enabled, elements.domReference, cleanupMouseMoveHandler, clearPointerEvents]);
  const reference = React.useMemo(() => {
    function setPointerRef(event) {
      pointerTypeRef.current = event.pointerType;
    }
    return {
      onPointerDown: setPointerRef,
      onPointerEnter: setPointerRef,
      onMouseMove(event) {
        const {
          nativeEvent
        } = event;
        function handleMouseMove() {
          !blockMouseMoveRef.current && !openRef.current && onOpenChange(!0, nativeEvent, "hover");
        }
        mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || open || restMs === 0 || restTimeoutPendingRef.current && event.movementX ** 2 + event.movementY ** 2 < 2 || (clearTimeout(restTimeoutRef.current), pointerTypeRef.current === "touch" ? handleMouseMove() : (restTimeoutPendingRef.current = !0, restTimeoutRef.current = window.setTimeout(handleMouseMove, restMs)));
      }
    };
  }, [mouseOnly, onOpenChange, open, openRef, restMs]), floating = React.useMemo(() => ({
    onMouseEnter() {
      clearTimeout(timeoutRef.current);
    },
    onMouseLeave(event) {
      isClickLikeOpenEvent() || closeWithDelay(event.nativeEvent, !1);
    }
  }), [closeWithDelay, isClickLikeOpenEvent]);
  return React.useMemo(() => enabled ? {
    reference,
    floating
  } : {}, [enabled, reference, floating]);
}
const NOOP = () => {
}, FloatingDelayGroupContext = /* @__PURE__ */ React.createContext({
  delay: 0,
  initialDelay: 0,
  timeoutMs: 0,
  currentId: null,
  setCurrentId: NOOP,
  setState: NOOP,
  isInstantPhase: !1
}), useDelayGroupContext = () => React.useContext(FloatingDelayGroupContext);
function FloatingDelayGroup(props) {
  const {
    children: children2,
    delay: delay2,
    timeoutMs = 0
  } = props, [state, setState] = React.useReducer((prev, next) => ({
    ...prev,
    ...next
  }), {
    delay: delay2,
    timeoutMs,
    initialDelay: delay2,
    currentId: null,
    isInstantPhase: !1
  }), initialCurrentIdRef = React.useRef(null), setCurrentId = React.useCallback((currentId) => {
    setState({
      currentId
    });
  }, []);
  return index(() => {
    state.currentId ? initialCurrentIdRef.current === null ? initialCurrentIdRef.current = state.currentId : state.isInstantPhase || setState({
      isInstantPhase: !0
    }) : (state.isInstantPhase && setState({
      isInstantPhase: !1
    }), initialCurrentIdRef.current = null);
  }, [state.currentId, state.isInstantPhase]), /* @__PURE__ */ React.createElement(FloatingDelayGroupContext.Provider, {
    value: React.useMemo(() => ({
      ...state,
      setState,
      setCurrentId
    }), [state, setCurrentId])
  }, children2);
}
function useDelayGroup(context, options) {
  options === void 0 && (options = {});
  const {
    open,
    onOpenChange,
    floatingId
  } = context, {
    id: optionId,
    enabled = !0
  } = options, id2 = optionId ?? floatingId, groupContext = useDelayGroupContext(), {
    currentId,
    setCurrentId,
    initialDelay,
    setState,
    timeoutMs
  } = groupContext;
  return index(() => {
    enabled && currentId && (setState({
      delay: {
        open: 1,
        close: getDelay(initialDelay, "close")
      }
    }), currentId !== id2 && onOpenChange(!1));
  }, [enabled, id2, onOpenChange, setState, currentId, initialDelay]), index(() => {
    function unset() {
      onOpenChange(!1), setState({
        delay: initialDelay,
        currentId: null
      });
    }
    if (enabled && currentId && !open && currentId === id2) {
      if (timeoutMs) {
        const timeout2 = window.setTimeout(unset, timeoutMs);
        return () => {
          clearTimeout(timeout2);
        };
      }
      unset();
    }
  }, [enabled, open, setState, currentId, id2, onOpenChange, initialDelay, timeoutMs]), index(() => {
    enabled && (setCurrentId === NOOP || !open || setCurrentId(id2));
  }, [enabled, open, setCurrentId, id2]), groupContext;
}
function getChildren(nodes, id2) {
  let allChildren = nodes.filter((node2) => {
    var _node$context;
    return node2.parentId === id2 && ((_node$context = node2.context) == null ? void 0 : _node$context.open);
  }), currentChildren = allChildren;
  for (; currentChildren.length; )
    currentChildren = nodes.filter((node2) => {
      var _currentChildren;
      return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some((n2) => {
        var _node$context2;
        return node2.parentId === n2.id && ((_node$context2 = node2.context) == null ? void 0 : _node$context2.open);
      });
    }), allChildren = allChildren.concat(currentChildren);
  return allChildren;
}
const FOCUSABLE_ATTRIBUTE = "data-floating-ui-focusable", bubbleHandlerKeys = {
  pointerdown: "onPointerDown",
  mousedown: "onMouseDown",
  click: "onClick"
}, captureHandlerKeys = {
  pointerdown: "onPointerDownCapture",
  mousedown: "onMouseDownCapture",
  click: "onClickCapture"
}, normalizeProp = (normalizable) => {
  var _normalizable$escapeK, _normalizable$outside;
  return {
    escapeKey: typeof normalizable == "boolean" ? normalizable : (_normalizable$escapeK = normalizable == null ? void 0 : normalizable.escapeKey) != null ? _normalizable$escapeK : !1,
    outsidePress: typeof normalizable == "boolean" ? normalizable : (_normalizable$outside = normalizable == null ? void 0 : normalizable.outsidePress) != null ? _normalizable$outside : !0
  };
};
function useDismiss(context, props) {
  props === void 0 && (props = {});
  const {
    open,
    onOpenChange,
    elements,
    dataRef
  } = context, {
    enabled = !0,
    escapeKey = !0,
    outsidePress: unstable_outsidePress = !0,
    outsidePressEvent = "pointerdown",
    referencePress = !1,
    referencePressEvent = "pointerdown",
    ancestorScroll = !1,
    bubbles,
    capture
  } = props, tree = useFloatingTree(), outsidePressFn = useEffectEvent(typeof unstable_outsidePress == "function" ? unstable_outsidePress : () => !1), outsidePress = typeof unstable_outsidePress == "function" ? outsidePressFn : unstable_outsidePress, insideReactTreeRef = React.useRef(!1), endedOrStartedInsideRef = React.useRef(!1), {
    escapeKey: escapeKeyBubbles,
    outsidePress: outsidePressBubbles
  } = normalizeProp(bubbles), {
    escapeKey: escapeKeyCapture,
    outsidePress: outsidePressCapture
  } = normalizeProp(capture), isComposingRef = React.useRef(!1), closeOnEscapeKeyDown = useEffectEvent((event) => {
    var _dataRef$current$floa;
    if (!open || !enabled || !escapeKey || event.key !== "Escape" || isComposingRef.current)
      return;
    const nodeId = (_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.nodeId, children2 = tree ? getChildren(tree.nodesRef.current, nodeId) : [];
    if (!escapeKeyBubbles && (event.stopPropagation(), children2.length > 0)) {
      let shouldDismiss = !0;
      if (children2.forEach((child) => {
        var _child$context;
        if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {
          shouldDismiss = !1;
          return;
        }
      }), !shouldDismiss)
        return;
    }
    onOpenChange(!1, isReactEvent(event) ? event.nativeEvent : event, "escape-key");
  }), closeOnEscapeKeyDownCapture = useEffectEvent((event) => {
    var _getTarget2;
    const callback = () => {
      var _getTarget;
      closeOnEscapeKeyDown(event), (_getTarget = getTarget(event)) == null || _getTarget.removeEventListener("keydown", callback);
    };
    (_getTarget2 = getTarget(event)) == null || _getTarget2.addEventListener("keydown", callback);
  }), closeOnPressOutside = useEffectEvent((event) => {
    var _dataRef$current$floa2;
    const insideReactTree = insideReactTreeRef.current;
    insideReactTreeRef.current = !1;
    const endedOrStartedInside = endedOrStartedInsideRef.current;
    if (endedOrStartedInsideRef.current = !1, outsidePressEvent === "click" && endedOrStartedInside || insideReactTree || typeof outsidePress == "function" && !outsidePress(event))
      return;
    const target = getTarget(event), inertSelector = "[" + createAttribute("inert") + "]", markers = getDocument(elements.floating).querySelectorAll(inertSelector);
    let targetRootAncestor = isElement(target) ? target : null;
    for (; targetRootAncestor && !isLastTraversableNode(targetRootAncestor); ) {
      const nextParent = getParentNode(targetRootAncestor);
      if (isLastTraversableNode(nextParent) || !isElement(nextParent))
        break;
      targetRootAncestor = nextParent;
    }
    if (markers.length && isElement(target) && !isRootElement(target) && // Clicked on a direct ancestor (e.g. FloatingOverlay).
    !contains(target, elements.floating) && // If the target root element contains none of the markers, then the
    // element was injected after the floating element rendered.
    Array.from(markers).every((marker) => !contains(targetRootAncestor, marker)))
      return;
    if (isHTMLElement(target) && floating) {
      const canScrollX = target.clientWidth > 0 && target.scrollWidth > target.clientWidth, canScrollY = target.clientHeight > 0 && target.scrollHeight > target.clientHeight;
      let xCond = canScrollY && event.offsetX > target.clientWidth;
      if (canScrollY && getComputedStyle$2(target).direction === "rtl" && (xCond = event.offsetX <= target.offsetWidth - target.clientWidth), xCond || canScrollX && event.offsetY > target.clientHeight)
        return;
    }
    const nodeId = (_dataRef$current$floa2 = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa2.nodeId, targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some((node2) => {
      var _node$context;
      return isEventTargetWithin(event, (_node$context = node2.context) == null ? void 0 : _node$context.elements.floating);
    });
    if (isEventTargetWithin(event, elements.floating) || isEventTargetWithin(event, elements.domReference) || targetIsInsideChildren)
      return;
    const children2 = tree ? getChildren(tree.nodesRef.current, nodeId) : [];
    if (children2.length > 0) {
      let shouldDismiss = !0;
      if (children2.forEach((child) => {
        var _child$context2;
        if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {
          shouldDismiss = !1;
          return;
        }
      }), !shouldDismiss)
        return;
    }
    onOpenChange(!1, event, "outside-press");
  }), closeOnPressOutsideCapture = useEffectEvent((event) => {
    var _getTarget4;
    const callback = () => {
      var _getTarget3;
      closeOnPressOutside(event), (_getTarget3 = getTarget(event)) == null || _getTarget3.removeEventListener(outsidePressEvent, callback);
    };
    (_getTarget4 = getTarget(event)) == null || _getTarget4.addEventListener(outsidePressEvent, callback);
  });
  React.useEffect(() => {
    if (!open || !enabled)
      return;
    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles, dataRef.current.__outsidePressBubbles = outsidePressBubbles;
    let compositionTimeout = -1;
    function onScroll(event) {
      onOpenChange(!1, event, "ancestor-scroll");
    }
    function handleCompositionStart() {
      window.clearTimeout(compositionTimeout), isComposingRef.current = !0;
    }
    function handleCompositionEnd() {
      compositionTimeout = window.setTimeout(
        () => {
          isComposingRef.current = !1;
        },
        // 0ms or 1ms don't work in Safari. 5ms appears to consistently work.
        // Only apply to WebKit for the test to remain 0ms.
        isWebKit() ? 5 : 0
      );
    }
    const doc = getDocument(elements.floating);
    escapeKey && (doc.addEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture), doc.addEventListener("compositionstart", handleCompositionStart), doc.addEventListener("compositionend", handleCompositionEnd)), outsidePress && doc.addEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);
    let ancestors = [];
    return ancestorScroll && (isElement(elements.domReference) && (ancestors = getOverflowAncestors(elements.domReference)), isElement(elements.floating) && (ancestors = ancestors.concat(getOverflowAncestors(elements.floating))), !isElement(elements.reference) && elements.reference && elements.reference.contextElement && (ancestors = ancestors.concat(getOverflowAncestors(elements.reference.contextElement)))), ancestors = ancestors.filter((ancestor) => {
      var _doc$defaultView;
      return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);
    }), ancestors.forEach((ancestor) => {
      ancestor.addEventListener("scroll", onScroll, {
        passive: !0
      });
    }), () => {
      escapeKey && (doc.removeEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture), doc.removeEventListener("compositionstart", handleCompositionStart), doc.removeEventListener("compositionend", handleCompositionEnd)), outsidePress && doc.removeEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture), ancestors.forEach((ancestor) => {
        ancestor.removeEventListener("scroll", onScroll);
      }), window.clearTimeout(compositionTimeout);
    };
  }, [dataRef, elements, escapeKey, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, escapeKeyCapture, closeOnEscapeKeyDownCapture, closeOnPressOutside, outsidePressCapture, closeOnPressOutsideCapture]), React.useEffect(() => {
    insideReactTreeRef.current = !1;
  }, [outsidePress, outsidePressEvent]);
  const reference = React.useMemo(() => ({
    onKeyDown: closeOnEscapeKeyDown,
    [bubbleHandlerKeys[referencePressEvent]]: (event) => {
      referencePress && onOpenChange(!1, event.nativeEvent, "reference-press");
    }
  }), [closeOnEscapeKeyDown, onOpenChange, referencePress, referencePressEvent]), floating = React.useMemo(() => ({
    onKeyDown: closeOnEscapeKeyDown,
    onMouseDown() {
      endedOrStartedInsideRef.current = !0;
    },
    onMouseUp() {
      endedOrStartedInsideRef.current = !0;
    },
    [captureHandlerKeys[outsidePressEvent]]: () => {
      insideReactTreeRef.current = !0;
    }
  }), [closeOnEscapeKeyDown, outsidePressEvent]);
  return React.useMemo(() => enabled ? {
    reference,
    floating
  } : {}, [enabled, reference, floating]);
}
function useFloatingRootContext(options) {
  const {
    open = !1,
    onOpenChange: onOpenChangeProp,
    elements: elementsProp
  } = options, floatingId = useId(), dataRef = React.useRef({}), [events] = React.useState(() => createPubSub()), nested = useFloatingParentNodeId() != null, [positionReference, setPositionReference] = React.useState(elementsProp.reference), onOpenChange = useEffectEvent((open2, event, reason) => {
    dataRef.current.openEvent = open2 ? event : void 0, events.emit("openchange", {
      open: open2,
      event,
      reason,
      nested
    }), onOpenChangeProp == null || onOpenChangeProp(open2, event, reason);
  }), refs = React.useMemo(() => ({
    setPositionReference
  }), []), elements = React.useMemo(() => ({
    reference: positionReference || elementsProp.reference || null,
    floating: elementsProp.floating || null,
    domReference: elementsProp.reference
  }), [positionReference, elementsProp.reference, elementsProp.floating]);
  return React.useMemo(() => ({
    dataRef,
    open,
    onOpenChange,
    elements,
    events,
    floatingId,
    refs
  }), [open, onOpenChange, elements, events, floatingId, refs]);
}
function useFloating(options) {
  options === void 0 && (options = {});
  const {
    nodeId
  } = options, internalRootContext = useFloatingRootContext({
    ...options,
    elements: {
      reference: null,
      floating: null,
      ...options.elements
    }
  }), rootContext = options.rootContext || internalRootContext, computedElements = rootContext.elements, [_domReference, setDomReference] = React.useState(null), [positionReference, _setPositionReference] = React.useState(null), domReference = (computedElements == null ? void 0 : computedElements.domReference) || _domReference, domReferenceRef = React.useRef(null), tree = useFloatingTree();
  index(() => {
    domReference && (domReferenceRef.current = domReference);
  }, [domReference]);
  const position2 = useFloating$1({
    ...options,
    elements: {
      ...computedElements,
      ...positionReference && {
        reference: positionReference
      }
    }
  }), setPositionReference = React.useCallback((node2) => {
    const computedPositionReference = isElement(node2) ? {
      getBoundingClientRect: () => node2.getBoundingClientRect(),
      contextElement: node2
    } : node2;
    _setPositionReference(computedPositionReference), position2.refs.setReference(computedPositionReference);
  }, [position2.refs]), setReference = React.useCallback((node2) => {
    (isElement(node2) || node2 === null) && (domReferenceRef.current = node2, setDomReference(node2)), (isElement(position2.refs.reference.current) || position2.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node2 !== null && !isElement(node2)) && position2.refs.setReference(node2);
  }, [position2.refs]), refs = React.useMemo(() => ({
    ...position2.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position2.refs, setReference, setPositionReference]), elements = React.useMemo(() => ({
    ...position2.elements,
    domReference
  }), [position2.elements, domReference]), context = React.useMemo(() => ({
    ...position2,
    ...rootContext,
    refs,
    elements,
    nodeId
  }), [position2, refs, elements, nodeId, rootContext]);
  return index(() => {
    rootContext.dataRef.current.floatingContext = context;
    const node2 = tree == null ? void 0 : tree.nodesRef.current.find((node22) => node22.id === nodeId);
    node2 && (node2.context = context);
  }), React.useMemo(() => ({
    ...position2,
    context,
    refs,
    elements
  }), [position2, refs, elements, context]);
}
function useFocus(context, props) {
  props === void 0 && (props = {});
  const {
    open,
    onOpenChange,
    events,
    dataRef,
    elements
  } = context, {
    enabled = !0,
    visibleOnly = !0
  } = props, blockFocusRef = React.useRef(!1), timeoutRef = React.useRef(), keyboardModalityRef = React.useRef(!0);
  React.useEffect(() => {
    if (!enabled) return;
    const win2 = getWindow(elements.domReference);
    function onBlur() {
      !open && isHTMLElement(elements.domReference) && elements.domReference === activeElement(getDocument(elements.domReference)) && (blockFocusRef.current = !0);
    }
    function onKeyDown() {
      keyboardModalityRef.current = !0;
    }
    return win2.addEventListener("blur", onBlur), win2.addEventListener("keydown", onKeyDown, !0), () => {
      win2.removeEventListener("blur", onBlur), win2.removeEventListener("keydown", onKeyDown, !0);
    };
  }, [elements.domReference, open, enabled]), React.useEffect(() => {
    if (!enabled) return;
    function onOpenChange2(_ref) {
      let {
        reason
      } = _ref;
      (reason === "reference-press" || reason === "escape-key") && (blockFocusRef.current = !0);
    }
    return events.on("openchange", onOpenChange2), () => {
      events.off("openchange", onOpenChange2);
    };
  }, [events, enabled]), React.useEffect(() => () => {
    clearTimeout(timeoutRef.current);
  }, []);
  const reference = React.useMemo(() => ({
    onPointerDown(event) {
      isVirtualPointerEvent(event.nativeEvent) || (keyboardModalityRef.current = !1);
    },
    onMouseLeave() {
      blockFocusRef.current = !1;
    },
    onFocus(event) {
      if (blockFocusRef.current) return;
      const target = getTarget(event.nativeEvent);
      if (visibleOnly && isElement(target))
        try {
          if (isSafari() && isMac()) throw Error();
          if (!target.matches(":focus-visible")) return;
        } catch {
          if (!keyboardModalityRef.current && !isTypeableElement(target))
            return;
        }
      onOpenChange(!0, event.nativeEvent, "focus");
    },
    onBlur(event) {
      blockFocusRef.current = !1;
      const relatedTarget = event.relatedTarget, nativeEvent = event.nativeEvent, movedToFocusGuard = isElement(relatedTarget) && relatedTarget.hasAttribute(createAttribute("focus-guard")) && relatedTarget.getAttribute("data-type") === "outside";
      timeoutRef.current = window.setTimeout(() => {
        var _dataRef$current$floa;
        const activeEl = activeElement(elements.domReference ? elements.domReference.ownerDocument : document);
        !relatedTarget && activeEl === elements.domReference || contains((_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.refs.floating.current, activeEl) || contains(elements.domReference, activeEl) || movedToFocusGuard || onOpenChange(!1, nativeEvent, "focus");
      });
    }
  }), [dataRef, elements.domReference, onOpenChange, visibleOnly]);
  return React.useMemo(() => enabled ? {
    reference
  } : {}, [enabled, reference]);
}
const ACTIVE_KEY = "active", SELECTED_KEY = "selected";
function mergeProps(userProps, propsList, elementKey) {
  const map2 = /* @__PURE__ */ new Map(), isItem = elementKey === "item";
  let domUserProps = userProps;
  if (isItem && userProps) {
    const {
      [ACTIVE_KEY]: _,
      [SELECTED_KEY]: __,
      ...validProps
    } = userProps;
    domUserProps = validProps;
  }
  return {
    ...elementKey === "floating" && {
      tabIndex: -1,
      [FOCUSABLE_ATTRIBUTE]: ""
    },
    ...domUserProps,
    ...propsList.map((value) => {
      const propsOrGetProps = value ? value[elementKey] : null;
      return typeof propsOrGetProps == "function" ? userProps ? propsOrGetProps(userProps) : null : propsOrGetProps;
    }).concat(userProps).reduce((acc, props) => (props && Object.entries(props).forEach((_ref) => {
      let [key, value] = _ref;
      if (!(isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)))
        if (key.indexOf("on") === 0) {
          if (map2.has(key) || map2.set(key, []), typeof value == "function") {
            var _map$get;
            (_map$get = map2.get(key)) == null || _map$get.push(value), acc[key] = function() {
              for (var _map$get2, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
                args[_key] = arguments[_key];
              return (_map$get2 = map2.get(key)) == null ? void 0 : _map$get2.map((fn) => fn(...args)).find((val) => val !== void 0);
            };
          }
        } else
          acc[key] = value;
    }), acc), {})
  };
}
function useInteractions(propsList) {
  propsList === void 0 && (propsList = []);
  const referenceDeps = propsList.map((key) => key == null ? void 0 : key.reference), floatingDeps = propsList.map((key) => key == null ? void 0 : key.floating), itemDeps = propsList.map((key) => key == null ? void 0 : key.item), getReferenceProps = React.useCallback(
    (userProps) => mergeProps(userProps, propsList, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    referenceDeps
  ), getFloatingProps = React.useCallback(
    (userProps) => mergeProps(userProps, propsList, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    floatingDeps
  ), getItemProps = React.useCallback(
    (userProps) => mergeProps(userProps, propsList, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    itemDeps
  );
  return React.useMemo(() => ({
    getReferenceProps,
    getFloatingProps,
    getItemProps
  }), [getReferenceProps, getFloatingProps, getItemProps]);
}
const componentRoleToAriaRoleMap = /* @__PURE__ */ new Map([["select", "listbox"], ["combobox", "listbox"], ["label", !1]]);
function useRole(context, props) {
  var _componentRoleToAriaR;
  props === void 0 && (props = {});
  const {
    open,
    floatingId
  } = context, {
    enabled = !0,
    role = "dialog"
  } = props, ariaRole = (_componentRoleToAriaR = componentRoleToAriaRoleMap.get(role)) != null ? _componentRoleToAriaR : role, referenceId = useId(), isNested = useFloatingParentNodeId() != null, reference = React.useMemo(() => ariaRole === "tooltip" || role === "label" ? {
    ["aria-" + (role === "label" ? "labelledby" : "describedby")]: open ? floatingId : void 0
  } : {
    "aria-expanded": open ? "true" : "false",
    "aria-haspopup": ariaRole === "alertdialog" ? "dialog" : ariaRole,
    "aria-controls": open ? floatingId : void 0,
    ...ariaRole === "listbox" && {
      role: "combobox"
    },
    ...ariaRole === "menu" && {
      id: referenceId
    },
    ...ariaRole === "menu" && isNested && {
      role: "menuitem"
    },
    ...role === "select" && {
      "aria-autocomplete": "none"
    },
    ...role === "combobox" && {
      "aria-autocomplete": "list"
    }
  }, [ariaRole, floatingId, isNested, open, referenceId, role]), floating = React.useMemo(() => {
    const floatingProps = {
      id: floatingId,
      ...ariaRole && {
        role: ariaRole
      }
    };
    return ariaRole === "tooltip" || role === "label" ? floatingProps : {
      ...floatingProps,
      ...ariaRole === "menu" && {
        "aria-labelledby": referenceId
      }
    };
  }, [ariaRole, floatingId, referenceId, role]), item = React.useCallback((_ref) => {
    let {
      active,
      selected: selected2
    } = _ref;
    const commonProps = {
      role: "option",
      ...active && {
        id: floatingId + "-option"
      }
    };
    switch (role) {
      case "select":
        return {
          ...commonProps,
          "aria-selected": active && selected2
        };
      case "combobox":
        return {
          ...commonProps,
          ...active && {
            "aria-selected": !0
          }
        };
    }
    return {};
  }, [floatingId, role]);
  return React.useMemo(() => enabled ? {
    reference,
    floating,
    item
  } : {}, [enabled, reference, floating, item]);
}
function getFloatingPosition(dir, position2) {
  if (dir === "rtl" && (position2.includes("right") || position2.includes("left"))) {
    const [side, placement] = position2.split("-"), flippedPosition = side === "right" ? "left" : "right";
    return placement === void 0 ? flippedPosition : `${flippedPosition}-${placement}`;
  }
  return position2;
}
function horizontalSide(placement, arrowY, arrowOffset, arrowPosition) {
  return placement === "center" || arrowPosition === "center" ? { top: arrowY } : placement === "end" ? { bottom: arrowOffset } : placement === "start" ? { top: arrowOffset } : {};
}
function verticalSide(placement, arrowX, arrowOffset, arrowPosition, dir) {
  return placement === "center" || arrowPosition === "center" ? { left: arrowX } : placement === "end" ? { [dir === "ltr" ? "right" : "left"]: arrowOffset } : placement === "start" ? { [dir === "ltr" ? "left" : "right"]: arrowOffset } : {};
}
const radiusByFloatingSide = {
  bottom: "borderTopLeftRadius",
  left: "borderTopRightRadius",
  right: "borderBottomLeftRadius",
  top: "borderBottomRightRadius"
};
function getArrowPositionStyles({
  position: position2,
  arrowSize,
  arrowOffset,
  arrowRadius,
  arrowPosition,
  arrowX,
  arrowY,
  dir
}) {
  const [side, placement = "center"] = position2.split("-"), baseStyles = {
    width: arrowSize,
    height: arrowSize,
    transform: "rotate(45deg)",
    position: "absolute",
    [radiusByFloatingSide[side]]: arrowRadius
  }, arrowPlacement = -arrowSize / 2;
  return side === "left" ? {
    ...baseStyles,
    ...horizontalSide(placement, arrowY, arrowOffset, arrowPosition),
    right: arrowPlacement,
    borderLeftColor: "transparent",
    borderBottomColor: "transparent"
  } : side === "right" ? {
    ...baseStyles,
    ...horizontalSide(placement, arrowY, arrowOffset, arrowPosition),
    left: arrowPlacement,
    borderRightColor: "transparent",
    borderTopColor: "transparent"
  } : side === "top" ? {
    ...baseStyles,
    ...verticalSide(placement, arrowX, arrowOffset, arrowPosition, dir),
    bottom: arrowPlacement,
    borderTopColor: "transparent",
    borderLeftColor: "transparent"
  } : side === "bottom" ? {
    ...baseStyles,
    ...verticalSide(placement, arrowX, arrowOffset, arrowPosition, dir),
    top: arrowPlacement,
    borderBottomColor: "transparent",
    borderRightColor: "transparent"
  } : {};
}
const FloatingArrow = forwardRef(
  ({
    position: position2,
    arrowSize,
    arrowOffset,
    arrowRadius,
    arrowPosition,
    visible: visible2,
    arrowX,
    arrowY,
    style: style2,
    ...others
  }, ref) => {
    const { dir } = useDirection();
    return visible2 ? /* @__PURE__ */ jsx(
      "div",
      {
        ...others,
        ref,
        style: {
          ...style2,
          ...getArrowPositionStyles({
            position: position2,
            arrowSize,
            arrowOffset,
            arrowRadius,
            arrowPosition,
            dir,
            arrowX,
            arrowY
          })
        }
      }
    ) : null;
  }
);
FloatingArrow.displayName = "@mantine/core/FloatingArrow";
const [PopoverContextProvider, usePopoverContext] = createSafeContext(
  "Popover component was not found in the tree"
);
function FocusTrap({
  children: children2,
  active = !0,
  refProp = "ref",
  innerRef
}) {
  const focusTrapRef = useFocusTrap(active), ref = useMergedRef(focusTrapRef, innerRef);
  return isElement$1(children2) ? cloneElement(children2, { [refProp]: ref }) : children2;
}
function FocusTrapInitialFocus(props) {
  return /* @__PURE__ */ jsx(VisuallyHidden, { tabIndex: -1, "data-autofocus": !0, ...props });
}
FocusTrap.displayName = "@mantine/core/FocusTrap";
FocusTrapInitialFocus.displayName = "@mantine/core/FocusTrapInitialFocus";
FocusTrap.InitialFocus = FocusTrapInitialFocus;
function createPortalNode(props) {
  const node2 = document.createElement("div");
  return node2.setAttribute("data-portal", "true"), typeof props.className == "string" && node2.classList.add(...props.className.split(" ").filter(Boolean)), typeof props.style == "object" && Object.assign(node2.style, props.style), typeof props.id == "string" && node2.setAttribute("id", props.id), node2;
}
const defaultProps$1a = {}, Portal = forwardRef((props, ref) => {
  const { children: children2, target, ...others } = useProps("Portal", defaultProps$1a, props), [mounted, setMounted] = useState(!1), nodeRef = useRef(null);
  return useIsomorphicEffect(() => (setMounted(!0), nodeRef.current = target ? typeof target == "string" ? document.querySelector(target) : target : createPortalNode(others), assignRef(ref, nodeRef.current), !target && nodeRef.current && document.body.appendChild(nodeRef.current), () => {
    !target && nodeRef.current && document.body.removeChild(nodeRef.current);
  }), [target]), !mounted || !nodeRef.current ? null : createPortal(/* @__PURE__ */ jsx(Fragment, { children: children2 }), nodeRef.current);
});
Portal.displayName = "@mantine/core/Portal";
function OptionalPortal({ withinPortal = !0, children: children2, ...others }) {
  return withinPortal ? /* @__PURE__ */ jsx(Portal, { ...others, children: children2 }) : /* @__PURE__ */ jsx(Fragment, { children: children2 });
}
OptionalPortal.displayName = "@mantine/core/OptionalPortal";
const popIn = (from) => ({
  in: { opacity: 1, transform: "scale(1)" },
  out: { opacity: 0, transform: `scale(.9) translateY(${rem(from === "bottom" ? 10 : -10)})` },
  transitionProperty: "transform, opacity"
}), transitions = {
  fade: {
    in: { opacity: 1 },
    out: { opacity: 0 },
    transitionProperty: "opacity"
  },
  "fade-up": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: `translateY(${rem(30)}` },
    transitionProperty: "opacity, transform"
  },
  "fade-down": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: `translateY(${rem(-30)}` },
    transitionProperty: "opacity, transform"
  },
  "fade-left": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: `translateX(${rem(30)}` },
    transitionProperty: "opacity, transform"
  },
  "fade-right": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: `translateX(${rem(-30)}` },
    transitionProperty: "opacity, transform"
  },
  scale: {
    in: { opacity: 1, transform: "scale(1)" },
    out: { opacity: 0, transform: "scale(0)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "scale-y": {
    in: { opacity: 1, transform: "scaleY(1)" },
    out: { opacity: 0, transform: "scaleY(0)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "scale-x": {
    in: { opacity: 1, transform: "scaleX(1)" },
    out: { opacity: 0, transform: "scaleX(0)" },
    common: { transformOrigin: "left" },
    transitionProperty: "transform, opacity"
  },
  "skew-up": {
    in: { opacity: 1, transform: "translateY(0) skew(0deg, 0deg)" },
    out: { opacity: 0, transform: `translateY(${rem(-20)}) skew(-10deg, -5deg)` },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "skew-down": {
    in: { opacity: 1, transform: "translateY(0) skew(0deg, 0deg)" },
    out: { opacity: 0, transform: `translateY(${rem(20)}) skew(-10deg, -5deg)` },
    common: { transformOrigin: "bottom" },
    transitionProperty: "transform, opacity"
  },
  "rotate-left": {
    in: { opacity: 1, transform: "translateY(0) rotate(0deg)" },
    out: { opacity: 0, transform: `translateY(${rem(20)}) rotate(-5deg)` },
    common: { transformOrigin: "bottom" },
    transitionProperty: "transform, opacity"
  },
  "rotate-right": {
    in: { opacity: 1, transform: "translateY(0) rotate(0deg)" },
    out: { opacity: 0, transform: `translateY(${rem(20)}) rotate(5deg)` },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "slide-down": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: "translateY(-100%)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "slide-up": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: "translateY(100%)" },
    common: { transformOrigin: "bottom" },
    transitionProperty: "transform, opacity"
  },
  "slide-left": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: "translateX(100%)" },
    common: { transformOrigin: "left" },
    transitionProperty: "transform, opacity"
  },
  "slide-right": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: "translateX(-100%)" },
    common: { transformOrigin: "right" },
    transitionProperty: "transform, opacity"
  },
  pop: {
    ...popIn("bottom"),
    common: { transformOrigin: "center center" }
  },
  "pop-bottom-left": {
    ...popIn("bottom"),
    common: { transformOrigin: "bottom left" }
  },
  "pop-bottom-right": {
    ...popIn("bottom"),
    common: { transformOrigin: "bottom right" }
  },
  "pop-top-left": {
    ...popIn("top"),
    common: { transformOrigin: "top left" }
  },
  "pop-top-right": {
    ...popIn("top"),
    common: { transformOrigin: "top right" }
  }
}, transitionStatuses = {
  entering: "in",
  entered: "in",
  exiting: "out",
  exited: "out",
  "pre-exiting": "out",
  "pre-entering": "out"
};
function getTransitionStyles({
  transition,
  state,
  duration,
  timingFunction
}) {
  const shared = {
    transitionDuration: `${duration}ms`,
    transitionTimingFunction: timingFunction
  };
  return typeof transition == "string" ? transition in transitions ? {
    transitionProperty: transitions[transition].transitionProperty,
    ...shared,
    ...transitions[transition].common,
    ...transitions[transition][transitionStatuses[state]]
  } : {} : {
    transitionProperty: transition.transitionProperty,
    ...shared,
    ...transition.common,
    ...transition[transitionStatuses[state]]
  };
}
function useTransition({
  duration,
  exitDuration,
  timingFunction,
  mounted,
  onEnter,
  onExit,
  onEntered,
  onExited,
  enterDelay,
  exitDelay
}) {
  const theme = useMantineTheme(), shouldReduceMotion = useReducedMotion(), reduceMotion = theme.respectReducedMotion ? shouldReduceMotion : !1, [transitionDuration, setTransitionDuration] = useState(reduceMotion ? 0 : duration), [transitionStatus, setStatus] = useState(mounted ? "entered" : "exited"), transitionTimeoutRef = useRef(-1), delayTimeoutRef = useRef(-1), rafRef = useRef(-1), handleStateChange = (shouldMount) => {
    const preHandler = shouldMount ? onEnter : onExit, handler = shouldMount ? onEntered : onExited;
    window.clearTimeout(transitionTimeoutRef.current);
    const newTransitionDuration = reduceMotion ? 0 : shouldMount ? duration : exitDuration;
    setTransitionDuration(newTransitionDuration), newTransitionDuration === 0 ? (typeof preHandler == "function" && preHandler(), typeof handler == "function" && handler(), setStatus(shouldMount ? "entered" : "exited")) : rafRef.current = requestAnimationFrame(() => {
      ReactDOM__default.flushSync(() => {
        setStatus(shouldMount ? "pre-entering" : "pre-exiting");
      }), rafRef.current = requestAnimationFrame(() => {
        typeof preHandler == "function" && preHandler(), setStatus(shouldMount ? "entering" : "exiting"), transitionTimeoutRef.current = window.setTimeout(() => {
          typeof handler == "function" && handler(), setStatus(shouldMount ? "entered" : "exited");
        }, newTransitionDuration);
      });
    });
  }, handleTransitionWithDelay = (shouldMount) => {
    if (window.clearTimeout(delayTimeoutRef.current), typeof (shouldMount ? enterDelay : exitDelay) != "number") {
      handleStateChange(shouldMount);
      return;
    }
    delayTimeoutRef.current = window.setTimeout(
      () => {
        handleStateChange(shouldMount);
      },
      shouldMount ? enterDelay : exitDelay
    );
  };
  return useDidUpdate(() => {
    handleTransitionWithDelay(mounted);
  }, [mounted]), useEffect(
    () => () => {
      window.clearTimeout(transitionTimeoutRef.current), cancelAnimationFrame(rafRef.current);
    },
    []
  ), {
    transitionDuration,
    transitionStatus,
    transitionTimingFunction: timingFunction || "ease"
  };
}
function Transition({
  keepMounted,
  transition = "fade",
  duration = 250,
  exitDuration = duration,
  mounted,
  children: children2,
  timingFunction = "ease",
  onExit,
  onEntered,
  onEnter,
  onExited,
  enterDelay,
  exitDelay
}) {
  const { transitionDuration, transitionStatus, transitionTimingFunction } = useTransition({
    mounted,
    exitDuration,
    duration,
    timingFunction,
    onExit,
    onEntered,
    onEnter,
    onExited,
    enterDelay,
    exitDelay
  });
  return transitionDuration === 0 ? mounted ? /* @__PURE__ */ jsx(Fragment, { children: children2({}) }) : keepMounted ? children2({ display: "none" }) : null : transitionStatus === "exited" ? keepMounted ? children2({ display: "none" }) : null : /* @__PURE__ */ jsx(Fragment, { children: children2(
    getTransitionStyles({
      transition,
      duration: transitionDuration,
      state: transitionStatus,
      timingFunction: transitionTimingFunction
    })
  ) });
}
Transition.displayName = "@mantine/core/Transition";
var __default__$x = { dropdown: "m_38a85659", arrow: "m_a31dc6c1" };
const classes$y = __default__$x, defaultProps$19 = {}, PopoverDropdown = factory((_props, ref) => {
  var _a4, _b2, _c, _d;
  const props = useProps("PopoverDropdown", defaultProps$19, _props), {
    className,
    style: style2,
    vars: vars2,
    children: children2,
    onKeyDownCapture,
    variant,
    classNames,
    styles,
    ...others
  } = props, ctx = usePopoverContext(), returnFocus = useFocusReturn({
    opened: ctx.opened,
    shouldReturnFocus: ctx.returnFocus
  }), accessibleProps = ctx.withRoles ? {
    "aria-labelledby": ctx.getTargetId(),
    id: ctx.getDropdownId(),
    role: "dialog",
    tabIndex: -1
  } : {}, mergedRef = useMergedRef(ref, ctx.floating);
  return ctx.disabled ? null : /* @__PURE__ */ jsx(OptionalPortal, { ...ctx.portalProps, withinPortal: ctx.withinPortal, children: /* @__PURE__ */ jsx(
    Transition,
    {
      mounted: ctx.opened,
      ...ctx.transitionProps,
      transition: ((_a4 = ctx.transitionProps) == null ? void 0 : _a4.transition) || "fade",
      duration: ((_b2 = ctx.transitionProps) == null ? void 0 : _b2.duration) ?? 150,
      keepMounted: ctx.keepMounted,
      exitDuration: typeof ((_c = ctx.transitionProps) == null ? void 0 : _c.exitDuration) == "number" ? ctx.transitionProps.exitDuration : (_d = ctx.transitionProps) == null ? void 0 : _d.duration,
      children: (transitionStyles) => /* @__PURE__ */ jsx(FocusTrap, { active: ctx.trapFocus && ctx.opened, innerRef: mergedRef, children: /* @__PURE__ */ jsxs(
        Box,
        {
          ...accessibleProps,
          ...others,
          variant,
          onKeyDownCapture: closeOnEscape(ctx.onClose, {
            active: ctx.closeOnEscape,
            onTrigger: returnFocus,
            onKeyDown: onKeyDownCapture
          }),
          "data-position": ctx.placement,
          "data-fixed": ctx.floatingStrategy === "fixed" || void 0,
          ...ctx.getStyles("dropdown", {
            className,
            props,
            classNames,
            styles,
            style: [
              {
                ...transitionStyles,
                zIndex: ctx.zIndex,
                top: ctx.y ?? 0,
                left: ctx.x ?? 0,
                width: ctx.width === "target" ? void 0 : rem(ctx.width)
              },
              ctx.resolvedStyles.dropdown,
              styles == null ? void 0 : styles.dropdown,
              style2
            ]
          }),
          children: [
            children2,
            /* @__PURE__ */ jsx(
              FloatingArrow,
              {
                ref: ctx.arrowRef,
                arrowX: ctx.arrowX,
                arrowY: ctx.arrowY,
                visible: ctx.withArrow,
                position: ctx.placement,
                arrowSize: ctx.arrowSize,
                arrowRadius: ctx.arrowRadius,
                arrowOffset: ctx.arrowOffset,
                arrowPosition: ctx.arrowPosition,
                ...ctx.getStyles("arrow", {
                  props,
                  classNames,
                  styles
                })
              }
            )
          ]
        }
      ) })
    }
  ) });
});
PopoverDropdown.classes = classes$y;
PopoverDropdown.displayName = "@mantine/core/PopoverDropdown";
const defaultProps$18 = {
  refProp: "ref",
  popupType: "dialog"
}, PopoverTarget = factory((props, ref) => {
  const { children: children2, refProp, popupType, ...others } = useProps(
    "PopoverTarget",
    defaultProps$18,
    props
  );
  if (!isElement$1(children2))
    throw new Error(
      "Popover.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  const forwardedProps = others, ctx = usePopoverContext(), targetRef = useMergedRef(ctx.reference, getRefProp(children2), ref), accessibleProps = ctx.withRoles ? {
    "aria-haspopup": popupType,
    "aria-expanded": ctx.opened,
    "aria-controls": ctx.getDropdownId(),
    id: ctx.getTargetId()
  } : {};
  return cloneElement(children2, {
    ...forwardedProps,
    ...accessibleProps,
    ...ctx.targetProps,
    className: clsx(ctx.targetProps.className, forwardedProps.className, children2.props.className),
    [refProp]: targetRef,
    ...ctx.controlled ? null : { onClick: ctx.onToggle }
  });
});
PopoverTarget.displayName = "@mantine/core/PopoverTarget";
function useFloatingAutoUpdate({
  opened,
  floating,
  position: position2,
  positionDependencies
}) {
  const [delayedUpdate, setDelayedUpdate] = useState(0);
  useEffect(() => {
    if (floating.refs.reference.current && floating.refs.floating.current && opened)
      return autoUpdate(
        floating.refs.reference.current,
        floating.refs.floating.current,
        floating.update
      );
  }, [
    floating.refs.reference.current,
    floating.refs.floating.current,
    opened,
    delayedUpdate,
    position2
  ]), useDidUpdate(() => {
    floating.update();
  }, positionDependencies), useDidUpdate(() => {
    setDelayedUpdate((c) => c + 1);
  }, [opened]);
}
function getDefaultMiddlewares(middlewares) {
  if (middlewares === void 0)
    return { shift: !0, flip: !0 };
  const result = { ...middlewares };
  return middlewares.shift === void 0 && (result.shift = !0), middlewares.flip === void 0 && (result.flip = !0), result;
}
function getPopoverMiddlewares(options, getFloating) {
  const middlewaresOptions = getDefaultMiddlewares(options.middlewares), middlewares = [offset(options.offset)];
  return middlewaresOptions.shift && middlewares.push(
    shift(
      typeof middlewaresOptions.shift == "boolean" ? { limiter: limitShift(), padding: 5 } : { limiter: limitShift(), padding: 5, ...middlewaresOptions.shift }
    )
  ), middlewaresOptions.flip && middlewares.push(
    typeof middlewaresOptions.flip == "boolean" ? flip() : flip(middlewaresOptions.flip)
  ), middlewaresOptions.inline && middlewares.push(
    typeof middlewaresOptions.inline == "boolean" ? inline() : inline(middlewaresOptions.inline)
  ), middlewares.push(arrow({ element: options.arrowRef, padding: options.arrowOffset })), (middlewaresOptions.size || options.width === "target") && middlewares.push(
    size({
      ...typeof middlewaresOptions.size == "boolean" ? {} : middlewaresOptions.size,
      apply({ rects, availableWidth, availableHeight, ...rest }) {
        var _a4;
        const styles = ((_a4 = getFloating().refs.floating.current) == null ? void 0 : _a4.style) ?? {};
        middlewaresOptions.size && (typeof middlewaresOptions.size == "object" && middlewaresOptions.size.apply ? middlewaresOptions.size.apply({ rects, availableWidth, availableHeight, ...rest }) : Object.assign(styles, {
          maxWidth: `${availableWidth}px`,
          maxHeight: `${availableHeight}px`
        })), options.width === "target" && Object.assign(styles, {
          width: `${rects.reference.width}px`
        });
      }
    })
  ), middlewares;
}
function usePopover(options) {
  const [_opened, setOpened] = useUncontrolled({
    value: options.opened,
    defaultValue: options.defaultOpened,
    finalValue: !1,
    onChange: options.onChange
  }), previouslyOpened = useRef(_opened), onClose = () => {
    _opened && setOpened(!1);
  }, onToggle = () => setOpened(!_opened), floating = useFloating({
    strategy: options.strategy,
    placement: options.position,
    middleware: getPopoverMiddlewares(options, () => floating)
  });
  return useFloatingAutoUpdate({
    opened: _opened,
    position: options.position,
    positionDependencies: options.positionDependencies || [],
    floating
  }), useDidUpdate(() => {
    var _a4;
    (_a4 = options.onPositionChange) == null || _a4.call(options, floating.placement);
  }, [floating.placement]), useDidUpdate(() => {
    var _a4, _b2;
    _opened !== previouslyOpened.current && (_opened ? (_b2 = options.onOpen) == null || _b2.call(options) : (_a4 = options.onClose) == null || _a4.call(options)), previouslyOpened.current = _opened;
  }, [_opened, options.onClose, options.onOpen]), {
    floating,
    controlled: typeof options.opened == "boolean",
    opened: _opened,
    onClose,
    onToggle
  };
}
const defaultProps$17 = {
  position: "bottom",
  offset: 8,
  positionDependencies: [],
  transitionProps: { transition: "fade", duration: 150 },
  middlewares: { flip: !0, shift: !0, inline: !1 },
  arrowSize: 7,
  arrowOffset: 5,
  arrowRadius: 0,
  arrowPosition: "side",
  closeOnClickOutside: !0,
  withinPortal: !0,
  closeOnEscape: !0,
  trapFocus: !1,
  withRoles: !0,
  returnFocus: !1,
  clickOutsideEvents: ["mousedown", "touchstart"],
  zIndex: getDefaultZIndex("popover"),
  __staticSelector: "Popover",
  width: "max-content"
}, varsResolver$z = (_, { radius, shadow }) => ({
  dropdown: {
    "--popover-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--popover-shadow": getShadow(shadow)
  }
});
function Popover(_props) {
  var _a4, _b2, _c, _d, _e, _f;
  const props = useProps("Popover", defaultProps$17, _props), {
    children: children2,
    position: position2,
    offset: offset2,
    onPositionChange,
    positionDependencies,
    opened,
    transitionProps,
    width: width2,
    middlewares,
    withArrow,
    arrowSize,
    arrowOffset,
    arrowRadius,
    arrowPosition,
    unstyled,
    classNames,
    styles,
    closeOnClickOutside,
    withinPortal,
    portalProps,
    closeOnEscape: closeOnEscape2,
    clickOutsideEvents,
    trapFocus,
    onClose,
    onOpen,
    onChange,
    zIndex,
    radius,
    shadow,
    id: id2,
    defaultOpened,
    __staticSelector,
    withRoles,
    disabled,
    returnFocus,
    variant,
    keepMounted,
    vars: vars2,
    floatingStrategy,
    ...others
  } = props, getStyles2 = useStyles({
    name: __staticSelector,
    props,
    classes: classes$y,
    classNames,
    styles,
    unstyled,
    rootSelector: "dropdown",
    vars: vars2,
    varsResolver: varsResolver$z
  }), { resolvedStyles } = useResolvedStylesApi({ classNames, styles, props }), arrowRef = useRef(null), [targetNode, setTargetNode] = useState(null), [dropdownNode, setDropdownNode] = useState(null), { dir } = useDirection(), uid = useId$1(id2), popover = usePopover({
    middlewares,
    width: width2,
    position: getFloatingPosition(dir, position2),
    offset: typeof offset2 == "number" ? offset2 + (withArrow ? arrowSize / 2 : 0) : offset2,
    arrowRef,
    arrowOffset,
    onPositionChange,
    positionDependencies,
    opened,
    defaultOpened,
    onChange,
    onOpen,
    onClose,
    strategy: floatingStrategy
  });
  useClickOutside(() => closeOnClickOutside && popover.onClose(), clickOutsideEvents, [
    targetNode,
    dropdownNode
  ]);
  const reference = useCallback(
    (node2) => {
      setTargetNode(node2), popover.floating.refs.setReference(node2);
    },
    [popover.floating.refs.setReference]
  ), floating = useCallback(
    (node2) => {
      setDropdownNode(node2), popover.floating.refs.setFloating(node2);
    },
    [popover.floating.refs.setFloating]
  );
  return /* @__PURE__ */ jsx(
    PopoverContextProvider,
    {
      value: {
        returnFocus,
        disabled,
        controlled: popover.controlled,
        reference,
        floating,
        x: popover.floating.x,
        y: popover.floating.y,
        arrowX: (_c = (_b2 = (_a4 = popover.floating) == null ? void 0 : _a4.middlewareData) == null ? void 0 : _b2.arrow) == null ? void 0 : _c.x,
        arrowY: (_f = (_e = (_d = popover.floating) == null ? void 0 : _d.middlewareData) == null ? void 0 : _e.arrow) == null ? void 0 : _f.y,
        opened: popover.opened,
        arrowRef,
        transitionProps,
        width: width2,
        withArrow,
        arrowSize,
        arrowOffset,
        arrowRadius,
        arrowPosition,
        placement: popover.floating.placement,
        trapFocus,
        withinPortal,
        portalProps,
        zIndex,
        radius,
        shadow,
        closeOnEscape: closeOnEscape2,
        onClose: popover.onClose,
        onToggle: popover.onToggle,
        getTargetId: () => `${uid}-target`,
        getDropdownId: () => `${uid}-dropdown`,
        withRoles,
        targetProps: others,
        __staticSelector,
        classNames,
        styles,
        unstyled,
        variant,
        keepMounted,
        getStyles: getStyles2,
        resolvedStyles,
        floatingStrategy
      },
      children: children2
    }
  );
}
Popover.Target = PopoverTarget;
Popover.Dropdown = PopoverDropdown;
Popover.displayName = "@mantine/core/Popover";
Popover.extend = (input) => input;
var __default__$w = { root: "m_5ae2e3c", barsLoader: "m_7a2bd4cd", bar: "m_870bb79", "bars-loader-animation": "m_5d2b3b9d", dotsLoader: "m_4e3f22d7", dot: "m_870c4af", "loader-dots-animation": "m_aac34a1", ovalLoader: "m_b34414df", "oval-loader-animation": "m_f8e89c4b" };
const classes$x = __default__$w, Bars = forwardRef(({ className, ...others }, ref) => /* @__PURE__ */ jsxs(Box, { component: "span", className: clsx(classes$x.barsLoader, className), ...others, ref, children: [
  /* @__PURE__ */ jsx("span", { className: classes$x.bar }),
  /* @__PURE__ */ jsx("span", { className: classes$x.bar }),
  /* @__PURE__ */ jsx("span", { className: classes$x.bar })
] }));
Bars.displayName = "@mantine/core/Bars";
const Dots = forwardRef(({ className, ...others }, ref) => /* @__PURE__ */ jsxs(Box, { component: "span", className: clsx(classes$x.dotsLoader, className), ...others, ref, children: [
  /* @__PURE__ */ jsx("span", { className: classes$x.dot }),
  /* @__PURE__ */ jsx("span", { className: classes$x.dot }),
  /* @__PURE__ */ jsx("span", { className: classes$x.dot })
] }));
Dots.displayName = "@mantine/core/Dots";
const Oval = forwardRef(({ className, ...others }, ref) => /* @__PURE__ */ jsx(Box, { component: "span", className: clsx(classes$x.ovalLoader, className), ...others, ref }));
Oval.displayName = "@mantine/core/Oval";
const defaultLoaders = {
  bars: Bars,
  oval: Oval,
  dots: Dots
}, defaultProps$16 = {
  loaders: defaultLoaders,
  type: "oval"
}, varsResolver$y = (theme, { size: size2, color: color2 }) => ({
  root: {
    "--loader-size": getSize(size2, "loader-size"),
    "--loader-color": color2 ? getThemeColor(color2, theme) : void 0
  }
}), Loader = factory((_props, ref) => {
  const props = useProps("Loader", defaultProps$16, _props), {
    size: size2,
    color: color2,
    type,
    vars: vars2,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    loaders,
    variant,
    children: children2,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Loader",
    props,
    classes: classes$x,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars: vars2,
    varsResolver: varsResolver$y
  });
  return children2 ? /* @__PURE__ */ jsx(Box, { ...getStyles2("root"), ref, ...others, children: children2 }) : /* @__PURE__ */ jsx(
    Box,
    {
      ...getStyles2("root"),
      ref,
      component: loaders[type],
      variant,
      size: size2,
      ...others
    }
  );
});
Loader.defaultLoaders = defaultLoaders;
Loader.classes = classes$x;
Loader.displayName = "@mantine/core/Loader";
var __default__$v = { root: "m_8d3f4000", icon: "m_8d3afb97", loader: "m_302b9fb1", group: "m_1a0f1b21" };
const classes$w = __default__$v, defaultProps$15 = {
  orientation: "horizontal"
}, varsResolver$x = (_, { borderWidth }) => ({
  group: { "--ai-border-width": rem(borderWidth) }
}), ActionIconGroup = factory((_props, ref) => {
  const props = useProps("ActionIconGroup", defaultProps$15, _props), {
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    orientation,
    vars: vars2,
    borderWidth,
    variant,
    mod,
    ...others
  } = useProps("ActionIconGroup", defaultProps$15, _props), getStyles2 = useStyles({
    name: "ActionIconGroup",
    props,
    classes: classes$w,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars: vars2,
    varsResolver: varsResolver$x,
    rootSelector: "group"
  });
  return /* @__PURE__ */ jsx(
    Box,
    {
      ...getStyles2("group"),
      ref,
      variant,
      mod: [{ "data-orientation": orientation }, mod],
      role: "group",
      ...others
    }
  );
});
ActionIconGroup.classes = classes$w;
ActionIconGroup.displayName = "@mantine/core/ActionIconGroup";
const defaultProps$14 = {}, varsResolver$w = (theme, { size: size2, radius, variant, gradient, color: color2, autoContrast }) => {
  const colors2 = theme.variantColorResolver({
    color: color2 || theme.primaryColor,
    theme,
    gradient,
    variant: variant || "filled",
    autoContrast
  });
  return {
    root: {
      "--ai-size": getSize(size2, "ai-size"),
      "--ai-radius": radius === void 0 ? void 0 : getRadius$1(radius),
      "--ai-bg": color2 || variant ? colors2.background : void 0,
      "--ai-hover": color2 || variant ? colors2.hover : void 0,
      "--ai-hover-color": color2 || variant ? colors2.hoverColor : void 0,
      "--ai-color": colors2.color,
      "--ai-bd": color2 || variant ? colors2.border : void 0
    }
  };
}, ActionIcon$1 = polymorphicFactory((_props, ref) => {
  const props = useProps("ActionIcon", defaultProps$14, _props), {
    className,
    unstyled,
    variant,
    classNames,
    styles,
    style: style2,
    loading,
    loaderProps,
    size: size2,
    color: color2,
    radius,
    __staticSelector,
    gradient,
    vars: vars2,
    children: children2,
    disabled,
    "data-disabled": dataDisabled,
    autoContrast,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: ["ActionIcon", __staticSelector],
    props,
    className,
    style: style2,
    classes: classes$w,
    classNames,
    styles,
    unstyled,
    vars: vars2,
    varsResolver: varsResolver$w
  });
  return /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      ...getStyles2("root", { active: !disabled && !loading && !dataDisabled }),
      ...others,
      unstyled,
      variant,
      size: size2,
      disabled: disabled || loading,
      ref,
      mod: [{ loading, disabled: disabled || dataDisabled }, mod],
      children: [
        /* @__PURE__ */ jsx(Transition, { mounted: !!loading, transition: "slide-down", duration: 150, children: (transitionStyles) => /* @__PURE__ */ jsx(Box, { component: "span", ...getStyles2("loader", { style: transitionStyles }), "aria-hidden": !0, children: /* @__PURE__ */ jsx(Loader, { color: "var(--ai-color)", size: "calc(var(--ai-size) * 0.55)", ...loaderProps }) }) }),
        /* @__PURE__ */ jsx(Box, { component: "span", mod: { loading }, ...getStyles2("icon"), children: children2 })
      ]
    }
  );
});
ActionIcon$1.classes = classes$w;
ActionIcon$1.displayName = "@mantine/core/ActionIcon";
ActionIcon$1.Group = ActionIconGroup;
const CloseIcon = forwardRef(
  ({ size: size2 = "var(--cb-icon-size, 70%)", style: style2, ...others }, ref) => /* @__PURE__ */ jsx(
    "svg",
    {
      viewBox: "0 0 15 15",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      style: { ...style2, width: size2, height: size2 },
      ref,
      ...others,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z",
          fill: "currentColor",
          fillRule: "evenodd",
          clipRule: "evenodd"
        }
      )
    }
  )
);
CloseIcon.displayName = "@mantine/core/CloseIcon";
var __default__$u = { root: "m_86a44da5", "root--subtle": "m_220c80f2" };
const classes$v = __default__$u, defaultProps$13 = {
  variant: "subtle"
}, varsResolver$v = (_, { size: size2, radius, iconSize }) => ({
  root: {
    "--cb-size": getSize(size2, "cb-size"),
    "--cb-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--cb-icon-size": rem(iconSize)
  }
}), CloseButton = polymorphicFactory((_props, ref) => {
  const props = useProps("CloseButton", defaultProps$13, _props), {
    iconSize,
    children: children2,
    vars: vars2,
    radius,
    className,
    classNames,
    style: style2,
    styles,
    unstyled,
    "data-disabled": dataDisabled,
    disabled,
    variant,
    icon,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: "CloseButton",
    props,
    className,
    style: style2,
    classes: classes$v,
    classNames,
    styles,
    unstyled,
    vars: vars2,
    varsResolver: varsResolver$v
  });
  return /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      ref,
      ...others,
      unstyled,
      variant,
      disabled,
      mod: [{ disabled: disabled || dataDisabled }, mod],
      ...getStyles2("root", { variant, active: !disabled && !dataDisabled }),
      children: [
        icon || /* @__PURE__ */ jsx(CloseIcon, {}),
        children2
      ]
    }
  );
});
CloseButton.classes = classes$v;
CloseButton.displayName = "@mantine/core/CloseButton";
function filterFalsyChildren(children2) {
  return Children.toArray(children2).filter(Boolean);
}
var __default__$t = { root: "m_4081bf90" };
const classes$u = __default__$t, defaultProps$12 = {
  preventGrowOverflow: !0,
  gap: "md",
  align: "center",
  justify: "flex-start",
  wrap: "wrap"
}, varsResolver$u = (_, { grow, preventGrowOverflow, gap, align: align2, justify, wrap: wrap2 }, { childWidth }) => ({
  root: {
    "--group-child-width": grow && preventGrowOverflow ? childWidth : void 0,
    "--group-gap": getSpacing(gap),
    "--group-align": align2,
    "--group-justify": justify,
    "--group-wrap": wrap2
  }
}), Group = factory((_props, ref) => {
  const props = useProps("Group", defaultProps$12, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    children: children2,
    gap,
    align: align2,
    justify,
    wrap: wrap2,
    grow,
    preventGrowOverflow,
    vars: vars2,
    variant,
    __size,
    mod,
    ...others
  } = props, filteredChildren = filterFalsyChildren(children2), childrenCount = filteredChildren.length, resolvedGap = getSpacing(gap ?? "md"), stylesCtx = { childWidth: `calc(${100 / childrenCount}% - (${resolvedGap} - ${resolvedGap} / ${childrenCount}))` }, getStyles2 = useStyles({
    name: "Group",
    props,
    stylesCtx,
    className,
    style: style2,
    classes: classes$u,
    classNames,
    styles,
    unstyled,
    vars: vars2,
    varsResolver: varsResolver$u
  });
  return /* @__PURE__ */ jsx(
    Box,
    {
      ...getStyles2("root"),
      ref,
      variant,
      mod: [{ grow }, mod],
      size: __size,
      ...others,
      children: filteredChildren
    }
  );
});
Group.classes = classes$u;
Group.displayName = "@mantine/core/Group";
var __default__$s = { root: "m_9814e45f" };
const classes$t = __default__$s, defaultProps$11 = {
  zIndex: getDefaultZIndex("modal")
}, varsResolver$t = (_, { gradient, color: color2, backgroundOpacity, blur, radius, zIndex }) => ({
  root: {
    "--overlay-bg": gradient || (color2 !== void 0 || backgroundOpacity !== void 0) && rgba$1(color2 || "#000", backgroundOpacity ?? 0.6) || void 0,
    "--overlay-filter": blur ? `blur(${rem(blur)})` : void 0,
    "--overlay-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--overlay-z-index": zIndex == null ? void 0 : zIndex.toString()
  }
}), Overlay = polymorphicFactory((_props, ref) => {
  const props = useProps("Overlay", defaultProps$11, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars: vars2,
    fixed,
    center,
    children: children2,
    radius,
    zIndex,
    gradient,
    blur,
    color: color2,
    backgroundOpacity,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Overlay",
    props,
    classes: classes$t,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars: vars2,
    varsResolver: varsResolver$t
  });
  return /* @__PURE__ */ jsx(Box, { ref, ...getStyles2("root"), mod: [{ center, fixed }, mod], ...others, children: children2 });
});
Overlay.classes = classes$t;
Overlay.displayName = "@mantine/core/Overlay";
const [ModalBaseProvider, useModalBaseContext] = createSafeContext(
  "ModalBase component was not found in tree"
);
function useLockScroll({ opened, transitionDuration }) {
  const [shouldLockScroll, setShouldLockScroll] = useState(opened), timeout2 = useRef(), _transitionDuration = useReducedMotion() ? 0 : transitionDuration;
  return useEffect(() => (opened ? (setShouldLockScroll(!0), window.clearTimeout(timeout2.current)) : _transitionDuration === 0 ? setShouldLockScroll(!1) : timeout2.current = window.setTimeout(() => setShouldLockScroll(!1), _transitionDuration), () => window.clearTimeout(timeout2.current)), [opened, _transitionDuration]), shouldLockScroll;
}
function useModal({
  id: id2,
  transitionProps,
  opened,
  trapFocus,
  closeOnEscape: closeOnEscape2,
  onClose,
  returnFocus
}) {
  const _id = useId$1(id2), [titleMounted, setTitleMounted] = useState(!1), [bodyMounted, setBodyMounted] = useState(!1), transitionDuration = typeof (transitionProps == null ? void 0 : transitionProps.duration) == "number" ? transitionProps == null ? void 0 : transitionProps.duration : 200, shouldLockScroll = useLockScroll({ opened, transitionDuration });
  return useWindowEvent(
    "keydown",
    (event) => {
      var _a4;
      event.key === "Escape" && closeOnEscape2 && opened && ((_a4 = event.target) == null ? void 0 : _a4.getAttribute("data-mantine-stop-propagation")) !== "true" && onClose();
    },
    { capture: !0 }
  ), useFocusReturn({ opened, shouldReturnFocus: trapFocus && returnFocus }), {
    _id,
    titleMounted,
    bodyMounted,
    shouldLockScroll,
    setTitleMounted,
    setBodyMounted
  };
}
const ModalBase = forwardRef(
  ({
    keepMounted,
    opened,
    onClose,
    id: id2,
    transitionProps,
    trapFocus,
    closeOnEscape: closeOnEscape2,
    returnFocus,
    closeOnClickOutside,
    withinPortal,
    portalProps,
    lockScroll,
    children: children2,
    zIndex,
    shadow,
    padding,
    __vars,
    unstyled,
    removeScrollProps,
    ...others
  }, ref) => {
    const { _id, titleMounted, bodyMounted, shouldLockScroll, setTitleMounted, setBodyMounted } = useModal({ id: id2, transitionProps, opened, trapFocus, closeOnEscape: closeOnEscape2, onClose, returnFocus }), { key: removeScrollKey, ...otherRemoveScrollProps } = removeScrollProps || {};
    return /* @__PURE__ */ jsx(OptionalPortal, { ...portalProps, withinPortal, children: /* @__PURE__ */ jsx(
      ModalBaseProvider,
      {
        value: {
          opened,
          onClose,
          closeOnClickOutside,
          transitionProps: { ...transitionProps, keepMounted },
          getTitleId: () => `${_id}-title`,
          getBodyId: () => `${_id}-body`,
          titleMounted,
          bodyMounted,
          setTitleMounted,
          setBodyMounted,
          trapFocus,
          closeOnEscape: closeOnEscape2,
          zIndex,
          unstyled
        },
        children: /* @__PURE__ */ jsx(
          RemoveScroll,
          {
            enabled: shouldLockScroll && lockScroll,
            ...otherRemoveScrollProps,
            children: /* @__PURE__ */ jsx(
              Box,
              {
                ref,
                ...others,
                __vars: {
                  ...__vars,
                  "--mb-z-index": (zIndex || getDefaultZIndex("modal")).toString(),
                  "--mb-shadow": getShadow(shadow),
                  "--mb-padding": getSpacing(padding)
                },
                children: children2
              }
            )
          },
          removeScrollKey
        )
      }
    ) });
  }
);
ModalBase.displayName = "@mantine/core/ModalBase";
function useModalBodyId() {
  const ctx = useModalBaseContext();
  return useEffect(() => (ctx.setBodyMounted(!0), () => ctx.setBodyMounted(!1)), []), ctx.getBodyId();
}
var __default__$r = { title: "m_615af6c9", header: "m_b5489c3c", inner: "m_60c222c7", content: "m_fd1ab0aa", close: "m_606cb269", body: "m_5df29311" };
const classes$s = __default__$r, ModalBaseBody = forwardRef(
  ({ className, ...others }, ref) => {
    const bodyId = useModalBodyId(), ctx = useModalBaseContext();
    return /* @__PURE__ */ jsx(
      Box,
      {
        ref,
        ...others,
        id: bodyId,
        className: clsx({ [classes$s.body]: !ctx.unstyled }, className)
      }
    );
  }
);
ModalBaseBody.displayName = "@mantine/core/ModalBaseBody";
const ModalBaseCloseButton = forwardRef(
  ({ className, onClick, ...others }, ref) => {
    const ctx = useModalBaseContext();
    return /* @__PURE__ */ jsx(
      CloseButton,
      {
        ref,
        ...others,
        onClick: (event) => {
          ctx.onClose(), onClick == null || onClick(event);
        },
        className: clsx({ [classes$s.close]: !ctx.unstyled }, className),
        unstyled: ctx.unstyled
      }
    );
  }
);
ModalBaseCloseButton.displayName = "@mantine/core/ModalBaseCloseButton";
const ModalBaseContent = forwardRef(
  ({ transitionProps, className, innerProps, onKeyDown, style: style2, ...others }, ref) => {
    const ctx = useModalBaseContext();
    return /* @__PURE__ */ jsx(
      Transition,
      {
        mounted: ctx.opened,
        transition: "pop",
        ...ctx.transitionProps,
        ...transitionProps,
        children: (transitionStyles) => /* @__PURE__ */ jsx(
          "div",
          {
            ...innerProps,
            className: clsx({ [classes$s.inner]: !ctx.unstyled }, innerProps.className),
            children: /* @__PURE__ */ jsx(FocusTrap, { active: ctx.opened && ctx.trapFocus, innerRef: ref, children: /* @__PURE__ */ jsx(
              Paper,
              {
                ...others,
                component: "section",
                role: "dialog",
                tabIndex: -1,
                "aria-modal": !0,
                "aria-describedby": ctx.bodyMounted ? ctx.getBodyId() : void 0,
                "aria-labelledby": ctx.titleMounted ? ctx.getTitleId() : void 0,
                style: [style2, transitionStyles],
                className: clsx({ [classes$s.content]: !ctx.unstyled }, className),
                unstyled: ctx.unstyled,
                children: others.children
              }
            ) })
          }
        )
      }
    );
  }
);
ModalBaseContent.displayName = "@mantine/core/ModalBaseContent";
const ModalBaseHeader = forwardRef(
  ({ className, ...others }, ref) => {
    const ctx = useModalBaseContext();
    return /* @__PURE__ */ jsx(
      Box,
      {
        component: "header",
        ref,
        className: clsx({ [classes$s.header]: !ctx.unstyled }, className),
        ...others
      }
    );
  }
);
ModalBaseHeader.displayName = "@mantine/core/ModalBaseHeader";
const DEFAULT_TRANSITION = {
  duration: 200,
  timingFunction: "ease",
  transition: "fade"
};
function useModalTransition(transitionOverride) {
  const ctx = useModalBaseContext();
  return { ...DEFAULT_TRANSITION, ...ctx.transitionProps, ...transitionOverride };
}
const ModalBaseOverlay = forwardRef(
  ({ onClick, transitionProps, style: style2, visible: visible2, ...others }, ref) => {
    const ctx = useModalBaseContext(), transition = useModalTransition(transitionProps);
    return /* @__PURE__ */ jsx(
      Transition,
      {
        mounted: visible2 !== void 0 ? visible2 : ctx.opened,
        ...transition,
        transition: "fade",
        children: (transitionStyles) => /* @__PURE__ */ jsx(
          Overlay,
          {
            ref,
            fixed: !0,
            style: [style2, transitionStyles],
            zIndex: ctx.zIndex,
            unstyled: ctx.unstyled,
            onClick: (event) => {
              onClick == null || onClick(event), ctx.closeOnClickOutside && ctx.onClose();
            },
            ...others
          }
        )
      }
    );
  }
);
ModalBaseOverlay.displayName = "@mantine/core/ModalBaseOverlay";
function useModalTitle() {
  const ctx = useModalBaseContext();
  return useEffect(() => (ctx.setTitleMounted(!0), () => ctx.setTitleMounted(!1)), []), ctx.getTitleId();
}
const ModalBaseTitle = forwardRef(
  ({ className, ...others }, ref) => {
    const id2 = useModalTitle(), ctx = useModalBaseContext();
    return /* @__PURE__ */ jsx(
      Box,
      {
        component: "h2",
        ref,
        className: clsx({ [classes$s.title]: !ctx.unstyled }, className),
        ...others,
        id: id2
      }
    );
  }
);
ModalBaseTitle.displayName = "@mantine/core/ModalBaseTitle";
function NativeScrollArea({ children: children2 }) {
  return /* @__PURE__ */ jsx(Fragment, { children: children2 });
}
const [InputWrapperProvider, useInputWrapperContext] = createOptionalContext({
  offsetBottom: !1,
  offsetTop: !1,
  describedBy: void 0,
  getStyles: null,
  inputId: void 0,
  labelId: void 0
});
var __default__$q = { wrapper: "m_6c018570", input: "m_8fb7ebe7", section: "m_82577fc2", placeholder: "m_88bacfd0", root: "m_46b77525", label: "m_8fdc1311", required: "m_78a94662", error: "m_8f816625", description: "m_fe47ce59" };
const classes$r = __default__$q, defaultProps$10 = {}, varsResolver$s = (_, { size: size2 }) => ({
  description: {
    "--input-description-size": size2 === void 0 ? void 0 : `calc(${getFontSize(size2)} - ${rem(2)})`
  }
}), InputDescription = factory((_props, ref) => {
  const props = useProps("InputDescription", defaultProps$10, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars: vars2,
    size: size2,
    __staticSelector,
    __inheritStyles = !0,
    variant,
    ...others
  } = useProps("InputDescription", defaultProps$10, props), ctx = useInputWrapperContext(), _getStyles = useStyles({
    name: ["InputWrapper", __staticSelector],
    props,
    classes: classes$r,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    rootSelector: "description",
    vars: vars2,
    varsResolver: varsResolver$s
  }), getStyles2 = __inheritStyles && (ctx == null ? void 0 : ctx.getStyles) || _getStyles;
  return /* @__PURE__ */ jsx(
    Box,
    {
      component: "p",
      ref,
      variant,
      size: size2,
      ...getStyles2("description", ctx != null && ctx.getStyles ? { className, style: style2 } : void 0),
      ...others
    }
  );
});
InputDescription.classes = classes$r;
InputDescription.displayName = "@mantine/core/InputDescription";
const defaultProps$$ = {}, varsResolver$r = (_, { size: size2 }) => ({
  error: {
    "--input-error-size": size2 === void 0 ? void 0 : `calc(${getFontSize(size2)} - ${rem(2)})`
  }
}), InputError = factory((_props, ref) => {
  const props = useProps("InputError", defaultProps$$, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars: vars2,
    size: size2,
    __staticSelector,
    __inheritStyles = !0,
    variant,
    ...others
  } = props, _getStyles = useStyles({
    name: ["InputWrapper", __staticSelector],
    props,
    classes: classes$r,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    rootSelector: "error",
    vars: vars2,
    varsResolver: varsResolver$r
  }), ctx = useInputWrapperContext(), getStyles2 = __inheritStyles && (ctx == null ? void 0 : ctx.getStyles) || _getStyles;
  return /* @__PURE__ */ jsx(
    Box,
    {
      component: "p",
      ref,
      variant,
      size: size2,
      ...getStyles2("error", ctx != null && ctx.getStyles ? { className, style: style2 } : void 0),
      ...others
    }
  );
});
InputError.classes = classes$r;
InputError.displayName = "@mantine/core/InputError";
const defaultProps$_ = {
  labelElement: "label"
}, varsResolver$q = (_, { size: size2 }) => ({
  label: {
    "--input-label-size": getFontSize(size2),
    "--input-asterisk-color": void 0
  }
}), InputLabel = factory((_props, ref) => {
  const props = useProps("InputLabel", defaultProps$_, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars: vars2,
    labelElement,
    size: size2,
    required,
    htmlFor,
    onMouseDown,
    children: children2,
    __staticSelector,
    variant,
    mod,
    ...others
  } = useProps("InputLabel", defaultProps$_, props), _getStyles = useStyles({
    name: ["InputWrapper", __staticSelector],
    props,
    classes: classes$r,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    rootSelector: "label",
    vars: vars2,
    varsResolver: varsResolver$q
  }), ctx = useInputWrapperContext(), getStyles2 = (ctx == null ? void 0 : ctx.getStyles) || _getStyles;
  return /* @__PURE__ */ jsxs(
    Box,
    {
      ...getStyles2("label", ctx != null && ctx.getStyles ? { className, style: style2 } : void 0),
      component: labelElement,
      variant,
      size: size2,
      ref,
      htmlFor: labelElement === "label" ? htmlFor : void 0,
      mod: [{ required }, mod],
      onMouseDown: (event) => {
        onMouseDown == null || onMouseDown(event), !event.defaultPrevented && event.detail > 1 && event.preventDefault();
      },
      ...others,
      children: [
        children2,
        required && /* @__PURE__ */ jsx("span", { ...getStyles2("required"), "aria-hidden": !0, children: " *" })
      ]
    }
  );
});
InputLabel.classes = classes$r;
InputLabel.displayName = "@mantine/core/InputLabel";
const defaultProps$Z = {}, InputPlaceholder = factory((_props, ref) => {
  const props = useProps("InputPlaceholder", defaultProps$Z, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars: vars2,
    __staticSelector,
    variant,
    error,
    mod,
    ...others
  } = useProps("InputPlaceholder", defaultProps$Z, props), getStyles2 = useStyles({
    name: ["InputPlaceholder", __staticSelector],
    props,
    classes: classes$r,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    rootSelector: "placeholder"
  });
  return /* @__PURE__ */ jsx(
    Box,
    {
      ...getStyles2("placeholder"),
      mod: [{ error: !!error }, mod],
      component: "span",
      variant,
      ref,
      ...others
    }
  );
});
InputPlaceholder.classes = classes$r;
InputPlaceholder.displayName = "@mantine/core/InputPlaceholder";
function getInputOffsets(inputWrapperOrder, { hasDescription, hasError }) {
  const inputIndex = inputWrapperOrder.findIndex((part) => part === "input"), aboveInput = inputWrapperOrder.slice(0, inputIndex), belowInput = inputWrapperOrder.slice(inputIndex + 1), offsetTop = hasDescription && aboveInput.includes("description") || hasError && aboveInput.includes("error");
  return { offsetBottom: hasDescription && belowInput.includes("description") || hasError && belowInput.includes("error"), offsetTop };
}
const defaultProps$Y = {
  labelElement: "label",
  inputContainer: (children2) => children2,
  inputWrapperOrder: ["label", "description", "input", "error"]
}, varsResolver$p = (_, { size: size2 }) => ({
  label: {
    "--input-label-size": getFontSize(size2),
    "--input-asterisk-color": void 0
  },
  error: {
    "--input-error-size": size2 === void 0 ? void 0 : `calc(${getFontSize(size2)} - ${rem(2)})`
  },
  description: {
    "--input-description-size": size2 === void 0 ? void 0 : `calc(${getFontSize(size2)} - ${rem(2)})`
  }
}), InputWrapper = factory((_props, ref) => {
  const props = useProps("InputWrapper", defaultProps$Y, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars: vars2,
    size: size2,
    variant,
    __staticSelector,
    inputContainer,
    inputWrapperOrder,
    label: label2,
    error,
    description: description2,
    labelProps,
    descriptionProps,
    errorProps,
    labelElement,
    children: children2,
    withAsterisk,
    id: id2,
    required,
    __stylesApiProps,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: ["InputWrapper", __staticSelector],
    props: __stylesApiProps || props,
    classes: classes$r,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars: vars2,
    varsResolver: varsResolver$p
  }), sharedProps = {
    size: size2,
    variant,
    __staticSelector
  }, idBase = useId$1(id2), isRequired = typeof withAsterisk == "boolean" ? withAsterisk : required, errorId = (errorProps == null ? void 0 : errorProps.id) || `${idBase}-error`, descriptionId = (descriptionProps == null ? void 0 : descriptionProps.id) || `${idBase}-description`, inputId = idBase, hasError = !!error && typeof error != "boolean", hasDescription = !!description2, _describedBy = `${hasError ? errorId : ""} ${hasDescription ? descriptionId : ""}`, describedBy = _describedBy.trim().length > 0 ? _describedBy.trim() : void 0, labelId = (labelProps == null ? void 0 : labelProps.id) || `${idBase}-label`, _label = label2 && /* @__PURE__ */ jsx(
    InputLabel,
    {
      labelElement,
      id: labelId,
      htmlFor: inputId,
      required: isRequired,
      ...sharedProps,
      ...labelProps,
      children: label2
    },
    "label"
  ), _description = hasDescription && /* @__PURE__ */ jsx(
    InputDescription,
    {
      ...descriptionProps,
      ...sharedProps,
      size: (descriptionProps == null ? void 0 : descriptionProps.size) || sharedProps.size,
      id: (descriptionProps == null ? void 0 : descriptionProps.id) || descriptionId,
      children: description2
    },
    "description"
  ), _input = /* @__PURE__ */ jsx(Fragment$1, { children: inputContainer(children2) }, "input"), _error = hasError && /* @__PURE__ */ createElement(
    InputError,
    {
      ...errorProps,
      ...sharedProps,
      size: (errorProps == null ? void 0 : errorProps.size) || sharedProps.size,
      key: "error",
      id: (errorProps == null ? void 0 : errorProps.id) || errorId
    },
    error
  ), content = inputWrapperOrder.map((part) => {
    switch (part) {
      case "label":
        return _label;
      case "input":
        return _input;
      case "description":
        return _description;
      case "error":
        return _error;
      default:
        return null;
    }
  });
  return /* @__PURE__ */ jsx(
    InputWrapperProvider,
    {
      value: {
        getStyles: getStyles2,
        describedBy,
        inputId,
        labelId,
        ...getInputOffsets(inputWrapperOrder, { hasDescription, hasError })
      },
      children: /* @__PURE__ */ jsx(
        Box,
        {
          ref,
          variant,
          size: size2,
          mod: [{ error: !!error }, mod],
          ...getStyles2("root"),
          ...others,
          children: content
        }
      )
    }
  );
});
InputWrapper.classes = classes$r;
InputWrapper.displayName = "@mantine/core/InputWrapper";
const defaultProps$X = {
  variant: "default",
  leftSectionPointerEvents: "none",
  rightSectionPointerEvents: "none",
  withAria: !0,
  withErrorStyles: !0
}, varsResolver$o = (_, props, ctx) => ({
  wrapper: {
    "--input-margin-top": ctx.offsetTop ? "calc(var(--mantine-spacing-xs) / 2)" : void 0,
    "--input-margin-bottom": ctx.offsetBottom ? "calc(var(--mantine-spacing-xs) / 2)" : void 0,
    "--input-height": getSize(props.size, "input-height"),
    "--input-fz": getFontSize(props.size),
    "--input-radius": props.radius === void 0 ? void 0 : getRadius$1(props.radius),
    "--input-left-section-width": props.leftSectionWidth !== void 0 ? rem(props.leftSectionWidth) : void 0,
    "--input-right-section-width": props.rightSectionWidth !== void 0 ? rem(props.rightSectionWidth) : void 0,
    "--input-padding-y": props.multiline ? getSize(props.size, "input-padding-y") : void 0,
    "--input-left-section-pointer-events": props.leftSectionPointerEvents,
    "--input-right-section-pointer-events": props.rightSectionPointerEvents
  }
}), Input = polymorphicFactory((_props, ref) => {
  const props = useProps("Input", defaultProps$X, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    required,
    __staticSelector,
    __stylesApiProps,
    size: size2,
    wrapperProps,
    error,
    disabled,
    leftSection,
    leftSectionProps,
    leftSectionWidth,
    rightSection,
    rightSectionProps,
    rightSectionWidth,
    rightSectionPointerEvents,
    leftSectionPointerEvents,
    variant,
    vars: vars2,
    pointer: pointer2,
    multiline,
    radius,
    id: id2,
    withAria,
    withErrorStyles,
    mod,
    inputSize,
    ...others
  } = props, { styleProps, rest } = extractStyleProps(others), ctx = useInputWrapperContext(), stylesCtx = { offsetBottom: ctx == null ? void 0 : ctx.offsetBottom, offsetTop: ctx == null ? void 0 : ctx.offsetTop }, getStyles2 = useStyles({
    name: ["Input", __staticSelector],
    props: __stylesApiProps || props,
    classes: classes$r,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    stylesCtx,
    rootSelector: "wrapper",
    vars: vars2,
    varsResolver: varsResolver$o
  }), ariaAttributes = withAria ? {
    required,
    disabled,
    "aria-invalid": !!error,
    "aria-describedby": ctx == null ? void 0 : ctx.describedBy,
    id: (ctx == null ? void 0 : ctx.inputId) || id2
  } : {};
  return /* @__PURE__ */ jsxs(
    Box,
    {
      ...getStyles2("wrapper"),
      ...styleProps,
      ...wrapperProps,
      mod: [
        {
          error: !!error && withErrorStyles,
          pointer: pointer2,
          disabled,
          multiline,
          "data-with-right-section": !!rightSection,
          "data-with-left-section": !!leftSection
        },
        mod
      ],
      variant,
      size: size2,
      children: [
        leftSection && /* @__PURE__ */ jsx(
          "div",
          {
            ...leftSectionProps,
            "data-position": "left",
            ...getStyles2("section", {
              className: leftSectionProps == null ? void 0 : leftSectionProps.className,
              style: leftSectionProps == null ? void 0 : leftSectionProps.style
            }),
            children: leftSection
          }
        ),
        /* @__PURE__ */ jsx(
          Box,
          {
            component: "input",
            ...rest,
            ...ariaAttributes,
            ref,
            required,
            mod: { disabled, error: !!error && withErrorStyles },
            variant,
            __size: inputSize,
            ...getStyles2("input")
          }
        ),
        rightSection && /* @__PURE__ */ jsx(
          "div",
          {
            ...rightSectionProps,
            "data-position": "right",
            ...getStyles2("section", {
              className: rightSectionProps == null ? void 0 : rightSectionProps.className,
              style: rightSectionProps == null ? void 0 : rightSectionProps.style
            }),
            children: rightSection
          }
        )
      ]
    }
  );
});
Input.classes = classes$r;
Input.Wrapper = InputWrapper;
Input.Label = InputLabel;
Input.Error = InputError;
Input.Description = InputDescription;
Input.Placeholder = InputPlaceholder;
Input.displayName = "@mantine/core/Input";
const FLEX_STYLE_PROPS_DATA = {
  gap: { type: "spacing", property: "gap" },
  rowGap: { type: "spacing", property: "rowGap" },
  columnGap: { type: "spacing", property: "columnGap" },
  align: { type: "identity", property: "alignItems" },
  justify: { type: "identity", property: "justifyContent" },
  wrap: { type: "identity", property: "flexWrap" },
  direction: { type: "identity", property: "flexDirection" }
};
var __default__$p = { root: "m_8bffd616" };
const classes$q = __default__$p, defaultProps$W = {}, Flex = polymorphicFactory((_props, ref) => {
  const props = useProps("Flex", defaultProps$W, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars: vars2,
    gap,
    rowGap,
    columnGap,
    align: align2,
    justify,
    wrap: wrap2,
    direction,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Flex",
    classes: classes$q,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars: vars2
  }), theme = useMantineTheme(), responsiveClassName = useRandomClassName(), parsedStyleProps = parseStyleProps({
    styleProps: { gap, rowGap, columnGap, align: align2, justify, wrap: wrap2, direction },
    theme,
    data: FLEX_STYLE_PROPS_DATA
  });
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    parsedStyleProps.hasResponsiveStyles && /* @__PURE__ */ jsx(
      InlineStyles,
      {
        selector: `.${responsiveClassName}`,
        styles: parsedStyleProps.styles,
        media: parsedStyleProps.media
      }
    ),
    /* @__PURE__ */ jsx(
      Box,
      {
        ref,
        ...getStyles2("root", {
          className: responsiveClassName,
          style: filterProps$1(parsedStyleProps.inlineStyles)
        }),
        ...others
      }
    )
  ] });
});
Flex.classes = classes$q;
Flex.displayName = "@mantine/core/Flex";
function isParent(parentElement, childElement) {
  if (!childElement || !parentElement)
    return !1;
  let parent = childElement.parentNode;
  for (; parent != null; ) {
    if (parent === parentElement)
      return !0;
    parent = parent.parentNode;
  }
  return !1;
}
function useFloatingIndicator({
  target,
  parent,
  ref,
  displayAfterTransitionEnd
}) {
  const transitionTimeout = useRef(), [initialized, setInitialized] = useState(!1), [hidden2, setHidden] = useState(
    typeof displayAfterTransitionEnd == "boolean" ? displayAfterTransitionEnd : !1
  ), updatePosition = () => {
    if (!target || !parent)
      return;
    const targetRect = target.getBoundingClientRect(), parentRect = parent.getBoundingClientRect(), position2 = {
      top: targetRect.top - parentRect.top,
      left: targetRect.left - parentRect.left,
      width: targetRect.width,
      height: targetRect.height
    };
    ref.current && (ref.current.style.transform = `translateY(${position2.top}px) translateX(${position2.left}px)`, ref.current.style.width = `${position2.width}px`, ref.current.style.height = `${position2.height}px`);
  }, updatePositionWithoutAnimation = () => {
    window.clearTimeout(transitionTimeout.current), ref.current && (ref.current.style.transitionDuration = "0ms"), updatePosition(), transitionTimeout.current = window.setTimeout(() => {
      ref.current && (ref.current.style.transitionDuration = "");
    }, 30);
  }, targetResizeObserver = useRef(), parentResizeObserver = useRef();
  return useEffect(() => {
    if (updatePosition(), target)
      return targetResizeObserver.current = new ResizeObserver(updatePositionWithoutAnimation), targetResizeObserver.current.observe(target), parent && (parentResizeObserver.current = new ResizeObserver(updatePositionWithoutAnimation), parentResizeObserver.current.observe(parent)), () => {
        var _a4, _b2;
        (_a4 = targetResizeObserver.current) == null || _a4.disconnect(), (_b2 = parentResizeObserver.current) == null || _b2.disconnect();
      };
  }, [parent, target]), useEffect(() => {
    if (parent) {
      const handleTransitionEnd = (event) => {
        isParent(event.target, parent) && (updatePositionWithoutAnimation(), setHidden(!1));
      };
      return parent.addEventListener("transitionend", handleTransitionEnd), () => {
        parent.removeEventListener("transitionend", handleTransitionEnd);
      };
    }
  }, [parent]), useTimeout(
    () => {
      getEnv() !== "test" && setInitialized(!0);
    },
    20,
    { autoInvoke: !0 }
  ), useMutationObserver(
    (mutations) => {
      mutations.forEach((mutation) => {
        mutation.type === "attributes" && mutation.attributeName === "dir" && updatePositionWithoutAnimation();
      });
    },
    { attributes: !0, attributeFilter: ["dir"] },
    () => document.documentElement
  ), { initialized, hidden: hidden2 };
}
var __default__$o = { root: "m_96b553a6" };
const classes$p = __default__$o, defaultProps$V = {}, varsResolver$n = (_theme, { transitionDuration }) => ({
  root: {
    "--transition-duration": typeof transitionDuration == "number" ? `${transitionDuration}ms` : transitionDuration
  }
}), FloatingIndicator = factory((_props, ref) => {
  const props = useProps("FloatingIndicator", defaultProps$V, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars: vars2,
    target,
    parent,
    transitionDuration,
    mod,
    displayAfterTransitionEnd,
    ...others
  } = props, getStyles2 = useStyles({
    name: "FloatingIndicator",
    classes: classes$p,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars: vars2,
    varsResolver: varsResolver$n
  }), innerRef = useRef(null), { initialized, hidden: hidden2 } = useFloatingIndicator({
    target,
    parent,
    ref: innerRef,
    displayAfterTransitionEnd
  }), mergedRef = useMergedRef(ref, innerRef);
  return !target || !parent ? null : /* @__PURE__ */ jsx(Box, { ref: mergedRef, mod: [{ initialized, hidden: hidden2 }, mod], ...getStyles2("root"), ...others });
});
FloatingIndicator.displayName = "@mantine/core/FloatingIndicator";
FloatingIndicator.classes = classes$p;
var __default__$n = { root: "m_66836ed3", wrapper: "m_a5d60502", body: "m_667c2793", title: "m_6a03f287", label: "m_698f4f23", icon: "m_667f2a6a", message: "m_7fa78076", closeButton: "m_87f54839" };
const classes$o = __default__$n, defaultProps$U = {}, varsResolver$m = (theme, { radius, color: color2, variant, autoContrast }) => {
  const colors2 = theme.variantColorResolver({
    color: color2 || theme.primaryColor,
    theme,
    variant: variant || "light",
    autoContrast
  });
  return {
    root: {
      "--alert-radius": radius === void 0 ? void 0 : getRadius$1(radius),
      "--alert-bg": color2 || variant ? colors2.background : void 0,
      "--alert-color": colors2.color,
      "--alert-bd": color2 || variant ? colors2.border : void 0
    }
  };
}, Alert = factory((_props, ref) => {
  const props = useProps("Alert", defaultProps$U, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars: vars2,
    radius,
    color: color2,
    title: title2,
    children: children2,
    id: id2,
    icon,
    withCloseButton,
    onClose,
    closeButtonLabel,
    variant,
    autoContrast,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Alert",
    classes: classes$o,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars: vars2,
    varsResolver: varsResolver$m
  }), rootId = useId$1(id2), titleId = title2 && `${rootId}-title` || void 0, bodyId = `${rootId}-body`;
  return /* @__PURE__ */ jsx(
    Box,
    {
      id: rootId,
      ...getStyles2("root", { variant }),
      variant,
      ref,
      ...others,
      role: "alert",
      "aria-describedby": bodyId,
      "aria-labelledby": titleId,
      children: /* @__PURE__ */ jsxs("div", { ...getStyles2("wrapper"), children: [
        icon && /* @__PURE__ */ jsx("div", { ...getStyles2("icon"), children: icon }),
        /* @__PURE__ */ jsxs("div", { ...getStyles2("body"), children: [
          title2 && /* @__PURE__ */ jsx("div", { ...getStyles2("title"), "data-with-close-button": withCloseButton || void 0, children: /* @__PURE__ */ jsx("span", { id: titleId, ...getStyles2("label"), children: title2 }) }),
          children2 && /* @__PURE__ */ jsx("div", { id: bodyId, ...getStyles2("message"), "data-variant": variant, children: children2 })
        ] }),
        withCloseButton && /* @__PURE__ */ jsx(
          CloseButton,
          {
            ...getStyles2("closeButton"),
            onClick: onClose,
            variant: "transparent",
            size: 16,
            iconSize: 16,
            "aria-label": closeButtonLabel,
            unstyled
          }
        )
      ] })
    }
  );
});
Alert.classes = classes$o;
Alert.displayName = "@mantine/core/Alert";
var __default__$m = { root: "m_b6d8b162" };
const classes$n = __default__$m;
function getTextTruncate(truncate) {
  if (truncate === "start")
    return "start";
  if (truncate === "end" || truncate)
    return "end";
}
const defaultProps$T = {
  inherit: !1
}, varsResolver$l = (theme, { variant, lineClamp, gradient, size: size2, color: color2 }) => ({
  root: {
    "--text-fz": getFontSize(size2),
    "--text-lh": getLineHeight(size2),
    "--text-gradient": variant === "gradient" ? getGradient(gradient, theme) : void 0,
    "--text-line-clamp": typeof lineClamp == "number" ? lineClamp.toString() : void 0,
    "--text-color": color2 ? getThemeColor(color2, theme) : void 0
  }
}), Text$6 = polymorphicFactory((_props, ref) => {
  const props = useProps("Text", defaultProps$T, _props), {
    lineClamp,
    truncate,
    inline: inline2,
    inherit: inherit2,
    gradient,
    span,
    __staticSelector,
    vars: vars2,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    variant,
    mod,
    size: size2,
    ...others
  } = props, getStyles2 = useStyles({
    name: ["Text", __staticSelector],
    props,
    classes: classes$n,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars: vars2,
    varsResolver: varsResolver$l
  });
  return /* @__PURE__ */ jsx(
    Box,
    {
      ...getStyles2("root", { focusable: !0 }),
      ref,
      component: span ? "span" : "p",
      variant,
      mod: [
        {
          "data-truncate": getTextTruncate(truncate),
          "data-line-clamp": typeof lineClamp == "number",
          "data-inline": inline2,
          "data-inherit": inherit2
        },
        mod
      ],
      size: size2,
      ...others
    }
  );
});
Text$6.classes = classes$n;
Text$6.displayName = "@mantine/core/Text";
var __default__$l = { root: "m_849cf0da" };
const classes$m = __default__$l, defaultProps$S = {
  underline: "hover"
}, Anchor = polymorphicFactory((props, ref) => {
  const { underline, className, unstyled, mod, ...others } = useProps(
    "Anchor",
    defaultProps$S,
    props
  );
  return /* @__PURE__ */ jsx(
    Text$6,
    {
      component: "a",
      ref,
      className: clsx({ [classes$m.root]: !unstyled }, className),
      ...others,
      mod: [{ underline }, mod],
      __staticSelector: "Anchor",
      unstyled
    }
  );
});
Anchor.classes = classes$m;
Anchor.displayName = "@mantine/core/Anchor";
function CheckIcon({ size: size2, style: style2, ...others }) {
  const _style = size2 !== void 0 ? { width: rem(size2), height: rem(size2), ...style2 } : style2;
  return /* @__PURE__ */ jsx(
    "svg",
    {
      viewBox: "0 0 10 7",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      style: _style,
      "aria-hidden": !0,
      ...others,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M4 4.586L1.707 2.293A1 1 0 1 0 .293 3.707l3 3a.997.997 0 0 0 1.414 0l5-5A1 1 0 1 0 8.293.293L4 4.586z",
          fill: "currentColor",
          fillRule: "evenodd",
          clipRule: "evenodd"
        }
      )
    }
  );
}
var __default__$k = { root: "m_347db0ec", "root--dot": "m_fbd81e3d", label: "m_5add502a", section: "m_91fdda9b" };
const classes$l = __default__$k, defaultProps$R = {}, varsResolver$k = (theme, { radius, color: color2, gradient, variant, size: size2, autoContrast }) => {
  const colors2 = theme.variantColorResolver({
    color: color2 || theme.primaryColor,
    theme,
    gradient,
    variant: variant || "filled",
    autoContrast
  });
  return {
    root: {
      "--badge-height": getSize(size2, "badge-height"),
      "--badge-padding-x": getSize(size2, "badge-padding-x"),
      "--badge-fz": getSize(size2, "badge-fz"),
      "--badge-radius": radius === void 0 ? void 0 : getRadius$1(radius),
      "--badge-bg": color2 || variant ? colors2.background : void 0,
      "--badge-color": color2 || variant ? colors2.color : void 0,
      "--badge-bd": color2 || variant ? colors2.border : void 0,
      "--badge-dot-color": variant === "dot" ? getThemeColor(color2, theme) : void 0
    }
  };
}, Badge = polymorphicFactory((_props, ref) => {
  const props = useProps("Badge", defaultProps$R, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars: vars2,
    radius,
    color: color2,
    gradient,
    leftSection,
    rightSection,
    children: children2,
    variant,
    fullWidth,
    autoContrast,
    circle,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Badge",
    props,
    classes: classes$l,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars: vars2,
    varsResolver: varsResolver$k
  });
  return /* @__PURE__ */ jsxs(
    Box,
    {
      variant,
      mod: [
        {
          block: fullWidth,
          circle,
          "with-right-section": !!rightSection,
          "with-left-section": !!leftSection
        },
        mod
      ],
      ...getStyles2("root", { variant }),
      ref,
      ...others,
      children: [
        leftSection && /* @__PURE__ */ jsx("span", { ...getStyles2("section"), "data-position": "left", children: leftSection }),
        /* @__PURE__ */ jsx("span", { ...getStyles2("label"), children: children2 }),
        rightSection && /* @__PURE__ */ jsx("span", { ...getStyles2("section"), "data-position": "right", children: rightSection })
      ]
    }
  );
});
Badge.classes = classes$l;
Badge.displayName = "@mantine/core/Badge";
var __default__$j = { root: "m_77c9d27d", inner: "m_80f1301b", label: "m_811560b9", section: "m_a74036a", loader: "m_a25b86ee", group: "m_80d6d844" };
const classes$k = __default__$j, defaultProps$Q = {
  orientation: "horizontal"
}, varsResolver$j = (_, { borderWidth }) => ({
  group: { "--button-border-width": rem(borderWidth) }
}), ButtonGroup = factory((_props, ref) => {
  const props = useProps("ButtonGroup", defaultProps$Q, _props), {
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    orientation,
    vars: vars2,
    borderWidth,
    variant,
    mod,
    ...others
  } = useProps("ButtonGroup", defaultProps$Q, _props), getStyles2 = useStyles({
    name: "ButtonGroup",
    props,
    classes: classes$k,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars: vars2,
    varsResolver: varsResolver$j,
    rootSelector: "group"
  });
  return /* @__PURE__ */ jsx(
    Box,
    {
      ...getStyles2("group"),
      ref,
      variant,
      mod: [{ "data-orientation": orientation }, mod],
      role: "group",
      ...others
    }
  );
});
ButtonGroup.classes = classes$k;
ButtonGroup.displayName = "@mantine/core/ButtonGroup";
const loaderTransition = {
  in: { opacity: 1, transform: `translate(-50%, calc(-50% + ${rem(1)}))` },
  out: { opacity: 0, transform: "translate(-50%, -200%)" },
  common: { transformOrigin: "center" },
  transitionProperty: "transform, opacity"
}, defaultProps$P = {}, varsResolver$i = (theme, { radius, color: color2, gradient, variant, size: size2, justify, autoContrast }) => {
  const colors2 = theme.variantColorResolver({
    color: color2 || theme.primaryColor,
    theme,
    gradient,
    variant: variant || "filled",
    autoContrast
  });
  return {
    root: {
      "--button-justify": justify,
      "--button-height": getSize(size2, "button-height"),
      "--button-padding-x": getSize(size2, "button-padding-x"),
      "--button-fz": size2 != null && size2.includes("compact") ? getFontSize(size2.replace("compact-", "")) : getFontSize(size2),
      "--button-radius": radius === void 0 ? void 0 : getRadius$1(radius),
      "--button-bg": color2 || variant ? colors2.background : void 0,
      "--button-hover": color2 || variant ? colors2.hover : void 0,
      "--button-color": colors2.color,
      "--button-bd": color2 || variant ? colors2.border : void 0,
      "--button-hover-color": color2 || variant ? colors2.hoverColor : void 0
    }
  };
}, Button = polymorphicFactory((_props, ref) => {
  const props = useProps("Button", defaultProps$P, _props), {
    style: style2,
    vars: vars2,
    className,
    color: color2,
    disabled,
    children: children2,
    leftSection,
    rightSection,
    fullWidth,
    variant,
    radius,
    loading,
    loaderProps,
    gradient,
    classNames,
    styles,
    unstyled,
    "data-disabled": dataDisabled,
    autoContrast,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Button",
    props,
    classes: classes$k,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars: vars2,
    varsResolver: varsResolver$i
  }), hasLeftSection = !!leftSection, hasRightSection = !!rightSection;
  return /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      ref,
      ...getStyles2("root", { active: !disabled && !loading && !dataDisabled }),
      unstyled,
      variant,
      disabled: disabled || loading,
      mod: [
        {
          disabled: disabled || dataDisabled,
          loading,
          block: fullWidth,
          "with-left-section": hasLeftSection,
          "with-right-section": hasRightSection
        },
        mod
      ],
      ...others,
      children: [
        /* @__PURE__ */ jsx(Transition, { mounted: !!loading, transition: loaderTransition, duration: 150, children: (transitionStyles) => /* @__PURE__ */ jsx(Box, { component: "span", ...getStyles2("loader", { style: transitionStyles }), "aria-hidden": !0, children: /* @__PURE__ */ jsx(
          Loader,
          {
            color: "var(--button-color)",
            size: "calc(var(--button-height) / 1.8)",
            ...loaderProps
          }
        ) }) }),
        /* @__PURE__ */ jsxs("span", { ...getStyles2("inner"), children: [
          leftSection && /* @__PURE__ */ jsx(Box, { component: "span", ...getStyles2("section"), mod: { position: "left" }, children: leftSection }),
          /* @__PURE__ */ jsx(Box, { component: "span", mod: { loading }, ...getStyles2("label"), children: children2 }),
          rightSection && /* @__PURE__ */ jsx(Box, { component: "span", ...getStyles2("section"), mod: { position: "right" }, children: rightSection })
        ] })
      ]
    }
  );
});
Button.classes = classes$k;
Button.displayName = "@mantine/core/Button";
Button.Group = ButtonGroup;
const [CardProvider, useCardContext] = createSafeContext(
  "Card component was not found in tree"
);
var __default__$i = { root: "m_e615b15f", section: "m_599a2148" };
const classes$j = __default__$i, defaultProps$O = {}, CardSection = polymorphicFactory((_props, ref) => {
  const props = useProps("CardSection", defaultProps$O, _props), { classNames, className, style: style2, styles, vars: vars2, withBorder, inheritPadding, mod, ...others } = props, ctx = useCardContext();
  return /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      mod: [{ "with-border": withBorder, "inherit-padding": inheritPadding }, mod],
      ...ctx.getStyles("section", { className, style: style2, styles, classNames }),
      ...others
    }
  );
});
CardSection.classes = classes$j;
CardSection.displayName = "@mantine/core/CardSection";
const defaultProps$N = {}, varsResolver$h = (_, { padding }) => ({
  root: {
    "--card-padding": getSpacing(padding)
  }
}), Card = polymorphicFactory((_props, ref) => {
  const props = useProps("Card", defaultProps$N, _props), { classNames, className, style: style2, styles, unstyled, vars: vars2, children: children2, padding, ...others } = props, getStyles2 = useStyles({
    name: "Card",
    props,
    classes: classes$j,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars: vars2,
    varsResolver: varsResolver$h
  }), _children = Children.toArray(children2), content = _children.map((child, index2) => typeof child == "object" && child && "type" in child && child.type === CardSection ? cloneElement(child, {
    "data-first-section": index2 === 0 || void 0,
    "data-last-section": index2 === _children.length - 1 || void 0
  }) : child);
  return /* @__PURE__ */ jsx(CardProvider, { value: { getStyles: getStyles2 }, children: /* @__PURE__ */ jsx(Paper, { ref, unstyled, ...getStyles2("root"), ...others, children: content }) });
});
Card.classes = classes$j;
Card.displayName = "@mantine/core/Card";
Card.Section = CardSection;
var __default__$h = { root: "m_4451eb3a" };
const classes$i = __default__$h, defaultProps$M = {}, Center = polymorphicFactory((_props, ref) => {
  const props = useProps("Center", defaultProps$M, _props), { classNames, className, style: style2, styles, unstyled, vars: vars2, inline: inline2, mod, ...others } = props, getStyles2 = useStyles({
    name: "Center",
    props,
    classes: classes$i,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars: vars2
  });
  return /* @__PURE__ */ jsx(Box, { ref, mod: [{ inline: inline2 }, mod], ...getStyles2("root"), ...others });
});
Center.classes = classes$i;
Center.displayName = "@mantine/core/Center";
var __default__$g = { root: "m_b183c0a2" };
const classes$h = __default__$g, defaultProps$L = {}, varsResolver$g = (theme, { color: color2 }) => ({
  root: {
    "--code-bg": color2 ? getThemeColor(color2, theme) : void 0
  }
}), Code = factory((_props, ref) => {
  const props = useProps("Code", defaultProps$L, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars: vars2,
    color: color2,
    block,
    variant,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Code",
    props,
    classes: classes$h,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars: vars2,
    varsResolver: varsResolver$g
  });
  return /* @__PURE__ */ jsx(
    Box,
    {
      component: block ? "pre" : "code",
      variant,
      ref,
      mod: [{ block }, mod],
      ...getStyles2("root"),
      ...others,
      dir: "ltr"
    }
  );
});
Code.classes = classes$h;
Code.displayName = "@mantine/core/Code";
var __default__$f = { root: "m_de3d2490", colorOverlay: "m_862f3d1b", shadowOverlay: "m_98ae7f22", alphaOverlay: "m_95709ac0", childrenOverlay: "m_93e74e3" };
const classes$g = __default__$f, defaultProps$K = {
  withShadow: !0
}, varsResolver$f = (_, { radius, size: size2 }) => ({
  root: {
    "--cs-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--cs-size": rem(size2)
  }
}), ColorSwatch = polymorphicFactory((_props, ref) => {
  const props = useProps("ColorSwatch", defaultProps$K, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars: vars2,
    color: color2,
    size: size2,
    radius,
    withShadow,
    children: children2,
    variant,
    ...others
  } = useProps("ColorSwatch", defaultProps$K, props), getStyles2 = useStyles({
    name: "ColorSwatch",
    props,
    classes: classes$g,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars: vars2,
    varsResolver: varsResolver$f
  });
  return /* @__PURE__ */ jsxs(
    Box,
    {
      ref,
      variant,
      size: size2,
      ...getStyles2("root", { focusable: !0 }),
      ...others,
      children: [
        /* @__PURE__ */ jsx("span", { ...getStyles2("alphaOverlay") }),
        withShadow && /* @__PURE__ */ jsx("span", { ...getStyles2("shadowOverlay") }),
        /* @__PURE__ */ jsx("span", { ...getStyles2("colorOverlay", { style: { backgroundColor: color2 } }) }),
        /* @__PURE__ */ jsx("span", { ...getStyles2("childrenOverlay"), children: children2 })
      ]
    }
  );
});
ColorSwatch.classes = classes$g;
ColorSwatch.displayName = "@mantine/core/ColorSwatch";
const defaultProps$J = {
  timeout: 1e3
};
function CopyButton(props) {
  const { children: children2, timeout: timeout2, value, ...others } = useProps("CopyButton", defaultProps$J, props), clipboard = useClipboard({ timeout: timeout2 });
  return /* @__PURE__ */ jsx(Fragment, { children: children2({ copy: () => clipboard.copy(value), copied: clipboard.copied, ...others }) });
}
CopyButton.displayName = "@mantine/core/CopyButton";
var __default__$e = { root: "m_3eebeb36", label: "m_9e365f20" };
const classes$f = __default__$e, defaultProps$I = {
  orientation: "horizontal"
}, varsResolver$e = (theme, { color: color2, variant, size: size2 }) => ({
  root: {
    "--divider-color": color2 ? getThemeColor(color2, theme) : void 0,
    "--divider-border-style": variant,
    "--divider-size": getSize(size2, "divider-size")
  }
}), Divider$1 = factory((_props, ref) => {
  const props = useProps("Divider", defaultProps$I, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars: vars2,
    color: color2,
    orientation,
    label: label2,
    labelPosition,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Divider",
    classes: classes$f,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars: vars2,
    varsResolver: varsResolver$e
  });
  return /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      mod: [{ orientation, "with-label": !!label2 }, mod],
      ...getStyles2("root"),
      ...others,
      role: "separator",
      children: label2 && /* @__PURE__ */ jsx(Box, { component: "span", mod: { position: labelPosition }, ...getStyles2("label"), children: label2 })
    }
  );
});
Divider$1.classes = classes$f;
Divider$1.displayName = "@mantine/core/Divider";
function useDelayedHover({ open, close, openDelay, closeDelay }) {
  const openTimeout = useRef(-1), closeTimeout = useRef(-1), clearTimeouts = () => {
    window.clearTimeout(openTimeout.current), window.clearTimeout(closeTimeout.current);
  }, openDropdown = () => {
    clearTimeouts(), openDelay === 0 || openDelay === void 0 ? open() : openTimeout.current = window.setTimeout(open, openDelay);
  }, closeDropdown = () => {
    clearTimeouts(), closeDelay === 0 || closeDelay === void 0 ? close() : closeTimeout.current = window.setTimeout(close, closeDelay);
  };
  return useEffect(() => clearTimeouts, []), { openDropdown, closeDropdown };
}
function getMarkColor({ color: color2, theme, defaultShade }) {
  const parsed = parseThemeColor({ color: color2, theme });
  return parsed.isThemeColor ? parsed.shade === void 0 ? `var(--mantine-color-${parsed.color}-${defaultShade})` : `var(${parsed.variable})` : color2;
}
var __default__$d = { root: "m_bcb3f3c2" };
const classes$e = __default__$d, defaultProps$H = {
  color: "yellow"
}, varsResolver$d = (theme, { color: color2 }) => ({
  root: {
    "--mark-bg-dark": getMarkColor({ color: color2, theme, defaultShade: 5 }),
    "--mark-bg-light": getMarkColor({ color: color2, theme, defaultShade: 2 })
  }
}), Mark = factory((_props, ref) => {
  const props = useProps("Mark", defaultProps$H, _props), { classNames, className, style: style2, styles, unstyled, vars: vars2, color: color2, variant, ...others } = props, getStyles2 = useStyles({
    name: "Mark",
    props,
    className,
    style: style2,
    classes: classes$e,
    classNames,
    styles,
    unstyled,
    vars: vars2,
    varsResolver: varsResolver$d
  });
  return /* @__PURE__ */ jsx(Box, { component: "mark", ref, variant, ...getStyles2("root"), ...others });
});
Mark.classes = classes$e;
Mark.displayName = "@mantine/core/Mark";
function escapeRegex$1(value) {
  return value.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&");
}
function highlighter(value, _highlight) {
  if (_highlight == null)
    return [{ chunk: value, highlighted: !1 }];
  const highlight = Array.isArray(_highlight) ? _highlight.map(escapeRegex$1) : escapeRegex$1(_highlight);
  if (!(Array.isArray(highlight) ? highlight.filter((part) => part.trim().length > 0).length > 0 : highlight.trim() !== ""))
    return [{ chunk: value, highlighted: !1 }];
  const matcher2 = typeof highlight == "string" ? highlight.trim() : highlight.filter((part) => part.trim().length !== 0).map((part) => part.trim()).sort((a2, b2) => b2.length - a2.length).join("|"), re = new RegExp(`(${matcher2})`, "gi");
  return value.split(re).map((part) => ({ chunk: part, highlighted: re.test(part) })).filter(({ chunk }) => chunk);
}
const defaultProps$G = {}, Highlight = polymorphicFactory((props, ref) => {
  const { unstyled, children: children2, highlight, highlightStyles, color: color2, ...others } = useProps(
    "Highlight",
    defaultProps$G,
    props
  ), highlightChunks = highlighter(children2, highlight);
  return /* @__PURE__ */ jsx(Text$6, { unstyled, ref, ...others, __staticSelector: "Highlight", children: highlightChunks.map(
    ({ chunk, highlighted }, i2) => highlighted ? /* @__PURE__ */ jsx(
      Mark,
      {
        unstyled,
        color: color2,
        style: highlightStyles,
        "data-highlight": chunk,
        children: chunk
      },
      i2
    ) : /* @__PURE__ */ jsx("span", { children: chunk }, i2)
  ) });
});
Highlight.classes = Text$6.classes;
Highlight.displayName = "@mantine/core/Highlight";
const [HoverCardContextProvider, useHoverCardContext] = createSafeContext(
  "HoverCard component was not found in the tree"
), defaultProps$F = {};
function HoverCardDropdown(props) {
  const { children: children2, onMouseEnter, onMouseLeave, ...others } = useProps(
    "HoverCardDropdown",
    defaultProps$F,
    props
  ), ctx = useHoverCardContext(), handleMouseEnter = createEventHandler(onMouseEnter, ctx.openDropdown), handleMouseLeave = createEventHandler(onMouseLeave, ctx.closeDropdown);
  return /* @__PURE__ */ jsx(Popover.Dropdown, { onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, ...others, children: children2 });
}
HoverCardDropdown.displayName = "@mantine/core/HoverCardDropdown";
const defaultProps$E = {
  refProp: "ref"
}, HoverCardTarget = forwardRef((props, ref) => {
  const { children: children2, refProp, eventPropsWrapperName, ...others } = useProps(
    "HoverCardTarget",
    defaultProps$E,
    props
  );
  if (!isElement$1(children2))
    throw new Error(
      "HoverCard.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  const ctx = useHoverCardContext(), onMouseEnter = createEventHandler(children2.props.onMouseEnter, ctx.openDropdown), onMouseLeave = createEventHandler(children2.props.onMouseLeave, ctx.closeDropdown), eventListeners = { onMouseEnter, onMouseLeave };
  return /* @__PURE__ */ jsx(Popover.Target, { refProp, ref, ...others, children: cloneElement(
    children2,
    eventPropsWrapperName ? { [eventPropsWrapperName]: eventListeners } : eventListeners
  ) });
});
HoverCardTarget.displayName = "@mantine/core/HoverCardTarget";
const defaultProps$D = {
  openDelay: 0,
  closeDelay: 150,
  initiallyOpened: !1
};
function HoverCard(props) {
  const { children: children2, onOpen, onClose, openDelay, closeDelay, initiallyOpened, ...others } = useProps(
    "HoverCard",
    defaultProps$D,
    props
  ), [opened, { open, close }] = useDisclosure(initiallyOpened, { onClose, onOpen }), { openDropdown, closeDropdown } = useDelayedHover({ open, close, openDelay, closeDelay });
  return /* @__PURE__ */ jsx(HoverCardContextProvider, { value: { openDropdown, closeDropdown }, children: /* @__PURE__ */ jsx(Popover, { ...others, opened, __staticSelector: "HoverCard", children: children2 }) });
}
HoverCard.displayName = "@mantine/core/HoverCard";
HoverCard.Target = HoverCardTarget;
HoverCard.Dropdown = HoverCardDropdown;
HoverCard.extend = (input) => input;
const [MenuContextProvider, useMenuContext] = createSafeContext(
  "Menu component was not found in the tree"
);
var __default__$c = { dropdown: "m_dc9b7c9f", label: "m_9bfac126", divider: "m_efdf90cb", item: "m_99ac2aa1", itemLabel: "m_5476e0d3", itemSection: "m_8b75e504" };
const classes$d = __default__$c, defaultProps$C = {}, MenuDivider = factory((props, ref) => {
  const { classNames, className, style: style2, styles, vars: vars2, ...others } = useProps(
    "MenuDivider",
    defaultProps$C,
    props
  ), ctx = useMenuContext();
  return /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      ...ctx.getStyles("divider", { className, style: style2, styles, classNames }),
      ...others
    }
  );
});
MenuDivider.classes = classes$d;
MenuDivider.displayName = "@mantine/core/MenuDivider";
const defaultProps$B = {}, MenuDropdown = factory((props, ref) => {
  const {
    classNames,
    className,
    style: style2,
    styles,
    vars: vars2,
    onMouseEnter,
    onMouseLeave,
    onKeyDown,
    children: children2,
    ...others
  } = useProps("MenuDropdown", defaultProps$B, props), wrapperRef = useRef(null), ctx = useMenuContext(), handleKeyDown = createEventHandler(onKeyDown, (event) => {
    var _a4, _b2;
    (event.key === "ArrowUp" || event.key === "ArrowDown") && (event.preventDefault(), (_b2 = (_a4 = wrapperRef.current) == null ? void 0 : _a4.querySelectorAll("[data-menu-item]:not(:disabled)")[0]) == null || _b2.focus());
  }), handleMouseEnter = createEventHandler(
    onMouseEnter,
    () => (ctx.trigger === "hover" || ctx.trigger === "click-hover") && ctx.openDropdown()
  ), handleMouseLeave = createEventHandler(
    onMouseLeave,
    () => (ctx.trigger === "hover" || ctx.trigger === "click-hover") && ctx.closeDropdown()
  );
  return /* @__PURE__ */ jsxs(
    Popover.Dropdown,
    {
      ...others,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      role: "menu",
      "aria-orientation": "vertical",
      ref: useMergedRef(ref, wrapperRef),
      ...ctx.getStyles("dropdown", {
        className,
        style: style2,
        styles,
        classNames,
        withStaticClass: !1
      }),
      tabIndex: -1,
      "data-menu-dropdown": !0,
      onKeyDown: handleKeyDown,
      children: [
        /* @__PURE__ */ jsx("div", { tabIndex: -1, "data-autofocus": !0, "data-mantine-stop-propagation": !0, style: { outline: 0 } }),
        children2
      ]
    }
  );
});
MenuDropdown.classes = classes$d;
MenuDropdown.displayName = "@mantine/core/MenuDropdown";
const defaultProps$A = {}, MenuItem = polymorphicFactory((props, ref) => {
  const {
    classNames,
    className,
    style: style2,
    styles,
    vars: vars2,
    color: color2,
    closeMenuOnClick,
    leftSection,
    rightSection,
    children: children2,
    disabled,
    ...others
  } = useProps("MenuItem", defaultProps$A, props), ctx = useMenuContext(), theme = useMantineTheme(), { dir } = useDirection(), itemRef = useRef(), itemIndex = ctx.getItemIndex(itemRef.current), _others = others, handleMouseLeave = createEventHandler(_others.onMouseLeave, () => ctx.setHovered(-1)), handleMouseEnter = createEventHandler(
    _others.onMouseEnter,
    () => ctx.setHovered(ctx.getItemIndex(itemRef.current))
  ), handleClick = createEventHandler(_others.onClick, () => {
    typeof closeMenuOnClick == "boolean" ? closeMenuOnClick && ctx.closeDropdownImmediately() : ctx.closeOnItemClick && ctx.closeDropdownImmediately();
  }), handleFocus = createEventHandler(
    _others.onFocus,
    () => ctx.setHovered(ctx.getItemIndex(itemRef.current))
  ), colors2 = color2 ? theme.variantColorResolver({ color: color2, theme, variant: "light" }) : void 0, parsedThemeColor = color2 ? parseThemeColor({ color: color2, theme }) : null;
  return /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      ...others,
      unstyled: ctx.unstyled,
      tabIndex: ctx.menuItemTabIndex,
      onFocus: handleFocus,
      ...ctx.getStyles("item", { className, style: style2, styles, classNames }),
      ref: useMergedRef(itemRef, ref),
      role: "menuitem",
      disabled,
      "data-menu-item": !0,
      "data-disabled": disabled || void 0,
      "data-hovered": ctx.hovered === itemIndex ? !0 : void 0,
      "data-mantine-stop-propagation": !0,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      onClick: handleClick,
      onKeyDown: createScopedKeydownHandler({
        siblingSelector: "[data-menu-item]",
        parentSelector: "[data-menu-dropdown]",
        activateOnFocus: !1,
        loop: ctx.loop,
        dir,
        orientation: "vertical",
        onKeyDown: _others.onKeyDown
      }),
      __vars: {
        "--menu-item-color": parsedThemeColor != null && parsedThemeColor.isThemeColor && (parsedThemeColor == null ? void 0 : parsedThemeColor.shade) === void 0 ? `var(--mantine-color-${parsedThemeColor.color}-6)` : colors2 == null ? void 0 : colors2.color,
        "--menu-item-hover": colors2 == null ? void 0 : colors2.hover
      },
      children: [
        leftSection && /* @__PURE__ */ jsx("div", { ...ctx.getStyles("itemSection", { styles, classNames }), "data-position": "left", children: leftSection }),
        children2 && /* @__PURE__ */ jsx("div", { ...ctx.getStyles("itemLabel", { styles, classNames }), children: children2 }),
        rightSection && /* @__PURE__ */ jsx("div", { ...ctx.getStyles("itemSection", { styles, classNames }), "data-position": "right", children: rightSection })
      ]
    }
  );
});
MenuItem.classes = classes$d;
MenuItem.displayName = "@mantine/core/MenuItem";
const defaultProps$z = {}, MenuLabel = factory((props, ref) => {
  const { classNames, className, style: style2, styles, vars: vars2, ...others } = useProps(
    "MenuLabel",
    defaultProps$z,
    props
  ), ctx = useMenuContext();
  return /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      ...ctx.getStyles("label", { className, style: style2, styles, classNames }),
      ...others
    }
  );
});
MenuLabel.classes = classes$d;
MenuLabel.displayName = "@mantine/core/MenuLabel";
const defaultProps$y = {
  refProp: "ref"
}, MenuTarget = forwardRef((props, ref) => {
  const { children: children2, refProp, ...others } = useProps("MenuTarget", defaultProps$y, props);
  if (!isElement$1(children2))
    throw new Error(
      "Menu.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  const ctx = useMenuContext(), onClick = createEventHandler(children2.props.onClick, () => {
    ctx.trigger === "click" ? ctx.toggleDropdown() : ctx.trigger === "click-hover" && (ctx.setOpenedViaClick(!0), ctx.opened || ctx.openDropdown());
  }), onMouseEnter = createEventHandler(
    children2.props.onMouseEnter,
    () => (ctx.trigger === "hover" || ctx.trigger === "click-hover") && ctx.openDropdown()
  ), onMouseLeave = createEventHandler(children2.props.onMouseLeave, () => {
    (ctx.trigger === "hover" || ctx.trigger === "click-hover" && !ctx.openedViaClick) && ctx.closeDropdown();
  });
  return /* @__PURE__ */ jsx(Popover.Target, { refProp, popupType: "menu", ref, ...others, children: cloneElement(children2, {
    onClick,
    onMouseEnter,
    onMouseLeave,
    "data-expanded": ctx.opened ? !0 : void 0
  }) });
});
MenuTarget.displayName = "@mantine/core/MenuTarget";
const defaultProps$x = {
  trapFocus: !0,
  closeOnItemClick: !0,
  clickOutsideEvents: ["mousedown", "touchstart", "keydown"],
  loop: !0,
  trigger: "click",
  openDelay: 0,
  closeDelay: 100,
  menuItemTabIndex: -1
};
function Menu(_props) {
  const props = useProps("Menu", defaultProps$x, _props), {
    children: children2,
    onOpen,
    onClose,
    opened,
    defaultOpened,
    trapFocus,
    onChange,
    closeOnItemClick,
    loop,
    closeOnEscape: closeOnEscape2,
    trigger,
    openDelay,
    closeDelay,
    classNames,
    styles,
    unstyled,
    variant,
    vars: vars2,
    menuItemTabIndex,
    keepMounted,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Menu",
    classes: classes$d,
    props,
    classNames,
    styles,
    unstyled
  }), [hovered, { setHovered, resetHovered }] = useHovered(), [_opened, setOpened] = useUncontrolled({
    value: opened,
    defaultValue: defaultOpened,
    finalValue: !1,
    onChange
  }), [openedViaClick, setOpenedViaClick] = useState(!1), close = () => {
    setOpened(!1), setOpenedViaClick(!1), _opened && (onClose == null || onClose());
  }, open = () => {
    setOpened(!0), !_opened && (onOpen == null || onOpen());
  }, toggleDropdown = () => {
    _opened ? close() : open();
  }, { openDropdown, closeDropdown } = useDelayedHover({ open, close, closeDelay, openDelay }), getItemIndex = (node2) => getContextItemIndex("[data-menu-item]", "[data-menu-dropdown]", node2), { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    classNames,
    styles,
    props
  });
  return useDidUpdate(() => {
    resetHovered();
  }, [_opened]), /* @__PURE__ */ jsx(
    MenuContextProvider,
    {
      value: {
        getStyles: getStyles2,
        opened: _opened,
        toggleDropdown,
        getItemIndex,
        hovered,
        setHovered,
        openedViaClick,
        setOpenedViaClick,
        closeOnItemClick,
        closeDropdown: trigger === "click" ? close : closeDropdown,
        openDropdown: trigger === "click" ? open : openDropdown,
        closeDropdownImmediately: close,
        loop,
        trigger,
        unstyled,
        menuItemTabIndex
      },
      children: /* @__PURE__ */ jsx(
        Popover,
        {
          ...others,
          opened: _opened,
          onChange: toggleDropdown,
          defaultOpened,
          trapFocus: keepMounted ? !1 : trapFocus,
          closeOnEscape: closeOnEscape2,
          __staticSelector: "Menu",
          classNames: resolvedClassNames,
          styles: resolvedStyles,
          unstyled,
          variant,
          keepMounted,
          children: children2
        }
      )
    }
  );
}
Menu.extend = (input) => input;
Menu.classes = classes$d;
Menu.displayName = "@mantine/core/Menu";
Menu.Item = MenuItem;
Menu.Label = MenuLabel;
Menu.Dropdown = MenuDropdown;
Menu.Target = MenuTarget;
Menu.Divider = MenuDivider;
const [ModalProvider, useModalContext] = createSafeContext(
  "Modal component was not found in tree"
);
var __default__$b = { root: "m_9df02822", content: "m_54c44539", inner: "m_1f958f16", header: "m_d0e2b9cd" };
const classes$c = __default__$b, defaultProps$w = {}, ModalBody = factory((_props, ref) => {
  const props = useProps("ModalBody", defaultProps$w, _props), { classNames, className, style: style2, styles, vars: vars2, ...others } = props, ctx = useModalContext();
  return /* @__PURE__ */ jsx(
    ModalBaseBody,
    {
      ref,
      ...ctx.getStyles("body", { classNames, style: style2, styles, className }),
      ...others
    }
  );
});
ModalBody.classes = classes$c;
ModalBody.displayName = "@mantine/core/ModalBody";
const defaultProps$v = {}, ModalCloseButton = factory((_props, ref) => {
  const props = useProps("ModalCloseButton", defaultProps$v, _props), { classNames, className, style: style2, styles, vars: vars2, ...others } = props, ctx = useModalContext();
  return /* @__PURE__ */ jsx(
    ModalBaseCloseButton,
    {
      ref,
      ...ctx.getStyles("close", { classNames, style: style2, styles, className }),
      ...others
    }
  );
});
ModalCloseButton.classes = classes$c;
ModalCloseButton.displayName = "@mantine/core/ModalCloseButton";
const defaultProps$u = {}, ModalContent = factory((_props, ref) => {
  const props = useProps("ModalContent", defaultProps$u, _props), { classNames, className, style: style2, styles, vars: vars2, children: children2, __hidden, ...others } = props, ctx = useModalContext(), Scroll = ctx.scrollAreaComponent || NativeScrollArea;
  return /* @__PURE__ */ jsx(
    ModalBaseContent,
    {
      ...ctx.getStyles("content", { className, style: style2, styles, classNames }),
      innerProps: ctx.getStyles("inner", { className, style: style2, styles, classNames }),
      "data-full-screen": ctx.fullScreen || void 0,
      "data-modal-content": !0,
      "data-hidden": __hidden || void 0,
      ref,
      ...others,
      children: /* @__PURE__ */ jsx(
        Scroll,
        {
          style: {
            maxHeight: ctx.fullScreen ? "100dvh" : `calc(100dvh - (${rem(ctx.yOffset)} * 2))`
          },
          children: children2
        }
      )
    }
  );
});
ModalContent.classes = classes$c;
ModalContent.displayName = "@mantine/core/ModalContent";
const defaultProps$t = {}, ModalHeader = factory((_props, ref) => {
  const props = useProps("ModalHeader", defaultProps$t, _props), { classNames, className, style: style2, styles, vars: vars2, ...others } = props, ctx = useModalContext();
  return /* @__PURE__ */ jsx(
    ModalBaseHeader,
    {
      ref,
      ...ctx.getStyles("header", { classNames, style: style2, styles, className }),
      ...others
    }
  );
});
ModalHeader.classes = classes$c;
ModalHeader.displayName = "@mantine/core/ModalHeader";
const defaultProps$s = {}, ModalOverlay = factory((_props, ref) => {
  const props = useProps("ModalOverlay", defaultProps$s, _props), { classNames, className, style: style2, styles, vars: vars2, ...others } = props, ctx = useModalContext();
  return /* @__PURE__ */ jsx(
    ModalBaseOverlay,
    {
      ref,
      ...ctx.getStyles("overlay", { classNames, style: style2, styles, className }),
      ...others
    }
  );
});
ModalOverlay.classes = classes$c;
ModalOverlay.displayName = "@mantine/core/ModalOverlay";
const defaultProps$r = {
  __staticSelector: "Modal",
  closeOnClickOutside: !0,
  withinPortal: !0,
  lockScroll: !0,
  trapFocus: !0,
  returnFocus: !0,
  closeOnEscape: !0,
  keepMounted: !1,
  zIndex: getDefaultZIndex("modal"),
  transitionProps: { duration: 200, transition: "fade-down" },
  yOffset: "5dvh"
}, varsResolver$c = (_, { radius, size: size2, yOffset, xOffset }) => ({
  root: {
    "--modal-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--modal-size": getSize(size2, "modal-size"),
    "--modal-y-offset": rem(yOffset),
    "--modal-x-offset": rem(xOffset)
  }
}), ModalRoot = factory((_props, ref) => {
  const props = useProps("ModalRoot", defaultProps$r, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars: vars2,
    yOffset,
    scrollAreaComponent,
    radius,
    fullScreen,
    centered,
    xOffset,
    __staticSelector,
    ...others
  } = props, getStyles2 = useStyles({
    name: __staticSelector,
    classes: classes$c,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars: vars2,
    varsResolver: varsResolver$c
  });
  return /* @__PURE__ */ jsx(ModalProvider, { value: { yOffset, scrollAreaComponent, getStyles: getStyles2, fullScreen }, children: /* @__PURE__ */ jsx(
    ModalBase,
    {
      ref,
      ...getStyles2("root"),
      "data-full-screen": fullScreen || void 0,
      "data-centered": centered || void 0,
      unstyled,
      ...others
    }
  ) });
});
ModalRoot.classes = classes$c;
ModalRoot.displayName = "@mantine/core/ModalRoot";
const [ModalStackProvider, useModalStackContext] = createOptionalContext();
function ModalStack({ children: children2 }) {
  const [stack, setStack] = useState([]), [maxZIndex, setMaxZIndex] = useState(getDefaultZIndex("modal"));
  return /* @__PURE__ */ jsx(
    ModalStackProvider,
    {
      value: {
        stack,
        addModal: (id2, zIndex) => {
          setStack((current) => [.../* @__PURE__ */ new Set([...current, id2])]), setMaxZIndex(
            (current) => typeof zIndex == "number" && typeof current == "number" ? Math.max(current, zIndex) : current
          );
        },
        removeModal: (id2) => setStack((current) => current.filter((currentId) => currentId !== id2)),
        getZIndex: (id2) => `calc(${maxZIndex} + ${stack.indexOf(id2)} + 1)`,
        currentId: stack[stack.length - 1],
        maxZIndex
      },
      children: children2
    }
  );
}
ModalStack.displayName = "@mantine/core/ModalStack";
const defaultProps$q = {}, ModalTitle = factory((_props, ref) => {
  const props = useProps("ModalTitle", defaultProps$q, _props), { classNames, className, style: style2, styles, vars: vars2, ...others } = props, ctx = useModalContext();
  return /* @__PURE__ */ jsx(
    ModalBaseTitle,
    {
      ref,
      ...ctx.getStyles("title", { classNames, style: style2, styles, className }),
      ...others
    }
  );
});
ModalTitle.classes = classes$c;
ModalTitle.displayName = "@mantine/core/ModalTitle";
const defaultProps$p = {
  closeOnClickOutside: !0,
  withinPortal: !0,
  lockScroll: !0,
  trapFocus: !0,
  returnFocus: !0,
  closeOnEscape: !0,
  keepMounted: !1,
  zIndex: getDefaultZIndex("modal"),
  transitionProps: { duration: 200, transition: "fade-down" },
  withOverlay: !0,
  withCloseButton: !0
}, Modal = factory((_props, ref) => {
  const {
    title: title2,
    withOverlay,
    overlayProps,
    withCloseButton,
    closeButtonProps,
    children: children2,
    radius,
    opened,
    stackId,
    zIndex,
    ...others
  } = useProps("Modal", defaultProps$p, _props), ctx = useModalStackContext(), hasHeader = !!title2 || withCloseButton, stackProps = ctx && stackId ? {
    closeOnEscape: ctx.currentId === stackId,
    trapFocus: ctx.currentId === stackId,
    zIndex: ctx.getZIndex(stackId)
  } : {}, overlayVisible = withOverlay === !1 ? !1 : stackId && ctx ? ctx.currentId === stackId : opened;
  return useEffect(() => {
    ctx && stackId && (opened ? ctx.addModal(stackId, zIndex || getDefaultZIndex("modal")) : ctx.removeModal(stackId));
  }, [opened, stackId, zIndex]), /* @__PURE__ */ jsxs(
    ModalRoot,
    {
      ref,
      radius,
      opened,
      zIndex: ctx && stackId ? ctx.getZIndex(stackId) : zIndex,
      ...others,
      ...stackProps,
      children: [
        withOverlay && /* @__PURE__ */ jsx(
          ModalOverlay,
          {
            visible: overlayVisible,
            transitionProps: ctx && stackId ? { duration: 0 } : void 0,
            ...overlayProps
          }
        ),
        /* @__PURE__ */ jsxs(
          ModalContent,
          {
            radius,
            __hidden: ctx && stackId && opened ? stackId !== ctx.currentId : !1,
            children: [
              hasHeader && /* @__PURE__ */ jsxs(ModalHeader, { children: [
                title2 && /* @__PURE__ */ jsx(ModalTitle, { children: title2 }),
                withCloseButton && /* @__PURE__ */ jsx(ModalCloseButton, { ...closeButtonProps })
              ] }),
              /* @__PURE__ */ jsx(ModalBody, { children: children2 })
            ]
          }
        )
      ]
    }
  );
});
Modal.classes = classes$c;
Modal.displayName = "@mantine/core/Modal";
Modal.Root = ModalRoot;
Modal.Overlay = ModalOverlay;
Modal.Content = ModalContent;
Modal.Body = ModalBody;
Modal.Header = ModalHeader;
Modal.Title = ModalTitle;
Modal.CloseButton = ModalCloseButton;
Modal.Stack = ModalStack;
const [PillsInputProvider, usePillsInputContext] = createOptionalContext(), [PillGroupProvider, usePillGroupContext] = createOptionalContext();
var __default__$a = { root: "m_7cda1cd6", "root--default": "m_44da308b", "root--contrast": "m_e3a01f8", label: "m_1e0e6180", remove: "m_ae386778", group: "m_1dcfd90b" };
const classes$b = __default__$a, defaultProps$o = {}, varsResolver$b = (_, { gap }, { size: size2 }) => ({
  group: {
    "--pg-gap": gap !== void 0 ? getSize(gap) : getSize(size2, "pg-gap")
  }
}), PillGroup = factory((_props, ref) => {
  const props = useProps("PillGroup", defaultProps$o, _props), { classNames, className, style: style2, styles, unstyled, vars: vars2, size: size2, disabled, ...others } = props, pillsInputCtx = usePillsInputContext(), _size2 = (pillsInputCtx == null ? void 0 : pillsInputCtx.size) || size2 || void 0, getStyles2 = useStyles({
    name: "PillGroup",
    classes: classes$b,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars: vars2,
    varsResolver: varsResolver$b,
    stylesCtx: { size: _size2 },
    rootSelector: "group"
  });
  return /* @__PURE__ */ jsx(PillGroupProvider, { value: { size: _size2, disabled }, children: /* @__PURE__ */ jsx(Box, { ref, size: _size2, ...getStyles2("group"), ...others }) });
});
PillGroup.classes = classes$b;
PillGroup.displayName = "@mantine/core/PillGroup";
const defaultProps$n = {
  variant: "default"
}, varsResolver$a = (_, { radius }, { size: size2 }) => ({
  root: {
    "--pill-fz": getSize(size2, "pill-fz"),
    "--pill-height": getSize(size2, "pill-height"),
    "--pill-radius": radius === void 0 ? void 0 : getRadius$1(radius)
  }
}), Pill = factory((_props, ref) => {
  const props = useProps("Pill", defaultProps$n, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars: vars2,
    variant,
    children: children2,
    withRemoveButton,
    onRemove: onRemove2,
    removeButtonProps,
    radius,
    size: size2,
    disabled,
    mod,
    ...others
  } = props, ctx = usePillGroupContext(), pillsInputCtx = usePillsInputContext(), _size2 = size2 || (ctx == null ? void 0 : ctx.size) || void 0, _variant = (pillsInputCtx == null ? void 0 : pillsInputCtx.variant) === "filled" ? "contrast" : variant || "default", getStyles2 = useStyles({
    name: "Pill",
    classes: classes$b,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars: vars2,
    varsResolver: varsResolver$a,
    stylesCtx: { size: _size2 }
  });
  return /* @__PURE__ */ jsxs(
    Box,
    {
      component: "span",
      ref,
      variant: _variant,
      size: _size2,
      ...getStyles2("root", { variant: _variant }),
      mod: [
        { "with-remove": withRemoveButton && !disabled, disabled: disabled || (ctx == null ? void 0 : ctx.disabled) },
        mod
      ],
      ...others,
      children: [
        /* @__PURE__ */ jsx("span", { ...getStyles2("label"), children: children2 }),
        withRemoveButton && /* @__PURE__ */ jsx(
          CloseButton,
          {
            variant: "transparent",
            radius,
            tabIndex: -1,
            "aria-hidden": !0,
            unstyled,
            ...removeButtonProps,
            ...getStyles2("remove", {
              className: removeButtonProps == null ? void 0 : removeButtonProps.className,
              style: removeButtonProps == null ? void 0 : removeButtonProps.style
            }),
            onMouseDown: (event) => {
              var _a4;
              event.preventDefault(), event.stopPropagation(), (_a4 = removeButtonProps == null ? void 0 : removeButtonProps.onMouseDown) == null || _a4.call(removeButtonProps, event);
            },
            onClick: (event) => {
              var _a4;
              event.stopPropagation(), onRemove2 == null || onRemove2(), (_a4 = removeButtonProps == null ? void 0 : removeButtonProps.onClick) == null || _a4.call(removeButtonProps, event);
            }
          }
        )
      ]
    }
  );
});
Pill.classes = classes$b;
Pill.displayName = "@mantine/core/Pill";
Pill.Group = PillGroup;
var __default__$9 = { root: "m_a513464", icon: "m_a4ceffb", loader: "m_b0920b15", body: "m_a49ed24", title: "m_3feedf16", description: "m_3d733a3a", closeButton: "m_919a4d88" };
const classes$a = __default__$9, defaultProps$m = {
  withCloseButton: !0
}, varsResolver$9 = (theme, { radius, color: color2 }) => ({
  root: {
    "--notification-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--notification-color": color2 ? getThemeColor(color2, theme) : void 0
  }
}), Notification = factory((_props, ref) => {
  const props = useProps("Notification", defaultProps$m, _props), {
    className,
    color: color2,
    radius,
    loading,
    withCloseButton,
    withBorder,
    title: title2,
    icon,
    children: children2,
    onClose,
    closeButtonProps,
    classNames,
    style: style2,
    styles,
    unstyled,
    variant,
    vars: vars2,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Notification",
    classes: classes$a,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars: vars2,
    varsResolver: varsResolver$9
  });
  return /* @__PURE__ */ jsxs(
    Box,
    {
      ...getStyles2("root"),
      mod: [{ "data-with-icon": !!icon || loading, "data-with-border": withBorder }, mod],
      ref,
      variant,
      ...others,
      role: "alert",
      children: [
        icon && !loading && /* @__PURE__ */ jsx("div", { ...getStyles2("icon"), children: icon }),
        loading && /* @__PURE__ */ jsx(Loader, { size: 28, color: color2, ...getStyles2("loader") }),
        /* @__PURE__ */ jsxs("div", { ...getStyles2("body"), children: [
          title2 && /* @__PURE__ */ jsx("div", { ...getStyles2("title"), children: title2 }),
          /* @__PURE__ */ jsx(Box, { ...getStyles2("description"), mod: { "data-with-title": !!title2 }, children: children2 })
        ] }),
        withCloseButton && /* @__PURE__ */ jsx(
          CloseButton,
          {
            iconSize: 16,
            color: "gray",
            ...closeButtonProps,
            unstyled,
            onClick: onClose,
            ...getStyles2("closeButton")
          }
        )
      ]
    }
  );
});
Notification.classes = classes$a;
Notification.displayName = "@mantine/core/Notification";
const defaultTransition = {
  duration: 100,
  transition: "fade"
};
function getTransitionProps(transitionProps, componentTransition) {
  return { ...defaultTransition, ...componentTransition, ...transitionProps };
}
function useFloatingTooltip({
  offset: offset2,
  position: position2,
  defaultOpened
}) {
  const [opened, setOpened] = useState(defaultOpened), boundaryRef = useRef(), { x: x2, y: y2, elements, refs, update, placement } = useFloating({
    placement: position2,
    middleware: [
      shift({
        crossAxis: !0,
        padding: 5,
        rootBoundary: "document"
      })
    ]
  }), horizontalOffset = placement.includes("right") ? offset2 : position2.includes("left") ? offset2 * -1 : 0, verticalOffset = placement.includes("bottom") ? offset2 : position2.includes("top") ? offset2 * -1 : 0, handleMouseMove = useCallback(
    ({ clientX, clientY }) => {
      refs.setPositionReference({
        getBoundingClientRect() {
          return {
            width: 0,
            height: 0,
            x: clientX,
            y: clientY,
            left: clientX + horizontalOffset,
            top: clientY + verticalOffset,
            right: clientX,
            bottom: clientY
          };
        }
      });
    },
    [elements.reference]
  );
  return useEffect(() => {
    if (refs.floating.current) {
      const boundary = boundaryRef.current;
      boundary.addEventListener("mousemove", handleMouseMove);
      const parents = getOverflowAncestors(refs.floating.current);
      return parents.forEach((parent) => {
        parent.addEventListener("scroll", update);
      }), () => {
        boundary.removeEventListener("mousemove", handleMouseMove), parents.forEach((parent) => {
          parent.removeEventListener("scroll", update);
        });
      };
    }
  }, [elements.reference, refs.floating.current, update, handleMouseMove, opened]), { handleMouseMove, x: x2, y: y2, opened, setOpened, boundaryRef, floating: refs.setFloating };
}
var __default__$8 = { tooltip: "m_1b3c8819", arrow: "m_f898399f" };
const classes$9 = __default__$8, defaultProps$l = {
  refProp: "ref",
  withinPortal: !0,
  offset: 10,
  defaultOpened: !1,
  position: "right",
  zIndex: getDefaultZIndex("popover")
}, varsResolver$8 = (theme, { radius, color: color2 }) => ({
  tooltip: {
    "--tooltip-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--tooltip-bg": color2 ? getThemeColor(color2, theme) : void 0,
    "--tooltip-color": color2 ? "var(--mantine-color-white)" : void 0
  }
}), TooltipFloating = factory((_props, ref) => {
  const props = useProps("TooltipFloating", defaultProps$l, _props), {
    children: children2,
    refProp,
    withinPortal,
    style: style2,
    className,
    classNames,
    styles,
    unstyled,
    radius,
    color: color2,
    label: label2,
    offset: offset2,
    position: position2,
    multiline,
    zIndex,
    disabled,
    defaultOpened,
    variant,
    vars: vars2,
    portalProps,
    ...others
  } = props, theme = useMantineTheme(), getStyles2 = useStyles({
    name: "TooltipFloating",
    props,
    classes: classes$9,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    rootSelector: "tooltip",
    vars: vars2,
    varsResolver: varsResolver$8
  }), { handleMouseMove, x: x2, y: y2, opened, boundaryRef, floating, setOpened } = useFloatingTooltip({
    offset: offset2,
    position: position2,
    defaultOpened
  });
  if (!isElement$1(children2))
    throw new Error(
      "[@mantine/core] Tooltip.Floating component children should be an element or a component that accepts ref, fragments, strings, numbers and other primitive values are not supported"
    );
  const targetRef = useMergedRef(boundaryRef, getRefProp(children2), ref), onMouseEnter = (event) => {
    var _a4, _b2;
    (_b2 = (_a4 = children2.props).onMouseEnter) == null || _b2.call(_a4, event), handleMouseMove(event), setOpened(!0);
  }, onMouseLeave = (event) => {
    var _a4, _b2;
    (_b2 = (_a4 = children2.props).onMouseLeave) == null || _b2.call(_a4, event), setOpened(!1);
  };
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(OptionalPortal, { ...portalProps, withinPortal, children: /* @__PURE__ */ jsx(
      Box,
      {
        ...others,
        ...getStyles2("tooltip", {
          style: {
            ...getStyleObject(style2, theme),
            zIndex,
            display: !disabled && opened ? "block" : "none",
            top: (y2 && Math.round(y2)) ?? "",
            left: (x2 && Math.round(x2)) ?? ""
          }
        }),
        variant,
        ref: floating,
        mod: { multiline },
        children: label2
      }
    ) }),
    cloneElement(children2, {
      ...children2.props,
      [refProp]: targetRef,
      onMouseEnter,
      onMouseLeave
    })
  ] });
});
TooltipFloating.classes = classes$9;
TooltipFloating.displayName = "@mantine/core/TooltipFloating";
const TooltipGroupContext = createContext(!1), TooltipGroupProvider = TooltipGroupContext.Provider, useTooltipGroupContext = () => useContext(TooltipGroupContext), defaultProps$k = {
  openDelay: 0,
  closeDelay: 0
};
function TooltipGroup(props) {
  const { openDelay, closeDelay, children: children2 } = useProps("TooltipGroup", defaultProps$k, props);
  return /* @__PURE__ */ jsx(TooltipGroupProvider, { value: !0, children: /* @__PURE__ */ jsx(FloatingDelayGroup, { delay: { open: openDelay, close: closeDelay }, children: children2 }) });
}
TooltipGroup.displayName = "@mantine/core/TooltipGroup";
TooltipGroup.extend = (c) => c;
function useTooltip(settings) {
  var _a4, _b2, _c;
  const [uncontrolledOpened, setUncontrolledOpened] = useState(settings.defaultOpened), opened = typeof settings.opened == "boolean" ? settings.opened : uncontrolledOpened, withinGroup = useTooltipGroupContext(), uid = useId$1(), { delay: groupDelay, currentId, setCurrentId } = useDelayGroupContext(), onChange = useCallback(
    (_opened) => {
      setUncontrolledOpened(_opened), _opened && setCurrentId(uid);
    },
    [setCurrentId, uid]
  ), {
    x: x2,
    y: y2,
    context,
    refs,
    update,
    placement,
    middlewareData: { arrow: { x: arrowX, y: arrowY } = {} }
  } = useFloating({
    strategy: settings.strategy,
    placement: settings.position,
    open: opened,
    onOpenChange: onChange,
    middleware: [
      offset(settings.offset),
      shift({ padding: 8 }),
      flip(),
      arrow({ element: settings.arrowRef, padding: settings.arrowOffset }),
      ...settings.inline ? [inline()] : []
    ]
  });
  useDelayGroup(context, { id: uid });
  const { getReferenceProps, getFloatingProps } = useInteractions([
    useHover(context, {
      enabled: (_a4 = settings.events) == null ? void 0 : _a4.hover,
      delay: withinGroup ? groupDelay : { open: settings.openDelay, close: settings.closeDelay },
      mouseOnly: !((_b2 = settings.events) != null && _b2.touch)
    }),
    useFocus(context, { enabled: (_c = settings.events) == null ? void 0 : _c.focus, visibleOnly: !0 }),
    useRole(context, { role: "tooltip" }),
    // Cannot be used with controlled tooltip, page jumps
    useDismiss(context, { enabled: typeof settings.opened > "u" })
  ]);
  useFloatingAutoUpdate({
    opened,
    position: settings.position,
    positionDependencies: settings.positionDependencies,
    floating: { refs, update }
  }), useDidUpdate(() => {
    var _a5;
    (_a5 = settings.onPositionChange) == null || _a5.call(settings, placement);
  }, [placement]);
  const isGroupPhase = opened && currentId && currentId !== uid;
  return {
    x: x2,
    y: y2,
    arrowX,
    arrowY,
    reference: refs.setReference,
    floating: refs.setFloating,
    getFloatingProps,
    getReferenceProps,
    isGroupPhase,
    opened,
    placement
  };
}
const defaultProps$j = {
  position: "top",
  refProp: "ref",
  withinPortal: !0,
  inline: !1,
  defaultOpened: !1,
  arrowSize: 4,
  arrowOffset: 5,
  arrowRadius: 0,
  arrowPosition: "side",
  offset: 5,
  transitionProps: { duration: 100, transition: "fade" },
  events: { hover: !0, focus: !1, touch: !1 },
  zIndex: getDefaultZIndex("popover"),
  positionDependencies: []
}, varsResolver$7 = (theme, { radius, color: color2 }) => ({
  tooltip: {
    "--tooltip-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--tooltip-bg": color2 ? getThemeColor(color2, theme) : void 0,
    "--tooltip-color": color2 ? "var(--mantine-color-white)" : void 0
  }
}), Tooltip$5 = factory((_props, ref) => {
  const props = useProps("Tooltip", defaultProps$j, _props), {
    children: children2,
    position: position2,
    refProp,
    label: label2,
    openDelay,
    closeDelay,
    onPositionChange,
    opened,
    defaultOpened,
    withinPortal,
    radius,
    color: color2,
    classNames,
    styles,
    unstyled,
    style: style2,
    className,
    withArrow,
    arrowSize,
    arrowOffset,
    arrowRadius,
    arrowPosition,
    offset: offset2,
    transitionProps,
    multiline,
    events,
    zIndex,
    disabled,
    positionDependencies,
    onClick,
    onMouseEnter,
    onMouseLeave,
    inline: inline2,
    variant,
    keepMounted,
    vars: vars2,
    portalProps,
    mod,
    floatingStrategy,
    ...others
  } = useProps("Tooltip", defaultProps$j, props), { dir } = useDirection(), arrowRef = useRef(null), tooltip = useTooltip({
    position: getFloatingPosition(dir, position2),
    closeDelay,
    openDelay,
    onPositionChange,
    opened,
    defaultOpened,
    events,
    arrowRef,
    arrowOffset,
    offset: typeof offset2 == "number" ? offset2 + (withArrow ? arrowSize / 2 : 0) : offset2,
    positionDependencies: [...positionDependencies, children2],
    inline: inline2,
    strategy: floatingStrategy
  }), getStyles2 = useStyles({
    name: "Tooltip",
    props,
    classes: classes$9,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    rootSelector: "tooltip",
    vars: vars2,
    varsResolver: varsResolver$7
  });
  if (!isElement$1(children2))
    throw new Error(
      "[@mantine/core] Tooltip component children should be an element or a component that accepts ref, fragments, strings, numbers and other primitive values are not supported"
    );
  const targetRef = useMergedRef(tooltip.reference, getRefProp(children2), ref), transition = getTransitionProps(transitionProps, { duration: 100, transition: "fade" });
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(OptionalPortal, { ...portalProps, withinPortal, children: /* @__PURE__ */ jsx(
      Transition,
      {
        ...transition,
        keepMounted,
        mounted: !disabled && !!tooltip.opened,
        duration: tooltip.isGroupPhase ? 10 : transition.duration,
        children: (transitionStyles) => /* @__PURE__ */ jsxs(
          Box,
          {
            ...others,
            "data-fixed": floatingStrategy === "fixed" || void 0,
            variant,
            mod: [{ multiline }, mod],
            ...tooltip.getFloatingProps({
              ref: tooltip.floating,
              className: getStyles2("tooltip").className,
              style: {
                ...getStyles2("tooltip").style,
                ...transitionStyles,
                zIndex,
                top: tooltip.y ?? 0,
                left: tooltip.x ?? 0
              }
            }),
            children: [
              label2,
              /* @__PURE__ */ jsx(
                FloatingArrow,
                {
                  ref: arrowRef,
                  arrowX: tooltip.arrowX,
                  arrowY: tooltip.arrowY,
                  visible: withArrow,
                  position: tooltip.placement,
                  arrowSize,
                  arrowOffset,
                  arrowRadius,
                  arrowPosition,
                  ...getStyles2("arrow")
                }
              )
            ]
          }
        )
      }
    ) }),
    cloneElement(
      children2,
      tooltip.getReferenceProps({
        onClick,
        onMouseEnter,
        onMouseLeave,
        onMouseMove: props.onMouseMove,
        onPointerDown: props.onPointerDown,
        onPointerEnter: props.onPointerEnter,
        [refProp]: targetRef,
        className: clsx(className, children2.props.className),
        ...children2.props
      })
    )
  ] });
});
Tooltip$5.classes = classes$9;
Tooltip$5.displayName = "@mantine/core/Tooltip";
Tooltip$5.Floating = TooltipFloating;
Tooltip$5.Group = TooltipGroup;
var __default__$7 = { root: "m_cf365364", indicator: "m_9e182ccd", label: "m_1738fcb2", input: "m_1714d588", control: "m_69686b9b", innerLabel: "m_78882f40" };
const classes$8 = __default__$7, defaultProps$i = {
  withItemsBorders: !0
}, varsResolver$6 = (theme, { radius, color: color2, transitionDuration, size: size2, transitionTimingFunction }) => ({
  root: {
    "--sc-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--sc-color": color2 ? getThemeColor(color2, theme) : void 0,
    "--sc-shadow": color2 ? void 0 : "var(--mantine-shadow-xs)",
    "--sc-transition-duration": transitionDuration === void 0 ? void 0 : `${transitionDuration}ms`,
    "--sc-transition-timing-function": transitionTimingFunction,
    "--sc-padding": getSize(size2, "sc-padding"),
    "--sc-font-size": getFontSize(size2)
  }
}), SegmentedControl = factory((_props, ref) => {
  var _a4, _b2;
  const props = useProps("SegmentedControl", defaultProps$i, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars: vars2,
    data,
    value,
    defaultValue,
    onChange,
    size: size2,
    name,
    disabled,
    readOnly,
    fullWidth,
    orientation,
    radius,
    color: color2,
    transitionDuration,
    transitionTimingFunction,
    variant,
    autoContrast,
    withItemsBorders,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: "SegmentedControl",
    props,
    classes: classes$8,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars: vars2,
    varsResolver: varsResolver$6
  }), theme = useMantineTheme(), _data = data.map(
    (item) => typeof item == "string" ? { label: item, value: item } : item
  ), initialized = useMounted(), [parent, setParent] = useState(null), [refs, setRefs] = useState({}), setElementRef = (element, val) => {
    refs[val] = element, setRefs(refs);
  }, [_value, handleValueChange] = useUncontrolled({
    value,
    defaultValue,
    finalValue: Array.isArray(data) ? ((_a4 = _data.find((item) => !item.disabled)) == null ? void 0 : _a4.value) ?? ((_b2 = data[0]) == null ? void 0 : _b2.value) ?? null : null,
    onChange
  }), uuid = useId$1(name), controls = _data.map((item) => /* @__PURE__ */ createElement(
    Box,
    {
      ...getStyles2("control"),
      mod: { active: _value === item.value, orientation },
      key: item.value
    },
    /* @__PURE__ */ createElement(
      "input",
      {
        ...getStyles2("input"),
        disabled: disabled || item.disabled,
        type: "radio",
        name: uuid,
        value: item.value,
        id: `${uuid}-${item.value}`,
        checked: _value === item.value,
        onChange: () => !readOnly && handleValueChange(item.value),
        "data-focus-ring": theme.focusRing,
        key: `${item.value}-input`
      }
    ),
    /* @__PURE__ */ createElement(
      Box,
      {
        component: "label",
        ...getStyles2("label"),
        mod: {
          active: _value === item.value && !(disabled || item.disabled),
          disabled: disabled || item.disabled,
          "read-only": readOnly
        },
        htmlFor: `${uuid}-${item.value}`,
        ref: (node2) => setElementRef(node2, item.value),
        __vars: {
          "--sc-label-color": color2 !== void 0 ? getContrastColor({ color: color2, theme, autoContrast }) : void 0
        },
        key: `${item.value}-label`
      },
      /* @__PURE__ */ jsx("span", { ...getStyles2("innerLabel"), children: item.label })
    )
  )), mergedRef = useMergedRef(ref, (node2) => setParent(node2));
  return data.length === 0 ? null : /* @__PURE__ */ jsxs(
    Box,
    {
      ...getStyles2("root"),
      variant,
      size: size2,
      ref: mergedRef,
      mod: [
        {
          "full-width": fullWidth,
          orientation,
          initialized,
          "with-items-borders": withItemsBorders
        },
        mod
      ],
      ...others,
      role: "radiogroup",
      "data-disabled": disabled,
      children: [
        typeof _value == "string" && /* @__PURE__ */ jsx(
          FloatingIndicator,
          {
            target: refs[_value],
            parent,
            component: "span",
            transitionDuration: "var(--sc-transition-duration)",
            ...getStyles2("indicator")
          }
        ),
        controls
      ]
    }
  );
});
SegmentedControl.classes = classes$8;
SegmentedControl.displayName = "@mantine/core/SegmentedControl";
const [SliderProvider, useSliderContext] = createSafeContext(
  "SliderProvider was not found in tree"
), SliderRoot = forwardRef(
  ({ size: size2, disabled, variant, color: color2, thumbSize, radius, ...others }, ref) => {
    const { getStyles: getStyles2 } = useSliderContext();
    return /* @__PURE__ */ jsx(
      Box,
      {
        tabIndex: -1,
        variant,
        size: size2,
        ref,
        ...getStyles2("root"),
        ...others
      }
    );
  }
);
SliderRoot.displayName = "@mantine/core/SliderRoot";
const Thumb = forwardRef(
  ({
    max: max2,
    min: min2,
    value,
    position: position2,
    label: label2,
    dragging,
    onMouseDown,
    onKeyDownCapture,
    labelTransitionProps,
    labelAlwaysOn,
    thumbLabel,
    onFocus,
    onBlur,
    showLabelOnHover,
    isHovered,
    children: children2 = null,
    disabled
  }, ref) => {
    const { getStyles: getStyles2 } = useSliderContext(), [focused, setFocused] = useState(!1), isVisible = labelAlwaysOn || dragging || focused || showLabelOnHover && isHovered;
    return /* @__PURE__ */ jsxs(
      Box,
      {
        tabIndex: 0,
        role: "slider",
        "aria-label": thumbLabel,
        "aria-valuemax": max2,
        "aria-valuemin": min2,
        "aria-valuenow": value,
        ref,
        __vars: { "--slider-thumb-offset": `${position2}%` },
        ...getStyles2("thumb", { focusable: !0 }),
        mod: { dragging, disabled },
        onFocus: () => {
          setFocused(!0), typeof onFocus == "function" && onFocus();
        },
        onBlur: () => {
          setFocused(!1), typeof onBlur == "function" && onBlur();
        },
        onTouchStart: onMouseDown,
        onMouseDown,
        onKeyDownCapture,
        onClick: (event) => event.stopPropagation(),
        children: [
          children2,
          /* @__PURE__ */ jsx(
            Transition,
            {
              mounted: label2 != null && !!isVisible,
              transition: "fade",
              duration: 0,
              ...labelTransitionProps,
              children: (transitionStyles) => /* @__PURE__ */ jsx("div", { ...getStyles2("label", { style: transitionStyles }), children: label2 })
            }
          )
        ]
      }
    );
  }
);
Thumb.displayName = "@mantine/core/SliderThumb";
function getPosition({ value, min: min2, max: max2 }) {
  const position2 = (value - min2) / (max2 - min2) * 100;
  return Math.min(Math.max(position2, 0), 100);
}
function isMarkFilled({ mark, offset: offset2, value, inverted = !1 }) {
  return inverted ? typeof offset2 == "number" && mark.value <= offset2 || mark.value >= value : typeof offset2 == "number" ? mark.value >= offset2 && mark.value <= value : mark.value <= value;
}
function Marks({ marks, min: min2, max: max2, disabled, value, offset: offset2, inverted }) {
  const { getStyles: getStyles2 } = useSliderContext();
  if (!marks)
    return null;
  const items = marks.map((mark, index2) => /* @__PURE__ */ createElement(
    Box,
    {
      ...getStyles2("markWrapper"),
      __vars: { "--mark-offset": `${getPosition({ value: mark.value, min: min2, max: max2 })}%` },
      key: index2
    },
    /* @__PURE__ */ jsx(
      Box,
      {
        ...getStyles2("mark"),
        mod: { filled: isMarkFilled({ mark, value, offset: offset2, inverted }), disabled }
      }
    ),
    mark.label && /* @__PURE__ */ jsx("div", { ...getStyles2("markLabel"), children: mark.label })
  ));
  return /* @__PURE__ */ jsx("div", { children: items });
}
Marks.displayName = "@mantine/core/SliderMarks";
function Track({
  filled,
  children: children2,
  offset: offset2,
  disabled,
  marksOffset,
  inverted,
  containerProps,
  ...others
}) {
  const { getStyles: getStyles2 } = useSliderContext();
  return /* @__PURE__ */ jsx(Box, { ...getStyles2("trackContainer"), mod: { disabled }, ...containerProps, children: /* @__PURE__ */ jsxs(Box, { ...getStyles2("track"), mod: { inverted, disabled }, children: [
    /* @__PURE__ */ jsx(
      Box,
      {
        mod: { inverted, disabled },
        __vars: {
          "--slider-bar-width": `calc(${filled}% + var(--slider-size))`,
          "--slider-bar-offset": `calc(${offset2}% - var(--slider-size))`
        },
        ...getStyles2("bar")
      }
    ),
    children2,
    /* @__PURE__ */ jsx(Marks, { ...others, offset: marksOffset, disabled, inverted })
  ] }) });
}
Track.displayName = "@mantine/core/SliderTrack";
function getChangeValue({
  value,
  containerWidth,
  min: min2,
  max: max2,
  step,
  precision
}) {
  const dx = (containerWidth ? Math.min(Math.max(value, 0), containerWidth) / containerWidth : value) * (max2 - min2), nextValue = (dx !== 0 ? Math.round(dx / step) * step : 0) + min2, nextValueWithinStep = Math.max(nextValue, min2);
  return precision !== void 0 ? Number(nextValueWithinStep.toFixed(precision)) : nextValueWithinStep;
}
function getFloatingValue(value, precision) {
  return parseFloat(value.toFixed(precision));
}
function getPrecision(step) {
  if (!step)
    return 0;
  const split = step.toString().split(".");
  return split.length > 1 ? split[1].length : 0;
}
var __default__$6 = { root: "m_dd36362e", label: "m_c9357328", thumb: "m_c9a9a60a", trackContainer: "m_a8645c2", track: "m_c9ade57f", bar: "m_38aeed47", markWrapper: "m_b7b0423a", mark: "m_dd33bc19", markLabel: "m_68c77a5b" };
const classes$7 = __default__$6, defaultProps$h = {
  radius: "xl",
  min: 0,
  max: 100,
  step: 1,
  marks: [],
  label: (f2) => f2,
  labelTransitionProps: { transition: "fade", duration: 0 },
  labelAlwaysOn: !1,
  thumbLabel: "",
  showLabelOnHover: !0,
  disabled: !1,
  scale: (v2) => v2
}, varsResolver$5 = (theme, { size: size2, color: color2, thumbSize, radius }) => ({
  root: {
    "--slider-size": getSize(size2, "slider-size"),
    "--slider-color": color2 ? getThemeColor(color2, theme) : void 0,
    "--slider-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--slider-thumb-size": thumbSize !== void 0 ? rem(thumbSize) : "calc(var(--slider-size) * 2)"
  }
}), Slider = factory((_props, ref) => {
  const props = useProps("Slider", defaultProps$h, _props), {
    classNames,
    styles,
    value,
    onChange,
    onChangeEnd,
    size: size2,
    min: min2,
    max: max2,
    step,
    precision: _precision,
    defaultValue,
    name,
    marks,
    label: label2,
    labelTransitionProps,
    labelAlwaysOn,
    thumbLabel,
    showLabelOnHover,
    thumbChildren,
    disabled,
    unstyled,
    scale: scale2,
    inverted,
    className,
    style: style2,
    vars: vars2,
    hiddenInputProps,
    restrictToMarks,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Slider",
    props,
    classes: classes$7,
    classNames,
    className,
    styles,
    style: style2,
    vars: vars2,
    varsResolver: varsResolver$5,
    unstyled
  }), { dir } = useDirection(), [hovered, setHovered] = useState(!1), [_value, setValue] = useUncontrolled({
    value: typeof value == "number" ? clamp$3(value, min2, max2) : value,
    defaultValue: typeof defaultValue == "number" ? clamp$3(defaultValue, min2, max2) : defaultValue,
    finalValue: clamp$3(0, min2, max2),
    onChange
  }), valueRef = useRef(_value), root2 = useRef(), thumb = useRef(), position2 = getPosition({ value: _value, min: min2, max: max2 }), scaledValue = scale2(_value), _label = typeof label2 == "function" ? label2(scaledValue) : label2, precision = _precision ?? getPrecision(step), handleChange = useCallback(
    ({ x: x2 }) => {
      if (!disabled) {
        const nextValue = getChangeValue({
          value: x2,
          min: min2,
          max: max2,
          step,
          precision
        });
        setValue(
          restrictToMarks && (marks != null && marks.length) ? findClosestNumber(
            nextValue,
            marks.map((mark) => mark.value)
          ) : nextValue
        ), valueRef.current = nextValue;
      }
    },
    [disabled, min2, max2, step, precision, setValue, marks, restrictToMarks]
  ), { ref: container2, active } = useMove(
    handleChange,
    {
      onScrubEnd: () => onChangeEnd == null ? void 0 : onChangeEnd(
        restrictToMarks && (marks != null && marks.length) ? findClosestNumber(
          valueRef.current,
          marks.map((mark) => mark.value)
        ) : valueRef.current
      )
    },
    dir
  ), handleTrackKeydownCapture = (event) => {
    var _a4, _b2, _c, _d, _e, _f;
    if (!disabled)
      switch (event.key) {
        case "ArrowUp": {
          event.preventDefault(), (_a4 = thumb.current) == null || _a4.focus();
          const nextValue = getFloatingValue(
            Math.min(Math.max(_value + step, min2), max2),
            precision
          );
          setValue(nextValue), onChangeEnd == null || onChangeEnd(nextValue);
          break;
        }
        case "ArrowRight": {
          event.preventDefault(), (_b2 = thumb.current) == null || _b2.focus();
          const nextValue = getFloatingValue(
            Math.min(Math.max(dir === "rtl" ? _value - step : _value + step, min2), max2),
            precision
          );
          setValue(nextValue), onChangeEnd == null || onChangeEnd(nextValue);
          break;
        }
        case "ArrowDown": {
          event.preventDefault(), (_c = thumb.current) == null || _c.focus();
          const nextValue = getFloatingValue(
            Math.min(Math.max(_value - step, min2), max2),
            precision
          );
          setValue(nextValue), onChangeEnd == null || onChangeEnd(nextValue);
          break;
        }
        case "ArrowLeft": {
          event.preventDefault(), (_d = thumb.current) == null || _d.focus();
          const nextValue = getFloatingValue(
            Math.min(Math.max(dir === "rtl" ? _value + step : _value - step, min2), max2),
            precision
          );
          setValue(nextValue), onChangeEnd == null || onChangeEnd(nextValue);
          break;
        }
        case "Home": {
          event.preventDefault(), (_e = thumb.current) == null || _e.focus(), setValue(min2), onChangeEnd == null || onChangeEnd(min2);
          break;
        }
        case "End": {
          event.preventDefault(), (_f = thumb.current) == null || _f.focus(), setValue(max2), onChangeEnd == null || onChangeEnd(max2);
          break;
        }
      }
  };
  return /* @__PURE__ */ jsx(SliderProvider, { value: { getStyles: getStyles2 }, children: /* @__PURE__ */ jsxs(
    SliderRoot,
    {
      ...others,
      ref: useMergedRef(ref, root2),
      onKeyDownCapture: handleTrackKeydownCapture,
      onMouseDownCapture: () => {
        var _a4;
        return (_a4 = root2.current) == null ? void 0 : _a4.focus();
      },
      size: size2,
      disabled,
      children: [
        /* @__PURE__ */ jsx(
          Track,
          {
            inverted,
            offset: 0,
            filled: position2,
            marks,
            min: min2,
            max: max2,
            value: scaledValue,
            disabled,
            containerProps: {
              ref: container2,
              onMouseEnter: showLabelOnHover ? () => setHovered(!0) : void 0,
              onMouseLeave: showLabelOnHover ? () => setHovered(!1) : void 0
            },
            children: /* @__PURE__ */ jsx(
              Thumb,
              {
                max: max2,
                min: min2,
                value: scaledValue,
                position: position2,
                dragging: active,
                label: _label,
                ref: thumb,
                labelTransitionProps,
                labelAlwaysOn,
                thumbLabel,
                showLabelOnHover,
                isHovered: hovered,
                disabled,
                children: thumbChildren
              }
            )
          }
        ),
        /* @__PURE__ */ jsx("input", { type: "hidden", name, value: scaledValue, ...hiddenInputProps })
      ]
    }
  ) });
});
Slider.classes = classes$7;
Slider.displayName = "@mantine/core/Slider";
const defaultProps$g = {}, Space = factory((props, ref) => {
  const { w: w2, h: h2, miw, mih, ...others } = useProps("Space", defaultProps$g, props);
  return /* @__PURE__ */ jsx(Box, { ref, ...others, w: w2, miw: miw ?? w2, h: h2, mih: mih ?? h2 });
});
Space.displayName = "@mantine/core/Space";
var __default__$5 = { root: "m_559cce2d", content: "m_b912df4e", control: "m_b9131032" };
const classes$6 = __default__$5, defaultProps$f = {
  maxHeight: 100,
  initialState: !1
}, varsResolver$4 = (_, { transitionDuration }) => ({
  root: {
    "--spoiler-transition-duration": transitionDuration !== void 0 ? `${transitionDuration}ms` : void 0
  }
}), Spoiler = factory((_props, ref) => {
  const props = useProps("Spoiler", defaultProps$f, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars: vars2,
    initialState,
    maxHeight,
    hideLabel,
    showLabel,
    children: children2,
    controlRef,
    transitionDuration,
    id: id2,
    expanded,
    onExpandedChange,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Spoiler",
    classes: classes$6,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars: vars2,
    varsResolver: varsResolver$4
  }), _id = useId$1(id2), regionId = `${_id}-region`, [show, setShowState] = useUncontrolled({
    value: expanded,
    defaultValue: initialState,
    finalValue: !1,
    onChange: onExpandedChange
  }), { ref: contentRef, height } = useElementSize(), spoilerMoreContent = show ? hideLabel : showLabel, spoiler = spoilerMoreContent !== null && maxHeight < height;
  return /* @__PURE__ */ jsxs(
    Box,
    {
      ...getStyles2("root"),
      id: _id,
      ref,
      "data-has-spoiler": spoiler || void 0,
      ...others,
      children: [
        spoiler && /* @__PURE__ */ jsx(
          Anchor,
          {
            component: "button",
            type: "button",
            ref: controlRef,
            onClick: () => setShowState(!show),
            "aria-expanded": show,
            "aria-controls": regionId,
            ...getStyles2("control"),
            children: spoilerMoreContent
          }
        ),
        /* @__PURE__ */ jsx(
          "div",
          {
            ...getStyles2("content", {
              style: { maxHeight: show ? height ? rem(height) : void 0 : rem(maxHeight) }
            }),
            "data-reduce-motion": !0,
            role: "region",
            id: regionId,
            children: /* @__PURE__ */ jsx("div", { ref: contentRef, children: children2 })
          }
        )
      ]
    }
  );
});
Spoiler.classes = classes$6;
Spoiler.displayName = "@mantine/core/Spoiler";
var __default__$4 = { root: "m_6d731127" };
const classes$5 = __default__$4, defaultProps$e = {
  gap: "md",
  align: "stretch",
  justify: "flex-start"
}, varsResolver$3 = (_, { gap, align: align2, justify }) => ({
  root: {
    "--stack-gap": getSpacing(gap),
    "--stack-align": align2,
    "--stack-justify": justify
  }
}), Stack$1 = factory((_props, ref) => {
  const props = useProps("Stack", defaultProps$e, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars: vars2,
    align: align2,
    justify,
    gap,
    variant,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Stack",
    props,
    classes: classes$5,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars: vars2,
    varsResolver: varsResolver$3
  });
  return /* @__PURE__ */ jsx(Box, { ref, ...getStyles2("root"), variant, ...others });
});
Stack$1.classes = classes$5;
Stack$1.displayName = "@mantine/core/Stack";
const [TabsProvider, useTabsContext] = createSafeContext(
  "Tabs component was not found in the tree"
);
var __default__$3 = { root: "m_89d60db1", "list--default": "m_576c9d4", list: "m_89d33d6d", panel: "m_b0c91715", tab: "m_4ec4dce6", tabSection: "m_fc420b1f", "tab--default": "m_539e827b", "list--outline": "m_6772fbd5", "tab--outline": "m_b59ab47c", "tab--pills": "m_c3381914" };
const classes$4 = __default__$3, defaultProps$d = {}, TabsList = factory((_props, ref) => {
  const props = useProps("TabsList", defaultProps$d, _props), { children: children2, className, grow, justify, classNames, styles, style: style2, mod, ...others } = props, ctx = useTabsContext();
  return /* @__PURE__ */ jsx(
    Box,
    {
      ...others,
      ...ctx.getStyles("list", {
        className,
        style: style2,
        classNames,
        styles,
        props,
        variant: ctx.variant
      }),
      ref,
      role: "tablist",
      variant: ctx.variant,
      mod: [
        {
          grow,
          orientation: ctx.orientation,
          placement: ctx.orientation === "vertical" && ctx.placement,
          inverted: ctx.inverted
        },
        mod
      ],
      "aria-orientation": ctx.orientation,
      __vars: { "--tabs-justify": justify },
      children: children2
    }
  );
});
TabsList.classes = classes$4;
TabsList.displayName = "@mantine/core/TabsList";
const defaultProps$c = {}, TabsPanel = factory((_props, ref) => {
  const props = useProps("TabsPanel", defaultProps$c, _props), { children: children2, className, value, classNames, styles, style: style2, mod, keepMounted, ...others } = props, ctx = useTabsContext(), active = ctx.value === value, content = ctx.keepMounted || keepMounted || active ? children2 : null;
  return /* @__PURE__ */ jsx(
    Box,
    {
      ...others,
      ...ctx.getStyles("panel", {
        className,
        classNames,
        styles,
        style: [style2, active ? void 0 : { display: "none" }],
        props
      }),
      ref,
      mod: [{ orientation: ctx.orientation }, mod],
      role: "tabpanel",
      id: ctx.getPanelId(value),
      "aria-labelledby": ctx.getTabId(value),
      children: content
    }
  );
});
TabsPanel.classes = classes$4;
TabsPanel.displayName = "@mantine/core/TabsPanel";
const defaultProps$b = {}, TabsTab = factory((_props, ref) => {
  const props = useProps("TabsTab", defaultProps$b, _props), {
    className,
    children: children2,
    rightSection,
    leftSection,
    value,
    onClick,
    onKeyDown,
    disabled,
    color: color2,
    style: style2,
    classNames,
    styles,
    vars: vars2,
    mod,
    tabIndex,
    ...others
  } = props, theme = useMantineTheme(), { dir } = useDirection(), ctx = useTabsContext(), active = value === ctx.value, activateTab = (event) => {
    ctx.onChange(ctx.allowTabDeactivation && value === ctx.value ? null : value), onClick == null || onClick(event);
  }, stylesApiProps = { classNames, styles, props };
  return /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      ...others,
      ...ctx.getStyles("tab", { className, style: style2, variant: ctx.variant, ...stylesApiProps }),
      disabled,
      unstyled: ctx.unstyled,
      variant: ctx.variant,
      mod: [
        {
          active,
          disabled,
          orientation: ctx.orientation,
          inverted: ctx.inverted,
          placement: ctx.orientation === "vertical" && ctx.placement
        },
        mod
      ],
      ref,
      role: "tab",
      id: ctx.getTabId(value),
      "aria-selected": active,
      tabIndex: tabIndex || active || ctx.value === null ? 0 : -1,
      "aria-controls": ctx.getPanelId(value),
      onClick: activateTab,
      __vars: { "--tabs-color": color2 ? getThemeColor(color2, theme) : void 0 },
      onKeyDown: createScopedKeydownHandler({
        siblingSelector: '[role="tab"]',
        parentSelector: '[role="tablist"]',
        activateOnFocus: ctx.activateTabWithKeyboard,
        loop: ctx.loop,
        orientation: ctx.orientation || "horizontal",
        dir,
        onKeyDown
      }),
      children: [
        leftSection && /* @__PURE__ */ jsx("span", { ...ctx.getStyles("tabSection", stylesApiProps), "data-position": "left", children: leftSection }),
        children2 && /* @__PURE__ */ jsx("span", { ...ctx.getStyles("tabLabel", stylesApiProps), children: children2 }),
        rightSection && /* @__PURE__ */ jsx("span", { ...ctx.getStyles("tabSection", stylesApiProps), "data-position": "right", children: rightSection })
      ]
    }
  );
});
TabsTab.classes = classes$4;
TabsTab.displayName = "@mantine/core/TabsTab";
const VALUE_ERROR = "Tabs.Tab or Tabs.Panel component was rendered with invalid value or without value", defaultProps$a = {
  keepMounted: !0,
  orientation: "horizontal",
  loop: !0,
  activateTabWithKeyboard: !0,
  allowTabDeactivation: !1,
  unstyled: !1,
  inverted: !1,
  variant: "default",
  placement: "left"
}, varsResolver$2 = (theme, { radius, color: color2, autoContrast }) => ({
  root: {
    "--tabs-radius": getRadius$1(radius),
    "--tabs-color": getThemeColor(color2, theme),
    "--tabs-text-color": getAutoContrastValue(autoContrast, theme) ? getContrastColor({ color: color2, theme, autoContrast }) : void 0
  }
}), Tabs = factory((_props, ref) => {
  const props = useProps("Tabs", defaultProps$a, _props), {
    defaultValue,
    value,
    onChange,
    orientation,
    children: children2,
    loop,
    id: id2,
    activateTabWithKeyboard,
    allowTabDeactivation,
    variant,
    color: color2,
    radius,
    inverted,
    placement,
    keepMounted,
    classNames,
    styles,
    unstyled,
    className,
    style: style2,
    vars: vars2,
    autoContrast,
    mod,
    ...others
  } = props, uid = useId$1(id2), [currentTab, setCurrentTab] = useUncontrolled({
    value,
    defaultValue,
    finalValue: null,
    onChange
  }), getStyles2 = useStyles({
    name: "Tabs",
    props,
    classes: classes$4,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars: vars2,
    varsResolver: varsResolver$2
  });
  return /* @__PURE__ */ jsx(
    TabsProvider,
    {
      value: {
        placement,
        value: currentTab,
        orientation,
        id: uid,
        loop,
        activateTabWithKeyboard,
        getTabId: getSafeId(`${uid}-tab`, VALUE_ERROR),
        getPanelId: getSafeId(`${uid}-panel`, VALUE_ERROR),
        onChange: setCurrentTab,
        allowTabDeactivation,
        variant,
        color: color2,
        radius,
        inverted,
        keepMounted,
        unstyled,
        getStyles: getStyles2
      },
      children: /* @__PURE__ */ jsx(
        Box,
        {
          ref,
          id: uid,
          variant,
          mod: [
            {
              orientation,
              inverted: orientation === "horizontal" && inverted,
              placement: orientation === "vertical" && placement
            },
            mod
          ],
          ...getStyles2("root"),
          ...others,
          children: children2
        }
      )
    }
  );
});
Tabs.classes = classes$4;
Tabs.displayName = "@mantine/core/Tabs";
Tabs.Tab = TabsTab;
Tabs.Panel = TabsPanel;
Tabs.List = TabsList;
var __default__$2 = { root: "m_7341320d" };
const classes$3 = __default__$2, defaultProps$9 = {}, varsResolver$1 = (theme, { size: size2, radius, variant, gradient, color: color2, autoContrast }) => {
  const colors2 = theme.variantColorResolver({
    color: color2 || theme.primaryColor,
    theme,
    gradient,
    variant: variant || "filled",
    autoContrast
  });
  return {
    root: {
      "--ti-size": getSize(size2, "ti-size"),
      "--ti-radius": radius === void 0 ? void 0 : getRadius$1(radius),
      "--ti-bg": color2 || variant ? colors2.background : void 0,
      "--ti-color": color2 || variant ? colors2.color : void 0,
      "--ti-bd": color2 || variant ? colors2.border : void 0
    }
  };
}, ThemeIcon = factory((_props, ref) => {
  const props = useProps("ThemeIcon", defaultProps$9, _props), { classNames, className, style: style2, styles, unstyled, vars: vars2, autoContrast, ...others } = props, getStyles2 = useStyles({
    name: "ThemeIcon",
    classes: classes$3,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars: vars2,
    varsResolver: varsResolver$1
  });
  return /* @__PURE__ */ jsx(Box, { ref, ...getStyles2("root"), ...others });
});
ThemeIcon.classes = classes$3;
ThemeIcon.displayName = "@mantine/core/ThemeIcon";
function getValuesRange(anchor, value, flatValues) {
  if (!anchor || !value)
    return [];
  const anchorIndex = flatValues.indexOf(anchor), valueIndex = flatValues.indexOf(value), start2 = Math.min(anchorIndex, valueIndex), end = Math.max(anchorIndex, valueIndex);
  return flatValues.slice(start2, end + 1);
}
function TreeNode({
  node: node2,
  getStyles: getStyles2,
  rootIndex,
  controller,
  expandOnClick,
  selectOnClick,
  isSubtree,
  level = 1,
  renderNode,
  flatValues,
  allowRangeSelection,
  expandOnSpace
}) {
  const ref = useRef(null), nested = (node2.children || []).map((child) => /* @__PURE__ */ jsx(
    TreeNode,
    {
      node: child,
      flatValues,
      getStyles: getStyles2,
      rootIndex: void 0,
      level: level + 1,
      controller,
      expandOnClick,
      isSubtree: !0,
      renderNode,
      selectOnClick,
      allowRangeSelection,
      expandOnSpace
    },
    child.value
  )), handleKeyDown = (event) => {
    var _a4, _b2, _c;
    if (event.nativeEvent.code === "ArrowRight" && (event.stopPropagation(), event.preventDefault(), controller.expandedState[node2.value] ? (_a4 = event.currentTarget.querySelector("[role=treeitem]")) == null || _a4.focus() : controller.expand(node2.value)), event.nativeEvent.code === "ArrowLeft" && (event.stopPropagation(), event.preventDefault(), controller.expandedState[node2.value] && (node2.children || []).length > 0 ? controller.collapse(node2.value) : isSubtree && ((_b2 = findElementAncestor(event.currentTarget, "[role=treeitem]")) == null || _b2.focus())), event.nativeEvent.code === "ArrowDown" || event.nativeEvent.code === "ArrowUp") {
      const root2 = findElementAncestor(event.currentTarget, "[data-tree-root]");
      if (!root2)
        return;
      event.stopPropagation(), event.preventDefault();
      const nodes = Array.from(root2.querySelectorAll("[role=treeitem]")), index2 = nodes.indexOf(event.currentTarget);
      if (index2 === -1)
        return;
      const nextIndex = event.nativeEvent.code === "ArrowDown" ? index2 + 1 : index2 - 1;
      if ((_c = nodes[nextIndex]) == null || _c.focus(), event.shiftKey) {
        const selectNode = nodes[nextIndex];
        selectNode && controller.setSelectedState(
          getValuesRange(controller.anchorNode, selectNode.dataset.value, flatValues)
        );
      }
    }
    event.nativeEvent.code === "Space" && expandOnSpace && (event.stopPropagation(), event.preventDefault(), controller.toggleExpanded(node2.value));
  }, handleNodeClick2 = (event) => {
    var _a4, _b2;
    event.stopPropagation(), allowRangeSelection && event.shiftKey && controller.anchorNode ? (controller.setSelectedState(getValuesRange(controller.anchorNode, node2.value, flatValues)), (_a4 = ref.current) == null || _a4.focus()) : (expandOnClick && controller.toggleExpanded(node2.value), selectOnClick && controller.select(node2.value), (_b2 = ref.current) == null || _b2.focus());
  }, selected2 = controller.selectedState.includes(node2.value), elementProps = {
    ...getStyles2("label"),
    onClick: handleNodeClick2,
    "data-selected": selected2 || void 0,
    "data-value": node2.value,
    "data-hovered": controller.hoveredNode === node2.value || void 0
  };
  return /* @__PURE__ */ jsxs(
    "li",
    {
      ...getStyles2("node", {
        style: { "--label-offset": `calc(var(--level-offset) * ${level - 1})` }
      }),
      role: "treeitem",
      "aria-selected": selected2,
      "data-value": node2.value,
      "data-selected": selected2 || void 0,
      "data-hovered": controller.hoveredNode === node2.value || void 0,
      "data-level": level,
      tabIndex: rootIndex === 0 ? 0 : -1,
      onKeyDown: handleKeyDown,
      ref,
      onMouseOver: (event) => {
        event.stopPropagation(), controller.setHoveredNode(node2.value);
      },
      onMouseLeave: (event) => {
        event.stopPropagation(), controller.setHoveredNode(null);
      },
      children: [
        typeof renderNode == "function" ? renderNode({
          node: node2,
          level,
          selected: selected2,
          tree: controller,
          expanded: controller.expandedState[node2.value] || !1,
          hasChildren: Array.isArray(node2.children) && node2.children.length > 0,
          elementProps
        }) : /* @__PURE__ */ jsx("div", { ...elementProps, children: node2.label }),
        controller.expandedState[node2.value] && nested.length > 0 && /* @__PURE__ */ jsx("ul", { role: "group", ...getStyles2("subtree"), "data-level": level, children: nested })
      ]
    }
  );
}
TreeNode.displayName = "@mantine/core/TreeNode";
function getAllCheckedNodes(data, checkedState, acc = []) {
  const currentTreeChecked = [];
  for (const node2 of data)
    if (Array.isArray(node2.children) && node2.children.length > 0) {
      const innerChecked = getAllCheckedNodes(node2.children, checkedState, acc);
      if (innerChecked.currentTreeChecked.length === node2.children.length) {
        const isChecked = innerChecked.currentTreeChecked.every((item2) => item2.checked), item = {
          checked: isChecked,
          indeterminate: !isChecked,
          value: node2.value,
          hasChildren: !0
        };
        currentTreeChecked.push(item), acc.push(item);
      } else if (innerChecked.currentTreeChecked.length > 0) {
        const item = { checked: !1, indeterminate: !0, value: node2.value, hasChildren: !0 };
        currentTreeChecked.push(item), acc.push(item);
      }
    } else if (checkedState.includes(node2.value)) {
      const item = {
        checked: !0,
        indeterminate: !1,
        value: node2.value,
        hasChildren: !1
      };
      currentTreeChecked.push(item), acc.push(item);
    }
  return { result: acc, currentTreeChecked };
}
function findTreeNode(value, data) {
  for (const node2 of data) {
    if (node2.value === value)
      return node2;
    if (Array.isArray(node2.children)) {
      const childNode = findTreeNode(value, node2.children);
      if (childNode)
        return childNode;
    }
  }
  return null;
}
function getChildrenNodesValues(value, data, acc = []) {
  const node2 = findTreeNode(value, data);
  return node2 ? !Array.isArray(node2.children) || node2.children.length === 0 ? [node2.value] : (node2.children.forEach((child) => {
    Array.isArray(child.children) && child.children.length > 0 ? getChildrenNodesValues(child.value, data, acc) : acc.push(child.value);
  }), acc) : acc;
}
function getAllChildrenNodes(data) {
  return data.reduce((acc, node2) => (Array.isArray(node2.children) && node2.children.length > 0 ? acc.push(...getAllChildrenNodes(node2.children)) : acc.push(node2.value), acc), []);
}
function isNodeChecked(value, data, checkedState) {
  return checkedState.length === 0 ? !1 : checkedState.includes(value) ? !0 : getAllCheckedNodes(data, checkedState).result.some((node2) => node2.value === value && node2.checked);
}
const memoizedIsNodeChecked = memoize(isNodeChecked);
function isNodeIndeterminate(value, data, checkedState) {
  return checkedState.length === 0 ? !1 : getAllCheckedNodes(data, checkedState).result.some((node2) => node2.value === value && node2.indeterminate);
}
const memoizedIsNodeIndeterminate = memoize(isNodeIndeterminate);
function getInitialTreeExpandedState(initialState, data, value, acc = {}) {
  return data.forEach((node2) => {
    acc[node2.value] = node2.value in initialState ? initialState[node2.value] : node2.value === value, Array.isArray(node2.children) && getInitialTreeExpandedState(initialState, node2.children, value, acc);
  }), acc;
}
function getInitialCheckedState(initialState, data) {
  const acc = [];
  return initialState.forEach((node2) => acc.push(...getChildrenNodesValues(node2, data))), Array.from(new Set(acc));
}
function useTree({
  initialSelectedState = [],
  initialCheckedState = [],
  initialExpandedState = {},
  multiple = !1,
  onNodeCollapse,
  onNodeExpand
} = {}) {
  const [data, setData] = useState([]), [expandedState, setExpandedState] = useState(initialExpandedState), [selectedState, setSelectedState] = useState(initialSelectedState), [checkedState, setCheckedState] = useState(initialCheckedState), [anchorNode, setAnchorNode] = useState(null), [hoveredNode, setHoveredNode] = useState(null), initialize = useCallback(
    (_data) => {
      setExpandedState((current) => getInitialTreeExpandedState(current, _data, selectedState)), setCheckedState((current) => getInitialCheckedState(current, _data)), setData(_data);
    },
    [selectedState, checkedState]
  ), toggleExpanded = useCallback(
    (value) => {
      setExpandedState((current) => {
        const nextState = { ...current, [value]: !current[value] };
        return nextState[value] ? onNodeExpand == null || onNodeExpand(value) : onNodeCollapse == null || onNodeCollapse(value), nextState;
      });
    },
    [onNodeCollapse, onNodeExpand]
  ), collapse = useCallback(
    (value) => {
      setExpandedState((current) => (current[value] !== !1 && (onNodeCollapse == null || onNodeCollapse(value)), { ...current, [value]: !1 }));
    },
    [onNodeCollapse]
  ), expand = useCallback(
    (value) => {
      setExpandedState((current) => (current[value] !== !0 && (onNodeExpand == null || onNodeExpand(value)), { ...current, [value]: !0 }));
    },
    [onNodeExpand]
  ), expandAllNodes = useCallback(() => {
    setExpandedState((current) => {
      const next = { ...current };
      return Object.keys(next).forEach((key) => {
        next[key] = !0;
      }), next;
    });
  }, []), collapseAllNodes = useCallback(() => {
    setExpandedState((current) => {
      const next = { ...current };
      return Object.keys(next).forEach((key) => {
        next[key] = !1;
      }), next;
    });
  }, []), toggleSelected = useCallback(
    (value) => setSelectedState((current) => multiple ? current.includes(value) ? (setAnchorNode(null), current.filter((item) => item !== value)) : (setAnchorNode(value), [...current, value]) : current.includes(value) ? (setAnchorNode(null), []) : (setAnchorNode(value), [value])),
    []
  ), select2 = useCallback((value) => {
    setAnchorNode(value), setSelectedState(
      (current) => multiple ? current.includes(value) ? current : [...current, value] : [value]
    );
  }, []), deselect = useCallback((value) => {
    anchorNode === value && setAnchorNode(null), setSelectedState((current) => current.filter((item) => item !== value));
  }, []), clearSelected = useCallback(() => {
    setSelectedState([]), setAnchorNode(null);
  }, []), checkNode = useCallback(
    (value) => {
      const checkedNodes = getChildrenNodesValues(value, data);
      setCheckedState((current) => Array.from(/* @__PURE__ */ new Set([...current, ...checkedNodes])));
    },
    [data]
  ), uncheckNode = useCallback(
    (value) => {
      const checkedNodes = getChildrenNodesValues(value, data);
      setCheckedState((current) => current.filter((item) => !checkedNodes.includes(item)));
    },
    [data]
  ), checkAllNodes = useCallback(() => {
    setCheckedState(() => getAllChildrenNodes(data));
  }, [data]), uncheckAllNodes = useCallback(() => {
    setCheckedState([]);
  }, []);
  return {
    multiple,
    expandedState,
    selectedState,
    checkedState,
    anchorNode,
    initialize,
    toggleExpanded,
    collapse,
    expand,
    expandAllNodes,
    collapseAllNodes,
    setExpandedState,
    checkNode,
    uncheckNode,
    checkAllNodes,
    uncheckAllNodes,
    setCheckedState,
    toggleSelected,
    select: select2,
    deselect,
    clearSelected,
    setSelectedState,
    hoveredNode,
    setHoveredNode,
    getCheckedNodes: () => getAllCheckedNodes(data, checkedState).result,
    isNodeChecked: (value) => memoizedIsNodeChecked(value, data, checkedState),
    isNodeIndeterminate: (value) => memoizedIsNodeIndeterminate(value, data, checkedState)
  };
}
var __default__$1 = { root: "m_f698e191", subtree: "m_75f3ecf", node: "m_f6970eb1", label: "m_dc283425" };
const classes$2 = __default__$1;
function getFlatValues(data) {
  return data.reduce((acc, item) => (acc.push(item.value), item.children && acc.push(...getFlatValues(item.children)), acc), []);
}
const defaultProps$8 = {
  expandOnClick: !0,
  allowRangeSelection: !0,
  expandOnSpace: !0
}, varsResolver = (_theme, { levelOffset }) => ({
  root: {
    "--level-offset": getSpacing(levelOffset)
  }
}), Tree = factory((_props, ref) => {
  const props = useProps("Tree", defaultProps$8, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars: vars2,
    data,
    expandOnClick,
    tree,
    renderNode,
    selectOnClick,
    clearSelectionOnOutsideClick,
    allowRangeSelection,
    expandOnSpace,
    levelOffset,
    ...others
  } = props, defaultController = useTree(), controller = tree || defaultController, getStyles2 = useStyles({
    name: "Tree",
    classes: classes$2,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars: vars2,
    varsResolver
  }), clickOutsideRef = useClickOutside(
    () => clearSelectionOnOutsideClick && controller.clearSelected()
  ), mergedRef = useMergedRef(ref, clickOutsideRef), flatValues = useMemo(() => getFlatValues(data), [data]);
  useEffect(() => {
    controller.initialize(data);
  }, [data]);
  const nodes = data.map((node2, index2) => /* @__PURE__ */ jsx(
    TreeNode,
    {
      node: node2,
      getStyles: getStyles2,
      rootIndex: index2,
      expandOnClick,
      selectOnClick,
      controller,
      renderNode,
      flatValues,
      allowRangeSelection,
      expandOnSpace
    },
    node2.value
  ));
  return /* @__PURE__ */ jsx(
    Box,
    {
      component: "ul",
      ref: mergedRef,
      ...getStyles2("root"),
      ...others,
      role: "tree",
      "aria-multiselectable": controller.multiple,
      "data-tree-root": !0,
      children: nodes
    }
  );
});
Tree.displayName = "@mantine/core/Tree";
Tree.classes = classes$2;
function createDOMMotionComponentProxy(componentFactory) {
  if (typeof Proxy > "u")
    return componentFactory;
  const componentCache = /* @__PURE__ */ new Map(), deprecatedFactoryFunction = (...args) => componentFactory(...args);
  return new Proxy(deprecatedFactoryFunction, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (_target, key) => key === "create" ? componentFactory : (componentCache.has(key) || componentCache.set(key, componentFactory(key)), componentCache.get(key))
  });
}
function isAnimationControls(v2) {
  return v2 !== null && typeof v2 == "object" && typeof v2.start == "function";
}
const isKeyframesTarget = (v2) => Array.isArray(v2);
function shallowCompare(next, prev) {
  if (!Array.isArray(prev))
    return !1;
  const prevLength = prev.length;
  if (prevLength !== next.length)
    return !1;
  for (let i2 = 0; i2 < prevLength; i2++)
    if (prev[i2] !== next[i2])
      return !1;
  return !0;
}
function isVariantLabel(v2) {
  return typeof v2 == "string" || Array.isArray(v2);
}
function getValueState(visualElement) {
  const state = [{}, {}];
  return visualElement == null || visualElement.values.forEach((value, key) => {
    state[0][key] = value.get(), state[1][key] = value.getVelocity();
  }), state;
}
function resolveVariantFromProps(props, definition, custom5, visualElement) {
  if (typeof definition == "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom5 !== void 0 ? custom5 : props.custom, current, velocity);
  }
  if (typeof definition == "string" && (definition = props.variants && props.variants[definition]), typeof definition == "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom5 !== void 0 ? custom5 : props.custom, current, velocity);
  }
  return definition;
}
function resolveVariant(visualElement, definition, custom5) {
  const props = visualElement.getProps();
  return resolveVariantFromProps(props, definition, custom5 !== void 0 ? custom5 : props.custom, visualElement);
}
const variantPriorityOrder = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], variantProps = ["initial", ...variantPriorityOrder], transformPropOrder = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], transformProps = new Set(transformPropOrder), secondsToMilliseconds = (seconds) => seconds * 1e3, millisecondsToSeconds = (milliseconds) => milliseconds / 1e3, underDampedSpring = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, criticallyDampedSpring = (target) => ({
  type: "spring",
  stiffness: 550,
  damping: target === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), keyframesTransition = {
  type: "keyframes",
  duration: 0.8
}, ease = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, getDefaultTransition = (valueKey, { keyframes: keyframes2 }) => keyframes2.length > 2 ? keyframesTransition : transformProps.has(valueKey) ? valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes2[1]) : underDampedSpring : ease;
function getValueTransition$1(transition, key) {
  return transition ? transition[key] || transition.default || transition : void 0;
}
const MotionGlobalConfig = {
  skipAnimations: !1,
  useManualTiming: !1
}, isNotNull = (value) => value !== null;
function getFinalKeyframe(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe) {
  const resolvedKeyframes = keyframes2.filter(isNotNull), index2 = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
  return !index2 || finalKeyframe === void 0 ? resolvedKeyframes[index2] : finalKeyframe;
}
const noop$2 = (any) => any;
function createRenderStep(runNextFrame) {
  let thisFrame = /* @__PURE__ */ new Set(), nextFrame = /* @__PURE__ */ new Set(), isProcessing = !1, flushNextFrame = !1;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  let latestFrameData = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  };
  function triggerCallback(callback) {
    toKeepAlive.has(callback) && (step.schedule(callback), runNextFrame()), callback(latestFrameData);
  }
  const step = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (callback, keepAlive = !1, immediate = !1) => {
      const queue = immediate && isProcessing ? thisFrame : nextFrame;
      return keepAlive && toKeepAlive.add(callback), queue.has(callback) || queue.add(callback), callback;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (callback) => {
      nextFrame.delete(callback), toKeepAlive.delete(callback);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (frameData2) => {
      if (latestFrameData = frameData2, isProcessing) {
        flushNextFrame = !0;
        return;
      }
      isProcessing = !0, [thisFrame, nextFrame] = [nextFrame, thisFrame], nextFrame.clear(), thisFrame.forEach(triggerCallback), isProcessing = !1, flushNextFrame && (flushNextFrame = !1, step.process(frameData2));
    }
  };
  return step;
}
const stepsOrder = [
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
], maxElapsed = 40;
function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
  let runNextFrame = !1, useDefaultElapsed = !0;
  const state = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, flagRunNextFrame = () => runNextFrame = !0, steps = stepsOrder.reduce((acc, key) => (acc[key] = createRenderStep(flagRunNextFrame), acc), {}), { read: read2, resolveKeyframes, update, preRender, render, postRender } = steps, processBatch = () => {
    const timestamp = performance.now();
    runNextFrame = !1, state.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1), state.timestamp = timestamp, state.isProcessing = !0, read2.process(state), resolveKeyframes.process(state), update.process(state), preRender.process(state), render.process(state), postRender.process(state), state.isProcessing = !1, runNextFrame && allowKeepAlive && (useDefaultElapsed = !1, scheduleNextBatch(processBatch));
  }, wake2 = () => {
    runNextFrame = !0, useDefaultElapsed = !0, state.isProcessing || scheduleNextBatch(processBatch);
  };
  return { schedule: stepsOrder.reduce((acc, key) => {
    const step = steps[key];
    return acc[key] = (process2, keepAlive = !1, immediate = !1) => (runNextFrame || wake2(), step.schedule(process2, keepAlive, immediate)), acc;
  }, {}), cancel: (process2) => {
    for (let i2 = 0; i2 < stepsOrder.length; i2++)
      steps[stepsOrder[i2]].cancel(process2);
  }, state, steps };
}
const { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps } = createRenderBatcher(typeof requestAnimationFrame < "u" ? requestAnimationFrame : noop$2, !0), calcBezier = (t2, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t2 + (3 * a2 - 6 * a1)) * t2 + 3 * a1) * t2, subdivisionPrecision = 1e-7, subdivisionMaxIterations = 12;
function binarySubdivide(x2, lowerBound, upperBound, mX1, mX2) {
  let currentX, currentT, i2 = 0;
  do
    currentT = lowerBound + (upperBound - lowerBound) / 2, currentX = calcBezier(currentT, mX1, mX2) - x2, currentX > 0 ? upperBound = currentT : lowerBound = currentT;
  while (Math.abs(currentX) > subdivisionPrecision && ++i2 < subdivisionMaxIterations);
  return currentT;
}
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return noop$2;
  const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
  return (t2) => t2 === 0 || t2 === 1 ? t2 : calcBezier(getTForX(t2), mY1, mY2);
}
const mirrorEasing = (easing) => (p2) => p2 <= 0.5 ? easing(2 * p2) / 2 : (2 - easing(2 * (1 - p2))) / 2, reverseEasing = (easing) => (p2) => 1 - easing(1 - p2), backOut = /* @__PURE__ */ cubicBezier(0.33, 1.53, 0.69, 0.99), backIn = /* @__PURE__ */ reverseEasing(backOut), backInOut = /* @__PURE__ */ mirrorEasing(backIn), anticipate = (p2) => (p2 *= 2) < 1 ? 0.5 * backIn(p2) : 0.5 * (2 - Math.pow(2, -10 * (p2 - 1))), circIn = (p2) => 1 - Math.sin(Math.acos(p2)), circOut = reverseEasing(circIn), circInOut = mirrorEasing(circIn), isZeroValueString = (v2) => /^0[^.\s]+$/u.test(v2);
function isNone(value) {
  return typeof value == "number" ? value === 0 : value !== null ? value === "none" || value === "0" || isZeroValueString(value) : !0;
}
let invariant = noop$2;
const isNumericalString = (v2) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v2), checkStringStartsWith = (token) => (key) => typeof key == "string" && key.startsWith(token), isCSSVariableName = /* @__PURE__ */ checkStringStartsWith("--"), startsAsVariableToken = /* @__PURE__ */ checkStringStartsWith("var(--"), isCSSVariableToken = (value) => startsAsVariableToken(value) ? singleCssVariableRegex.test(value.split("/*")[0].trim()) : !1, singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, splitCSSVariableRegex = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function parseCSSVariable(current) {
  const match = splitCSSVariableRegex.exec(current);
  if (!match)
    return [,];
  const [, token1, token2, fallback] = match;
  return [`--${token1 ?? token2}`, fallback];
}
function getVariableValue(current, element, depth = 1) {
  const [token, fallback] = parseCSSVariable(current);
  if (!token)
    return;
  const resolved = window.getComputedStyle(element).getPropertyValue(token);
  if (resolved) {
    const trimmed = resolved.trim();
    return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
  }
  return isCSSVariableToken(fallback) ? getVariableValue(fallback, element, depth + 1) : fallback;
}
const clamp = (min2, max2, v2) => v2 > max2 ? max2 : v2 < min2 ? min2 : v2, number = {
  test: (v2) => typeof v2 == "number",
  parse: parseFloat,
  transform: (v2) => v2
}, alpha = {
  ...number,
  transform: (v2) => clamp(0, 1, v2)
}, scale = {
  ...number,
  default: 1
}, createUnitType = (unit) => ({
  test: (v2) => typeof v2 == "string" && v2.endsWith(unit) && v2.split(" ").length === 1,
  parse: parseFloat,
  transform: (v2) => `${v2}${unit}`
}), degrees = /* @__PURE__ */ createUnitType("deg"), percent = /* @__PURE__ */ createUnitType("%"), px = /* @__PURE__ */ createUnitType("px"), vh = /* @__PURE__ */ createUnitType("vh"), vw = /* @__PURE__ */ createUnitType("vw"), progressPercentage = {
  ...percent,
  parse: (v2) => percent.parse(v2) / 100,
  transform: (v2) => percent.transform(v2 * 100)
}, positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y",
  "translateX",
  "translateY"
]), isNumOrPxType = (v2) => v2 === number || v2 === px, getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(", ")[pos]), getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform: transform2 }) => {
  if (transform2 === "none" || !transform2)
    return 0;
  const matrix3d = transform2.match(/^matrix3d\((.+)\)$/u);
  if (matrix3d)
    return getPosFromMatrix(matrix3d[1], pos3);
  {
    const matrix = transform2.match(/^matrix\((.+)\)$/u);
    return matrix ? getPosFromMatrix(matrix[1], pos2) : 0;
  }
}, transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]), nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
function removeNonTranslationalTransform(visualElement) {
  const removedTransforms = [];
  return nonTranslationalTransformKeys.forEach((key) => {
    const value = visualElement.getValue(key);
    value !== void 0 && (removedTransforms.push([key, value.get()]), value.set(key.startsWith("scale") ? 1 : 0));
  }), removedTransforms;
}
const positionalValues = {
  // Dimensions
  width: ({ x: x2 }, { paddingLeft = "0", paddingRight = "0" }) => x2.max - x2.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
  height: ({ y: y2 }, { paddingTop = "0", paddingBottom = "0" }) => y2.max - y2.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
  top: (_bbox, { top }) => parseFloat(top),
  left: (_bbox, { left }) => parseFloat(left),
  bottom: ({ y: y2 }, { top }) => parseFloat(top) + (y2.max - y2.min),
  right: ({ x: x2 }, { left }) => parseFloat(left) + (x2.max - x2.min),
  // Transform
  x: getTranslateFromMatrix(4, 13),
  y: getTranslateFromMatrix(5, 14)
};
positionalValues.translateX = positionalValues.x;
positionalValues.translateY = positionalValues.y;
const testValueType = (v2) => (type) => type.test(v2), auto = {
  test: (v2) => v2 === "auto",
  parse: (v2) => v2
}, dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto], findDimensionValueType = (v2) => dimensionValueTypes.find(testValueType(v2)), toResolve = /* @__PURE__ */ new Set();
let isScheduled = !1, anyNeedsMeasurement = !1;
function measureAllKeyframes() {
  if (anyNeedsMeasurement) {
    const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement), elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element)), transformsToRestore = /* @__PURE__ */ new Map();
    elementsToMeasure.forEach((element) => {
      const removedTransforms = removeNonTranslationalTransform(element);
      removedTransforms.length && (transformsToRestore.set(element, removedTransforms), element.render());
    }), resolversToMeasure.forEach((resolver) => resolver.measureInitialState()), elementsToMeasure.forEach((element) => {
      element.render();
      const restore = transformsToRestore.get(element);
      restore && restore.forEach(([key, value]) => {
        var _a4;
        (_a4 = element.getValue(key)) === null || _a4 === void 0 || _a4.set(value);
      });
    }), resolversToMeasure.forEach((resolver) => resolver.measureEndState()), resolversToMeasure.forEach((resolver) => {
      resolver.suspendedScrollY !== void 0 && window.scrollTo(0, resolver.suspendedScrollY);
    });
  }
  anyNeedsMeasurement = !1, isScheduled = !1, toResolve.forEach((resolver) => resolver.complete()), toResolve.clear();
}
function readAllKeyframes() {
  toResolve.forEach((resolver) => {
    resolver.readKeyframes(), resolver.needsMeasurement && (anyNeedsMeasurement = !0);
  });
}
function flushKeyframeResolvers() {
  readAllKeyframes(), measureAllKeyframes();
}
class KeyframeResolver {
  constructor(unresolvedKeyframes, onComplete, name, motionValue2, element, isAsync = !1) {
    this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...unresolvedKeyframes], this.onComplete = onComplete, this.name = name, this.motionValue = motionValue2, this.element = element, this.isAsync = isAsync;
  }
  scheduleResolve() {
    this.isScheduled = !0, this.isAsync ? (toResolve.add(this), isScheduled || (isScheduled = !0, frame.read(readAllKeyframes), frame.resolveKeyframes(measureAllKeyframes))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes, name, element, motionValue: motionValue2 } = this;
    for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++)
      if (unresolvedKeyframes[i2] === null)
        if (i2 === 0) {
          const currentValue = motionValue2 == null ? void 0 : motionValue2.get(), finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
          if (currentValue !== void 0)
            unresolvedKeyframes[0] = currentValue;
          else if (element && name) {
            const valueAsRead = element.readValue(name, finalKeyframe);
            valueAsRead != null && (unresolvedKeyframes[0] = valueAsRead);
          }
          unresolvedKeyframes[0] === void 0 && (unresolvedKeyframes[0] = finalKeyframe), motionValue2 && currentValue === void 0 && motionValue2.set(unresolvedKeyframes[0]);
        } else
          unresolvedKeyframes[i2] = unresolvedKeyframes[i2 - 1];
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete() {
    this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), toResolve.delete(this);
  }
  cancel() {
    this.isComplete || (this.isScheduled = !1, toResolve.delete(this));
  }
  resume() {
    this.isComplete || this.scheduleResolve();
  }
}
const sanitize = (v2) => Math.round(v2 * 1e5) / 1e5, floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function isNullish(v2) {
  return v2 == null;
}
const singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, isColorString = (type, testProp) => (v2) => !!(typeof v2 == "string" && singleColorRegex.test(v2) && v2.startsWith(type) || testProp && !isNullish(v2) && Object.prototype.hasOwnProperty.call(v2, testProp)), splitColor = (aName, bName, cName) => (v2) => {
  if (typeof v2 != "string")
    return v2;
  const [a2, b2, c, alpha2] = v2.match(floatRegex);
  return {
    [aName]: parseFloat(a2),
    [bName]: parseFloat(b2),
    [cName]: parseFloat(c),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
}, clampRgbUnit = (v2) => clamp(0, 255, v2), rgbUnit = {
  ...number,
  transform: (v2) => Math.round(clampRgbUnit(v2))
}, rgba = {
  test: /* @__PURE__ */ isColorString("rgb", "red"),
  parse: /* @__PURE__ */ splitColor("red", "green", "blue"),
  transform: ({ red, green, blue: blue2, alpha: alpha$12 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue2) + ", " + sanitize(alpha.transform(alpha$12)) + ")"
};
function parseHex(v2) {
  let r2 = "", g2 = "", b2 = "", a2 = "";
  return v2.length > 5 ? (r2 = v2.substring(1, 3), g2 = v2.substring(3, 5), b2 = v2.substring(5, 7), a2 = v2.substring(7, 9)) : (r2 = v2.substring(1, 2), g2 = v2.substring(2, 3), b2 = v2.substring(3, 4), a2 = v2.substring(4, 5), r2 += r2, g2 += g2, b2 += b2, a2 += a2), {
    red: parseInt(r2, 16),
    green: parseInt(g2, 16),
    blue: parseInt(b2, 16),
    alpha: a2 ? parseInt(a2, 16) / 255 : 1
  };
}
const hex = {
  test: /* @__PURE__ */ isColorString("#"),
  parse: parseHex,
  transform: rgba.transform
}, hsla = {
  test: /* @__PURE__ */ isColorString("hsl", "hue"),
  parse: /* @__PURE__ */ splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$12 = 1 }) => "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$12)) + ")"
}, color = {
  test: (v2) => rgba.test(v2) || hex.test(v2) || hsla.test(v2),
  parse: (v2) => rgba.test(v2) ? rgba.parse(v2) : hsla.test(v2) ? hsla.parse(v2) : hex.parse(v2),
  transform: (v2) => typeof v2 == "string" ? v2 : v2.hasOwnProperty("red") ? rgba.transform(v2) : hsla.transform(v2)
}, colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function test(v2) {
  var _a4, _b2;
  return isNaN(v2) && typeof v2 == "string" && (((_a4 = v2.match(floatRegex)) === null || _a4 === void 0 ? void 0 : _a4.length) || 0) + (((_b2 = v2.match(colorRegex)) === null || _b2 === void 0 ? void 0 : _b2.length) || 0) > 0;
}
const NUMBER_TOKEN = "number", COLOR_TOKEN = "color", VAR_TOKEN = "var", VAR_FUNCTION_TOKEN = "var(", SPLIT_TOKEN = "${}", complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function analyseComplexValue(value) {
  const originalValue = value.toString(), values2 = [], indexes = {
    color: [],
    number: [],
    var: []
  }, types = [];
  let i2 = 0;
  const split = originalValue.replace(complexRegex, (parsedValue) => (color.test(parsedValue) ? (indexes.color.push(i2), types.push(COLOR_TOKEN), values2.push(color.parse(parsedValue))) : parsedValue.startsWith(VAR_FUNCTION_TOKEN) ? (indexes.var.push(i2), types.push(VAR_TOKEN), values2.push(parsedValue)) : (indexes.number.push(i2), types.push(NUMBER_TOKEN), values2.push(parseFloat(parsedValue))), ++i2, SPLIT_TOKEN)).split(SPLIT_TOKEN);
  return { values: values2, split, indexes, types };
}
function parseComplexValue(v2) {
  return analyseComplexValue(v2).values;
}
function createTransformer(source) {
  const { split, types } = analyseComplexValue(source), numSections = split.length;
  return (v2) => {
    let output = "";
    for (let i2 = 0; i2 < numSections; i2++)
      if (output += split[i2], v2[i2] !== void 0) {
        const type = types[i2];
        type === NUMBER_TOKEN ? output += sanitize(v2[i2]) : type === COLOR_TOKEN ? output += color.transform(v2[i2]) : output += v2[i2];
      }
    return output;
  };
}
const convertNumbersToZero = (v2) => typeof v2 == "number" ? 0 : v2;
function getAnimatableNone$1(v2) {
  const parsed = parseComplexValue(v2);
  return createTransformer(v2)(parsed.map(convertNumbersToZero));
}
const complex = {
  test,
  parse: parseComplexValue,
  createTransformer,
  getAnimatableNone: getAnimatableNone$1
}, maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v2) {
  const [name, value] = v2.slice(0, -1).split("(");
  if (name === "drop-shadow")
    return v2;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v2;
  const unit = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name) ? 1 : 0;
  return number2 !== value && (defaultValue *= 100), name + "(" + defaultValue + unit + ")";
}
const functionRegex = /\b([a-z-]*)\(.*?\)/gu, filter = {
  ...complex,
  getAnimatableNone: (v2) => {
    const functions = v2.match(functionRegex);
    return functions ? functions.map(applyDefaultFilter).join(" ") : v2;
  }
}, browserNumberValueTypes = {
  // Border props
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  // Positioning props
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  // Spacing props
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  // Misc
  backgroundPositionX: px,
  backgroundPositionY: px
}, transformValueTypes = {
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px
}, int = {
  ...number,
  transform: Math.round
}, numberValueTypes = {
  ...browserNumberValueTypes,
  ...transformValueTypes,
  zIndex: int,
  size: px,
  // SVG
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
}, defaultValueTypes = {
  ...numberValueTypes,
  // Color props
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  // Border props
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter,
  WebkitFilter: filter
}, getDefaultValueType = (key) => defaultValueTypes[key];
function getAnimatableNone(key, value) {
  let defaultValueType = getDefaultValueType(key);
  return defaultValueType !== filter && (defaultValueType = complex), defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
}
const invalidTemplates = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {
  let i2 = 0, animatableTemplate;
  for (; i2 < unresolvedKeyframes.length && !animatableTemplate; ) {
    const keyframe = unresolvedKeyframes[i2];
    typeof keyframe == "string" && !invalidTemplates.has(keyframe) && analyseComplexValue(keyframe).values.length && (animatableTemplate = unresolvedKeyframes[i2]), i2++;
  }
  if (animatableTemplate && name)
    for (const noneIndex of noneKeyframeIndexes)
      unresolvedKeyframes[noneIndex] = getAnimatableNone(name, animatableTemplate);
}
class DOMKeyframesResolver extends KeyframeResolver {
  constructor(unresolvedKeyframes, onComplete, name, motionValue2, element) {
    super(unresolvedKeyframes, onComplete, name, motionValue2, element, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes, element, name } = this;
    if (!element || !element.current)
      return;
    super.readKeyframes();
    for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
      let keyframe = unresolvedKeyframes[i2];
      if (typeof keyframe == "string" && (keyframe = keyframe.trim(), isCSSVariableToken(keyframe))) {
        const resolved = getVariableValue(keyframe, element.current);
        resolved !== void 0 && (unresolvedKeyframes[i2] = resolved), i2 === unresolvedKeyframes.length - 1 && (this.finalKeyframe = keyframe);
      }
    }
    if (this.resolveNoneKeyframes(), !positionalKeys.has(name) || unresolvedKeyframes.length !== 2)
      return;
    const [origin, target] = unresolvedKeyframes, originType = findDimensionValueType(origin), targetType = findDimensionValueType(target);
    if (originType !== targetType)
      if (isNumOrPxType(originType) && isNumOrPxType(targetType))
        for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
          const value = unresolvedKeyframes[i2];
          typeof value == "string" && (unresolvedKeyframes[i2] = parseFloat(value));
        }
      else
        this.needsMeasurement = !0;
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes, name } = this, noneKeyframeIndexes = [];
    for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++)
      isNone(unresolvedKeyframes[i2]) && noneKeyframeIndexes.push(i2);
    noneKeyframeIndexes.length && makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);
  }
  measureInitialState() {
    const { element, unresolvedKeyframes, name } = this;
    if (!element || !element.current)
      return;
    name === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current)), unresolvedKeyframes[0] = this.measuredOrigin;
    const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
    measureKeyframe !== void 0 && element.getValue(name, measureKeyframe).jump(measureKeyframe, !1);
  }
  measureEndState() {
    var _a4;
    const { element, name, unresolvedKeyframes } = this;
    if (!element || !element.current)
      return;
    const value = element.getValue(name);
    value && value.jump(this.measuredOrigin, !1);
    const finalKeyframeIndex = unresolvedKeyframes.length - 1, finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
    unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current)), finalKeyframe !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = finalKeyframe), !((_a4 = this.removedTransforms) === null || _a4 === void 0) && _a4.length && this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {
      element.getValue(unsetTransformName).set(unsetTransformValue);
    }), this.resolveNoneKeyframes();
  }
}
function isGenerator(type) {
  return typeof type == "function";
}
let now;
function clearTime() {
  now = void 0;
}
const time$1 = {
  now: () => (now === void 0 && time$1.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now()), now),
  set: (newTime) => {
    now = newTime, queueMicrotask(clearTime);
  }
}, isAnimatable = (value, name) => name === "zIndex" ? !1 : !!(typeof value == "number" || Array.isArray(value) || typeof value == "string" && // It's animatable if we have a string
(complex.test(value) || value === "0") && // And it contains numbers and/or colors
!value.startsWith("url("));
function hasKeyframesChanged(keyframes2) {
  const current = keyframes2[0];
  if (keyframes2.length === 1)
    return !0;
  for (let i2 = 0; i2 < keyframes2.length; i2++)
    if (keyframes2[i2] !== current)
      return !0;
}
function canAnimate(keyframes2, name, type, velocity) {
  const originKeyframe = keyframes2[0];
  if (originKeyframe === null)
    return !1;
  if (name === "display" || name === "visibility")
    return !0;
  const targetKeyframe = keyframes2[keyframes2.length - 1], isOriginAnimatable = isAnimatable(originKeyframe, name), isTargetAnimatable = isAnimatable(targetKeyframe, name);
  return !isOriginAnimatable || !isTargetAnimatable ? !1 : hasKeyframesChanged(keyframes2) || (type === "spring" || isGenerator(type)) && velocity;
}
const MAX_RESOLVE_DELAY = 40;
class BaseAnimation {
  constructor({ autoplay = !0, delay: delay2 = 0, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", ...options }) {
    this.isStopped = !1, this.hasAttemptedResolve = !1, this.createdAt = time$1.now(), this.options = {
      autoplay,
      delay: delay2,
      type,
      repeat,
      repeatDelay,
      repeatType,
      ...options
    }, this.updateFinishedPromise();
  }
  /**
   * This method uses the createdAt and resolvedAt to calculate the
   * animation startTime. *Ideally*, we would use the createdAt time as t=0
   * as the following frame would then be the first frame of the animation in
   * progress, which would feel snappier.
   *
   * However, if there's a delay (main thread work) between the creation of
   * the animation and the first commited frame, we prefer to use resolvedAt
   * to avoid a sudden jump into the animation.
   */
  calcStartTime() {
    return this.resolvedAt ? this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt : this.createdAt;
  }
  /**
   * A getter for resolved data. If keyframes are not yet resolved, accessing
   * this.resolved will synchronously flush all pending keyframe resolvers.
   * This is a deoptimisation, but at its worst still batches read/writes.
   */
  get resolved() {
    return !this._resolved && !this.hasAttemptedResolve && flushKeyframeResolvers(), this._resolved;
  }
  /**
   * A method to be called when the keyframes resolver completes. This method
   * will check if its possible to run the animation and, if not, skip it.
   * Otherwise, it will call initPlayback on the implementing class.
   */
  onKeyframesResolved(keyframes2, finalKeyframe) {
    this.resolvedAt = time$1.now(), this.hasAttemptedResolve = !0;
    const { name, type, velocity, delay: delay2, onComplete, onUpdate, isGenerator: isGenerator2 } = this.options;
    if (!isGenerator2 && !canAnimate(keyframes2, name, type, velocity))
      if (delay2)
        this.options.duration = 0;
      else {
        onUpdate == null || onUpdate(getFinalKeyframe(keyframes2, this.options, finalKeyframe)), onComplete == null || onComplete(), this.resolveFinishedPromise();
        return;
      }
    const resolvedAnimation = this.initPlayback(keyframes2, finalKeyframe);
    resolvedAnimation !== !1 && (this._resolved = {
      keyframes: keyframes2,
      finalKeyframe,
      ...resolvedAnimation
    }, this.onPostResolved());
  }
  onPostResolved() {
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(resolve, reject) {
    return this.currentFinishedPromise.then(resolve, reject);
  }
  flatten() {
    this.options.type = "keyframes", this.options.ease = "linear";
  }
  updateFinishedPromise() {
    this.currentFinishedPromise = new Promise((resolve) => {
      this.resolveFinishedPromise = resolve;
    });
  }
}
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}
const velocitySampleDuration = 5;
function calcGeneratorVelocity(resolveValue, t2, current) {
  const prevT = Math.max(t2 - velocitySampleDuration, 0);
  return velocityPerSecond(current - resolveValue(prevT), t2 - prevT);
}
const safeMin = 1e-3, minDuration = 0.01, maxDuration$1 = 10, minDamping = 0.05, maxDamping = 1;
function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1 }) {
  let envelope, derivative, dampingRatio = 1 - bounce;
  dampingRatio = clamp(minDamping, maxDamping, dampingRatio), duration = clamp(minDuration, maxDuration$1, millisecondsToSeconds(duration)), dampingRatio < 1 ? (envelope = (undampedFreq2) => {
    const exponentialDecay = undampedFreq2 * dampingRatio, delta = exponentialDecay * duration, a2 = exponentialDecay - velocity, b2 = calcAngularFreq(undampedFreq2, dampingRatio), c = Math.exp(-delta);
    return safeMin - a2 / b2 * c;
  }, derivative = (undampedFreq2) => {
    const delta = undampedFreq2 * dampingRatio * duration, d2 = delta * velocity + velocity, e2 = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration, f2 = Math.exp(-delta), g2 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
    return (-envelope(undampedFreq2) + safeMin > 0 ? -1 : 1) * ((d2 - e2) * f2) / g2;
  }) : (envelope = (undampedFreq2) => {
    const a2 = Math.exp(-undampedFreq2 * duration), b2 = (undampedFreq2 - velocity) * duration + 1;
    return -safeMin + a2 * b2;
  }, derivative = (undampedFreq2) => {
    const a2 = Math.exp(-undampedFreq2 * duration), b2 = (velocity - undampedFreq2) * (duration * duration);
    return a2 * b2;
  });
  const initialGuess = 5 / duration, undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  if (duration = secondsToMilliseconds(duration), isNaN(undampedFreq))
    return {
      stiffness: 100,
      damping: 10,
      duration
    };
  {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
const rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i2 = 1; i2 < rootIterations; i2++)
    result = result - envelope(result) / derivative(result);
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}
const durationKeys = ["duration", "bounce"], physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys2) {
  return keys2.some((key) => options[key] !== void 0);
}
function getSpringOptions(options) {
  let springOptions = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: !1,
    ...options
  };
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    const derived = findSpring(options);
    springOptions = {
      ...springOptions,
      ...derived,
      mass: 1
    }, springOptions.isResolvedFromDuration = !0;
  }
  return springOptions;
}
function spring({ keyframes: keyframes2, restDelta, restSpeed, ...options }) {
  const origin = keyframes2[0], target = keyframes2[keyframes2.length - 1], state = { done: !1, value: origin }, { stiffness, damping, mass, duration, velocity, isResolvedFromDuration } = getSpringOptions({
    ...options,
    velocity: -millisecondsToSeconds(options.velocity || 0)
  }), initialVelocity = velocity || 0, dampingRatio = damping / (2 * Math.sqrt(stiffness * mass)), initialDelta = target - origin, undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass)), isGranularScale = Math.abs(initialDelta) < 5;
  restSpeed || (restSpeed = isGranularScale ? 0.01 : 2), restDelta || (restDelta = isGranularScale ? 5e-3 : 0.5);
  let resolveSpring;
  if (dampingRatio < 1) {
    const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
    resolveSpring = (t2) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t2) + initialDelta * Math.cos(angularFreq * t2));
    };
  } else if (dampingRatio === 1)
    resolveSpring = (t2) => target - Math.exp(-undampedAngularFreq * t2) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t2);
  else {
    const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
    resolveSpring = (t2) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2), freqForT = Math.min(dampedAngularFreq * t2, 300);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
    };
  }
  return {
    calculatedDuration: isResolvedFromDuration && duration || null,
    next: (t2) => {
      const current = resolveSpring(t2);
      if (isResolvedFromDuration)
        state.done = t2 >= duration;
      else {
        let currentVelocity = 0;
        dampingRatio < 1 && (currentVelocity = t2 === 0 ? secondsToMilliseconds(initialVelocity) : calcGeneratorVelocity(resolveSpring, t2, current));
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed, isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      }
      return state.value = state.done ? target : current, state;
    }
  };
}
function inertia({ keyframes: keyframes2, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min: min2, max: max2, restDelta = 0.5, restSpeed }) {
  const origin = keyframes2[0], state = {
    done: !1,
    value: origin
  }, isOutOfBounds = (v2) => min2 !== void 0 && v2 < min2 || max2 !== void 0 && v2 > max2, nearestBoundary = (v2) => min2 === void 0 ? max2 : max2 === void 0 || Math.abs(min2 - v2) < Math.abs(max2 - v2) ? min2 : max2;
  let amplitude = power * velocity;
  const ideal = origin + amplitude, target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  target !== ideal && (amplitude = target - origin);
  const calcDelta = (t2) => -amplitude * Math.exp(-t2 / timeConstant), calcLatest = (t2) => target + calcDelta(t2), applyFriction = (t2) => {
    const delta = calcDelta(t2), latest = calcLatest(t2);
    state.done = Math.abs(delta) <= restDelta, state.value = state.done ? target : latest;
  };
  let timeReachedBoundary, spring$1;
  const checkCatchBoundary = (t2) => {
    isOutOfBounds(state.value) && (timeReachedBoundary = t2, spring$1 = spring({
      keyframes: [state.value, nearestBoundary(state.value)],
      velocity: calcGeneratorVelocity(calcLatest, t2, state.value),
      // TODO: This should be passing * 1000
      damping: bounceDamping,
      stiffness: bounceStiffness,
      restDelta,
      restSpeed
    }));
  };
  return checkCatchBoundary(0), {
    calculatedDuration: null,
    next: (t2) => {
      let hasUpdatedFrame = !1;
      return !spring$1 && timeReachedBoundary === void 0 && (hasUpdatedFrame = !0, applyFriction(t2), checkCatchBoundary(t2)), timeReachedBoundary !== void 0 && t2 >= timeReachedBoundary ? spring$1.next(t2 - timeReachedBoundary) : (!hasUpdatedFrame && applyFriction(t2), state);
    }
  };
}
const easeIn = /* @__PURE__ */ cubicBezier(0.42, 0, 1, 1), easeOut = /* @__PURE__ */ cubicBezier(0, 0, 0.58, 1), easeInOut = /* @__PURE__ */ cubicBezier(0.42, 0, 0.58, 1), isEasingArray = (ease2) => Array.isArray(ease2) && typeof ease2[0] != "number", isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] == "number", easingLookup = {
  linear: noop$2,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate
}, easingDefinitionToFunction = (definition) => {
  if (isBezierDefinition(definition)) {
    invariant(definition.length === 4);
    const [x1, y1, x2, y2] = definition;
    return cubicBezier(x1, y1, x2, y2);
  } else if (typeof definition == "string")
    return invariant(easingLookup[definition] !== void 0), easingLookup[definition];
  return definition;
}, combineFunctions = (a2, b2) => (v2) => b2(a2(v2)), pipe = (...transformers) => transformers.reduce(combineFunctions), progress = (from, to, value) => {
  const toFromDifference = to - from;
  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
}, mixNumber$1 = (from, to, progress2) => from + (to - from) * progress2;
function hueToRgb(p2, q2, t2) {
  return t2 < 0 && (t2 += 1), t2 > 1 && (t2 -= 1), t2 < 1 / 6 ? p2 + (q2 - p2) * 6 * t2 : t2 < 1 / 2 ? q2 : t2 < 2 / 3 ? p2 + (q2 - p2) * (2 / 3 - t2) * 6 : p2;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360, saturation /= 100, lightness /= 100;
  let red = 0, green = 0, blue2 = 0;
  if (!saturation)
    red = green = blue2 = lightness;
  else {
    const q2 = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation, p2 = 2 * lightness - q2;
    red = hueToRgb(p2, q2, hue + 1 / 3), green = hueToRgb(p2, q2, hue), blue2 = hueToRgb(p2, q2, hue - 1 / 3);
  }
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue2 * 255),
    alpha: alpha2
  };
}
function mixImmediate(a2, b2) {
  return (p2) => p2 > 0 ? b2 : a2;
}
const mixLinearColor = (from, to, v2) => {
  const fromExpo = from * from, expo = v2 * (to * to - fromExpo) + fromExpo;
  return expo < 0 ? 0 : Math.sqrt(expo);
}, colorTypes = [hex, rgba, hsla], getColorType = (v2) => colorTypes.find((type) => type.test(v2));
function asRGBA(color2) {
  const type = getColorType(color2);
  if (!type)
    return !1;
  let model = type.parse(color2);
  return type === hsla && (model = hslaToRgba(model)), model;
}
const mixColor = (from, to) => {
  const fromRGBA = asRGBA(from), toRGBA = asRGBA(to);
  if (!fromRGBA || !toRGBA)
    return mixImmediate(from, to);
  const blended = { ...fromRGBA };
  return (v2) => (blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v2), blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v2), blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v2), blended.alpha = mixNumber$1(fromRGBA.alpha, toRGBA.alpha, v2), rgba.transform(blended));
}, invisibleValues = /* @__PURE__ */ new Set(["none", "hidden"]);
function mixVisibility(origin, target) {
  return invisibleValues.has(origin) ? (p2) => p2 <= 0 ? origin : target : (p2) => p2 >= 1 ? target : origin;
}
function mixNumber(a2, b2) {
  return (p2) => mixNumber$1(a2, b2, p2);
}
function getMixer(a2) {
  return typeof a2 == "number" ? mixNumber : typeof a2 == "string" ? isCSSVariableToken(a2) ? mixImmediate : color.test(a2) ? mixColor : mixComplex : Array.isArray(a2) ? mixArray : typeof a2 == "object" ? color.test(a2) ? mixColor : mixObject : mixImmediate;
}
function mixArray(a2, b2) {
  const output = [...a2], numValues = output.length, blendValue = a2.map((v2, i2) => getMixer(v2)(v2, b2[i2]));
  return (p2) => {
    for (let i2 = 0; i2 < numValues; i2++)
      output[i2] = blendValue[i2](p2);
    return output;
  };
}
function mixObject(a2, b2) {
  const output = { ...a2, ...b2 }, blendValue = {};
  for (const key in output)
    a2[key] !== void 0 && b2[key] !== void 0 && (blendValue[key] = getMixer(a2[key])(a2[key], b2[key]));
  return (v2) => {
    for (const key in blendValue)
      output[key] = blendValue[key](v2);
    return output;
  };
}
function matchOrder(origin, target) {
  var _a4;
  const orderedOrigin = [], pointers = { color: 0, var: 0, number: 0 };
  for (let i2 = 0; i2 < target.values.length; i2++) {
    const type = target.types[i2], originIndex = origin.indexes[type][pointers[type]], originValue = (_a4 = origin.values[originIndex]) !== null && _a4 !== void 0 ? _a4 : 0;
    orderedOrigin[i2] = originValue, pointers[type]++;
  }
  return orderedOrigin;
}
const mixComplex = (origin, target) => {
  const template = complex.createTransformer(target), originStats = analyseComplexValue(origin), targetStats = analyseComplexValue(target);
  return originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length ? invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length ? mixVisibility(origin, target) : pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template) : mixImmediate(origin, target);
};
function mix(from, to, p2) {
  return typeof from == "number" && typeof to == "number" && typeof p2 == "number" ? mixNumber$1(from, to, p2) : getMixer(from)(from, to);
}
function createMixers(output, ease2, customMixer) {
  const mixers = [], mixerFactory = customMixer || mix, numMixers = output.length - 1;
  for (let i2 = 0; i2 < numMixers; i2++) {
    let mixer = mixerFactory(output[i2], output[i2 + 1]);
    if (ease2) {
      const easingFunction = Array.isArray(ease2) ? ease2[i2] || noop$2 : ease2;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function interpolate(input, output, { clamp: isClamp = !0, ease: ease2, mixer } = {}) {
  const inputLength = input.length;
  if (invariant(inputLength === output.length), inputLength === 1)
    return () => output[0];
  if (inputLength === 2 && input[0] === input[1])
    return () => output[1];
  input[0] > input[inputLength - 1] && (input = [...input].reverse(), output = [...output].reverse());
  const mixers = createMixers(output, ease2, mixer), numMixers = mixers.length, interpolator = (v2) => {
    let i2 = 0;
    if (numMixers > 1)
      for (; i2 < input.length - 2 && !(v2 < input[i2 + 1]); i2++)
        ;
    const progressInRange = progress(input[i2], input[i2 + 1], v2);
    return mixers[i2](progressInRange);
  };
  return isClamp ? (v2) => interpolator(clamp(input[0], input[inputLength - 1], v2)) : interpolator;
}
function fillOffset(offset2, remaining) {
  const min2 = offset2[offset2.length - 1];
  for (let i2 = 1; i2 <= remaining; i2++) {
    const offsetProgress = progress(0, remaining, i2);
    offset2.push(mixNumber$1(min2, 1, offsetProgress));
  }
}
function defaultOffset(arr) {
  const offset2 = [0];
  return fillOffset(offset2, arr.length - 1), offset2;
}
function convertOffsetToTimes(offset2, duration) {
  return offset2.map((o2) => o2 * duration);
}
function defaultEasing(values2, easing) {
  return values2.map(() => easing || easeInOut).splice(0, values2.length - 1);
}
function keyframes({ duration = 300, keyframes: keyframeValues, times, ease: ease2 = "easeInOut" }) {
  const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2), state = {
    done: !1,
    value: keyframeValues[0]
  }, absoluteTimes = convertOffsetToTimes(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
    duration
  ), mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
    ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
  });
  return {
    calculatedDuration: duration,
    next: (t2) => (state.value = mapTimeToKeyframe(t2), state.done = t2 >= duration, state)
  };
}
const maxGeneratorDuration = 2e4;
function calcGeneratorDuration(generator) {
  let duration = 0;
  const timeStep = 50;
  let state = generator.next(duration);
  for (; !state.done && duration < maxGeneratorDuration; )
    duration += timeStep, state = generator.next(duration);
  return duration >= maxGeneratorDuration ? 1 / 0 : duration;
}
const frameloopDriver = (update) => {
  const passTimestamp = ({ timestamp }) => update(timestamp);
  return {
    start: () => frame.update(passTimestamp, !0),
    stop: () => cancelFrame(passTimestamp),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => frameData.isProcessing ? frameData.timestamp : time$1.now()
  };
}, generators = {
  decay: inertia,
  inertia,
  tween: keyframes,
  keyframes,
  spring
}, percentToProgress = (percent2) => percent2 / 100;
class MainThreadAnimation extends BaseAnimation {
  constructor(options) {
    super(options), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => {
      if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
        return;
      this.teardown();
      const { onStop } = this.options;
      onStop && onStop();
    };
    const { name, motionValue: motionValue2, element, keyframes: keyframes2 } = this.options, KeyframeResolver$1 = (element == null ? void 0 : element.KeyframeResolver) || KeyframeResolver, onResolved = (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);
    this.resolver = new KeyframeResolver$1(keyframes2, onResolved, name, motionValue2, element), this.resolver.scheduleResolve();
  }
  flatten() {
    super.flatten(), this._resolved && Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));
  }
  initPlayback(keyframes$1) {
    const { type = "keyframes", repeat = 0, repeatDelay = 0, repeatType, velocity = 0 } = this.options, generatorFactory = isGenerator(type) ? type : generators[type] || keyframes;
    let mapPercentToKeyframes, mirroredGenerator;
    generatorFactory !== keyframes && typeof keyframes$1[0] != "number" && (mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1])), keyframes$1 = [0, 100]);
    const generator = generatorFactory({ ...this.options, keyframes: keyframes$1 });
    repeatType === "mirror" && (mirroredGenerator = generatorFactory({
      ...this.options,
      keyframes: [...keyframes$1].reverse(),
      velocity: -velocity
    })), generator.calculatedDuration === null && (generator.calculatedDuration = calcGeneratorDuration(generator));
    const { calculatedDuration } = generator, resolvedDuration = calculatedDuration + repeatDelay, totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;
    return {
      generator,
      mirroredGenerator,
      mapPercentToKeyframes,
      calculatedDuration,
      resolvedDuration,
      totalDuration
    };
  }
  onPostResolved() {
    const { autoplay = !0 } = this.options;
    this.play(), this.pendingPlayState === "paused" || !autoplay ? this.pause() : this.state = this.pendingPlayState;
  }
  tick(timestamp, sample = !1) {
    const { resolved } = this;
    if (!resolved) {
      const { keyframes: keyframes3 } = this.options;
      return { done: !0, value: keyframes3[keyframes3.length - 1] };
    }
    const { finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes: keyframes2, calculatedDuration, totalDuration, resolvedDuration } = resolved;
    if (this.startTime === null)
      return generator.next(0);
    const { delay: delay2, repeat, repeatType, repeatDelay, onUpdate } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, timestamp) : this.speed < 0 && (this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime)), sample ? this.currentTime = timestamp : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(timestamp - this.startTime) * this.speed;
    const timeWithoutDelay = this.currentTime - delay2 * (this.speed >= 0 ? 1 : -1), isInDelayPhase = this.speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
    this.currentTime = Math.max(timeWithoutDelay, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = totalDuration);
    let elapsed = this.currentTime, frameGenerator = generator;
    if (repeat) {
      const progress2 = Math.min(this.currentTime, totalDuration) / resolvedDuration;
      let currentIteration = Math.floor(progress2), iterationProgress = progress2 % 1;
      !iterationProgress && progress2 >= 1 && (iterationProgress = 1), iterationProgress === 1 && currentIteration--, currentIteration = Math.min(currentIteration, repeat + 1), !!(currentIteration % 2) && (repeatType === "reverse" ? (iterationProgress = 1 - iterationProgress, repeatDelay && (iterationProgress -= repeatDelay / resolvedDuration)) : repeatType === "mirror" && (frameGenerator = mirroredGenerator)), elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;
    }
    const state = isInDelayPhase ? { done: !1, value: keyframes2[0] } : frameGenerator.next(elapsed);
    mapPercentToKeyframes && (state.value = mapPercentToKeyframes(state.value));
    let { done } = state;
    !isInDelayPhase && calculatedDuration !== null && (done = this.speed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0);
    const isAnimationFinished = this.holdTime === null && (this.state === "finished" || this.state === "running" && done);
    return isAnimationFinished && finalKeyframe !== void 0 && (state.value = getFinalKeyframe(keyframes2, this.options, finalKeyframe)), onUpdate && onUpdate(state.value), isAnimationFinished && this.finish(), state;
  }
  get duration() {
    const { resolved } = this;
    return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;
  }
  get time() {
    return millisecondsToSeconds(this.currentTime);
  }
  set time(newTime) {
    newTime = secondsToMilliseconds(newTime), this.currentTime = newTime, this.holdTime !== null || this.speed === 0 ? this.holdTime = newTime : this.driver && (this.startTime = this.driver.now() - newTime / this.speed);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(newSpeed) {
    const hasChanged = this.playbackSpeed !== newSpeed;
    this.playbackSpeed = newSpeed, hasChanged && (this.time = millisecondsToSeconds(this.currentTime));
  }
  play() {
    if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) {
      this.pendingPlayState = "running";
      return;
    }
    if (this.isStopped)
      return;
    const { driver = frameloopDriver, onPlay, startTime } = this.options;
    this.driver || (this.driver = driver((timestamp) => this.tick(timestamp))), onPlay && onPlay();
    const now2 = this.driver.now();
    this.holdTime !== null ? this.startTime = now2 - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = now2) : this.startTime = startTime ?? this.calcStartTime(), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    var _a4;
    if (!this._resolved) {
      this.pendingPlayState = "paused";
      return;
    }
    this.state = "paused", this.holdTime = (_a4 = this.currentTime) !== null && _a4 !== void 0 ? _a4 : 0;
  }
  complete() {
    this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null;
  }
  finish() {
    this.teardown(), this.state = "finished";
    const { onComplete } = this.options;
    onComplete && onComplete();
  }
  cancel() {
    this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise();
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel();
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(time2) {
    return this.startTime = 0, this.tick(time2, !0);
  }
}
const acceleratedValues = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved
  // or until we implement support for linear() easing.
  // "background-color"
]), resolution = 10, generateLinearEasing = (easing, duration) => {
  let points = "";
  const numPoints = Math.max(Math.round(duration / resolution), 2);
  for (let i2 = 0; i2 < numPoints; i2++)
    points += easing(progress(0, numPoints - 1, i2)) + ", ";
  return `linear(${points.substring(0, points.length - 2)})`;
};
function memo(callback) {
  let result;
  return () => (result === void 0 && (result = callback()), result);
}
const supportsFlags = {
  linearEasing: void 0
};
function memoSupports(callback, supportsFlag) {
  const memoized = memo(callback);
  return () => {
    var _a4;
    return (_a4 = supportsFlags[supportsFlag]) !== null && _a4 !== void 0 ? _a4 : memoized();
  };
}
const supportsLinearEasing = /* @__PURE__ */ memoSupports(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch {
    return !1;
  }
  return !0;
}, "linearEasing");
function isWaapiSupportedEasing(easing) {
  return !!(typeof easing == "function" && supportsLinearEasing() || !easing || typeof easing == "string" && (easing in supportedWaapiEasing || supportsLinearEasing()) || isBezierDefinition(easing) || Array.isArray(easing) && easing.every(isWaapiSupportedEasing));
}
const cubicBezierAsString = ([a2, b2, c, d2]) => `cubic-bezier(${a2}, ${b2}, ${c}, ${d2})`, supportedWaapiEasing = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ cubicBezierAsString([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ cubicBezierAsString([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
};
function mapEasingToNativeEasing(easing, duration) {
  if (easing)
    return typeof easing == "function" && supportsLinearEasing() ? generateLinearEasing(easing, duration) : isBezierDefinition(easing) ? cubicBezierAsString(easing) : Array.isArray(easing) ? easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration) || supportedWaapiEasing.easeOut) : supportedWaapiEasing[easing];
}
function startWaapiAnimation(element, valueName, keyframes2, { delay: delay2 = 0, duration = 300, repeat = 0, repeatType = "loop", ease: ease2 = "easeInOut", times } = {}) {
  const keyframeOptions = { [valueName]: keyframes2 };
  times && (keyframeOptions.offset = times);
  const easing = mapEasingToNativeEasing(ease2, duration);
  return Array.isArray(easing) && (keyframeOptions.easing = easing), element.animate(keyframeOptions, {
    delay: delay2,
    duration,
    easing: Array.isArray(easing) ? "linear" : easing,
    fill: "both",
    iterations: repeat + 1,
    direction: repeatType === "reverse" ? "alternate" : "normal"
  });
}
function attachTimeline(animation, timeline) {
  animation.timeline = timeline, animation.onfinish = null;
}
const supportsWaapi = /* @__PURE__ */ memo(() => Object.hasOwnProperty.call(Element.prototype, "animate")), sampleDelta = 10, maxDuration = 2e4;
function requiresPregeneratedKeyframes(options) {
  return isGenerator(options.type) || options.type === "spring" || !isWaapiSupportedEasing(options.ease);
}
function pregenerateKeyframes(keyframes2, options) {
  const sampleAnimation = new MainThreadAnimation({
    ...options,
    keyframes: keyframes2,
    repeat: 0,
    delay: 0,
    isGenerator: !0
  });
  let state = { done: !1, value: keyframes2[0] };
  const pregeneratedKeyframes = [];
  let t2 = 0;
  for (; !state.done && t2 < maxDuration; )
    state = sampleAnimation.sample(t2), pregeneratedKeyframes.push(state.value), t2 += sampleDelta;
  return {
    times: void 0,
    keyframes: pregeneratedKeyframes,
    duration: t2 - sampleDelta,
    ease: "linear"
  };
}
const unsupportedEasingFunctions = {
  anticipate,
  backInOut,
  circInOut
};
function isUnsupportedEase(key) {
  return key in unsupportedEasingFunctions;
}
class AcceleratedAnimation extends BaseAnimation {
  constructor(options) {
    super(options);
    const { name, motionValue: motionValue2, element, keyframes: keyframes2 } = this.options;
    this.resolver = new DOMKeyframesResolver(keyframes2, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue2, element), this.resolver.scheduleResolve();
  }
  initPlayback(keyframes2, finalKeyframe) {
    var _a4;
    let { duration = 300, times, ease: ease2, type, motionValue: motionValue2, name, startTime } = this.options;
    if (!(!((_a4 = motionValue2.owner) === null || _a4 === void 0) && _a4.current))
      return !1;
    if (typeof ease2 == "string" && supportsLinearEasing() && isUnsupportedEase(ease2) && (ease2 = unsupportedEasingFunctions[ease2]), requiresPregeneratedKeyframes(this.options)) {
      const { onComplete, onUpdate, motionValue: motionValue3, element, ...options } = this.options, pregeneratedAnimation = pregenerateKeyframes(keyframes2, options);
      keyframes2 = pregeneratedAnimation.keyframes, keyframes2.length === 1 && (keyframes2[1] = keyframes2[0]), duration = pregeneratedAnimation.duration, times = pregeneratedAnimation.times, ease2 = pregeneratedAnimation.ease, type = "keyframes";
    }
    const animation = startWaapiAnimation(motionValue2.owner.current, name, keyframes2, { ...this.options, duration, times, ease: ease2 });
    return animation.startTime = startTime ?? this.calcStartTime(), this.pendingTimeline ? (attachTimeline(animation, this.pendingTimeline), this.pendingTimeline = void 0) : animation.onfinish = () => {
      const { onComplete } = this.options;
      motionValue2.set(getFinalKeyframe(keyframes2, this.options, finalKeyframe)), onComplete && onComplete(), this.cancel(), this.resolveFinishedPromise();
    }, {
      animation,
      duration,
      times,
      type,
      ease: ease2,
      keyframes: keyframes2
    };
  }
  get duration() {
    const { resolved } = this;
    if (!resolved)
      return 0;
    const { duration } = resolved;
    return millisecondsToSeconds(duration);
  }
  get time() {
    const { resolved } = this;
    if (!resolved)
      return 0;
    const { animation } = resolved;
    return millisecondsToSeconds(animation.currentTime || 0);
  }
  set time(newTime) {
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation } = resolved;
    animation.currentTime = secondsToMilliseconds(newTime);
  }
  get speed() {
    const { resolved } = this;
    if (!resolved)
      return 1;
    const { animation } = resolved;
    return animation.playbackRate;
  }
  set speed(newSpeed) {
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation } = resolved;
    animation.playbackRate = newSpeed;
  }
  get state() {
    const { resolved } = this;
    if (!resolved)
      return "idle";
    const { animation } = resolved;
    return animation.playState;
  }
  get startTime() {
    const { resolved } = this;
    if (!resolved)
      return null;
    const { animation } = resolved;
    return animation.startTime;
  }
  /**
   * Replace the default DocumentTimeline with another AnimationTimeline.
   * Currently used for scroll animations.
   */
  attachTimeline(timeline) {
    if (!this._resolved)
      this.pendingTimeline = timeline;
    else {
      const { resolved } = this;
      if (!resolved)
        return noop$2;
      const { animation } = resolved;
      attachTimeline(animation, timeline);
    }
    return noop$2;
  }
  play() {
    if (this.isStopped)
      return;
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation } = resolved;
    animation.playState === "finished" && this.updateFinishedPromise(), animation.play();
  }
  pause() {
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation } = resolved;
    animation.pause();
  }
  stop() {
    if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
      return;
    this.resolveFinishedPromise(), this.updateFinishedPromise();
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation, keyframes: keyframes2, duration, type, ease: ease2, times } = resolved;
    if (animation.playState === "idle" || animation.playState === "finished")
      return;
    if (this.time) {
      const { motionValue: motionValue2, onUpdate, onComplete, element, ...options } = this.options, sampleAnimation = new MainThreadAnimation({
        ...options,
        keyframes: keyframes2,
        duration,
        type,
        ease: ease2,
        times,
        isGenerator: !0
      }), sampleTime = secondsToMilliseconds(this.time);
      motionValue2.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);
    }
    const { onStop } = this.options;
    onStop && onStop(), this.cancel();
  }
  complete() {
    const { resolved } = this;
    resolved && resolved.animation.finish();
  }
  cancel() {
    const { resolved } = this;
    resolved && resolved.animation.cancel();
  }
  static supports(options) {
    const { motionValue: motionValue2, name, repeatDelay, repeatType, damping, type } = options;
    return supportsWaapi() && name && acceleratedValues.has(name) && motionValue2 && motionValue2.owner && motionValue2.owner.current instanceof HTMLElement && /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !motionValue2.owner.getProps().onUpdate && !repeatDelay && repeatType !== "mirror" && damping !== 0 && type !== "inertia";
  }
}
const supportsScrollTimeline = memo(() => window.ScrollTimeline !== void 0);
class GroupPlaybackControls {
  constructor(animations2) {
    this.stop = () => this.runAll("stop"), this.animations = animations2.filter(Boolean);
  }
  then(onResolve, onReject) {
    return Promise.all(this.animations).then(onResolve).catch(onReject);
  }
  /**
   * TODO: Filter out cancelled or stopped animations before returning
   */
  getAll(propName) {
    return this.animations[0][propName];
  }
  setAll(propName, newValue) {
    for (let i2 = 0; i2 < this.animations.length; i2++)
      this.animations[i2][propName] = newValue;
  }
  attachTimeline(timeline, fallback) {
    const subscriptions = this.animations.map((animation) => supportsScrollTimeline() && animation.attachTimeline ? animation.attachTimeline(timeline) : fallback(animation));
    return () => {
      subscriptions.forEach((cancel, i2) => {
        cancel && cancel(), this.animations[i2].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(time2) {
    this.setAll("time", time2);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(speed) {
    this.setAll("speed", speed);
  }
  get startTime() {
    return this.getAll("startTime");
  }
  get duration() {
    let max2 = 0;
    for (let i2 = 0; i2 < this.animations.length; i2++)
      max2 = Math.max(max2, this.animations[i2].duration);
    return max2;
  }
  runAll(methodName) {
    this.animations.forEach((controls) => controls[methodName]());
  }
  flatten() {
    this.runAll("flatten");
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
}
function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {
  return !!Object.keys(transition).length;
}
const animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {
  const valueTransition = getValueTransition$1(transition, name) || {}, delay2 = valueTransition.delay || transition.delay || 0;
  let { elapsed = 0 } = transition;
  elapsed = elapsed - secondsToMilliseconds(delay2);
  let options = {
    keyframes: Array.isArray(target) ? target : [null, target],
    ease: "easeOut",
    velocity: value.getVelocity(),
    ...valueTransition,
    delay: -elapsed,
    onUpdate: (v2) => {
      value.set(v2), valueTransition.onUpdate && valueTransition.onUpdate(v2);
    },
    onComplete: () => {
      onComplete(), valueTransition.onComplete && valueTransition.onComplete();
    },
    name,
    motionValue: value,
    element: isHandoff ? void 0 : element
  };
  isTransitionDefined(valueTransition) || (options = {
    ...options,
    ...getDefaultTransition(name, options)
  }), options.duration && (options.duration = secondsToMilliseconds(options.duration)), options.repeatDelay && (options.repeatDelay = secondsToMilliseconds(options.repeatDelay)), options.from !== void 0 && (options.keyframes[0] = options.from);
  let shouldSkip = !1;
  if ((options.type === !1 || options.duration === 0 && !options.repeatDelay) && (options.duration = 0, options.delay === 0 && (shouldSkip = !0)), shouldSkip && !isHandoff && value.get() !== void 0) {
    const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);
    if (finalKeyframe !== void 0)
      return frame.update(() => {
        options.onUpdate(finalKeyframe), options.onComplete();
      }), new GroupPlaybackControls([]);
  }
  return !isHandoff && AcceleratedAnimation.supports(options) ? new AcceleratedAnimation(options) : new MainThreadAnimation(options);
}, isCustomValue = (v2) => !!(v2 && typeof v2 == "object" && v2.mix && v2.toValue), resolveFinalValueInKeyframes = (v2) => isKeyframesTarget(v2) ? v2[v2.length - 1] || 0 : v2;
function addUniqueItem(arr, item) {
  arr.indexOf(item) === -1 && arr.push(item);
}
function removeItem(arr, item) {
  const index2 = arr.indexOf(item);
  index2 > -1 && arr.splice(index2, 1);
}
class SubscriptionManager {
  constructor() {
    this.subscriptions = [];
  }
  add(handler) {
    return addUniqueItem(this.subscriptions, handler), () => removeItem(this.subscriptions, handler);
  }
  notify(a2, b2, c) {
    const numSubscriptions = this.subscriptions.length;
    if (numSubscriptions)
      if (numSubscriptions === 1)
        this.subscriptions[0](a2, b2, c);
      else
        for (let i2 = 0; i2 < numSubscriptions; i2++) {
          const handler = this.subscriptions[i2];
          handler && handler(a2, b2, c);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const MAX_VELOCITY_DELTA = 30, isFloat = (value) => !isNaN(parseFloat(value));
class MotionValue {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(init2, options = {}) {
    this.version = "11.11.17", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (v2, render = !0) => {
      const currentTime = time$1.now();
      this.updatedAt !== currentTime && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(v2), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), render && this.events.renderRequest && this.events.renderRequest.notify(this.current);
    }, this.hasAnimated = !1, this.setCurrent(init2), this.owner = options.owner;
  }
  setCurrent(current) {
    this.current = current, this.updatedAt = time$1.now(), this.canTrackVelocity === null && current !== void 0 && (this.canTrackVelocity = isFloat(this.current));
  }
  setPrevFrameValue(prevFrameValue = this.current) {
    this.prevFrameValue = prevFrameValue, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(subscription) {
    return this.on("change", subscription);
  }
  on(eventName, callback) {
    this.events[eventName] || (this.events[eventName] = new SubscriptionManager());
    const unsubscribe = this.events[eventName].add(callback);
    return eventName === "change" ? () => {
      unsubscribe(), frame.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : unsubscribe;
  }
  clearListeners() {
    for (const eventManagers in this.events)
      this.events[eventManagers].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(passiveEffect, stopPassiveEffect) {
    this.passiveEffect = passiveEffect, this.stopPassiveEffect = stopPassiveEffect;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(v2, render = !0) {
    !render || !this.passiveEffect ? this.updateAndNotify(v2, render) : this.passiveEffect(v2, this.updateAndNotify);
  }
  setWithVelocity(prev, current, delta) {
    this.set(current), this.prev = void 0, this.prevFrameValue = prev, this.prevUpdatedAt = this.updatedAt - delta;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(v2, endAnimation = !0) {
    this.updateAndNotify(v2), this.prev = v2, this.prevUpdatedAt = this.prevFrameValue = void 0, endAnimation && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const currentTime = time$1.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA)
      return 0;
    const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
    return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(startAnimation) {
    return this.stop(), new Promise((resolve) => {
      this.hasAnimated = !0, this.animation = startAnimation(resolve), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function motionValue(init2, options) {
  return new MotionValue(init2, options);
}
function setMotionValue(visualElement, key, value) {
  visualElement.hasValue(key) ? visualElement.getValue(key).set(value) : visualElement.addValue(key, motionValue(value));
}
function setTarget(visualElement, definition) {
  const resolved = resolveVariant(visualElement, definition);
  let { transitionEnd = {}, transition = {}, ...target } = resolved || {};
  target = { ...target, ...transitionEnd };
  for (const key in target) {
    const value = resolveFinalValueInKeyframes(target[key]);
    setMotionValue(visualElement, key, value);
  }
}
const camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), optimizedAppearDataId = "framerAppearId", optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
function getOptimisedAppearId(visualElement) {
  return visualElement.props[optimizedAppearDataAttribute];
}
const isMotionValue = (value) => !!(value && value.getVelocity);
function isWillChangeMotionValue(value) {
  return !!(isMotionValue(value) && value.add);
}
function addValueToWillChange(visualElement, key) {
  const willChange = visualElement.getValue("willChange");
  if (isWillChangeMotionValue(willChange))
    return willChange.add(key);
}
function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
  const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== !0;
  return needsAnimating[key] = !1, shouldBlock;
}
function animateTarget(visualElement, targetAndTransition, { delay: delay2 = 0, transitionOverride, type } = {}) {
  var _a4;
  let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;
  transitionOverride && (transition = transitionOverride);
  const animations2 = [], animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
  for (const key in target) {
    const value = visualElement.getValue(key, (_a4 = visualElement.latestValues[key]) !== null && _a4 !== void 0 ? _a4 : null), valueTarget = target[key];
    if (valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key))
      continue;
    const valueTransition = {
      delay: delay2,
      ...getValueTransition$1(transition || {}, key)
    };
    let isHandoff = !1;
    if (window.MotionHandoffAnimation) {
      const appearId = getOptimisedAppearId(visualElement);
      if (appearId) {
        const startTime = window.MotionHandoffAnimation(appearId, key, frame);
        startTime !== null && (valueTransition.startTime = startTime, isHandoff = !0);
      }
    }
    addValueToWillChange(visualElement, key), value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key) ? { type: !1 } : valueTransition, visualElement, isHandoff));
    const animation = value.animation;
    animation && animations2.push(animation);
  }
  return transitionEnd && Promise.all(animations2).then(() => {
    frame.update(() => {
      transitionEnd && setTarget(visualElement, transitionEnd);
    });
  }), animations2;
}
function animateVariant(visualElement, variant, options = {}) {
  var _a4;
  const resolved = resolveVariant(visualElement, variant, options.type === "exit" ? (_a4 = visualElement.presenceContext) === null || _a4 === void 0 ? void 0 : _a4.custom : void 0);
  let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
  options.transitionOverride && (transition = options.transitionOverride);
  const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve(), getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
    const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
  } : () => Promise.resolve(), { when } = transition;
  if (when) {
    const [first, last] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
    return first().then(() => last());
  } else
    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
}
function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
  const animations2 = [], maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren, generateStaggerDuration = staggerDirection === 1 ? (i2 = 0) => i2 * staggerChildren : (i2 = 0) => maxStaggerDuration - i2 * staggerChildren;
  return Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i2) => {
    child.notify("AnimationStart", variant), animations2.push(animateVariant(child, variant, {
      ...options,
      delay: delayChildren + generateStaggerDuration(i2)
    }).then(() => child.notify("AnimationComplete", variant)));
  }), Promise.all(animations2);
}
function sortByTreeOrder(a2, b2) {
  return a2.sortNodePosition(b2);
}
function animateVisualElement(visualElement, definition, options = {}) {
  visualElement.notify("AnimationStart", definition);
  let animation;
  if (Array.isArray(definition)) {
    const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));
    animation = Promise.all(animations2);
  } else if (typeof definition == "string")
    animation = animateVariant(visualElement, definition, options);
  else {
    const resolvedDefinition = typeof definition == "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
    animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
  }
  return animation.then(() => {
    visualElement.notify("AnimationComplete", definition);
  });
}
const numVariantProps = variantProps.length;
function getVariantContext(visualElement) {
  if (!visualElement)
    return;
  if (!visualElement.isControllingVariants) {
    const context2 = visualElement.parent ? getVariantContext(visualElement.parent) || {} : {};
    return visualElement.props.initial !== void 0 && (context2.initial = visualElement.props.initial), context2;
  }
  const context = {};
  for (let i2 = 0; i2 < numVariantProps; i2++) {
    const name = variantProps[i2], prop = visualElement.props[name];
    (isVariantLabel(prop) || prop === !1) && (context[name] = prop);
  }
  return context;
}
const reversePriorityOrder = [...variantPriorityOrder].reverse(), numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement) {
  return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));
}
function createAnimationState(visualElement) {
  let animate = animateList(visualElement), state = createState(), isInitialRender = !0;
  const buildResolvedTypeValues = (type) => (acc, definition) => {
    var _a4;
    const resolved = resolveVariant(visualElement, definition, type === "exit" ? (_a4 = visualElement.presenceContext) === null || _a4 === void 0 ? void 0 : _a4.custom : void 0);
    if (resolved) {
      const { transition, transitionEnd, ...target } = resolved;
      acc = { ...acc, ...target, ...transitionEnd };
    }
    return acc;
  };
  function setAnimateFunction(makeAnimator) {
    animate = makeAnimator(visualElement);
  }
  function animateChanges(changedActiveType) {
    const { props } = visualElement, context = getVariantContext(visualElement.parent) || {}, animations2 = [], removedKeys = /* @__PURE__ */ new Set();
    let encounteredKeys = {}, removedVariantIndex = 1 / 0;
    for (let i2 = 0; i2 < numAnimationTypes; i2++) {
      const type = reversePriorityOrder[i2], typeState = state[type], prop = props[type] !== void 0 ? props[type] : context[type], propIsVariant = isVariantLabel(prop), activeDelta = type === changedActiveType ? typeState.isActive : null;
      activeDelta === !1 && (removedVariantIndex = i2);
      let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount && (isInherited = !1), typeState.protectedKeys = { ...encounteredKeys }, // If it isn't active and hasn't *just* been set as inactive
      !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
      !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
      isAnimationControls(prop) || typeof prop == "boolean")
        continue;
      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
      i2 > removedVariantIndex && propIsVariant, handledRemovedValues = !1;
      const definitionList = Array.isArray(prop) ? prop : [prop];
      let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});
      activeDelta === !1 && (resolvedValues = {});
      const { prevResolvedValues = {} } = typeState, allKeys = {
        ...prevResolvedValues,
        ...resolvedValues
      }, markToAnimate = (key) => {
        shouldAnimateType = !0, removedKeys.has(key) && (handledRemovedValues = !0, removedKeys.delete(key)), typeState.needsAnimating[key] = !0;
        const motionValue2 = visualElement.getValue(key);
        motionValue2 && (motionValue2.liveStyle = !1);
      };
      for (const key in allKeys) {
        const next = resolvedValues[key], prev = prevResolvedValues[key];
        if (encounteredKeys.hasOwnProperty(key))
          continue;
        let valueHasChanged = !1;
        isKeyframesTarget(next) && isKeyframesTarget(prev) ? valueHasChanged = !shallowCompare(next, prev) : valueHasChanged = next !== prev, valueHasChanged ? next != null ? markToAnimate(key) : removedKeys.add(key) : next !== void 0 && removedKeys.has(key) ? markToAnimate(key) : typeState.protectedKeys[key] = !0;
      }
      typeState.prevProp = prop, typeState.prevResolvedValues = resolvedValues, typeState.isActive && (encounteredKeys = { ...encounteredKeys, ...resolvedValues }), isInitialRender && visualElement.blockInitialAnimation && (shouldAnimateType = !1), shouldAnimateType && (!(isInherited && variantDidChange) || handledRemovedValues) && animations2.push(...definitionList.map((animation) => ({
        animation,
        options: { type }
      })));
    }
    if (removedKeys.size) {
      const fallbackAnimation = {};
      removedKeys.forEach((key) => {
        const fallbackTarget = visualElement.getBaseTarget(key), motionValue2 = visualElement.getValue(key);
        motionValue2 && (motionValue2.liveStyle = !0), fallbackAnimation[key] = fallbackTarget ?? null;
      }), animations2.push({ animation: fallbackAnimation });
    }
    let shouldAnimate = !!animations2.length;
    return isInitialRender && (props.initial === !1 || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount && (shouldAnimate = !1), isInitialRender = !1, shouldAnimate ? animate(animations2) : Promise.resolve();
  }
  function setActive(type, isActive) {
    var _a4;
    if (state[type].isActive === isActive)
      return Promise.resolve();
    (_a4 = visualElement.variantChildren) === null || _a4 === void 0 || _a4.forEach((child) => {
      var _a5;
      return (_a5 = child.animationState) === null || _a5 === void 0 ? void 0 : _a5.setActive(type, isActive);
    }), state[type].isActive = isActive;
    const animations2 = animateChanges(type);
    for (const key in state)
      state[key].protectedKeys = {};
    return animations2;
  }
  return {
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: () => state,
    reset: () => {
      state = createState(), isInitialRender = !0;
    }
  };
}
function checkVariantsDidChange(prev, next) {
  return typeof next == "string" ? next !== prev : Array.isArray(next) ? !shallowCompare(next, prev) : !1;
}
function createTypeState(isActive = !1) {
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  return {
    animate: createTypeState(!0),
    whileInView: createTypeState(),
    whileHover: createTypeState(),
    whileTap: createTypeState(),
    whileDrag: createTypeState(),
    whileFocus: createTypeState(),
    exit: createTypeState()
  };
}
class Feature {
  constructor(node2) {
    this.isMounted = !1, this.node = node2;
  }
  update() {
  }
}
class AnimationFeature extends Feature {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(node2) {
    super(node2), node2.animationState || (node2.animationState = createAnimationState(node2));
  }
  updateAnimationControlsSubscription() {
    const { animate } = this.node.getProps();
    isAnimationControls(animate) && (this.unmountControls = animate.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate } = this.node.getProps(), { animate: prevAnimate } = this.node.prevProps || {};
    animate !== prevAnimate && this.updateAnimationControlsSubscription();
  }
  unmount() {
    var _a4;
    this.node.animationState.reset(), (_a4 = this.unmountControls) === null || _a4 === void 0 || _a4.call(this);
  }
}
let id$1 = 0;
class ExitAnimationFeature extends Feature {
  constructor() {
    super(...arguments), this.id = id$1++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent, onExitComplete } = this.node.presenceContext, { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || isPresent === prevIsPresent)
      return;
    const exitAnimation = this.node.animationState.setActive("exit", !isPresent);
    onExitComplete && !isPresent && exitAnimation.then(() => onExitComplete(this.id));
  }
  mount() {
    const { register } = this.node.presenceContext || {};
    register && (this.unmount = register(this.id));
  }
  unmount() {
  }
}
const animations = {
  animation: {
    Feature: AnimationFeature
  },
  exit: {
    Feature: ExitAnimationFeature
  }
}, isPrimaryPointer = (event) => event.pointerType === "mouse" ? typeof event.button != "number" || event.button <= 0 : event.isPrimary !== !1;
function extractEventInfo(event, pointType = "page") {
  return {
    point: {
      x: event[`${pointType}X`],
      y: event[`${pointType}Y`]
    }
  };
}
const addPointerInfo = (handler) => (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
function addDomEvent(target, eventName, handler, options = { passive: !0 }) {
  return target.addEventListener(eventName, handler, options), () => target.removeEventListener(eventName, handler);
}
function addPointerEvent(target, eventName, handler, options) {
  return addDomEvent(target, eventName, addPointerInfo(handler), options);
}
const distance = (a2, b2) => Math.abs(a2 - b2);
function distance2D(a2, b2) {
  const xDelta = distance(a2.x, b2.x), yDelta = distance(a2.y, b2.y);
  return Math.sqrt(xDelta ** 2 + yDelta ** 2);
}
class PanSession {
  constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = !1 } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const info2 = getPanInfo(this.lastMoveEventInfo, this.history), isPanStarted = this.startEvent !== null, isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= 3;
      if (!isPanStarted && !isDistancePastThreshold)
        return;
      const { point: point3 } = info2, { timestamp: timestamp2 } = frameData;
      this.history.push({ ...point3, timestamp: timestamp2 });
      const { onStart, onMove } = this.handlers;
      isPanStarted || (onStart && onStart(this.lastMoveEvent, info2), this.startEvent = this.lastMoveEvent), onMove && onMove(this.lastMoveEvent, info2);
    }, this.handlePointerMove = (event2, info2) => {
      this.lastMoveEvent = event2, this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint), frame.update(this.updatePoint, !0);
    }, this.handlePointerUp = (event2, info2) => {
      this.end();
      const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
      if (this.dragSnapToOrigin && resumeAnimation && resumeAnimation(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
      this.startEvent && onEnd && onEnd(event2, panInfo), onSessionEnd && onSessionEnd(event2, panInfo);
    }, !isPrimaryPointer(event))
      return;
    this.dragSnapToOrigin = dragSnapToOrigin, this.handlers = handlers, this.transformPagePoint = transformPagePoint, this.contextWindow = contextWindow || window;
    const info = extractEventInfo(event), initialInfo = transformPoint(info, this.transformPagePoint), { point: point2 } = initialInfo, { timestamp } = frameData;
    this.history = [{ ...point2, timestamp }];
    const { onSessionStart } = handlers;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history)), this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(handlers) {
    this.handlers = handlers;
  }
  end() {
    this.removeListeners && this.removeListeners(), cancelFrame(this.updatePoint);
  }
}
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a2, b2) {
  return { x: a2.x - b2.x, y: a2.y - b2.y };
}
function getPanInfo({ point: point2 }, history) {
  return {
    point: point2,
    delta: subtractPoint(point2, lastDevicePoint(history)),
    offset: subtractPoint(point2, startDevicePoint(history)),
    velocity: getVelocity(history, 0.1)
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity(history, timeDelta) {
  if (history.length < 2)
    return { x: 0, y: 0 };
  let i2 = history.length - 1, timestampedPoint = null;
  const lastPoint = lastDevicePoint(history);
  for (; i2 >= 0 && (timestampedPoint = history[i2], !(lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta))); )
    i2--;
  if (!timestampedPoint)
    return { x: 0, y: 0 };
  const time2 = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
  if (time2 === 0)
    return { x: 0, y: 0 };
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time2,
    y: (lastPoint.y - timestampedPoint.y) / time2
  };
  return currentVelocity.x === 1 / 0 && (currentVelocity.x = 0), currentVelocity.y === 1 / 0 && (currentVelocity.y = 0), currentVelocity;
}
function createLock(name) {
  let lock = null;
  return () => {
    const openLock = () => {
      lock = null;
    };
    return lock === null ? (lock = name, openLock) : !1;
  };
}
const globalHorizontalLock = createLock("dragHorizontal"), globalVerticalLock = createLock("dragVertical");
function getGlobalLock(drag2) {
  let lock = !1;
  if (drag2 === "y")
    lock = globalVerticalLock();
  else if (drag2 === "x")
    lock = globalHorizontalLock();
  else {
    const openHorizontal = globalHorizontalLock(), openVertical = globalVerticalLock();
    openHorizontal && openVertical ? lock = () => {
      openHorizontal(), openVertical();
    } : (openHorizontal && openHorizontal(), openVertical && openVertical());
  }
  return lock;
}
function isDragActive() {
  const openGestureLock = getGlobalLock(!0);
  return openGestureLock ? (openGestureLock(), !1) : !0;
}
function isRefObject(ref) {
  return ref && typeof ref == "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}
const SCALE_PRECISION = 1e-4, SCALE_MIN = 1 - SCALE_PRECISION, SCALE_MAX = 1 + SCALE_PRECISION, TRANSLATE_PRECISION = 0.01, TRANSLATE_MIN = 0 - TRANSLATE_PRECISION, TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
function calcLength(axis) {
  return axis.max - axis.min;
}
function isNear(value, target, maxDistance) {
  return Math.abs(value - target) <= maxDistance;
}
function calcAxisDelta(delta, source, target, origin = 0.5) {
  delta.origin = origin, delta.originPoint = mixNumber$1(source.min, source.max, delta.origin), delta.scale = calcLength(target) / calcLength(source), delta.translate = mixNumber$1(target.min, target.max, delta.origin) - delta.originPoint, (delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX || isNaN(delta.scale)) && (delta.scale = 1), (delta.translate >= TRANSLATE_MIN && delta.translate <= TRANSLATE_MAX || isNaN(delta.translate)) && (delta.translate = 0);
}
function calcBoxDelta(delta, source, target, origin) {
  calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0), calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
}
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min, target.max = target.min + calcLength(relative);
}
function calcRelativeBox(target, relative, parent) {
  calcRelativeAxis(target.x, relative.x, parent.x), calcRelativeAxis(target.y, relative.y, parent.y);
}
function calcRelativeAxisPosition(target, layout2, parent) {
  target.min = layout2.min - parent.min, target.max = target.min + calcLength(layout2);
}
function calcRelativePosition(target, layout2, parent) {
  calcRelativeAxisPosition(target.x, layout2.x, parent.x), calcRelativeAxisPosition(target.y, layout2.y, parent.y);
}
function applyConstraints(point2, { min: min2, max: max2 }, elastic) {
  return min2 !== void 0 && point2 < min2 ? point2 = elastic ? mixNumber$1(min2, point2, elastic.min) : Math.max(point2, min2) : max2 !== void 0 && point2 > max2 && (point2 = elastic ? mixNumber$1(max2, point2, elastic.max) : Math.min(point2, max2)), point2;
}
function calcRelativeAxisConstraints(axis, min2, max2) {
  return {
    min: min2 !== void 0 ? axis.min + min2 : void 0,
    max: max2 !== void 0 ? axis.max + max2 - (axis.max - axis.min) : void 0
  };
}
function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  let min2 = constraintsAxis.min - layoutAxis.min, max2 = constraintsAxis.max - layoutAxis.max;
  return constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min && ([min2, max2] = [max2, min2]), { min: min2, max: max2 };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcOrigin$1(source, target) {
  let origin = 0.5;
  const sourceLength = calcLength(source), targetLength = calcLength(target);
  return targetLength > sourceLength ? origin = progress(target.min, target.max - sourceLength, source.min) : sourceLength > targetLength && (origin = progress(source.min, source.max - targetLength, target.min)), clamp(0, 1, origin);
}
function rebaseAxisConstraints(layout2, constraints) {
  const relativeConstraints = {};
  return constraints.min !== void 0 && (relativeConstraints.min = constraints.min - layout2.min), constraints.max !== void 0 && (relativeConstraints.max = constraints.max - layout2.min), relativeConstraints;
}
const defaultElastic = 0.35;
function resolveDragElastic(dragElastic = defaultElastic) {
  return dragElastic === !1 ? dragElastic = 0 : dragElastic === !0 && (dragElastic = defaultElastic), {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label2) {
  return typeof dragElastic == "number" ? dragElastic : dragElastic[label2] || 0;
}
const createAxisDelta = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), createDelta = () => ({
  x: createAxisDelta(),
  y: createAxisDelta()
}), createAxis = () => ({ min: 0, max: 0 }), createBox = () => ({
  x: createAxis(),
  y: createAxis()
});
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}
function convertBoundingBoxToBox({ top, left, right, bottom }) {
  return {
    x: { min: left, max: right },
    y: { min: top, max: bottom }
  };
}
function convertBoxToBoundingBox({ x: x2, y: y2 }) {
  return { top: y2.min, right: x2.max, bottom: y2.max, left: x2.min };
}
function transformBoxPoints(point2, transformPoint2) {
  if (!transformPoint2)
    return point2;
  const topLeft = transformPoint2({ x: point2.left, y: point2.top }), bottomRight = transformPoint2({ x: point2.right, y: point2.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
function hasScale({ scale: scale2, scaleX, scaleY }) {
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
}
function hasTransform(values2) {
  return hasScale(values2) || has2DTranslate(values2) || values2.z || values2.rotate || values2.rotateX || values2.rotateY || values2.skewX || values2.skewY;
}
function has2DTranslate(values2) {
  return is2DTranslate(values2.x) || is2DTranslate(values2.y);
}
function is2DTranslate(value) {
  return value && value !== "0%";
}
function scalePoint(point2, scale2, originPoint) {
  const distanceFromOrigin = point2 - originPoint, scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point2, translate, scale2, originPoint, boxScale) {
  return boxScale !== void 0 && (point2 = scalePoint(point2, boxScale, originPoint)), scalePoint(point2, scale2, originPoint) + translate;
}
function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale), axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function applyBoxDelta(box, { x: x2, y: y2 }) {
  applyAxisDelta(box.x, x2.translate, x2.scale, x2.originPoint), applyAxisDelta(box.y, y2.translate, y2.scale, y2.originPoint);
}
const TREE_SCALE_SNAP_MIN = 0.999999999999, TREE_SCALE_SNAP_MAX = 1.0000000000001;
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = !1) {
  const treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  let node2, delta;
  for (let i2 = 0; i2 < treeLength; i2++) {
    node2 = treePath[i2], delta = node2.projectionDelta;
    const { visualElement } = node2.options;
    visualElement && visualElement.props.style && visualElement.props.style.display === "contents" || (isSharedTransition && node2.options.layoutScroll && node2.scroll && node2 !== node2.root && transformBox(box, {
      x: -node2.scroll.offset.x,
      y: -node2.scroll.offset.y
    }), delta && (treeScale.x *= delta.x.scale, treeScale.y *= delta.y.scale, applyBoxDelta(box, delta)), isSharedTransition && hasTransform(node2.latestValues) && transformBox(box, node2.latestValues));
  }
  treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN && (treeScale.x = 1), treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN && (treeScale.y = 1);
}
function translateAxis(axis, distance2) {
  axis.min = axis.min + distance2, axis.max = axis.max + distance2;
}
function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {
  const originPoint = mixNumber$1(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);
}
function transformBox(box, transform2) {
  transformAxis(box.x, transform2.x, transform2.scaleX, transform2.scale, transform2.originX), transformAxis(box.y, transform2.y, transform2.scaleY, transform2.scale, transform2.originY);
}
function measureViewportBox(instance, transformPoint2) {
  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
}
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  const viewportBox = measureViewportBox(element, transformPagePoint), { scroll } = rootProjectionNode2;
  return scroll && (translateAxis(viewportBox.x, scroll.offset.x), translateAxis(viewportBox.y, scroll.offset.y)), viewportBox;
}
const getContextWindow = ({ current }) => current ? current.ownerDocument.defaultView : null, elementDragControls = /* @__PURE__ */ new WeakMap();
class VisualElementDragControls {
  constructor(visualElement) {
    this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = createBox(), this.visualElement = visualElement;
  }
  start(originEvent, { snapToCursor = !1 } = {}) {
    const { presenceContext } = this.visualElement;
    if (presenceContext && presenceContext.isPresent === !1)
      return;
    const onSessionStart = (event) => {
      const { dragSnapToOrigin: dragSnapToOrigin2 } = this.getProps();
      dragSnapToOrigin2 ? this.pauseAnimation() : this.stopAnimation(), snapToCursor && this.snapToCursor(extractEventInfo(event, "page").point);
    }, onStart = (event, info) => {
      const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
      if (drag2 && !dragPropagation && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = getGlobalLock(drag2), !this.openGlobalLock))
        return;
      this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), eachAxis((axis) => {
        let current = this.getAxisMotionValue(axis).get() || 0;
        if (percent.test(current)) {
          const { projection } = this.visualElement;
          if (projection && projection.layout) {
            const measuredAxis = projection.layout.layoutBox[axis];
            measuredAxis && (current = calcLength(measuredAxis) * (parseFloat(current) / 100));
          }
        }
        this.originPoint[axis] = current;
      }), onDragStart && frame.postRender(() => onDragStart(event, info)), addValueToWillChange(this.visualElement, "transform");
      const { animationState } = this.visualElement;
      animationState && animationState.setActive("whileDrag", !0);
    }, onMove = (event, info) => {
      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
      if (!dragPropagation && !this.openGlobalLock)
        return;
      const { offset: offset2 } = info;
      if (dragDirectionLock && this.currentDirection === null) {
        this.currentDirection = getCurrentDirection(offset2), this.currentDirection !== null && onDirectionLock && onDirectionLock(this.currentDirection);
        return;
      }
      this.updateAxis("x", info.point, offset2), this.updateAxis("y", info.point, offset2), this.visualElement.render(), onDrag && onDrag(event, info);
    }, onSessionEnd = (event, info) => this.stop(event, info), resumeAnimation = () => eachAxis((axis) => {
      var _a4;
      return this.getAnimationState(axis) === "paused" && ((_a4 = this.getAxisMotionValue(axis).animation) === null || _a4 === void 0 ? void 0 : _a4.play());
    }), { dragSnapToOrigin } = this.getProps();
    this.panSession = new PanSession(originEvent, {
      onSessionStart,
      onStart,
      onMove,
      onSessionEnd,
      resumeAnimation
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin,
      contextWindow: getContextWindow(this.visualElement)
    });
  }
  stop(event, info) {
    const isDragging = this.isDragging;
    if (this.cancel(), !isDragging)
      return;
    const { velocity } = info;
    this.startAnimation(velocity);
    const { onDragEnd } = this.getProps();
    onDragEnd && frame.postRender(() => onDragEnd(event, info));
  }
  cancel() {
    this.isDragging = !1;
    const { projection, animationState } = this.visualElement;
    projection && (projection.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
    const { dragPropagation } = this.getProps();
    !dragPropagation && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), animationState && animationState.setActive("whileDrag", !1);
  }
  updateAxis(axis, _point, offset2) {
    const { drag: drag2 } = this.getProps();
    if (!offset2 || !shouldDrag(axis, drag2, this.currentDirection))
      return;
    const axisValue = this.getAxisMotionValue(axis);
    let next = this.originPoint[axis] + offset2[axis];
    this.constraints && this.constraints[axis] && (next = applyConstraints(next, this.constraints[axis], this.elastic[axis])), axisValue.set(next);
  }
  resolveConstraints() {
    var _a4;
    const { dragConstraints, dragElastic } = this.getProps(), layout2 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (_a4 = this.visualElement.projection) === null || _a4 === void 0 ? void 0 : _a4.layout, prevConstraints = this.constraints;
    dragConstraints && isRefObject(dragConstraints) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : dragConstraints && layout2 ? this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints) : this.constraints = !1, this.elastic = resolveDragElastic(dragElastic), prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints && eachAxis((axis) => {
      this.constraints !== !1 && this.getAxisMotionValue(axis) && (this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
    if (!constraints || !isRefObject(constraints))
      return !1;
    const constraintsElement = constraints.current, { projection } = this.visualElement;
    if (!projection || !projection.layout)
      return !1;
    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
    if (onMeasureDragConstraints) {
      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
      this.hasMutatedConstraints = !!userConstraints, userConstraints && (measuredConstraints = convertBoundingBoxToBox(userConstraints));
    }
    return measuredConstraints;
  }
  startAnimation(velocity) {
    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps(), constraints = this.constraints || {}, momentumAnimations = eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      let transition = constraints && constraints[axis] || {};
      dragSnapToOrigin && (transition = { min: 0, max: 0 });
      const bounceStiffness = dragElastic ? 200 : 1e6, bounceDamping = dragElastic ? 40 : 1e7, inertia2 = {
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...dragTransition,
        ...transition
      };
      return this.startAxisValueAnimation(axis, inertia2);
    });
    return Promise.all(momentumAnimations).then(onDragTransitionEnd);
  }
  startAxisValueAnimation(axis, transition) {
    const axisValue = this.getAxisMotionValue(axis);
    return addValueToWillChange(this.visualElement, axis), axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, !1));
  }
  stopAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).stop());
  }
  pauseAnimation() {
    eachAxis((axis) => {
      var _a4;
      return (_a4 = this.getAxisMotionValue(axis).animation) === null || _a4 === void 0 ? void 0 : _a4.pause();
    });
  }
  getAnimationState(axis) {
    var _a4;
    return (_a4 = this.getAxisMotionValue(axis).animation) === null || _a4 === void 0 ? void 0 : _a4.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(axis) {
    const dragKey = `_drag${axis.toUpperCase()}`, props = this.visualElement.getProps(), externalMotionValue = props[dragKey];
    return externalMotionValue || this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
  }
  snapToCursor(point2) {
    eachAxis((axis) => {
      const { drag: drag2 } = this.getProps();
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      const { projection } = this.visualElement, axisValue = this.getAxisMotionValue(axis);
      if (projection && projection.layout) {
        const { min: min2, max: max2 } = projection.layout.layoutBox[axis];
        axisValue.set(point2[axis] - mixNumber$1(min2, max2, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: drag2, dragConstraints } = this.getProps(), { projection } = this.visualElement;
    if (!isRefObject(dragConstraints) || !projection || !this.constraints)
      return;
    this.stopAnimation();
    const boxProgress = { x: 0, y: 0 };
    eachAxis((axis) => {
      const axisValue = this.getAxisMotionValue(axis);
      if (axisValue && this.constraints !== !1) {
        const latest = axisValue.get();
        boxProgress[axis] = calcOrigin$1({ min: latest, max: latest }, this.constraints[axis]);
      }
    });
    const { transformTemplate } = this.visualElement.getProps();
    this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none", projection.root && projection.root.updateScroll(), projection.updateLayout(), this.resolveConstraints(), eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, null))
        return;
      const axisValue = this.getAxisMotionValue(axis), { min: min2, max: max2 } = this.constraints[axis];
      axisValue.set(mixNumber$1(min2, max2, boxProgress[axis]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    elementDragControls.set(this.visualElement, this);
    const element = this.visualElement.current, stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
      const { drag: drag2, dragListener = !0 } = this.getProps();
      drag2 && dragListener && this.start(event);
    }), measureDragConstraints = () => {
      const { dragConstraints } = this.getProps();
      isRefObject(dragConstraints) && dragConstraints.current && (this.constraints = this.resolveRefConstraints());
    }, { projection } = this.visualElement, stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
    projection && !projection.layout && (projection.root && projection.root.updateScroll(), projection.updateLayout()), frame.read(measureDragConstraints);
    const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints()), stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({ delta, hasLayoutChanged }) => {
      this.isDragging && hasLayoutChanged && (eachAxis((axis) => {
        const motionValue2 = this.getAxisMotionValue(axis);
        motionValue2 && (this.originPoint[axis] += delta[axis].translate, motionValue2.set(motionValue2.get() + delta[axis].translate));
      }), this.visualElement.render());
    });
    return () => {
      stopResizeListener(), stopPointerListener(), stopMeasureLayoutListener(), stopLayoutUpdateListener && stopLayoutUpdateListener();
    };
  }
  getProps() {
    const props = this.visualElement.getProps(), { drag: drag2 = !1, dragDirectionLock = !1, dragPropagation = !1, dragConstraints = !1, dragElastic = defaultElastic, dragMomentum = !0 } = props;
    return {
      ...props,
      drag: drag2,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum
    };
  }
}
function shouldDrag(direction, drag2, currentDirection) {
  return (drag2 === !0 || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
function getCurrentDirection(offset2, lockThreshold = 10) {
  let direction = null;
  return Math.abs(offset2.y) > lockThreshold ? direction = "y" : Math.abs(offset2.x) > lockThreshold && (direction = "x"), direction;
}
class DragGesture extends Feature {
  constructor(node2) {
    super(node2), this.removeGroupControls = noop$2, this.removeListeners = noop$2, this.controls = new VisualElementDragControls(node2);
  }
  mount() {
    const { dragControls } = this.node.getProps();
    dragControls && (this.removeGroupControls = dragControls.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || noop$2;
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const asyncHandler = (handler) => (event, info) => {
  handler && frame.postRender(() => handler(event, info));
};
class PanGesture extends Feature {
  constructor() {
    super(...arguments), this.removePointerDownListener = noop$2;
  }
  onPointerDown(pointerDownEvent) {
    this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: getContextWindow(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
    return {
      onSessionStart: asyncHandler(onPanSessionStart),
      onStart: asyncHandler(onPanStart),
      onMove: onPan,
      onEnd: (event, info) => {
        delete this.session, onPanEnd && frame.postRender(() => onPanEnd(event, info));
      }
    };
  }
  mount() {
    this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
const PresenceContext = createContext(null);
function usePresence() {
  const context = useContext(PresenceContext);
  if (context === null)
    return [!0, null];
  const { isPresent, onExitComplete, register } = context, id2 = useId$2();
  useEffect(() => register(id2), []);
  const safeToRemove = useCallback(() => onExitComplete && onExitComplete(id2), [id2, onExitComplete]);
  return !isPresent && onExitComplete ? [!1, safeToRemove] : [!0];
}
const LayoutGroupContext = createContext({}), SwitchLayoutGroupContext = createContext({}), globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
};
function pixelsToPercent(pixels, axis) {
  return axis.max === axis.min ? 0 : pixels / (axis.max - axis.min) * 100;
}
const correctBorderRadius = {
  correct: (latest, node2) => {
    if (!node2.target)
      return latest;
    if (typeof latest == "string")
      if (px.test(latest))
        latest = parseFloat(latest);
      else
        return latest;
    const x2 = pixelsToPercent(latest, node2.target.x), y2 = pixelsToPercent(latest, node2.target.y);
    return `${x2}% ${y2}%`;
  }
}, correctBoxShadow = {
  correct: (latest, { treeScale, projectionDelta }) => {
    const original = latest, shadow = complex.parse(latest);
    if (shadow.length > 5)
      return original;
    const template = complex.createTransformer(latest), offset2 = typeof shadow[0] != "number" ? 1 : 0, xScale = projectionDelta.x.scale * treeScale.x, yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset2] /= xScale, shadow[1 + offset2] /= yScale;
    const averageScale = mixNumber$1(xScale, yScale, 0.5);
    return typeof shadow[2 + offset2] == "number" && (shadow[2 + offset2] /= averageScale), typeof shadow[3 + offset2] == "number" && (shadow[3 + offset2] /= averageScale), template(shadow);
  }
}, scaleCorrectors = {};
function addScaleCorrector(correctors) {
  Object.assign(scaleCorrectors, correctors);
}
const { schedule: microtask, cancel: cancelMicrotask } = createRenderBatcher(queueMicrotask, !1);
class MeasureLayoutWithContext extends Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props, { projection } = visualElement;
    addScaleCorrector(defaultScaleCorrectors), projection && (layoutGroup.group && layoutGroup.group.add(projection), switchLayoutGroup && switchLayoutGroup.register && layoutId && switchLayoutGroup.register(projection), projection.root.didUpdate(), projection.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), projection.setOptions({
      ...projection.options,
      onExitComplete: () => this.safeToRemove()
    })), globalProjectionState.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(prevProps) {
    const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props, projection = visualElement.projection;
    return projection && (projection.isPresent = isPresent, drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0 ? projection.willUpdate() : this.safeToRemove(), prevProps.isPresent !== isPresent && (isPresent ? projection.promote() : projection.relegate() || frame.postRender(() => {
      const stack = projection.getStack();
      (!stack || !stack.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection } = this.props.visualElement;
    projection && (projection.root.didUpdate(), microtask.postRender(() => {
      !projection.currentAnimation && projection.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props, { projection } = visualElement;
    projection && (projection.scheduleCheckAfterUnmount(), layoutGroup && layoutGroup.group && layoutGroup.group.remove(projection), promoteContext && promoteContext.deregister && promoteContext.deregister(projection));
  }
  safeToRemove() {
    const { safeToRemove } = this.props;
    safeToRemove && safeToRemove();
  }
  render() {
    return null;
  }
}
function MeasureLayout(props) {
  const [isPresent, safeToRemove] = usePresence(), layoutGroup = useContext(LayoutGroupContext);
  return jsx(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: useContext(SwitchLayoutGroupContext), isPresent, safeToRemove });
}
const defaultScaleCorrectors = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
}, borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], numBorders = borders.length, asNumber = (value) => typeof value == "string" ? parseFloat(value) : value, isPx = (value) => typeof value == "number" || px.test(value);
function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
  shouldCrossfadeOpacity ? (target.opacity = mixNumber$1(
    0,
    // TODO Reinstate this if only child
    lead.opacity !== void 0 ? lead.opacity : 1,
    easeCrossfadeIn(progress2)
  ), target.opacityExit = mixNumber$1(follow.opacity !== void 0 ? follow.opacity : 1, 0, easeCrossfadeOut(progress2))) : isOnlyMember && (target.opacity = mixNumber$1(follow.opacity !== void 0 ? follow.opacity : 1, lead.opacity !== void 0 ? lead.opacity : 1, progress2));
  for (let i2 = 0; i2 < numBorders; i2++) {
    const borderLabel = `border${borders[i2]}Radius`;
    let followRadius = getRadius(follow, borderLabel), leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0), leadRadius || (leadRadius = 0), followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius) ? (target[borderLabel] = Math.max(mixNumber$1(asNumber(followRadius), asNumber(leadRadius), progress2), 0), (percent.test(leadRadius) || percent.test(followRadius)) && (target[borderLabel] += "%")) : target[borderLabel] = leadRadius;
  }
  (follow.rotate || lead.rotate) && (target.rotate = mixNumber$1(follow.rotate || 0, lead.rotate || 0, progress2));
}
function getRadius(values2, radiusName) {
  return values2[radiusName] !== void 0 ? values2[radiusName] : values2.borderRadius;
}
const easeCrossfadeIn = /* @__PURE__ */ compress(0, 0.5, circOut), easeCrossfadeOut = /* @__PURE__ */ compress(0.5, 0.95, noop$2);
function compress(min2, max2, easing) {
  return (p2) => p2 < min2 ? 0 : p2 > max2 ? 1 : easing(progress(min2, max2, p2));
}
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min, axis.max = originAxis.max;
}
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x), copyAxisInto(box.y, originBox.y);
}
function copyAxisDeltaInto(delta, originDelta) {
  delta.translate = originDelta.translate, delta.scale = originDelta.scale, delta.originPoint = originDelta.originPoint, delta.origin = originDelta.origin;
}
function removePointDelta(point2, translate, scale2, originPoint, boxScale) {
  return point2 -= translate, point2 = scalePoint(point2, 1 / scale2, originPoint), boxScale !== void 0 && (point2 = scalePoint(point2, 1 / boxScale, originPoint)), point2;
}
function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
  if (percent.test(translate) && (translate = parseFloat(translate), translate = mixNumber$1(sourceAxis.min, sourceAxis.max, translate / 100) - sourceAxis.min), typeof translate != "number")
    return;
  let originPoint = mixNumber$1(originAxis.min, originAxis.max, origin);
  axis === originAxis && (originPoint -= translate), axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale), axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {
  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
}
const xKeys = ["x", "scaleX", "originX"], yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(box, transforms, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0), removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
}
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
function axisEquals(a2, b2) {
  return a2.min === b2.min && a2.max === b2.max;
}
function boxEquals(a2, b2) {
  return axisEquals(a2.x, b2.x) && axisEquals(a2.y, b2.y);
}
function axisEqualsRounded(a2, b2) {
  return Math.round(a2.min) === Math.round(b2.min) && Math.round(a2.max) === Math.round(b2.max);
}
function boxEqualsRounded(a2, b2) {
  return axisEqualsRounded(a2.x, b2.x) && axisEqualsRounded(a2.y, b2.y);
}
function aspectRatio(box) {
  return calcLength(box.x) / calcLength(box.y);
}
function axisDeltaEquals(a2, b2) {
  return a2.translate === b2.translate && a2.scale === b2.scale && a2.originPoint === b2.originPoint;
}
class NodeStack {
  constructor() {
    this.members = [];
  }
  add(node2) {
    addUniqueItem(this.members, node2), node2.scheduleRender();
  }
  remove(node2) {
    if (removeItem(this.members, node2), node2 === this.prevLead && (this.prevLead = void 0), node2 === this.lead) {
      const prevLead = this.members[this.members.length - 1];
      prevLead && this.promote(prevLead);
    }
  }
  relegate(node2) {
    const indexOfNode = this.members.findIndex((member) => node2 === member);
    if (indexOfNode === 0)
      return !1;
    let prevLead;
    for (let i2 = indexOfNode; i2 >= 0; i2--) {
      const member = this.members[i2];
      if (member.isPresent !== !1) {
        prevLead = member;
        break;
      }
    }
    return prevLead ? (this.promote(prevLead), !0) : !1;
  }
  promote(node2, preserveFollowOpacity) {
    const prevLead = this.lead;
    if (node2 !== prevLead && (this.prevLead = prevLead, this.lead = node2, node2.show(), prevLead)) {
      prevLead.instance && prevLead.scheduleRender(), node2.scheduleRender(), node2.resumeFrom = prevLead, preserveFollowOpacity && (node2.resumeFrom.preserveOpacity = !0), prevLead.snapshot && (node2.snapshot = prevLead.snapshot, node2.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues), node2.root && node2.root.isUpdating && (node2.isLayoutDirty = !0);
      const { crossfade } = node2.options;
      crossfade === !1 && prevLead.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((node2) => {
      const { options, resumingFrom } = node2;
      options.onExitComplete && options.onExitComplete(), resumingFrom && resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((node2) => {
      node2.instance && node2.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function buildProjectionTransform(delta, treeScale, latestTransform) {
  let transform2 = "";
  const xTranslate = delta.x.translate / treeScale.x, yTranslate = delta.y.translate / treeScale.y, zTranslate = (latestTransform == null ? void 0 : latestTransform.z) || 0;
  if ((xTranslate || yTranslate || zTranslate) && (transform2 = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `), (treeScale.x !== 1 || treeScale.y !== 1) && (transform2 += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `), latestTransform) {
    const { transformPerspective, rotate, rotateX, rotateY, skewX, skewY } = latestTransform;
    transformPerspective && (transform2 = `perspective(${transformPerspective}px) ${transform2}`), rotate && (transform2 += `rotate(${rotate}deg) `), rotateX && (transform2 += `rotateX(${rotateX}deg) `), rotateY && (transform2 += `rotateY(${rotateY}deg) `), skewX && (transform2 += `skewX(${skewX}deg) `), skewY && (transform2 += `skewY(${skewY}deg) `);
  }
  const elementScaleX = delta.x.scale * treeScale.x, elementScaleY = delta.y.scale * treeScale.y;
  return (elementScaleX !== 1 || elementScaleY !== 1) && (transform2 += `scale(${elementScaleX}, ${elementScaleY})`), transform2 || "none";
}
const compareByDepth = (a2, b2) => a2.depth - b2.depth;
class FlatTree {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(child) {
    addUniqueItem(this.children, child), this.isDirty = !0;
  }
  remove(child) {
    removeItem(this.children, child), this.isDirty = !0;
  }
  forEach(callback) {
    this.isDirty && this.children.sort(compareByDepth), this.isDirty = !1, this.children.forEach(callback);
  }
}
function resolveMotionValue(value) {
  const unwrappedValue = isMotionValue(value) ? value.get() : value;
  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}
function delay(callback, timeout2) {
  const start2 = time$1.now(), checkElapsed = ({ timestamp }) => {
    const elapsed = timestamp - start2;
    elapsed >= timeout2 && (cancelFrame(checkElapsed), callback(elapsed - timeout2));
  };
  return frame.read(checkElapsed, !0), () => cancelFrame(checkElapsed);
}
function isSVGElement(element) {
  return element instanceof SVGElement && element.tagName !== "svg";
}
function animateSingleValue(value, keyframes2, options) {
  const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
  return motionValue$1.start(animateMotionValue("", motionValue$1, keyframes2, options)), motionValue$1.animation;
}
const metrics = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
}, isDebug = typeof window < "u" && window.MotionDebug !== void 0, transformAxes = ["", "X", "Y", "Z"], hiddenVisibility = { visibility: "hidden" }, animationTarget = 1e3;
let id = 0;
function resetDistortingTransform(key, visualElement, values2, sharedAnimationValues) {
  const { latestValues } = visualElement;
  latestValues[key] && (values2[key] = latestValues[key], visualElement.setStaticValue(key, 0), sharedAnimationValues && (sharedAnimationValues[key] = 0));
}
function cancelTreeOptimisedTransformAnimations(projectionNode) {
  if (projectionNode.hasCheckedOptimisedAppear = !0, projectionNode.root === projectionNode)
    return;
  const { visualElement } = projectionNode.options;
  if (!visualElement)
    return;
  const appearId = getOptimisedAppearId(visualElement);
  if (window.MotionHasOptimisedAnimation(appearId, "transform")) {
    const { layout: layout2, layoutId } = projectionNode.options;
    window.MotionCancelOptimisedAnimation(appearId, "transform", frame, !(layout2 || layoutId));
  }
  const { parent } = projectionNode;
  parent && !parent.hasCheckedOptimisedAppear && cancelTreeOptimisedTransformAnimations(parent);
}
function createProjectionNode$1({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
  return class {
    constructor(latestValues = {}, parent = defaultParent == null ? void 0 : defaultParent()) {
      this.id = id++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, isDebug && (metrics.totalNodes = metrics.resolvedTargetDeltas = metrics.recalculatedProjection = 0), this.nodes.forEach(propagateDirtyNodes), this.nodes.forEach(resolveTargetDelta), this.nodes.forEach(calcProjection), this.nodes.forEach(cleanDirtyNodes), isDebug && window.MotionDebug.record(metrics);
      }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = latestValues, this.root = parent ? parent.root || parent : this, this.path = parent ? [...parent.path, parent] : [], this.parent = parent, this.depth = parent ? parent.depth + 1 : 0;
      for (let i2 = 0; i2 < this.path.length; i2++)
        this.path[i2].shouldResetTransform = !0;
      this.root === this && (this.nodes = new FlatTree());
    }
    addEventListener(name, handler) {
      return this.eventHandlers.has(name) || this.eventHandlers.set(name, new SubscriptionManager()), this.eventHandlers.get(name).add(handler);
    }
    notifyListeners(name, ...args) {
      const subscriptionManager = this.eventHandlers.get(name);
      subscriptionManager && subscriptionManager.notify(...args);
    }
    hasListeners(name) {
      return this.eventHandlers.has(name);
    }
    /**
     * Lifecycles
     */
    mount(instance, isLayoutDirty = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = isSVGElement(instance), this.instance = instance;
      const { layoutId, layout: layout2, visualElement } = this.options;
      if (visualElement && !visualElement.current && visualElement.mount(instance), this.root.nodes.add(this), this.parent && this.parent.children.add(this), isLayoutDirty && (layout2 || layoutId) && (this.isLayoutDirty = !0), attachResizeListener) {
        let cancelDelay;
        const resizeUnblockUpdate = () => this.root.updateBlockedByResize = !1;
        attachResizeListener(instance, () => {
          this.root.updateBlockedByResize = !0, cancelDelay && cancelDelay(), cancelDelay = delay(resizeUnblockUpdate, 250), globalProjectionState.hasAnimatedSinceResize && (globalProjectionState.hasAnimatedSinceResize = !1, this.nodes.forEach(finishAnimation));
        });
      }
      layoutId && this.root.registerSharedNode(layoutId, this), this.options.animate !== !1 && visualElement && (layoutId || layout2) && this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition, { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps(), targetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout) || hasRelativeTargetChanged, hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
        if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
          const animationOptions = {
            ...getValueTransition$1(layoutTransition, "layout"),
            onPlay: onLayoutAnimationStart,
            onComplete: onLayoutAnimationComplete
          };
          (visualElement.shouldReduceMotion || this.options.layoutRoot) && (animationOptions.delay = 0, animationOptions.type = !1), this.startAnimation(animationOptions);
        } else
          hasLayoutChanged || finishAnimation(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = newLayout;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const stack = this.getStack();
      stack && stack.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, cancelFrame(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(resetSkewAndRotation), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement } = this.options;
      return visualElement && visualElement.getProps().transformTemplate;
    }
    willUpdate(shouldNotifyListeners = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && cancelTreeOptimisedTransformAnimations(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node2 = this.path[i2];
        node2.shouldResetTransform = !0, node2.updateScroll("snapshot"), node2.options.layoutRoot && node2.willUpdate(!1);
      }
      const { layoutId, layout: layout2 } = this.options;
      if (layoutId === void 0 && !layout2)
        return;
      const transformTemplate = this.getTransformTemplate();
      this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0, this.updateSnapshot(), shouldNotifyListeners && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(clearMeasurements);
        return;
      }
      this.isUpdating || this.nodes.forEach(clearIsLayoutDirty), this.isUpdating = !1, this.nodes.forEach(resetTransformStyle), this.nodes.forEach(updateLayout), this.nodes.forEach(notifyLayoutUpdate), this.clearAllSnapshots();
      const now2 = time$1.now();
      frameData.delta = clamp(0, 1e3 / 60, now2 - frameData.timestamp), frameData.timestamp = now2, frameData.isProcessing = !0, frameSteps.update.process(frameData), frameSteps.preRender.process(frameData), frameSteps.render.process(frameData), frameData.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, microtask.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot), this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, frame.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      frame.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let i2 = 0; i2 < this.path.length; i2++)
          this.path[i2].updateScroll();
      const prevLayout = this.layout;
      this.layout = this.measure(!1), this.layoutCorrected = createBox(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement } = this.options;
      visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
    }
    updateScroll(phase = "measure") {
      let needsMeasurement = !!(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase && (needsMeasurement = !1), needsMeasurement) {
        const isRoot = checkIsScrollRoot(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase,
          isRoot,
          offset: measureScroll(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : isRoot
        };
      }
    }
    resetTransform() {
      if (!resetTransform)
        return;
      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta), transformTemplate = this.getTransformTemplate(), transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0, transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
      isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged) && (resetTransform(this.instance, transformTemplateValue), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(removeTransform = !0) {
      const pageBox = this.measurePageBox();
      let layoutBox = this.removeElementScroll(pageBox);
      return removeTransform && (layoutBox = this.removeTransform(layoutBox)), roundBox(layoutBox), {
        animationId: this.root.animationId,
        measuredBox: pageBox,
        layoutBox,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      var _a4;
      const { visualElement } = this.options;
      if (!visualElement)
        return createBox();
      const box = visualElement.measureViewportBox();
      if (!(((_a4 = this.scroll) === null || _a4 === void 0 ? void 0 : _a4.wasRoot) || this.path.some(checkNodeWasScrollRoot))) {
        const { scroll } = this.root;
        scroll && (translateAxis(box.x, scroll.offset.x), translateAxis(box.y, scroll.offset.y));
      }
      return box;
    }
    removeElementScroll(box) {
      var _a4;
      const boxWithoutScroll = createBox();
      if (copyBoxInto(boxWithoutScroll, box), !((_a4 = this.scroll) === null || _a4 === void 0) && _a4.wasRoot)
        return boxWithoutScroll;
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node2 = this.path[i2], { scroll, options } = node2;
        node2 !== this.root && scroll && options.layoutScroll && (scroll.wasRoot && copyBoxInto(boxWithoutScroll, box), translateAxis(boxWithoutScroll.x, scroll.offset.x), translateAxis(boxWithoutScroll.y, scroll.offset.y));
      }
      return boxWithoutScroll;
    }
    applyTransform(box, transformOnly = !1) {
      const withTransforms = createBox();
      copyBoxInto(withTransforms, box);
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node2 = this.path[i2];
        !transformOnly && node2.options.layoutScroll && node2.scroll && node2 !== node2.root && transformBox(withTransforms, {
          x: -node2.scroll.offset.x,
          y: -node2.scroll.offset.y
        }), hasTransform(node2.latestValues) && transformBox(withTransforms, node2.latestValues);
      }
      return hasTransform(this.latestValues) && transformBox(withTransforms, this.latestValues), withTransforms;
    }
    removeTransform(box) {
      const boxWithoutTransform = createBox();
      copyBoxInto(boxWithoutTransform, box);
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node2 = this.path[i2];
        if (!node2.instance || !hasTransform(node2.latestValues))
          continue;
        hasScale(node2.latestValues) && node2.updateSnapshot();
        const sourceBox = createBox(), nodeBox = node2.measurePageBox();
        copyBoxInto(sourceBox, nodeBox), removeBoxTransforms(boxWithoutTransform, node2.latestValues, node2.snapshot ? node2.snapshot.layoutBox : void 0, sourceBox);
      }
      return hasTransform(this.latestValues) && removeBoxTransforms(boxWithoutTransform, this.latestValues), boxWithoutTransform;
    }
    setTargetDelta(delta) {
      this.targetDelta = delta, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(options) {
      this.options = {
        ...this.options,
        ...options,
        crossfade: options.crossfade !== void 0 ? options.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(forceRecalculation = !1) {
      var _a4;
      const lead = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
      const isShared = !!this.resumingFrom || this !== lead;
      if (!(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || !((_a4 = this.parent) === null || _a4 === void 0) && _a4.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
        return;
      const { layout: layout2, layoutId } = this.options;
      if (!(!this.layout || !(layout2 || layoutId))) {
        if (this.resolvedRelativeTargetAt = frameData.timestamp, !this.targetDelta && !this.relativeTarget) {
          const relativeParent = this.getClosestProjectingParent();
          relativeParent && relativeParent.layout && this.animationProgress !== 1 ? (this.relativeParent = relativeParent, this.forceRelativeParentToResolveTarget(), this.relativeTarget = createBox(), this.relativeTargetOrigin = createBox(), calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox), copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (this.target || (this.target = createBox(), this.targetWithTransforms = createBox()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : copyBoxInto(this.target, this.layout.layoutBox), applyBoxDelta(this.target, this.targetDelta)) : copyBoxInto(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
            this.attemptToResolveRelativeTarget = !1;
            const relativeParent = this.getClosestProjectingParent();
            relativeParent && !!relativeParent.resumingFrom == !!this.resumingFrom && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1 ? (this.relativeParent = relativeParent, this.forceRelativeParentToResolveTarget(), this.relativeTarget = createBox(), this.relativeTargetOrigin = createBox(), calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target), copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
          }
          isDebug && metrics.resolvedTargetDeltas++;
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var _a4;
      const lead = this.getLead(), isShared = !!this.resumingFrom || this !== lead;
      let canSkip = !0;
      if ((this.isProjectionDirty || !((_a4 = this.parent) === null || _a4 === void 0) && _a4.isProjectionDirty) && (canSkip = !1), isShared && (this.isSharedProjectionDirty || this.isTransformDirty) && (canSkip = !1), this.resolvedRelativeTargetAt === frameData.timestamp && (canSkip = !1), canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(layout2 || layoutId))
        return;
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
      const prevTreeScaleX = this.treeScale.x, prevTreeScaleY = this.treeScale.y;
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared), lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (lead.target = lead.layout.layoutBox, lead.targetWithTransforms = createBox());
      const { target } = lead;
      if (!target) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x), copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y)), calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues), (this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", target)), isDebug && metrics.recalculatedProjection++;
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(notifyAll = !0) {
      var _a4;
      if ((_a4 = this.options.visualElement) === null || _a4 === void 0 || _a4.scheduleRender(), notifyAll) {
        const stack = this.getStack();
        stack && stack.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = createDelta(), this.projectionDelta = createDelta(), this.projectionDeltaWithTransform = createDelta();
    }
    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = !1) {
      const snapshot = this.snapshot, snapshotLatestValues = snapshot ? snapshot.latestValues : {}, mixedValues = { ...this.latestValues }, targetDelta = createDelta();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      const relativeLayout = createBox(), snapshotSource = snapshot ? snapshot.source : void 0, layoutSource = this.layout ? this.layout.source : void 0, isSharedLayoutAnimation = snapshotSource !== layoutSource, stack = this.getStack(), isOnlyMember = !stack || stack.members.length <= 1, shouldCrossfadeOpacity = !!(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === !0 && !this.path.some(hasOpacityCrossfade));
      this.animationProgress = 0;
      let prevRelativeTarget;
      this.mixTargetDelta = (latest) => {
        const progress2 = latest / 1e3;
        mixAxisDelta(targetDelta.x, delta.x, progress2), mixAxisDelta(targetDelta.y, delta.y, progress2), this.setTargetDelta(targetDelta), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox), mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2), prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget) && (this.isProjectionDirty = !1), prevRelativeTarget || (prevRelativeTarget = createBox()), copyBoxInto(prevRelativeTarget, this.relativeTarget)), isSharedLayoutAnimation && (this.animationValues = mixedValues, mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = progress2;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(options) {
      this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (cancelFrame(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = frame.update(() => {
        globalProjectionState.hasAnimatedSinceResize = !0, this.currentAnimation = animateSingleValue(0, animationTarget, {
          ...options,
          onUpdate: (latest) => {
            this.mixTargetDelta(latest), options.onUpdate && options.onUpdate(latest);
          },
          onComplete: () => {
            options.onComplete && options.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const stack = this.getStack();
      stack && stack.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(animationTarget), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const lead = this.getLead();
      let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
      if (!(!targetWithTransforms || !target || !layout2)) {
        if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
          target = this.target || createBox();
          const xLength = calcLength(this.layout.layoutBox.x);
          target.x.min = lead.target.x.min, target.x.max = target.x.min + xLength;
          const yLength = calcLength(this.layout.layoutBox.y);
          target.y.min = lead.target.y.min, target.y.max = target.y.min + yLength;
        }
        copyBoxInto(targetWithTransforms, target), transformBox(targetWithTransforms, latestValues), calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
      }
    }
    registerSharedNode(layoutId, node2) {
      this.sharedNodes.has(layoutId) || this.sharedNodes.set(layoutId, new NodeStack()), this.sharedNodes.get(layoutId).add(node2);
      const config = node2.options.initialPromotionConfig;
      node2.promote({
        transition: config ? config.transition : void 0,
        preserveFollowOpacity: config && config.shouldPreserveFollowOpacity ? config.shouldPreserveFollowOpacity(node2) : void 0
      });
    }
    isLead() {
      const stack = this.getStack();
      return stack ? stack.lead === this : !0;
    }
    getLead() {
      var _a4;
      const { layoutId } = this.options;
      return layoutId ? ((_a4 = this.getStack()) === null || _a4 === void 0 ? void 0 : _a4.lead) || this : this;
    }
    getPrevLead() {
      var _a4;
      const { layoutId } = this.options;
      return layoutId ? (_a4 = this.getStack()) === null || _a4 === void 0 ? void 0 : _a4.prevLead : void 0;
    }
    getStack() {
      const { layoutId } = this.options;
      if (layoutId)
        return this.root.sharedNodes.get(layoutId);
    }
    promote({ needsReset, transition, preserveFollowOpacity } = {}) {
      const stack = this.getStack();
      stack && stack.promote(this, preserveFollowOpacity), needsReset && (this.projectionDelta = void 0, this.needsReset = !0), transition && this.setOptions({ transition });
    }
    relegate() {
      const stack = this.getStack();
      return stack ? stack.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement } = this.options;
      if (!visualElement)
        return;
      let hasDistortingTransform = !1;
      const { latestValues } = visualElement;
      if ((latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) && (hasDistortingTransform = !0), !hasDistortingTransform)
        return;
      const resetValues = {};
      latestValues.z && resetDistortingTransform("z", visualElement, resetValues, this.animationValues);
      for (let i2 = 0; i2 < transformAxes.length; i2++)
        resetDistortingTransform(`rotate${transformAxes[i2]}`, visualElement, resetValues, this.animationValues), resetDistortingTransform(`skew${transformAxes[i2]}`, visualElement, resetValues, this.animationValues);
      visualElement.render();
      for (const key in resetValues)
        visualElement.setStaticValue(key, resetValues[key]), this.animationValues && (this.animationValues[key] = resetValues[key]);
      visualElement.scheduleRender();
    }
    getProjectionStyles(styleProp) {
      var _a4, _b2;
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible)
        return hiddenVisibility;
      const styles = {
        visibility: ""
      }, transformTemplate = this.getTransformTemplate();
      if (this.needsReset)
        return this.needsReset = !1, styles.opacity = "", styles.pointerEvents = resolveMotionValue(styleProp == null ? void 0 : styleProp.pointerEvents) || "", styles.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none", styles;
      const lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        const emptyStyles = {};
        return this.options.layoutId && (emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, emptyStyles.pointerEvents = resolveMotionValue(styleProp == null ? void 0 : styleProp.pointerEvents) || ""), this.hasProjected && !hasTransform(this.latestValues) && (emptyStyles.transform = transformTemplate ? transformTemplate({}, "") : "none", this.hasProjected = !1), emptyStyles;
      }
      const valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget(), styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender), transformTemplate && (styles.transform = transformTemplate(valuesToRender, styles.transform));
      const { x: x2, y: y2 } = this.projectionDelta;
      styles.transformOrigin = `${x2.origin * 100}% ${y2.origin * 100}% 0`, lead.animationValues ? styles.opacity = lead === this ? (_b2 = (_a4 = valuesToRender.opacity) !== null && _a4 !== void 0 ? _a4 : this.latestValues.opacity) !== null && _b2 !== void 0 ? _b2 : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit : styles.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
      for (const key in scaleCorrectors) {
        if (valuesToRender[key] === void 0)
          continue;
        const { correct, applyTo } = scaleCorrectors[key], corrected = styles.transform === "none" ? valuesToRender[key] : correct(valuesToRender[key], lead);
        if (applyTo) {
          const num = applyTo.length;
          for (let i2 = 0; i2 < num; i2++)
            styles[applyTo[i2]] = corrected;
        } else
          styles[key] = corrected;
      }
      return this.options.layoutId && (styles.pointerEvents = lead === this ? resolveMotionValue(styleProp == null ? void 0 : styleProp.pointerEvents) || "" : "none"), styles;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((node2) => {
        var _a4;
        return (_a4 = node2.currentAnimation) === null || _a4 === void 0 ? void 0 : _a4.stop();
      }), this.root.nodes.forEach(clearMeasurements), this.root.sharedNodes.clear();
    }
  };
}
function updateLayout(node2) {
  node2.updateLayout();
}
function notifyLayoutUpdate(node2) {
  var _a4;
  const snapshot = ((_a4 = node2.resumeFrom) === null || _a4 === void 0 ? void 0 : _a4.snapshot) || node2.snapshot;
  if (node2.isLead() && node2.layout && snapshot && node2.hasListeners("didUpdate")) {
    const { layoutBox: layout2, measuredBox: measuredLayout } = node2.layout, { animationType } = node2.options, isShared = snapshot.source !== node2.layout.source;
    animationType === "size" ? eachAxis((axis) => {
      const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis], length = calcLength(axisSnapshot);
      axisSnapshot.min = layout2[axis].min, axisSnapshot.max = axisSnapshot.min + length;
    }) : shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2) && eachAxis((axis) => {
      const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis], length = calcLength(layout2[axis]);
      axisSnapshot.max = axisSnapshot.min + length, node2.relativeTarget && !node2.currentAnimation && (node2.isProjectionDirty = !0, node2.relativeTarget[axis].max = node2.relativeTarget[axis].min + length);
    });
    const layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
    const visualDelta = createDelta();
    isShared ? calcBoxDelta(visualDelta, node2.applyTransform(measuredLayout, !0), snapshot.measuredBox) : calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
    const hasLayoutChanged = !isDeltaZero(layoutDelta);
    let hasRelativeTargetChanged = !1;
    if (!node2.resumeFrom) {
      const relativeParent = node2.getClosestProjectingParent();
      if (relativeParent && !relativeParent.resumeFrom) {
        const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
        if (parentSnapshot && parentLayout) {
          const relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
          const relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox), boxEqualsRounded(relativeSnapshot, relativeLayout) || (hasRelativeTargetChanged = !0), relativeParent.options.layoutRoot && (node2.relativeTarget = relativeLayout, node2.relativeTargetOrigin = relativeSnapshot, node2.relativeParent = relativeParent);
        }
      }
    }
    node2.notifyListeners("didUpdate", {
      layout: layout2,
      snapshot,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeTargetChanged
    });
  } else if (node2.isLead()) {
    const { onExitComplete } = node2.options;
    onExitComplete && onExitComplete();
  }
  node2.options.transition = void 0;
}
function propagateDirtyNodes(node2) {
  isDebug && metrics.totalNodes++, node2.parent && (node2.isProjecting() || (node2.isProjectionDirty = node2.parent.isProjectionDirty), node2.isSharedProjectionDirty || (node2.isSharedProjectionDirty = !!(node2.isProjectionDirty || node2.parent.isProjectionDirty || node2.parent.isSharedProjectionDirty)), node2.isTransformDirty || (node2.isTransformDirty = node2.parent.isTransformDirty));
}
function cleanDirtyNodes(node2) {
  node2.isProjectionDirty = node2.isSharedProjectionDirty = node2.isTransformDirty = !1;
}
function clearSnapshot(node2) {
  node2.clearSnapshot();
}
function clearMeasurements(node2) {
  node2.clearMeasurements();
}
function clearIsLayoutDirty(node2) {
  node2.isLayoutDirty = !1;
}
function resetTransformStyle(node2) {
  const { visualElement } = node2.options;
  visualElement && visualElement.getProps().onBeforeLayoutMeasure && visualElement.notify("BeforeLayoutMeasure"), node2.resetTransform();
}
function finishAnimation(node2) {
  node2.finishAnimation(), node2.targetDelta = node2.relativeTarget = node2.target = void 0, node2.isProjectionDirty = !0;
}
function resolveTargetDelta(node2) {
  node2.resolveTargetDelta();
}
function calcProjection(node2) {
  node2.calcProjection();
}
function resetSkewAndRotation(node2) {
  node2.resetSkewAndRotation();
}
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
function mixAxisDelta(output, delta, p2) {
  output.translate = mixNumber$1(delta.translate, 0, p2), output.scale = mixNumber$1(delta.scale, 1, p2), output.origin = delta.origin, output.originPoint = delta.originPoint;
}
function mixAxis(output, from, to, p2) {
  output.min = mixNumber$1(from.min, to.min, p2), output.max = mixNumber$1(from.max, to.max, p2);
}
function mixBox(output, from, to, p2) {
  mixAxis(output.x, from.x, to.x, p2), mixAxis(output.y, from.y, to.y, p2);
}
function hasOpacityCrossfade(node2) {
  return node2.animationValues && node2.animationValues.opacityExit !== void 0;
}
const defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, userAgentContains = (string) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string), roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop$2;
function roundAxis(axis) {
  axis.min = roundPoint(axis.min), axis.max = roundPoint(axis.max);
}
function roundBox(box) {
  roundAxis(box.x), roundAxis(box.y);
}
function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
  return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);
}
function checkNodeWasScrollRoot(node2) {
  var _a4;
  return node2 !== node2.root && ((_a4 = node2.scroll) === null || _a4 === void 0 ? void 0 : _a4.wasRoot);
}
const DocumentProjectionNode = createProjectionNode$1({
  attachResizeListener: (ref, notify2) => addDomEvent(ref, "resize", notify2),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => !0
}), rootProjectionNode = {
  current: void 0
}, HTMLProjectionNode = createProjectionNode$1({
  measureScroll: (instance) => ({
    x: instance.scrollLeft,
    y: instance.scrollTop
  }),
  defaultParent: () => {
    if (!rootProjectionNode.current) {
      const documentNode = new DocumentProjectionNode({});
      documentNode.mount(window), documentNode.setOptions({ layoutScroll: !0 }), rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: (instance, value) => {
    instance.style.transform = value !== void 0 ? value : "none";
  },
  checkIsScrollRoot: (instance) => window.getComputedStyle(instance).position === "fixed"
}), drag = {
  pan: {
    Feature: PanGesture
  },
  drag: {
    Feature: DragGesture,
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};
function addHoverEvent(node2, isActive) {
  const eventName = isActive ? "pointerenter" : "pointerleave", callbackName = isActive ? "onHoverStart" : "onHoverEnd", handleEvent = (event, info) => {
    if (event.pointerType === "touch" || isDragActive())
      return;
    const props = node2.getProps();
    node2.animationState && props.whileHover && node2.animationState.setActive("whileHover", isActive);
    const callback = props[callbackName];
    callback && frame.postRender(() => callback(event, info));
  };
  return addPointerEvent(node2.current, eventName, handleEvent, {
    passive: !node2.getProps()[callbackName]
  });
}
class HoverGesture extends Feature {
  mount() {
    this.unmount = pipe(addHoverEvent(this.node, !0), addHoverEvent(this.node, !1));
  }
  unmount() {
  }
}
class FocusGesture extends Feature {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let isFocusVisible = !1;
    try {
      isFocusVisible = this.node.current.matches(":focus-visible");
    } catch {
      isFocusVisible = !0;
    }
    !isFocusVisible || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
const isNodeOrChild = (parent, child) => child ? parent === child ? !0 : isNodeOrChild(parent, child.parentElement) : !1;
function fireSyntheticPointerEvent(name, handler) {
  if (!handler)
    return;
  const syntheticPointerEvent = new PointerEvent("pointer" + name);
  handler(syntheticPointerEvent, extractEventInfo(syntheticPointerEvent));
}
class PressGesture extends Feature {
  constructor() {
    super(...arguments), this.removeStartListeners = noop$2, this.removeEndListeners = noop$2, this.removeAccessibleListeners = noop$2, this.startPointerPress = (startEvent, startInfo) => {
      if (this.isPressing)
        return;
      this.removeEndListeners();
      const props = this.node.getProps(), removePointerUpListener = addPointerEvent(window, "pointerup", (endEvent, endInfo) => {
        if (!this.checkPressEnd())
          return;
        const { onTap, onTapCancel, globalTapTarget } = this.node.getProps(), handler = !globalTapTarget && !isNodeOrChild(this.node.current, endEvent.target) ? onTapCancel : onTap;
        handler && frame.update(() => handler(endEvent, endInfo));
      }, {
        passive: !(props.onTap || props.onPointerUp)
      }), removePointerCancelListener = addPointerEvent(window, "pointercancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo), {
        passive: !(props.onTapCancel || props.onPointerCancel)
      });
      this.removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener), this.startPress(startEvent, startInfo);
    }, this.startAccessiblePress = () => {
      const handleKeydown = (keydownEvent) => {
        if (keydownEvent.key !== "Enter" || this.isPressing)
          return;
        const handleKeyup = (keyupEvent) => {
          keyupEvent.key !== "Enter" || !this.checkPressEnd() || fireSyntheticPointerEvent("up", (event, info) => {
            const { onTap } = this.node.getProps();
            onTap && frame.postRender(() => onTap(event, info));
          });
        };
        this.removeEndListeners(), this.removeEndListeners = addDomEvent(this.node.current, "keyup", handleKeyup), fireSyntheticPointerEvent("down", (event, info) => {
          this.startPress(event, info);
        });
      }, removeKeydownListener = addDomEvent(this.node.current, "keydown", handleKeydown), handleBlur = () => {
        this.isPressing && fireSyntheticPointerEvent("cancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo));
      }, removeBlurListener = addDomEvent(this.node.current, "blur", handleBlur);
      this.removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);
    };
  }
  startPress(event, info) {
    this.isPressing = !0;
    const { onTapStart, whileTap } = this.node.getProps();
    whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !0), onTapStart && frame.postRender(() => onTapStart(event, info));
  }
  checkPressEnd() {
    return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !isDragActive();
  }
  cancelPress(event, info) {
    if (!this.checkPressEnd())
      return;
    const { onTapCancel } = this.node.getProps();
    onTapCancel && frame.postRender(() => onTapCancel(event, info));
  }
  mount() {
    const props = this.node.getProps(), removePointerListener = addPointerEvent(props.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, {
      passive: !(props.onTapStart || props.onPointerStart)
    }), removeFocusListener = addDomEvent(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = pipe(removePointerListener, removeFocusListener);
  }
  unmount() {
    this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners();
  }
}
const observerCallbacks = /* @__PURE__ */ new WeakMap(), observers = /* @__PURE__ */ new WeakMap(), fireObserverCallback = (entry) => {
  const callback = observerCallbacks.get(entry.target);
  callback && callback(entry);
}, fireAllObserverCallbacks = (entries) => {
  entries.forEach(fireObserverCallback);
};
function initIntersectionObserver({ root: root2, ...options }) {
  const lookupRoot = root2 || document;
  observers.has(lookupRoot) || observers.set(lookupRoot, {});
  const rootObservers = observers.get(lookupRoot), key = JSON.stringify(options);
  return rootObservers[key] || (rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root: root2, ...options })), rootObservers[key];
}
function observeIntersection(element, options, callback) {
  const rootInteresectionObserver = initIntersectionObserver(options);
  return observerCallbacks.set(element, callback), rootInteresectionObserver.observe(element), () => {
    observerCallbacks.delete(element), rootInteresectionObserver.unobserve(element);
  };
}
const thresholdNames = {
  some: 0,
  all: 1
};
class InViewFeature extends Feature {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport = {} } = this.node.getProps(), { root: root2, margin: rootMargin, amount = "some", once } = viewport, options = {
      root: root2 ? root2.current : void 0,
      rootMargin,
      threshold: typeof amount == "number" ? amount : thresholdNames[amount]
    }, onIntersectionUpdate = (entry) => {
      const { isIntersecting } = entry;
      if (this.isInView === isIntersecting || (this.isInView = isIntersecting, once && !isIntersecting && this.hasEnteredView))
        return;
      isIntersecting && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", isIntersecting);
      const { onViewportEnter, onViewportLeave } = this.node.getProps(), callback = isIntersecting ? onViewportEnter : onViewportLeave;
      callback && callback(entry);
    };
    return observeIntersection(this.node.current, options, onIntersectionUpdate);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props, prevProps } = this.node;
    ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps)) && this.startObserver();
  }
  unmount() {
  }
}
function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
  return (name) => viewport[name] !== prevViewport[name];
}
const gestureAnimations = {
  inView: {
    Feature: InViewFeature
  },
  tap: {
    Feature: PressGesture
  },
  focus: {
    Feature: FocusGesture
  },
  hover: {
    Feature: HoverGesture
  }
}, layout$3 = {
  layout: {
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
}, MotionConfigContext = createContext({
  transformPagePoint: (p2) => p2,
  isStatic: !1,
  reducedMotion: "never"
}), MotionContext = createContext({}), isBrowser$1 = typeof window < "u", useIsomorphicLayoutEffect$1 = isBrowser$1 ? useLayoutEffect : useEffect, LazyContext = createContext({ strict: !1 });
function useVisualElement(Component2, visualState, props, createVisualElement, ProjectionNodeConstructor) {
  var _a4, _b2;
  const { visualElement: parent } = useContext(MotionContext), lazyContext = useContext(LazyContext), presenceContext = useContext(PresenceContext), reducedMotionConfig = useContext(MotionConfigContext).reducedMotion, visualElementRef = useRef();
  createVisualElement = createVisualElement || lazyContext.renderer, !visualElementRef.current && createVisualElement && (visualElementRef.current = createVisualElement(Component2, {
    visualState,
    parent,
    props,
    presenceContext,
    blockInitialAnimation: presenceContext ? presenceContext.initial === !1 : !1,
    reducedMotionConfig
  }));
  const visualElement = visualElementRef.current, initialLayoutGroupConfig = useContext(SwitchLayoutGroupContext);
  visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === "html" || visualElement.type === "svg") && createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
  const isMounted = useRef(!1);
  useInsertionEffect$1(() => {
    visualElement && isMounted.current && visualElement.update(props, presenceContext);
  });
  const optimisedAppearId = props[optimizedAppearDataAttribute], wantsHandoff = useRef(!!optimisedAppearId && !(!((_a4 = window.MotionHandoffIsComplete) === null || _a4 === void 0) && _a4.call(window, optimisedAppearId)) && ((_b2 = window.MotionHasOptimisedAnimation) === null || _b2 === void 0 ? void 0 : _b2.call(window, optimisedAppearId)));
  return useIsomorphicLayoutEffect$1(() => {
    visualElement && (isMounted.current = !0, window.MotionIsMounted = !0, visualElement.updateFeatures(), microtask.render(visualElement.render), wantsHandoff.current && visualElement.animationState && visualElement.animationState.animateChanges());
  }), useEffect(() => {
    visualElement && (!wantsHandoff.current && visualElement.animationState && visualElement.animationState.animateChanges(), wantsHandoff.current && (queueMicrotask(() => {
      var _a5;
      (_a5 = window.MotionHandoffMarkAsComplete) === null || _a5 === void 0 || _a5.call(window, optimisedAppearId);
    }), wantsHandoff.current = !1));
  }), visualElement;
}
function createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {
  const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot } = props;
  visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(visualElement.parent)), visualElement.projection.setOptions({
    layoutId,
    layout: layout2,
    alwaysMeasureLayout: !!drag2 || dragConstraints && isRefObject(dragConstraints),
    visualElement,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof layout2 == "string" ? layout2 : "both",
    initialPromotionConfig,
    layoutScroll,
    layoutRoot
  });
}
function getClosestProjectingNode(visualElement) {
  if (visualElement)
    return visualElement.options.allowProjection !== !1 ? visualElement.projection : getClosestProjectingNode(visualElement.parent);
}
function useMotionRef(visualState, visualElement, externalRef) {
  return useCallback(
    (instance) => {
      instance && visualState.mount && visualState.mount(instance), visualElement && (instance ? visualElement.mount(instance) : visualElement.unmount()), externalRef && (typeof externalRef == "function" ? externalRef(instance) : isRefObject(externalRef) && (externalRef.current = instance));
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [visualElement]
  );
}
function isControllingVariants(props) {
  return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));
}
function isVariantNode(props) {
  return !!(isControllingVariants(props) || props.variants);
}
function getCurrentTreeVariants(props, context) {
  if (isControllingVariants(props)) {
    const { initial, animate } = props;
    return {
      initial: initial === !1 || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate) ? animate : void 0
    };
  }
  return props.inherit !== !1 ? context : {};
}
function useCreateMotionContext(props) {
  const { initial, animate } = getCurrentTreeVariants(props, useContext(MotionContext));
  return useMemo(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
}
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}
const featureProps = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, featureDefinitions = {};
for (const key in featureProps)
  featureDefinitions[key] = {
    isEnabled: (props) => featureProps[key].some((name) => !!props[name])
  };
function loadFeatures(features) {
  for (const key in features)
    featureDefinitions[key] = {
      ...featureDefinitions[key],
      ...features[key]
    };
}
const motionComponentSymbol = Symbol.for("motionComponentSymbol");
function createRendererMotionComponent({ preloadedFeatures, createVisualElement, useRender, useVisualState, Component: Component2 }) {
  preloadedFeatures && loadFeatures(preloadedFeatures);
  function MotionComponent(props, externalRef) {
    let MeasureLayout2;
    const configAndProps = {
      ...useContext(MotionConfigContext),
      ...props,
      layoutId: useLayoutId(props)
    }, { isStatic } = configAndProps, context = useCreateMotionContext(props), visualState = useVisualState(props, isStatic);
    if (!isStatic && isBrowser$1) {
      useStrictMode();
      const layoutProjection = getProjectionFunctionality(configAndProps);
      MeasureLayout2 = layoutProjection.MeasureLayout, context.visualElement = useVisualElement(Component2, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);
    }
    return jsxs(MotionContext.Provider, { value: context, children: [MeasureLayout2 && context.visualElement ? jsx(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps }) : null, useRender(Component2, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)] });
  }
  const ForwardRefMotionComponent = forwardRef(MotionComponent);
  return ForwardRefMotionComponent[motionComponentSymbol] = Component2, ForwardRefMotionComponent;
}
function useLayoutId({ layoutId }) {
  const layoutGroupId = useContext(LayoutGroupContext).id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}
function useStrictMode(configAndProps, preloadedFeatures) {
  useContext(LazyContext).strict;
}
function getProjectionFunctionality(props) {
  const { drag: drag2, layout: layout2 } = featureDefinitions;
  if (!drag2 && !layout2)
    return {};
  const combined = { ...drag2, ...layout2 };
  return {
    MeasureLayout: drag2 != null && drag2.isEnabled(props) || layout2 != null && layout2.isEnabled(props) ? combined.MeasureLayout : void 0,
    ProjectionNode: combined.ProjectionNode
  };
}
const lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function isSVGComponent(Component2) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component2 != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    Component2.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(lowercaseSVGElements.indexOf(Component2) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/u.test(Component2))
    )
  );
}
function renderHTML(element, { style: style2, vars: vars2 }, styleProp, projection) {
  Object.assign(element.style, style2, projection && projection.getProjectionStyles(styleProp));
  for (const key in vars2)
    element.style.setProperty(key, vars2[key]);
}
const camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, void 0, projection);
  for (const key in renderState.attrs)
    element.setAttribute(camelCaseAttributes.has(key) ? key : camelToDash(key), renderState.attrs[key]);
}
function isForcedMotionValue(key, { layout: layout2, layoutId }) {
  return transformProps.has(key) || key.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
}
function scrapeMotionValuesFromProps$1(props, prevProps, visualElement) {
  var _a4;
  const { style: style2 } = props, newValues = {};
  for (const key in style2)
    (isMotionValue(style2[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props) || ((_a4 = visualElement == null ? void 0 : visualElement.getValue(key)) === null || _a4 === void 0 ? void 0 : _a4.liveStyle) !== void 0) && (newValues[key] = style2[key]);
  return newValues;
}
function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
  const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
  for (const key in props)
    if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
      const targetKey = transformPropOrder.indexOf(key) !== -1 ? "attr" + key.charAt(0).toUpperCase() + key.substring(1) : key;
      newValues[targetKey] = props[key];
    }
  return newValues;
}
function useConstant(init2) {
  const ref = useRef(null);
  return ref.current === null && (ref.current = init2()), ref.current;
}
function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2, createRenderState, onMount: onMount2 }, props, context, presenceContext) {
  const state = {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps2),
    renderState: createRenderState()
  };
  return onMount2 && (state.mount = (instance) => onMount2(props, instance, state)), state;
}
const makeUseVisualState = (config) => (props, isStatic) => {
  const context = useContext(MotionContext), presenceContext = useContext(PresenceContext), make = () => makeState(config, props, context, presenceContext);
  return isStatic ? make() : useConstant(make);
};
function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
  const values2 = {}, motionValues = scrapeMotionValues(props, {});
  for (const key in motionValues)
    values2[key] = resolveMotionValue(motionValues[key]);
  let { initial, animate } = props;
  const isControllingVariants$1 = isControllingVariants(props), isVariantNode$1 = isVariantNode(props);
  context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== !1 && (initial === void 0 && (initial = context.initial), animate === void 0 && (animate = context.animate));
  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === !1 : !1;
  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === !1;
  const variantToSet = isInitialAnimationBlocked ? animate : initial;
  if (variantToSet && typeof variantToSet != "boolean" && !isAnimationControls(variantToSet)) {
    const list2 = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    for (let i2 = 0; i2 < list2.length; i2++) {
      const resolved = resolveVariantFromProps(props, list2[i2]);
      if (resolved) {
        const { transitionEnd, transition, ...target } = resolved;
        for (const key in target) {
          let valueTarget = target[key];
          if (Array.isArray(valueTarget)) {
            const index2 = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
            valueTarget = valueTarget[index2];
          }
          valueTarget !== null && (values2[key] = valueTarget);
        }
        for (const key in transitionEnd)
          values2[key] = transitionEnd[key];
      }
    }
  }
  return values2;
}
const createHtmlRenderState = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
}), createSvgRenderState = () => ({
  ...createHtmlRenderState(),
  attrs: {}
}), getValueAsType = (value, type) => type && typeof value == "number" ? type.transform(value) : value, translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, numTransforms = transformPropOrder.length;
function buildTransform(latestValues, transform2, transformTemplate) {
  let transformString = "", transformIsDefault = !0;
  for (let i2 = 0; i2 < numTransforms; i2++) {
    const key = transformPropOrder[i2], value = latestValues[key];
    if (value === void 0)
      continue;
    let valueIsDefault = !0;
    if (typeof value == "number" ? valueIsDefault = value === (key.startsWith("scale") ? 1 : 0) : valueIsDefault = parseFloat(value) === 0, !valueIsDefault || transformTemplate) {
      const valueAsType = getValueAsType(value, numberValueTypes[key]);
      if (!valueIsDefault) {
        transformIsDefault = !1;
        const transformName = translateAlias[key] || key;
        transformString += `${transformName}(${valueAsType}) `;
      }
      transformTemplate && (transform2[key] = valueAsType);
    }
  }
  return transformString = transformString.trim(), transformTemplate ? transformString = transformTemplate(transform2, transformIsDefault ? "" : transformString) : transformIsDefault && (transformString = "none"), transformString;
}
function buildHTMLStyles(state, latestValues, transformTemplate) {
  const { style: style2, vars: vars2, transformOrigin } = state;
  let hasTransform2 = !1, hasTransformOrigin = !1;
  for (const key in latestValues) {
    const value = latestValues[key];
    if (transformProps.has(key)) {
      hasTransform2 = !0;
      continue;
    } else if (isCSSVariableName(key)) {
      vars2[key] = value;
      continue;
    } else {
      const valueAsType = getValueAsType(value, numberValueTypes[key]);
      key.startsWith("origin") ? (hasTransformOrigin = !0, transformOrigin[key] = valueAsType) : style2[key] = valueAsType;
    }
  }
  if (latestValues.transform || (hasTransform2 || transformTemplate ? style2.transform = buildTransform(latestValues, state.transform, transformTemplate) : style2.transform && (style2.transform = "none")), hasTransformOrigin) {
    const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
    style2.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}
function calcOrigin(origin, offset2, size2) {
  return typeof origin == "string" ? origin : px.transform(offset2 + size2 * origin);
}
function calcSVGTransformOrigin(dimensions, originX, originY) {
  const pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width), pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);
  return `${pxOriginX} ${pxOriginY}`;
}
const dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length, spacing = 1, offset2 = 0, useDashCase = !0) {
  attrs.pathLength = 1;
  const keys2 = useDashCase ? dashKeys : camelKeys;
  attrs[keys2.offset] = px.transform(-offset2);
  const pathLength = px.transform(length), pathSpacing = px.transform(spacing);
  attrs[keys2.array] = `${pathLength} ${pathSpacing}`;
}
function buildSVGAttrs(state, {
  attrX,
  attrY,
  attrScale,
  originX,
  originY,
  pathLength,
  pathSpacing = 1,
  pathOffset = 0,
  // This is object creation, which we try to avoid per-frame.
  ...latest
}, isSVGTag2, transformTemplate) {
  if (buildHTMLStyles(state, latest, transformTemplate), isSVGTag2) {
    state.style.viewBox && (state.attrs.viewBox = state.style.viewBox);
    return;
  }
  state.attrs = state.style, state.style = {};
  const { attrs, style: style2, dimensions } = state;
  attrs.transform && (dimensions && (style2.transform = attrs.transform), delete attrs.transform), dimensions && (originX !== void 0 || originY !== void 0 || style2.transform) && (style2.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5)), attrX !== void 0 && (attrs.x = attrX), attrY !== void 0 && (attrs.y = attrY), attrScale !== void 0 && (attrs.scale = attrScale), pathLength !== void 0 && buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, !1);
}
const isSVGTag = (tag) => typeof tag == "string" && tag.toLowerCase() === "svg", svgMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createSvgRenderState,
    onMount: (props, instance, { renderState, latestValues }) => {
      frame.read(() => {
        try {
          renderState.dimensions = typeof instance.getBBox == "function" ? instance.getBBox() : instance.getBoundingClientRect();
        } catch {
          renderState.dimensions = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
      }), frame.render(() => {
        buildSVGAttrs(renderState, latestValues, isSVGTag(instance.tagName), props.transformTemplate), renderSVG(instance, renderState);
      });
    }
  })
}, htmlMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
    createRenderState: createHtmlRenderState
  })
};
function copyRawValuesOnly(target, source, props) {
  for (const key in source)
    !isMotionValue(source[key]) && !isForcedMotionValue(key, props) && (target[key] = source[key]);
}
function useInitialMotionValues({ transformTemplate }, visualState) {
  return useMemo(() => {
    const state = createHtmlRenderState();
    return buildHTMLStyles(state, visualState, transformTemplate), Object.assign({}, state.vars, state.style);
  }, [visualState]);
}
function useStyle(props, visualState) {
  const styleProp = props.style || {}, style2 = {};
  return copyRawValuesOnly(style2, styleProp, props), Object.assign(style2, useInitialMotionValues(props, visualState)), style2;
}
function useHTMLProps(props, visualState) {
  const htmlProps = {}, style2 = useStyle(props, visualState);
  return props.drag && props.dragListener !== !1 && (htmlProps.draggable = !1, style2.userSelect = style2.WebkitUserSelect = style2.WebkitTouchCallout = "none", style2.touchAction = props.drag === !0 ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`), props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap) && (htmlProps.tabIndex = 0), htmlProps.style = style2, htmlProps;
}
const validMotionProps = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function isValidMotionProp(key) {
  return key.startsWith("while") || key.startsWith("drag") && key !== "draggable" || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || key.startsWith("onLayout") || validMotionProps.has(key);
}
let shouldForward = (key) => !isValidMotionProp(key);
function loadExternalIsValidProp(isValidProp) {
  isValidProp && (shouldForward = (key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key));
}
try {
  loadExternalIsValidProp((void 0).default);
} catch {
}
function filterProps(props, isDom, forwardMotionProps) {
  const filteredProps = {};
  for (const key in props)
    key === "values" && typeof props.values == "object" || (shouldForward(key) || forwardMotionProps === !0 && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || // If trying to use native HTML drag events, forward drag listeners
    props.draggable && key.startsWith("onDrag")) && (filteredProps[key] = props[key]);
  return filteredProps;
}
function useSVGProps(props, visualState, _isStatic, Component2) {
  const visualProps = useMemo(() => {
    const state = createSvgRenderState();
    return buildSVGAttrs(state, visualState, isSVGTag(Component2), props.transformTemplate), {
      ...state.attrs,
      style: { ...state.style }
    };
  }, [visualState]);
  if (props.style) {
    const rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props), visualProps.style = { ...rawStyles, ...visualProps.style };
  }
  return visualProps;
}
function createUseRender(forwardMotionProps = !1) {
  return (Component2, props, ref, { latestValues }, isStatic) => {
    const visualProps = (isSVGComponent(Component2) ? useSVGProps : useHTMLProps)(props, latestValues, isStatic, Component2), filteredProps = filterProps(props, typeof Component2 == "string", forwardMotionProps), elementProps = Component2 !== Fragment$1 ? { ...filteredProps, ...visualProps, ref } : {}, { children: children2 } = props, renderedChildren = useMemo(() => isMotionValue(children2) ? children2.get() : children2, [children2]);
    return createElement(Component2, {
      ...elementProps,
      children: renderedChildren
    });
  };
}
function createMotionComponentFactory(preloadedFeatures, createVisualElement) {
  return function(Component2, { forwardMotionProps } = { forwardMotionProps: !1 }) {
    const config = {
      ...isSVGComponent(Component2) ? svgMotionConfig : htmlMotionConfig,
      preloadedFeatures,
      useRender: createUseRender(forwardMotionProps),
      createVisualElement,
      Component: Component2
    };
    return createRendererMotionComponent(config);
  };
}
const prefersReducedMotion = { current: null }, hasReducedMotionListener = { current: !1 };
function initPrefersReducedMotion() {
  if (hasReducedMotionListener.current = !0, !!isBrowser$1)
    if (window.matchMedia) {
      const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)"), setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
      motionMediaQuery.addListener(setReducedMotionPreferences), setReducedMotionPreferences();
    } else
      prefersReducedMotion.current = !1;
}
function updateMotionValuesFromProps(element, next, prev) {
  for (const key in next) {
    const nextValue = next[key], prevValue = prev[key];
    if (isMotionValue(nextValue))
      element.addValue(key, nextValue);
    else if (isMotionValue(prevValue))
      element.addValue(key, motionValue(nextValue, { owner: element }));
    else if (prevValue !== nextValue)
      if (element.hasValue(key)) {
        const existingValue = element.getValue(key);
        existingValue.liveStyle === !0 ? existingValue.jump(nextValue) : existingValue.hasAnimated || existingValue.set(nextValue);
      } else {
        const latestValue = element.getStaticValue(key);
        element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
      }
  }
  for (const key in prev)
    next[key] === void 0 && element.removeValue(key);
  return next;
}
const visualElementStore = /* @__PURE__ */ new WeakMap(), valueTypes = [...dimensionValueTypes, color, complex], findValueType = (v2) => valueTypes.find(testValueType(v2)), propEventHandlers = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class VisualElement {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
    return {};
  }
  constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState }, options = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = KeyframeResolver, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.renderScheduledAt = 0, this.scheduleRender = () => {
      const now2 = time$1.now();
      this.renderScheduledAt < now2 && (this.renderScheduledAt = now2, frame.render(this.render, !1, !0));
    };
    const { latestValues, renderState } = visualState;
    this.latestValues = latestValues, this.baseTarget = { ...latestValues }, this.initialValues = props.initial ? { ...latestValues } : {}, this.renderState = renderState, this.parent = parent, this.props = props, this.presenceContext = presenceContext, this.depth = parent ? parent.depth + 1 : 0, this.reducedMotionConfig = reducedMotionConfig, this.options = options, this.blockInitialAnimation = !!blockInitialAnimation, this.isControllingVariants = isControllingVariants(props), this.isVariantNode = isVariantNode(props), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(parent && parent.current);
    const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);
    for (const key in initialMotionValues) {
      const value = initialMotionValues[key];
      latestValues[key] !== void 0 && isMotionValue(value) && value.set(latestValues[key], !1);
    }
  }
  mount(instance) {
    this.current = instance, visualElementStore.set(instance, this), this.projection && !this.projection.instance && this.projection.mount(instance), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((value, key) => this.bindToMotionValue(key, value)), hasReducedMotionListener.current || initPrefersReducedMotion(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : prefersReducedMotion.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    visualElementStore.delete(this.current), this.projection && this.projection.unmount(), cancelFrame(this.notifyUpdate), cancelFrame(this.render), this.valueSubscriptions.forEach((remove2) => remove2()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
    for (const key in this.events)
      this.events[key].clear();
    for (const key in this.features) {
      const feature = this.features[key];
      feature && (feature.unmount(), feature.isMounted = !1);
    }
    this.current = null;
  }
  bindToMotionValue(key, value) {
    this.valueSubscriptions.has(key) && this.valueSubscriptions.get(key)();
    const valueIsTransform = transformProps.has(key), removeOnChange = value.on("change", (latestValue) => {
      this.latestValues[key] = latestValue, this.props.onUpdate && frame.preRender(this.notifyUpdate), valueIsTransform && this.projection && (this.projection.isTransformDirty = !0);
    }), removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
    let removeSyncCheck;
    window.MotionCheckAppearSync && (removeSyncCheck = window.MotionCheckAppearSync(this, key, value)), this.valueSubscriptions.set(key, () => {
      removeOnChange(), removeOnRenderRequest(), removeSyncCheck && removeSyncCheck(), value.owner && value.stop();
    });
  }
  sortNodePosition(other) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== other.type ? 0 : this.sortInstanceNodePosition(this.current, other.current);
  }
  updateFeatures() {
    let key = "animation";
    for (key in featureDefinitions) {
      const featureDefinition = featureDefinitions[key];
      if (!featureDefinition)
        continue;
      const { isEnabled, Feature: FeatureConstructor } = featureDefinition;
      if (!this.features[key] && FeatureConstructor && isEnabled(this.props) && (this.features[key] = new FeatureConstructor(this)), this.features[key]) {
        const feature = this.features[key];
        feature.isMounted ? feature.update() : (feature.mount(), feature.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
  }
  getStaticValue(key) {
    return this.latestValues[key];
  }
  setStaticValue(key, value) {
    this.latestValues[key] = value;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(props, presenceContext) {
    (props.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = props, this.prevPresenceContext = this.presenceContext, this.presenceContext = presenceContext;
    for (let i2 = 0; i2 < propEventHandlers.length; i2++) {
      const key = propEventHandlers[i2];
      this.propEventSubscriptions[key] && (this.propEventSubscriptions[key](), delete this.propEventSubscriptions[key]);
      const listenerName = "on" + key, listener = props[listenerName];
      listener && (this.propEventSubscriptions[key] = this.on(key, listener));
    }
    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(name) {
    return this.props.variants ? this.props.variants[name] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(child) {
    const closestVariantNode = this.getClosestVariantNode();
    if (closestVariantNode)
      return closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child), () => closestVariantNode.variantChildren.delete(child);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(key, value) {
    const existingValue = this.values.get(key);
    value !== existingValue && (existingValue && this.removeValue(key), this.bindToMotionValue(key, value), this.values.set(key, value), this.latestValues[key] = value.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(key) {
    this.values.delete(key);
    const unsubscribe = this.valueSubscriptions.get(key);
    unsubscribe && (unsubscribe(), this.valueSubscriptions.delete(key)), delete this.latestValues[key], this.removeValueFromRenderState(key, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(key) {
    return this.values.has(key);
  }
  getValue(key, defaultValue) {
    if (this.props.values && this.props.values[key])
      return this.props.values[key];
    let value = this.values.get(key);
    return value === void 0 && defaultValue !== void 0 && (value = motionValue(defaultValue === null ? void 0 : defaultValue, { owner: this }), this.addValue(key, value)), value;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(key, target) {
    var _a4;
    let value = this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : (_a4 = this.getBaseTargetFromProps(this.props, key)) !== null && _a4 !== void 0 ? _a4 : this.readValueFromInstance(this.current, key, this.options);
    return value != null && (typeof value == "string" && (isNumericalString(value) || isZeroValueString(value)) ? value = parseFloat(value) : !findValueType(value) && complex.test(target) && (value = getAnimatableNone(key, target)), this.setBaseTarget(key, isMotionValue(value) ? value.get() : value)), isMotionValue(value) ? value.get() : value;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(key, value) {
    this.baseTarget[key] = value;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(key) {
    var _a4;
    const { initial } = this.props;
    let valueFromInitial;
    if (typeof initial == "string" || typeof initial == "object") {
      const variant = resolveVariantFromProps(this.props, initial, (_a4 = this.presenceContext) === null || _a4 === void 0 ? void 0 : _a4.custom);
      variant && (valueFromInitial = variant[key]);
    }
    if (initial && valueFromInitial !== void 0)
      return valueFromInitial;
    const target = this.getBaseTargetFromProps(this.props, key);
    return target !== void 0 && !isMotionValue(target) ? target : this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];
  }
  on(eventName, callback) {
    return this.events[eventName] || (this.events[eventName] = new SubscriptionManager()), this.events[eventName].add(callback);
  }
  notify(eventName, ...args) {
    this.events[eventName] && this.events[eventName].notify(...args);
  }
}
class DOMVisualElement extends VisualElement {
  constructor() {
    super(...arguments), this.KeyframeResolver = DOMKeyframesResolver;
  }
  sortInstanceNodePosition(a2, b2) {
    return a2.compareDocumentPosition(b2) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(props, key) {
    return props.style ? props.style[key] : void 0;
  }
  removeValueFromRenderState(key, { vars: vars2, style: style2 }) {
    delete vars2[key], delete style2[key];
  }
}
function getComputedStyle$1(element) {
  return window.getComputedStyle(element);
}
class HTMLVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments), this.type = "html", this.renderInstance = renderHTML;
  }
  readValueFromInstance(instance, key) {
    if (transformProps.has(key)) {
      const defaultType = getDefaultValueType(key);
      return defaultType && defaultType.default || 0;
    } else {
      const computedStyle = getComputedStyle$1(instance), value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
      return typeof value == "string" ? value.trim() : value;
    }
  }
  measureInstanceViewportBox(instance, { transformPagePoint }) {
    return measureViewportBox(instance, transformPagePoint);
  }
  build(renderState, latestValues, props) {
    buildHTMLStyles(renderState, latestValues, props.transformTemplate);
  }
  scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    return scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: children2 } = this.props;
    isMotionValue(children2) && (this.childSubscription = children2.on("change", (latest) => {
      this.current && (this.current.textContent = `${latest}`);
    }));
  }
}
class SVGVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = createBox;
  }
  getBaseTargetFromProps(props, key) {
    return props[key];
  }
  readValueFromInstance(instance, key) {
    if (transformProps.has(key)) {
      const defaultType = getDefaultValueType(key);
      return defaultType && defaultType.default || 0;
    }
    return key = camelCaseAttributes.has(key) ? key : camelToDash(key), instance.getAttribute(key);
  }
  scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    return scrapeMotionValuesFromProps(props, prevProps, visualElement);
  }
  build(renderState, latestValues, props) {
    buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate);
  }
  renderInstance(instance, renderState, styleProp, projection) {
    renderSVG(instance, renderState, styleProp, projection);
  }
  mount(instance) {
    this.isSVGTag = isSVGTag(instance.tagName), super.mount(instance);
  }
}
const createDomVisualElement = (Component2, options) => isSVGComponent(Component2) ? new SVGVisualElement(options) : new HTMLVisualElement(options, {
  allowProjection: Component2 !== Fragment$1
}), createMinimalMotionComponent = /* @__PURE__ */ createMotionComponentFactory(), m$1 = /* @__PURE__ */ createDOMMotionComponentProxy(createMinimalMotionComponent);
class PopChildMeasure extends React.Component {
  getSnapshotBeforeUpdate(prevProps) {
    const element = this.props.childRef.current;
    if (element && prevProps.isPresent && !this.props.isPresent) {
      const size2 = this.props.sizeRef.current;
      size2.height = element.offsetHeight || 0, size2.width = element.offsetWidth || 0, size2.top = element.offsetTop, size2.left = element.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function PopChild({ children: children2, isPresent }) {
  const id2 = useId$2(), ref = useRef(null), size2 = useRef({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  }), { nonce } = useContext(MotionConfigContext);
  return useInsertionEffect$1(() => {
    const { width: width2, height, top, left } = size2.current;
    if (isPresent || !ref.current || !width2 || !height)
      return;
    ref.current.dataset.motionPopId = id2;
    const style2 = document.createElement("style");
    return nonce && (style2.nonce = nonce), document.head.appendChild(style2), style2.sheet && style2.sheet.insertRule(`
          [data-motion-pop-id="${id2}"] {
            position: absolute !important;
            width: ${width2}px !important;
            height: ${height}px !important;
            top: ${top}px !important;
            left: ${left}px !important;
          }
        `), () => {
      document.head.removeChild(style2);
    };
  }, [isPresent]), jsx(PopChildMeasure, { isPresent, childRef: ref, sizeRef: size2, children: React.cloneElement(children2, { ref }) });
}
const PresenceChild = ({ children: children2, initial, isPresent, onExitComplete, custom: custom5, presenceAffectsLayout, mode }) => {
  const presenceChildren = useConstant(newChildrenMap), id2 = useId$2(), memoizedOnExitComplete = useCallback((childId) => {
    presenceChildren.set(childId, !0);
    for (const isComplete of presenceChildren.values())
      if (!isComplete)
        return;
    onExitComplete && onExitComplete();
  }, [presenceChildren, onExitComplete]), context = useMemo(
    () => ({
      id: id2,
      initial,
      isPresent,
      custom: custom5,
      onExitComplete: memoizedOnExitComplete,
      register: (childId) => (presenceChildren.set(childId, !1), () => presenceChildren.delete(childId))
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    presenceAffectsLayout ? [Math.random(), memoizedOnExitComplete] : [isPresent, memoizedOnExitComplete]
  );
  return useMemo(() => {
    presenceChildren.forEach((_, key) => presenceChildren.set(key, !1));
  }, [isPresent]), React.useEffect(() => {
    !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
  }, [isPresent]), mode === "popLayout" && (children2 = jsx(PopChild, { isPresent, children: children2 })), jsx(PresenceContext.Provider, { value: context, children: children2 });
};
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}
const getChildKey = (child) => child.key || "";
function onlyElements(children2) {
  const filtered = [];
  return Children.forEach(children2, (child) => {
    isValidElement(child) && filtered.push(child);
  }), filtered;
}
const AnimatePresence = ({ children: children2, exitBeforeEnter, custom: custom5, initial = !0, onExitComplete, presenceAffectsLayout = !0, mode = "sync" }) => {
  const presentChildren = useMemo(() => onlyElements(children2), [children2]), presentKeys = presentChildren.map(getChildKey), isInitialRender = useRef(!0), pendingPresentChildren = useRef(presentChildren), exitComplete = useConstant(() => /* @__PURE__ */ new Map()), [diffedChildren, setDiffedChildren] = useState(presentChildren), [renderedChildren, setRenderedChildren] = useState(presentChildren);
  useIsomorphicLayoutEffect$1(() => {
    isInitialRender.current = !1, pendingPresentChildren.current = presentChildren;
    for (let i2 = 0; i2 < renderedChildren.length; i2++) {
      const key = getChildKey(renderedChildren[i2]);
      presentKeys.includes(key) ? exitComplete.delete(key) : exitComplete.get(key) !== !0 && exitComplete.set(key, !1);
    }
  }, [renderedChildren, presentKeys.length, presentKeys.join("-")]);
  const exitingChildren = [];
  if (presentChildren !== diffedChildren) {
    let nextChildren = [...presentChildren];
    for (let i2 = 0; i2 < renderedChildren.length; i2++) {
      const child = renderedChildren[i2], key = getChildKey(child);
      presentKeys.includes(key) || (nextChildren.splice(i2, 0, child), exitingChildren.push(child));
    }
    mode === "wait" && exitingChildren.length && (nextChildren = exitingChildren), setRenderedChildren(onlyElements(nextChildren)), setDiffedChildren(presentChildren);
    return;
  }
  const { forceRender } = useContext(LayoutGroupContext);
  return jsx(Fragment, { children: renderedChildren.map((child) => {
    const key = getChildKey(child), isPresent = presentChildren === renderedChildren || presentKeys.includes(key), onExit = () => {
      if (exitComplete.has(key))
        exitComplete.set(key, !0);
      else
        return;
      let isEveryExitComplete = !0;
      exitComplete.forEach((isExitComplete) => {
        isExitComplete || (isEveryExitComplete = !1);
      }), isEveryExitComplete && (forceRender == null || forceRender(), setRenderedChildren(pendingPresentChildren.current), onExitComplete && onExitComplete());
    };
    return jsx(PresenceChild, { isPresent, initial: !isInitialRender.current || initial ? void 0 : !1, custom: isPresent ? void 0 : custom5, presenceAffectsLayout, mode, onExitComplete: isPresent ? void 0 : onExit, children: child }, key);
  }) });
};
function MotionConfig({ children: children2, isValidProp, ...config }) {
  isValidProp && loadExternalIsValidProp(isValidProp), config = { ...useContext(MotionConfigContext), ...config }, config.isStatic = useConstant(() => config.isStatic);
  const context = useMemo(() => config, [
    JSON.stringify(config.transition),
    config.transformPagePoint,
    config.reducedMotion
  ]);
  return jsx(MotionConfigContext.Provider, { value: context, children: children2 });
}
function LazyMotion({ children: children2, features, strict = !1 }) {
  const [, setIsLoaded] = useState(!isLazyBundle(features)), loadedRenderer = useRef(void 0);
  if (!isLazyBundle(features)) {
    const { renderer, ...loadedFeatures } = features;
    loadedRenderer.current = renderer, loadFeatures(loadedFeatures);
  }
  return useEffect(() => {
    isLazyBundle(features) && features().then(({ renderer, ...loadedFeatures }) => {
      loadFeatures(loadedFeatures), loadedRenderer.current = renderer, setIsLoaded(!0);
    });
  }, []), jsx(LazyContext.Provider, { value: { renderer: loadedRenderer.current, strict }, children: children2 });
}
function isLazyBundle(features) {
  return typeof features == "function";
}
const DeprecatedLayoutGroupContext = createContext(null);
function useIsMounted() {
  const isMounted = useRef(!1);
  return useIsomorphicLayoutEffect$1(() => (isMounted.current = !0, () => {
    isMounted.current = !1;
  }), []), isMounted;
}
function useForceUpdate() {
  const isMounted = useIsMounted(), [forcedRenderCount, setForcedRenderCount] = useState(0), forceRender = useCallback(() => {
    isMounted.current && setForcedRenderCount(forcedRenderCount + 1);
  }, [forcedRenderCount]);
  return [useCallback(() => frame.postRender(forceRender), [forceRender]), forcedRenderCount];
}
const notify = (node2) => !node2.isLayoutDirty && node2.willUpdate(!1);
function nodeGroup() {
  const nodes = /* @__PURE__ */ new Set(), subscriptions = /* @__PURE__ */ new WeakMap(), dirtyAll = () => nodes.forEach(notify);
  return {
    add: (node2) => {
      nodes.add(node2), subscriptions.set(node2, node2.addEventListener("willUpdate", dirtyAll));
    },
    remove: (node2) => {
      nodes.delete(node2);
      const unsubscribe = subscriptions.get(node2);
      unsubscribe && (unsubscribe(), subscriptions.delete(node2)), dirtyAll();
    },
    dirty: dirtyAll
  };
}
const shouldInheritGroup = (inherit2) => inherit2 === !0, shouldInheritId = (inherit2) => shouldInheritGroup(inherit2 === !0) || inherit2 === "id", LayoutGroup = ({ children: children2, id: id2, inherit: inherit2 = !0 }) => {
  const layoutGroupContext = useContext(LayoutGroupContext), deprecatedLayoutGroupContext = useContext(DeprecatedLayoutGroupContext), [forceRender, key] = useForceUpdate(), context = useRef(null), upstreamId = layoutGroupContext.id || deprecatedLayoutGroupContext;
  context.current === null && (shouldInheritId(inherit2) && upstreamId && (id2 = id2 ? upstreamId + "-" + id2 : upstreamId), context.current = {
    id: id2,
    group: shouldInheritGroup(inherit2) && layoutGroupContext.group || nodeGroup()
  });
  const memoizedContext = useMemo(() => ({ ...context.current, forceRender }), [key]);
  return jsx(LayoutGroupContext.Provider, { value: memoizedContext, children: children2 });
}, domAnimation = {
  renderer: createDomVisualElement,
  ...animations,
  ...gestureAnimations
}, domMax = {
  ...domAnimation,
  ...drag,
  ...layout$3
};
function useMotionValue(initial) {
  const value = useConstant(() => motionValue(initial)), { isStatic } = useContext(MotionConfigContext);
  if (isStatic) {
    const [, setLatest] = useState(initial);
    useEffect(() => value.on("change", setLatest), []);
  }
  return value;
}
function resolveElements(elements, scope, selectorCache) {
  var _a4;
  if (typeof elements == "string") {
    let root2 = document;
    scope && (invariant(!!scope.current), root2 = scope.current), selectorCache ? ((_a4 = selectorCache[elements]) !== null && _a4 !== void 0 || (selectorCache[elements] = root2.querySelectorAll(elements)), elements = selectorCache[elements]) : elements = root2.querySelectorAll(elements);
  } else elements instanceof Element && (elements = [elements]);
  return Array.from(elements || []);
}
function useUnmountEffect$1(callback) {
  return useEffect(() => () => callback(), []);
}
function createGeneratorEasing(options, scale2 = 100, createGenerator) {
  const generator = createGenerator({ ...options, keyframes: [0, scale2] }), duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
  return {
    type: "keyframes",
    ease: (progress2) => generator.next(duration * progress2).value / scale2,
    duration: millisecondsToSeconds(duration)
  };
}
function isDOMKeyframes(keyframes2) {
  return typeof keyframes2 == "object" && !Array.isArray(keyframes2);
}
function resolveSubjects(subject, keyframes2, scope, selectorCache) {
  return typeof subject == "string" && isDOMKeyframes(keyframes2) ? resolveElements(subject, scope, selectorCache) : subject instanceof NodeList ? Array.from(subject) : Array.isArray(subject) ? subject : [subject];
}
function calcNextTime(current, next, prev, labels) {
  var _a4;
  return typeof next == "number" ? next : next.startsWith("-") || next.startsWith("+") ? Math.max(0, current + parseFloat(next)) : next === "<" ? prev : (_a4 = labels.get(next)) !== null && _a4 !== void 0 ? _a4 : current;
}
const wrap = (min2, max2, v2) => {
  const rangeSize = max2 - min2;
  return ((v2 - min2) % rangeSize + rangeSize) % rangeSize + min2;
};
function getEasingForSegment(easing, i2) {
  return isEasingArray(easing) ? easing[wrap(0, easing.length, i2)] : easing;
}
function eraseKeyframes(sequence, startTime, endTime) {
  for (let i2 = 0; i2 < sequence.length; i2++) {
    const keyframe = sequence[i2];
    keyframe.at > startTime && keyframe.at < endTime && (removeItem(sequence, keyframe), i2--);
  }
}
function addKeyframes(sequence, keyframes2, easing, offset2, startTime, endTime) {
  eraseKeyframes(sequence, startTime, endTime);
  for (let i2 = 0; i2 < keyframes2.length; i2++)
    sequence.push({
      value: keyframes2[i2],
      at: mixNumber$1(startTime, endTime, offset2[i2]),
      easing: getEasingForSegment(easing, i2)
    });
}
function compareByTime(a2, b2) {
  return a2.at === b2.at ? a2.value === null ? 1 : b2.value === null ? -1 : 0 : a2.at - b2.at;
}
const defaultSegmentEasing = "easeInOut";
function createAnimationsFromSequence(sequence, { defaultTransition: defaultTransition2 = {}, ...sequenceTransition } = {}, scope, generators2) {
  const defaultDuration = defaultTransition2.duration || 0.3, animationDefinitions = /* @__PURE__ */ new Map(), sequences = /* @__PURE__ */ new Map(), elementCache = {}, timeLabels = /* @__PURE__ */ new Map();
  let prevTime = 0, currentTime = 0, totalDuration = 0;
  for (let i2 = 0; i2 < sequence.length; i2++) {
    const segment = sequence[i2];
    if (typeof segment == "string") {
      timeLabels.set(segment, currentTime);
      continue;
    } else if (!Array.isArray(segment)) {
      timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));
      continue;
    }
    let [subject, keyframes2, transition = {}] = segment;
    transition.at !== void 0 && (currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels));
    let maxDuration2 = 0;
    const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numSubjects = 0) => {
      const valueKeyframesAsList = keyframesAsList(valueKeyframes), { delay: delay2 = 0, times = defaultOffset(valueKeyframesAsList), type = "keyframes", ...remainingTransition } = valueTransition;
      let { ease: ease2 = defaultTransition2.ease || "easeOut", duration } = valueTransition;
      const calculatedDelay = typeof delay2 == "function" ? delay2(elementIndex, numSubjects) : delay2, numKeyframes = valueKeyframesAsList.length, createGenerator = isGenerator(type) ? type : generators2 == null ? void 0 : generators2[type];
      if (numKeyframes <= 2 && createGenerator) {
        let absoluteDelta = 100;
        if (numKeyframes === 2 && isNumberKeyframesArray(valueKeyframesAsList)) {
          const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];
          absoluteDelta = Math.abs(delta);
        }
        const springTransition = { ...remainingTransition };
        duration !== void 0 && (springTransition.duration = secondsToMilliseconds(duration));
        const springEasing = createGeneratorEasing(springTransition, absoluteDelta, createGenerator);
        ease2 = springEasing.ease, duration = springEasing.duration;
      }
      duration ?? (duration = defaultDuration);
      const startTime = currentTime + calculatedDelay, targetTime = startTime + duration;
      times.length === 1 && times[0] === 0 && (times[1] = 1);
      const remainder = times.length - valueKeyframesAsList.length;
      remainder > 0 && fillOffset(times, remainder), valueKeyframesAsList.length === 1 && valueKeyframesAsList.unshift(null), addKeyframes(valueSequence, valueKeyframesAsList, ease2, times, startTime, targetTime), maxDuration2 = Math.max(calculatedDelay + duration, maxDuration2), totalDuration = Math.max(targetTime, totalDuration);
    };
    if (isMotionValue(subject)) {
      const subjectSequence = getSubjectSequence(subject, sequences);
      resolveValueSequence(keyframes2, transition, getValueSequence("default", subjectSequence));
    } else {
      const subjects = resolveSubjects(subject, keyframes2, scope, elementCache), numSubjects = subjects.length;
      for (let subjectIndex = 0; subjectIndex < numSubjects; subjectIndex++) {
        keyframes2 = keyframes2, transition = transition;
        const thisSubject = subjects[subjectIndex], subjectSequence = getSubjectSequence(thisSubject, sequences);
        for (const key in keyframes2)
          resolveValueSequence(keyframes2[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), subjectIndex, numSubjects);
      }
    }
    prevTime = currentTime, currentTime += maxDuration2;
  }
  return sequences.forEach((valueSequences, element) => {
    for (const key in valueSequences) {
      const valueSequence = valueSequences[key];
      valueSequence.sort(compareByTime);
      const keyframes2 = [], valueOffset = [], valueEasing = [];
      for (let i2 = 0; i2 < valueSequence.length; i2++) {
        const { at, value, easing } = valueSequence[i2];
        keyframes2.push(value), valueOffset.push(progress(0, totalDuration, at)), valueEasing.push(easing || "easeOut");
      }
      valueOffset[0] !== 0 && (valueOffset.unshift(0), keyframes2.unshift(keyframes2[0]), valueEasing.unshift(defaultSegmentEasing)), valueOffset[valueOffset.length - 1] !== 1 && (valueOffset.push(1), keyframes2.push(null)), animationDefinitions.has(element) || animationDefinitions.set(element, {
        keyframes: {},
        transition: {}
      });
      const definition = animationDefinitions.get(element);
      definition.keyframes[key] = keyframes2, definition.transition[key] = {
        ...defaultTransition2,
        duration: totalDuration,
        ease: valueEasing,
        times: valueOffset,
        ...sequenceTransition
      };
    }
  }), animationDefinitions;
}
function getSubjectSequence(subject, sequences) {
  return !sequences.has(subject) && sequences.set(subject, {}), sequences.get(subject);
}
function getValueSequence(name, sequences) {
  return sequences[name] || (sequences[name] = []), sequences[name];
}
function keyframesAsList(keyframes2) {
  return Array.isArray(keyframes2) ? keyframes2 : [keyframes2];
}
function getValueTransition(transition, key) {
  return transition && transition[key] ? {
    ...transition,
    ...transition[key]
  } : { ...transition };
}
const isNumber = (keyframe) => typeof keyframe == "number", isNumberKeyframesArray = (keyframes2) => keyframes2.every(isNumber);
function isObjectKey(key, object2) {
  return key in object2;
}
class ObjectVisualElement extends VisualElement {
  constructor() {
    super(...arguments), this.type = "object";
  }
  readValueFromInstance(instance, key) {
    if (isObjectKey(key, instance)) {
      const value = instance[key];
      if (typeof value == "string" || typeof value == "number")
        return value;
    }
  }
  getBaseTargetFromProps() {
  }
  removeValueFromRenderState(key, renderState) {
    delete renderState.output[key];
  }
  measureInstanceViewportBox() {
    return createBox();
  }
  build(renderState, latestValues) {
    Object.assign(renderState.output, latestValues);
  }
  renderInstance(instance, { output }) {
    Object.assign(instance, output);
  }
  sortInstanceNodePosition() {
    return 0;
  }
}
function createDOMVisualElement(element) {
  const options = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        transform: {},
        transformOrigin: {},
        style: {},
        vars: {},
        attrs: {}
      },
      latestValues: {}
    }
  }, node2 = isSVGElement(element) ? new SVGVisualElement(options) : new HTMLVisualElement(options);
  node2.mount(element), visualElementStore.set(element, node2);
}
function createObjectVisualElement(subject) {
  const options = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        output: {}
      },
      latestValues: {}
    }
  }, node2 = new ObjectVisualElement(options);
  node2.mount(subject), visualElementStore.set(subject, node2);
}
function isSingleValue(subject, keyframes2) {
  return isMotionValue(subject) || typeof subject == "number" || typeof subject == "string" && !isDOMKeyframes(keyframes2);
}
function animateSubject(subject, keyframes2, options, scope) {
  const animations2 = [];
  if (isSingleValue(subject, keyframes2))
    animations2.push(animateSingleValue(subject, isDOMKeyframes(keyframes2) && keyframes2.default || keyframes2, options && (options.default || options)));
  else {
    const subjects = resolveSubjects(subject, keyframes2, scope), numSubjects = subjects.length;
    for (let i2 = 0; i2 < numSubjects; i2++) {
      const thisSubject = subjects[i2], createVisualElement = thisSubject instanceof Element ? createDOMVisualElement : createObjectVisualElement;
      visualElementStore.has(thisSubject) || createVisualElement(thisSubject);
      const visualElement = visualElementStore.get(thisSubject), transition = { ...options };
      "delay" in transition && typeof transition.delay == "function" && (transition.delay = transition.delay(i2, numSubjects)), animations2.push(...animateTarget(visualElement, { ...keyframes2, transition }, {}));
    }
  }
  return animations2;
}
function animateSequence(sequence, options, scope) {
  const animations2 = [];
  return createAnimationsFromSequence(sequence, options, scope, { spring }).forEach(({ keyframes: keyframes2, transition }, subject) => {
    animations2.push(...animateSubject(subject, keyframes2, transition));
  }), animations2;
}
function isSequence(value) {
  return Array.isArray(value) && Array.isArray(value[0]);
}
function createScopedAnimate(scope) {
  function scopedAnimate(subjectOrSequence, optionsOrKeyframes, options) {
    let animations2 = [];
    isSequence(subjectOrSequence) ? animations2 = animateSequence(subjectOrSequence, optionsOrKeyframes, scope) : animations2 = animateSubject(subjectOrSequence, optionsOrKeyframes, options, scope);
    const animation = new GroupPlaybackControls(animations2);
    return scope && scope.animations.push(animation), animation;
  }
  return scopedAnimate;
}
function useAnimate() {
  const scope = useConstant(() => ({
    current: null,
    // Will be hydrated by React
    animations: []
  })), animate = useConstant(() => createScopedAnimate(scope));
  return useUnmountEffect$1(() => {
    scope.animations.forEach((animation) => animation.stop());
  }), [scope, animate];
}
class DragControls {
  constructor() {
    this.componentControls = /* @__PURE__ */ new Set();
  }
  /**
   * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.
   *
   * @internal
   */
  subscribe(controls) {
    return this.componentControls.add(controls), () => this.componentControls.delete(controls);
  }
  /**
   * Start a drag gesture on every `motion` component that has this set of drag controls
   * passed into it via the `dragControls` prop.
   *
   * ```jsx
   * dragControls.start(e, {
   *   snapToCursor: true
   * })
   * ```
   *
   * @param event - PointerEvent
   * @param options - Options
   *
   * @public
   */
  start(event, options) {
    this.componentControls.forEach((controls) => {
      controls.start(event.nativeEvent || event, options);
    });
  }
}
const createDragControls = () => new DragControls();
function useDragControls() {
  return useConstant(createDragControls);
}
function useSyncedRef(value) {
  const ref = useRef(value);
  return ref.current = value, useMemo(() => Object.freeze({
    get current() {
      return ref.current;
    }
  }), []);
}
function useUnmountEffect(effect) {
  const effectRef = useSyncedRef(effect);
  useEffect(() => () => {
    effectRef.current();
  }, []);
}
function useDebouncedCallback(callback, deps, delay2, maxWait = 0) {
  const timeout2 = useRef(), waitTimeout = useRef(), cb = useRef(callback), lastCall = useRef(), clear = () => {
    timeout2.current && (clearTimeout(timeout2.current), timeout2.current = void 0), waitTimeout.current && (clearTimeout(waitTimeout.current), waitTimeout.current = void 0);
  };
  return useUnmountEffect(clear), useEffect(() => {
    cb.current = callback;
  }, deps), useMemo(() => {
    const execute = () => {
      if (clear(), !lastCall.current)
        return;
      const context = lastCall.current;
      lastCall.current = void 0, cb.current.apply(context.this, context.args);
    }, wrapped = function(...args) {
      timeout2.current && clearTimeout(timeout2.current), lastCall.current = { args, this: this }, timeout2.current = setTimeout(execute, delay2), maxWait > 0 && !waitTimeout.current && (waitTimeout.current = setTimeout(execute, maxWait));
    };
    return Object.defineProperties(wrapped, {
      length: { value: callback.length },
      name: { value: `${callback.name || "anonymous"}__debounced__${delay2}` }
    }), wrapped;
  }, [delay2, maxWait, ...deps]);
}
const noop$1 = () => {
}, isBrowser = typeof window < "u" && typeof navigator < "u" && typeof document < "u", basicDepsComparator = (d1, d2) => {
  if (d1 === d2)
    return !0;
  if (d1.length !== d2.length)
    return !1;
  for (const [i2, element] of d1.entries())
    if (element !== d2[i2])
      return !1;
  return !0;
};
function useCustomCompareEffect(callback, deps, comparator = basicDepsComparator, effectHook = useEffect, ...effectHookRestArgs) {
  const dependencies = useRef();
  (dependencies.current === void 0 || isBrowser && !comparator(dependencies.current, deps)) && (dependencies.current = deps), effectHook(callback, dependencies.current, ...effectHookRestArgs);
}
function useDebouncedEffect(callback, deps, delay2, maxWait = 0) {
  useEffect(useDebouncedCallback(callback, deps, delay2, maxWait), deps);
}
var compareDates = function(a2, b2) {
  return a2.getTime() === b2.getTime();
}, compareRegexps = function(a2, b2) {
  return a2.source === b2.source && a2.flags === b2.flags;
}, compareArrays = function(a2, b2, equal) {
  var l2 = a2.length;
  if (l2 !== b2.length)
    return !1;
  for (; l2-- && equal(a2[l2], b2[l2]); )
    ;
  return l2 === -1;
}, compareMaps = function(a2, b2, equal) {
  if (a2.size !== b2.size)
    return !1;
  for (var it = a2.entries(), i2; !(i2 = it.next()).done; )
    if (!b2.has(i2.value[0]) || !equal(i2.value[1], b2.get(i2.value[0])))
      return !1;
  return !0;
}, compareSets = function(a2, b2) {
  if (a2.size !== b2.size)
    return !1;
  for (var it = a2.values(), i2; !(i2 = it.next()).done; )
    if (!b2.has(i2.value))
      return !1;
  return !0;
}, compareDataViews = function(a2, b2) {
  var l2 = a2.byteLength;
  if (l2 !== b2.byteLength)
    return !1;
  for (; l2-- && a2.getInt8(l2) === b2.getInt8(l2); )
    ;
  return l2 === -1;
}, compareArrayBuffers = function(a2, b2) {
  var l2 = a2.length;
  if (l2 !== b2.length)
    return !1;
  for (; l2-- && a2[l2] === b2[l2]; )
    ;
  return l2 === -1;
}, hasOwnProperty$1 = Object.prototype.hasOwnProperty, oKeys = Object.keys, compareObjects = function(a2, b2, equal) {
  var i2, len = 0;
  for (i2 in a2)
    if (hasOwnProperty$1.call(a2, i2) && (len++, !hasOwnProperty$1.call(b2, i2) || !equal(a2[i2], b2[i2])))
      return !1;
  return oKeys(b2).length === len;
}, _a = Object.prototype, valueOf = _a.valueOf, toString$1 = _a.toString, isEqual = function(a2, b2) {
  if (a2 === b2)
    return !0;
  if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
    var ctor = a2.constructor;
    return ctor !== b2.constructor ? !1 : ctor === Array ? compareArrays(a2, b2, isEqual) : ctor === Date ? compareDates(a2, b2) : ctor === RegExp ? compareRegexps(a2, b2) : ctor === Map && a2 instanceof Map && b2 instanceof Map ? compareMaps(a2, b2, isEqual) : ctor === Set && a2 instanceof Set && b2 instanceof Set ? compareSets(a2, b2) : ctor === DataView ? compareDataViews(a2, b2) : ctor === ArrayBuffer ? compareArrayBuffers(new Uint8Array(a2), new Uint8Array(b2)) : ArrayBuffer.isView(a2) && ArrayBuffer.isView(b2) ? compareArrayBuffers(a2, b2) : a2.valueOf !== valueOf ? a2.valueOf() === b2.valueOf() : a2.toString !== toString$1 ? a2.toString() === b2.toString() : compareObjects(a2, b2, isEqual);
  }
  return a2 !== a2 && b2 !== b2;
};
function useDeepCompareEffect(callback, deps, effectHook = useEffect, ...effectHookRestArgs) {
  useCustomCompareEffect(callback, deps, isEqual, effectHook, ...effectHookRestArgs);
}
function useFirstMountState() {
  const isFirstMount = useRef(!0);
  return useEffect(() => {
    isFirstMount.current = !1;
  }, []), isFirstMount.current;
}
const useIsomorphicLayoutEffect = isBrowser ? useLayoutEffect : useEffect;
function useUpdateEffect$1(effect, deps) {
  const isFirstMount = useFirstMountState();
  useEffect(isFirstMount ? noop$1 : effect, deps);
}
const noop = () => {
}, depsShallowEqual = (d1, d2) => {
  if (d1 === d2)
    return !0;
  if (d1.length !== d2.length)
    return !1;
  for (const [i2, element] of d1.entries())
    if (!shallowEqual(element, d2[i2]))
      return !1;
  return !0;
};
function useUpdateEffect(callback, deps, equalityFn, effectHook) {
  const isFirstMount = useFirstMountState();
  useCustomCompareEffect(
    isFirstMount ? noop : callback,
    deps,
    equalityFn ?? depsShallowEqual,
    effectHook
  );
}
const useXYFlow = useReactFlow, useXYNodesData = useNodesData;
function useXYStore(selector2, equalityFn) {
  return useStore$2(
    selector2,
    shallowEqual
  );
}
const useXYStoreApi = useStoreApi, DEV = !1, __vite_import_meta_env__ = { BASE_URL: "/", DEV: !1, MODE: "production", PROD: !0, SSR: !1 }, trackedConnections = /* @__PURE__ */ new Map(), getTrackedConnectionState = (name) => {
  const api = trackedConnections.get(name);
  return api ? Object.fromEntries(
    Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])
  ) : {};
}, extractConnectionInformation = (store, extensionConnector, options) => {
  if (store === void 0)
    return {
      type: "untracked",
      connection: extensionConnector.connect(options)
    };
  const existingConnection = trackedConnections.get(options.name);
  if (existingConnection)
    return { type: "tracked", store, ...existingConnection };
  const newConnection = {
    connection: extensionConnector.connect(options),
    stores: {}
  };
  return trackedConnections.set(options.name, newConnection), { type: "tracked", store, ...newConnection };
}, devtoolsImpl = (fn, devtoolsOptions = {}) => (set2, get2, api) => {
  const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;
  let extensionConnector;
  try {
    extensionConnector = (enabled ?? (__vite_import_meta_env__ ? "production" : void 0) !== "production") && window.__REDUX_DEVTOOLS_EXTENSION__;
  } catch {
  }
  if (!extensionConnector)
    return (__vite_import_meta_env__ ? "production" : void 0) !== "production" && enabled && console.warn(
      "[zustand devtools middleware] Please install/enable Redux devtools extension"
    ), fn(set2, get2, api);
  const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);
  let isRecording = !0;
  api.setState = (state, replace, nameOrAction) => {
    const r2 = set2(state, replace);
    if (!isRecording) return r2;
    const action = nameOrAction === void 0 ? { type: anonymousActionType || "anonymous" } : typeof nameOrAction == "string" ? { type: nameOrAction } : nameOrAction;
    return store === void 0 ? (connection == null || connection.send(action, get2()), r2) : (connection == null || connection.send(
      {
        ...action,
        type: `${store}/${action.type}`
      },
      {
        ...getTrackedConnectionState(options.name),
        [store]: api.getState()
      }
    ), r2);
  };
  const setStateFromDevtools = (...a2) => {
    const originalIsRecording = isRecording;
    isRecording = !1, set2(...a2), isRecording = originalIsRecording;
  }, initialState = fn(api.setState, get2, api);
  if (connectionInformation.type === "untracked" ? connection == null || connection.init(initialState) : (connectionInformation.stores[connectionInformation.store] = api, connection == null || connection.init(
    Object.fromEntries(
      Object.entries(connectionInformation.stores).map(([key, store2]) => [
        key,
        key === connectionInformation.store ? initialState : store2.getState()
      ])
    )
  )), api.dispatchFromDevtools && typeof api.dispatch == "function") {
    let didWarnAboutReservedActionType = !1;
    const originalDispatch = api.dispatch;
    api.dispatch = (...a2) => {
      (__vite_import_meta_env__ ? "production" : void 0) !== "production" && a2[0].type === "__setState" && !didWarnAboutReservedActionType && (console.warn(
        '[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'
      ), didWarnAboutReservedActionType = !0), originalDispatch(...a2);
    };
  }
  return connection.subscribe((message) => {
    var _a4;
    switch (message.type) {
      case "ACTION":
        if (typeof message.payload != "string") {
          console.error(
            "[zustand devtools middleware] Unsupported action format"
          );
          return;
        }
        return parseJsonThen(
          message.payload,
          (action) => {
            if (action.type === "__setState") {
              if (store === void 0) {
                setStateFromDevtools(action.state);
                return;
              }
              Object.keys(action.state).length !== 1 && console.error(
                `
                    [zustand devtools middleware] Unsupported __setState action format. 
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `
              );
              const stateFromDevtools = action.state[store];
              if (stateFromDevtools == null)
                return;
              JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools) && setStateFromDevtools(stateFromDevtools);
              return;
            }
            api.dispatchFromDevtools && typeof api.dispatch == "function" && api.dispatch(action);
          }
        );
      case "DISPATCH":
        switch (message.payload.type) {
          case "RESET":
            return setStateFromDevtools(initialState), store === void 0 ? connection == null ? void 0 : connection.init(api.getState()) : connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
          case "COMMIT":
            if (store === void 0) {
              connection == null || connection.init(api.getState());
              return;
            }
            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
          case "ROLLBACK":
            return parseJsonThen(message.state, (state) => {
              if (store === void 0) {
                setStateFromDevtools(state), connection == null || connection.init(api.getState());
                return;
              }
              setStateFromDevtools(state[store]), connection == null || connection.init(getTrackedConnectionState(options.name));
            });
          case "JUMP_TO_STATE":
          case "JUMP_TO_ACTION":
            return parseJsonThen(message.state, (state) => {
              if (store === void 0) {
                setStateFromDevtools(state);
                return;
              }
              JSON.stringify(api.getState()) !== JSON.stringify(state[store]) && setStateFromDevtools(state[store]);
            });
          case "IMPORT_STATE": {
            const { nextLiftedState } = message.payload, lastComputedState = (_a4 = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a4.state;
            if (!lastComputedState) return;
            setStateFromDevtools(store === void 0 ? lastComputedState : lastComputedState[store]), connection == null || connection.send(
              null,
              // FIXME no-any
              nextLiftedState
            );
            return;
          }
          case "PAUSE_RECORDING":
            return isRecording = !isRecording;
        }
        return;
    }
  }), initialState;
}, devtools = devtoolsImpl, parseJsonThen = (stringified, f2) => {
  let parsed;
  try {
    parsed = JSON.parse(stringified);
  } catch (e2) {
    console.error(
      "[zustand devtools middleware] Could not parse the received json",
      e2
    );
  }
  parsed !== void 0 && f2(parsed);
}, subscribeWithSelectorImpl = (fn) => (set2, get2, api) => {
  const origSubscribe = api.subscribe;
  return api.subscribe = (selector2, optListener, options) => {
    let listener = selector2;
    if (optListener) {
      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;
      let currentSlice = selector2(api.getState());
      listener = (state) => {
        const nextSlice = selector2(state);
        if (!equalityFn(currentSlice, nextSlice)) {
          const previousSlice = currentSlice;
          optListener(currentSlice = nextSlice, previousSlice);
        }
      }, options != null && options.fireImmediately && optListener(currentSlice, currentSlice);
    }
    return origSubscribe(listener);
  }, fn(set2, get2, api);
}, subscribeWithSelector = subscribeWithSelectorImpl;
class VectorImpl {
  constructor(x2, y2) {
    this.x = x2, this.y = y2;
  }
  static create(position2) {
    return new VectorImpl(position2.x, position2.y);
  }
  static add(a2, b2) {
    return { x: a2.x + b2.x, y: a2.y + b2.y };
  }
  static sub(a2, b2) {
    return { x: a2.x - b2.x, y: a2.y - b2.y };
  }
  static mul(a2, b2) {
    return { x: a2.x * b2, y: a2.y * b2 };
  }
  static dot(a2, b2) {
    return a2.x * b2.x + a2.y * b2.y;
  }
  static cross(a2, b2) {
    return new VectorImpl(a2.y * b2.x - a2.x * b2.y, a2.x * b2.y - a2.y * b2.x);
  }
  static setLength(a2, length) {
    return vector(a2).setLength(length);
  }
  add(b2) {
    return new VectorImpl(this.x + b2.x, this.y + b2.y);
  }
  sub(b2) {
    return new VectorImpl(this.x - b2.x, this.y - b2.y);
  }
  mul(b2) {
    return new VectorImpl(this.x * b2, this.y * b2);
  }
  dot(b2) {
    return this.x * b2.x + this.y * b2.y;
  }
  cross(b2) {
    return new VectorImpl(this.y * b2.x - this.x * b2.y, this.x * b2.y - this.y * b2.x);
  }
  abs() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  setLength(length) {
    return this.mul(length / this.abs());
  }
}
function vector(source) {
  return VectorImpl.create(source);
}
const ZIndexes$2 = {
  Compound: 2,
  Edge: 4,
  Element: 6
}, MinZoom = 0.1, MaxZoom = 2;
function useMantinePortalProps() {
  const target = useDiagramState((s2) => s2.getContainer());
  return useMemo(() => target ? { portalProps: { target }, withinPortal: !0 } : { withinPortal: !1 }, [target]);
}
class Rect {
  constructor() {
    __publicField(this, "id");
    __publicField(this, "minX", 1 / 0);
    __publicField(this, "minY", 1 / 0);
    __publicField(this, "maxX", -1 / 0);
    __publicField(this, "maxY", -1 / 0);
  }
  get positionAbsolute() {
    return {
      x: this.minX,
      y: this.minY
    };
  }
  set positionAbsolute(pos) {
    this.maxX += pos.x - this.minX, this.maxY += pos.y - this.minY, this.minX = pos.x, this.minY = pos.y;
  }
  get dimensions() {
    return {
      width: this.maxX - this.minX,
      height: this.maxY - this.minY
    };
  }
  // Position relative to parent
  get position() {
    const positionAbsolute = this.positionAbsolute;
    if (!this.parent)
      return positionAbsolute;
    const parentPosition = this.parent.positionAbsolute;
    return {
      x: positionAbsolute.x - parentPosition.x,
      y: positionAbsolute.y - parentPosition.y
    };
  }
}
__publicField(Rect, "LeftPadding", 40), __publicField(Rect, "RightPadding", 40), __publicField(Rect, "TopPadding", 55), __publicField(Rect, "BottomPadding", 40);
class Compound extends Rect {
  constructor(xynode, parent = null) {
    super();
    __publicField(this, "children", []);
    this.parent = parent, this.id = xynode.id, parent && parent.children.push(this);
  }
}
class Leaf extends Rect {
  constructor(xynode, parent = null) {
    super(), this.parent = parent, this.id = xynode.id, this.positionAbsolute = xynode.internals.positionAbsolute;
    const { width: width2, height } = getNodeDimensions(xynode);
    this.maxX = this.minX + Math.ceil(width2), this.maxY = this.minY + Math.ceil(height), parent && parent.children.push(this);
  }
}
function createLayoutConstraints(xyflowApi, editingNodeIds) {
  var _a4;
  const { parentLookup, nodeLookup } = xyflowApi.getState(), rects = /* @__PURE__ */ new Map(), ancestorsOf = (nodeId) => {
    const ancestors = [], xynode = nodeLookup.get(nodeId);
    let parent = xynode == null ? void 0 : xynode.parentId, parentNode;
    for (; parent && (parentNode = nodeLookup.get(parent)); )
      ancestors.push(parentNode.id), parent = parentNode.parentId;
    return ancestors;
  }, ancestorsOfDraggingNodes = new Set(
    editingNodeIds.flatMap(ancestorsOf)
  ), traverse = new Array();
  for (const [, xynode] of nodeLookup)
    n$2(xynode.parentId) && traverse.push({
      xynode,
      parent: null
    });
  for (; traverse.length > 0; ) {
    const { xynode, parent } = traverse.shift(), shouldTraverse = !editingNodeIds.includes(xynode.id) && xynode.type === "compound" && ancestorsOfDraggingNodes.has(xynode.id), rect = shouldTraverse ? new Compound(xynode, parent) : new Leaf(xynode, parent);
    rects.set(xynode.id, rect), shouldTraverse && ((_a4 = parentLookup.get(xynode.id)) == null || _a4.forEach((child) => {
      traverse.push({
        xynode: child,
        parent: rect
      });
    }));
  }
  const rectsToUpdate = [...rects.values()];
  applyConstraints2(rectsToUpdate);
  function applyConstraints2(targets) {
    targets.filter((x2) => x2 instanceof Compound).forEach((r2) => {
      applyConstraints2(r2.children);
      const childrenBB = r2.children.reduce((acc, r22) => ({
        minX: Math.min(acc.minX, r22.minX),
        minY: Math.min(acc.minY, r22.minY),
        maxX: Math.max(acc.maxX, r22.maxX),
        maxY: Math.max(acc.maxY, r22.maxY)
      }), {
        minX: 1 / 0,
        minY: 1 / 0,
        maxX: -1 / 0,
        maxY: -1 / 0
      });
      r2.minX = childrenBB.minX - Rect.LeftPadding, r2.minY = childrenBB.minY - Rect.TopPadding, r2.maxX = childrenBB.maxX + Rect.RightPadding, r2.maxY = childrenBB.maxY + Rect.BottomPadding;
    });
  }
  function updateXYFlowNodes() {
    applyConstraints2(rectsToUpdate), xyflowApi.getState().triggerNodeChanges(
      rectsToUpdate.reduce((acc, r2) => (acc.push({
        id: r2.id,
        type: "position",
        dragging: !1,
        position: r2.position,
        positionAbsolute: r2.positionAbsolute
      }), r2 instanceof Compound && acc.push({
        id: r2.id,
        type: "dimensions",
        setAttributes: !0,
        dimensions: r2.dimensions
      }), acc), [])
    );
  }
  let animationFrameId = null;
  function onMove(updater) {
    rectsToUpdate.length !== 0 && (animationFrameId ?? (animationFrameId = requestAnimationFrame(() => {
      animationFrameId = null, updater(
        x$2(
          editingNodeIds,
          T$1((id2) => rects.has(id2) && nodeLookup.has(id2)),
          m$2((id2) => ({
            rect: nonNullable(rects.get(id2)),
            node: nonNullable(nodeLookup.get(id2))
          }))
        )
      ), updateXYFlowNodes();
    })));
  }
  return {
    updateXYFlowNodes,
    onMove
  };
}
function useLayoutConstraints() {
  const diagramApi = useDiagramStoreApi(), solverRef = useRef();
  return useMemo(() => ({
    onNodeDragStart: (_event, xynode) => {
      const { cancelSaveManualLayout, xystore } = diagramApi.getState(), { nodeLookup } = xystore.getState();
      cancelSaveManualLayout();
      const draggingNodes = x$2(
        Array.from(nodeLookup.values()),
        T$1((n2) => n2.dragging === !0 || n2.id === xynode.id || n2.selected === !0),
        T$1((n2) => n2.draggable !== !1),
        m$2((x2) => x2.id)
      );
      i$8(draggingNodes, 1) && (solverRef.current = createLayoutConstraints(xystore, draggingNodes));
    },
    onNodeDrag: () => {
      var _a4;
      (_a4 = solverRef.current) == null || _a4.onMove((nodes) => {
        nodes.forEach(({ rect, node: node2 }) => {
          rect.positionAbsolute = node2.internals.positionAbsolute;
        });
      });
    },
    onNodeDragStop: () => {
      var _a4;
      (_a4 = solverRef.current) == null || _a4.updateXYFlowNodes(), diagramApi.getState().scheduleSaveManualLayout(), solverRef.current = void 0;
    }
  }), [diagramApi]);
}
const { abs: abs$1, cos: cos$1, sin: sin$1, acos: acos$1, atan2, sqrt: sqrt$1, pow } = Math;
function crt(v2) {
  return v2 < 0 ? -pow(-v2, 1 / 3) : pow(v2, 1 / 3);
}
const pi$2 = Math.PI, tau$1 = 2 * pi$2, quart = pi$2 / 2, epsilon$2 = 1e-6, nMax = Number.MAX_SAFE_INTEGER || 9007199254740991, nMin = Number.MIN_SAFE_INTEGER || -9007199254740991, ZERO = { x: 0, y: 0, z: 0 }, utils = {
  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
  Tvalues: [
    -0.06405689286260563,
    0.06405689286260563,
    -0.1911188674736163,
    0.1911188674736163,
    -0.3150426796961634,
    0.3150426796961634,
    -0.4337935076260451,
    0.4337935076260451,
    -0.5454214713888396,
    0.5454214713888396,
    -0.6480936519369755,
    0.6480936519369755,
    -0.7401241915785544,
    0.7401241915785544,
    -0.820001985973903,
    0.820001985973903,
    -0.8864155270044011,
    0.8864155270044011,
    -0.9382745520027328,
    0.9382745520027328,
    -0.9747285559713095,
    0.9747285559713095,
    -0.9951872199970213,
    0.9951872199970213
  ],
  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
  Cvalues: [
    0.12793819534675216,
    0.12793819534675216,
    0.1258374563468283,
    0.1258374563468283,
    0.12167047292780339,
    0.12167047292780339,
    0.1155056680537256,
    0.1155056680537256,
    0.10744427011596563,
    0.10744427011596563,
    0.09761865210411388,
    0.09761865210411388,
    0.08619016153195327,
    0.08619016153195327,
    0.0733464814110803,
    0.0733464814110803,
    0.05929858491543678,
    0.05929858491543678,
    0.04427743881741981,
    0.04427743881741981,
    0.028531388628933663,
    0.028531388628933663,
    0.0123412297999872,
    0.0123412297999872
  ],
  arcfn: function(t2, derivativeFn) {
    const d2 = derivativeFn(t2);
    let l2 = d2.x * d2.x + d2.y * d2.y;
    return typeof d2.z < "u" && (l2 += d2.z * d2.z), sqrt$1(l2);
  },
  compute: function(t2, points, _3d) {
    if (t2 === 0)
      return points[0].t = 0, points[0];
    const order2 = points.length - 1;
    if (t2 === 1)
      return points[order2].t = 1, points[order2];
    const mt = 1 - t2;
    let p2 = points;
    if (order2 === 0)
      return points[0].t = t2, points[0];
    if (order2 === 1) {
      const ret = {
        x: mt * p2[0].x + t2 * p2[1].x,
        y: mt * p2[0].y + t2 * p2[1].y,
        t: t2
      };
      return _3d && (ret.z = mt * p2[0].z + t2 * p2[1].z), ret;
    }
    if (order2 < 4) {
      let mt2 = mt * mt, t22 = t2 * t2, a2, b2, c, d2 = 0;
      order2 === 2 ? (p2 = [p2[0], p2[1], p2[2], ZERO], a2 = mt2, b2 = mt * t2 * 2, c = t22) : order2 === 3 && (a2 = mt2 * mt, b2 = mt2 * t2 * 3, c = mt * t22 * 3, d2 = t2 * t22);
      const ret = {
        x: a2 * p2[0].x + b2 * p2[1].x + c * p2[2].x + d2 * p2[3].x,
        y: a2 * p2[0].y + b2 * p2[1].y + c * p2[2].y + d2 * p2[3].y,
        t: t2
      };
      return _3d && (ret.z = a2 * p2[0].z + b2 * p2[1].z + c * p2[2].z + d2 * p2[3].z), ret;
    }
    const dCpts = JSON.parse(JSON.stringify(points));
    for (; dCpts.length > 1; ) {
      for (let i2 = 0; i2 < dCpts.length - 1; i2++)
        dCpts[i2] = {
          x: dCpts[i2].x + (dCpts[i2 + 1].x - dCpts[i2].x) * t2,
          y: dCpts[i2].y + (dCpts[i2 + 1].y - dCpts[i2].y) * t2
        }, typeof dCpts[i2].z < "u" && (dCpts[i2].z = dCpts[i2].z + (dCpts[i2 + 1].z - dCpts[i2].z) * t2);
      dCpts.splice(dCpts.length - 1, 1);
    }
    return dCpts[0].t = t2, dCpts[0];
  },
  computeWithRatios: function(t2, points, ratios, _3d) {
    const mt = 1 - t2, r2 = ratios, p2 = points;
    let f1 = r2[0], f2 = r2[1], f3 = r2[2], f4 = r2[3], d2;
    if (f1 *= mt, f2 *= t2, p2.length === 2)
      return d2 = f1 + f2, {
        x: (f1 * p2[0].x + f2 * p2[1].x) / d2,
        y: (f1 * p2[0].y + f2 * p2[1].y) / d2,
        z: _3d ? (f1 * p2[0].z + f2 * p2[1].z) / d2 : !1,
        t: t2
      };
    if (f1 *= mt, f2 *= 2 * mt, f3 *= t2 * t2, p2.length === 3)
      return d2 = f1 + f2 + f3, {
        x: (f1 * p2[0].x + f2 * p2[1].x + f3 * p2[2].x) / d2,
        y: (f1 * p2[0].y + f2 * p2[1].y + f3 * p2[2].y) / d2,
        z: _3d ? (f1 * p2[0].z + f2 * p2[1].z + f3 * p2[2].z) / d2 : !1,
        t: t2
      };
    if (f1 *= mt, f2 *= 1.5 * mt, f3 *= 3 * mt, f4 *= t2 * t2 * t2, p2.length === 4)
      return d2 = f1 + f2 + f3 + f4, {
        x: (f1 * p2[0].x + f2 * p2[1].x + f3 * p2[2].x + f4 * p2[3].x) / d2,
        y: (f1 * p2[0].y + f2 * p2[1].y + f3 * p2[2].y + f4 * p2[3].y) / d2,
        z: _3d ? (f1 * p2[0].z + f2 * p2[1].z + f3 * p2[2].z + f4 * p2[3].z) / d2 : !1,
        t: t2
      };
  },
  derive: function(points, _3d) {
    const dpoints = [];
    for (let p2 = points, d2 = p2.length, c = d2 - 1; d2 > 1; d2--, c--) {
      const list2 = [];
      for (let j2 = 0, dpt; j2 < c; j2++)
        dpt = {
          x: c * (p2[j2 + 1].x - p2[j2].x),
          y: c * (p2[j2 + 1].y - p2[j2].y)
        }, _3d && (dpt.z = c * (p2[j2 + 1].z - p2[j2].z)), list2.push(dpt);
      dpoints.push(list2), p2 = list2;
    }
    return dpoints;
  },
  between: function(v2, m2, M) {
    return m2 <= v2 && v2 <= M || utils.approximately(v2, m2) || utils.approximately(v2, M);
  },
  approximately: function(a2, b2, precision) {
    return abs$1(a2 - b2) <= (precision || epsilon$2);
  },
  length: function(derivativeFn) {
    const len = utils.Tvalues.length;
    let sum = 0;
    for (let i2 = 0, t2; i2 < len; i2++)
      t2 = 0.5 * utils.Tvalues[i2] + 0.5, sum += utils.Cvalues[i2] * utils.arcfn(t2, derivativeFn);
    return 0.5 * sum;
  },
  map: function(v2, ds, de, ts, te) {
    const d1 = de - ds, d2 = te - ts, v22 = v2 - ds, r2 = v22 / d1;
    return ts + d2 * r2;
  },
  lerp: function(r2, v1, v2) {
    const ret = {
      x: v1.x + r2 * (v2.x - v1.x),
      y: v1.y + r2 * (v2.y - v1.y)
    };
    return v1.z !== void 0 && v2.z !== void 0 && (ret.z = v1.z + r2 * (v2.z - v1.z)), ret;
  },
  pointToString: function(p2) {
    let s2 = p2.x + "/" + p2.y;
    return typeof p2.z < "u" && (s2 += "/" + p2.z), s2;
  },
  pointsToString: function(points) {
    return "[" + points.map(utils.pointToString).join(", ") + "]";
  },
  copy: function(obj) {
    return JSON.parse(JSON.stringify(obj));
  },
  angle: function(o2, v1, v2) {
    const dx1 = v1.x - o2.x, dy1 = v1.y - o2.y, dx2 = v2.x - o2.x, dy2 = v2.y - o2.y, cross = dx1 * dy2 - dy1 * dx2, dot = dx1 * dx2 + dy1 * dy2;
    return atan2(cross, dot);
  },
  // round as string, to avoid rounding errors
  round: function(v2, d2) {
    const s2 = "" + v2, pos = s2.indexOf(".");
    return parseFloat(s2.substring(0, pos + 1 + d2));
  },
  dist: function(p1, p2) {
    const dx = p1.x - p2.x, dy = p1.y - p2.y;
    return sqrt$1(dx * dx + dy * dy);
  },
  closest: function(LUT, point2) {
    let mdist = pow(2, 63), mpos, d2;
    return LUT.forEach(function(p2, idx) {
      d2 = utils.dist(point2, p2), d2 < mdist && (mdist = d2, mpos = idx);
    }), { mdist, mpos };
  },
  abcratio: function(t2, n2) {
    if (n2 !== 2 && n2 !== 3)
      return !1;
    if (typeof t2 > "u")
      t2 = 0.5;
    else if (t2 === 0 || t2 === 1)
      return t2;
    const bottom = pow(t2, n2) + pow(1 - t2, n2), top = bottom - 1;
    return abs$1(top / bottom);
  },
  projectionratio: function(t2, n2) {
    if (n2 !== 2 && n2 !== 3)
      return !1;
    if (typeof t2 > "u")
      t2 = 0.5;
    else if (t2 === 0 || t2 === 1)
      return t2;
    const top = pow(1 - t2, n2), bottom = pow(t2, n2) + top;
    return top / bottom;
  },
  lli8: function(x1, y1, x2, y2, x3, y3, x4, y4) {
    const nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4), ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4), d2 = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    return d2 == 0 ? !1 : { x: nx / d2, y: ny / d2 };
  },
  lli4: function(p1, p2, p3, p4) {
    const x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y, x3 = p3.x, y3 = p3.y, x4 = p4.x, y4 = p4.y;
    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);
  },
  lli: function(v1, v2) {
    return utils.lli4(v1, v1.c, v2, v2.c);
  },
  makeline: function(p1, p2) {
    return new Bezier(
      p1.x,
      p1.y,
      (p1.x + p2.x) / 2,
      (p1.y + p2.y) / 2,
      p2.x,
      p2.y
    );
  },
  findbbox: function(sections) {
    let mx = nMax, my = nMax, MX = nMin, MY = nMin;
    return sections.forEach(function(s2) {
      const bbox = s2.bbox();
      mx > bbox.x.min && (mx = bbox.x.min), my > bbox.y.min && (my = bbox.y.min), MX < bbox.x.max && (MX = bbox.x.max), MY < bbox.y.max && (MY = bbox.y.max);
    }), {
      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },
      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my }
    };
  },
  shapeintersections: function(s1, bbox1, s2, bbox2, curveIntersectionThreshold) {
    if (!utils.bboxoverlap(bbox1, bbox2)) return [];
    const intersections = [], a1 = [s1.startcap, s1.forward, s1.back, s1.endcap], a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];
    return a1.forEach(function(l1) {
      l1.virtual || a2.forEach(function(l2) {
        if (l2.virtual) return;
        const iss = l1.intersects(l2, curveIntersectionThreshold);
        iss.length > 0 && (iss.c1 = l1, iss.c2 = l2, iss.s1 = s1, iss.s2 = s2, intersections.push(iss));
      });
    }), intersections;
  },
  makeshape: function(forward, back, curveIntersectionThreshold) {
    const bpl = back.points.length, fpl = forward.points.length, start2 = utils.makeline(back.points[bpl - 1], forward.points[0]), end = utils.makeline(forward.points[fpl - 1], back.points[0]), shape = {
      startcap: start2,
      forward,
      back,
      endcap: end,
      bbox: utils.findbbox([start2, forward, back, end])
    };
    return shape.intersections = function(s2) {
      return utils.shapeintersections(
        shape,
        shape.bbox,
        s2,
        s2.bbox,
        curveIntersectionThreshold
      );
    }, shape;
  },
  getminmax: function(curve2, d2, list2) {
    if (!list2) return { min: 0, max: 0 };
    let min2 = nMax, max2 = nMin, t2, c;
    list2.indexOf(0) === -1 && (list2 = [0].concat(list2)), list2.indexOf(1) === -1 && list2.push(1);
    for (let i2 = 0, len = list2.length; i2 < len; i2++)
      t2 = list2[i2], c = curve2.get(t2), c[d2] < min2 && (min2 = c[d2]), c[d2] > max2 && (max2 = c[d2]);
    return { min: min2, mid: (min2 + max2) / 2, max: max2, size: max2 - min2 };
  },
  align: function(points, line) {
    const tx = line.p1.x, ty = line.p1.y, a2 = -atan2(line.p2.y - ty, line.p2.x - tx), d2 = function(v2) {
      return {
        x: (v2.x - tx) * cos$1(a2) - (v2.y - ty) * sin$1(a2),
        y: (v2.x - tx) * sin$1(a2) + (v2.y - ty) * cos$1(a2)
      };
    };
    return points.map(d2);
  },
  roots: function(points, line) {
    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };
    const order2 = points.length - 1, aligned = utils.align(points, line), reduce = function(t2) {
      return 0 <= t2 && t2 <= 1;
    };
    if (order2 === 2) {
      const a3 = aligned[0].y, b3 = aligned[1].y, c2 = aligned[2].y, d3 = a3 - 2 * b3 + c2;
      if (d3 !== 0) {
        const m1 = -sqrt$1(b3 * b3 - a3 * c2), m2 = -a3 + b3, v12 = -(m1 + m2) / d3, v2 = -(-m1 + m2) / d3;
        return [v12, v2].filter(reduce);
      } else if (b3 !== c2 && d3 === 0)
        return [(2 * b3 - c2) / (2 * b3 - 2 * c2)].filter(reduce);
      return [];
    }
    const pa = aligned[0].y, pb = aligned[1].y, pc = aligned[2].y, pd = aligned[3].y;
    let d2 = -pa + 3 * pb - 3 * pc + pd, a2 = 3 * pa - 6 * pb + 3 * pc, b2 = -3 * pa + 3 * pb, c = pa;
    if (utils.approximately(d2, 0)) {
      if (utils.approximately(a2, 0))
        return utils.approximately(b2, 0) ? [] : [-c / b2].filter(reduce);
      const q3 = sqrt$1(b2 * b2 - 4 * a2 * c), a22 = 2 * a2;
      return [(q3 - b2) / a22, (-b2 - q3) / a22].filter(reduce);
    }
    a2 /= d2, b2 /= d2, c /= d2;
    const p2 = (3 * b2 - a2 * a2) / 3, p3 = p2 / 3, q2 = (2 * a2 * a2 * a2 - 9 * a2 * b2 + 27 * c) / 27, q22 = q2 / 2, discriminant = q22 * q22 + p3 * p3 * p3;
    let u1, v1, x1, x2, x3;
    if (discriminant < 0) {
      const mp3 = -p2 / 3, mp33 = mp3 * mp3 * mp3, r2 = sqrt$1(mp33), t2 = -q2 / (2 * r2), cosphi = t2 < -1 ? -1 : t2 > 1 ? 1 : t2, phi = acos$1(cosphi), crtr = crt(r2), t1 = 2 * crtr;
      return x1 = t1 * cos$1(phi / 3) - a2 / 3, x2 = t1 * cos$1((phi + tau$1) / 3) - a2 / 3, x3 = t1 * cos$1((phi + 2 * tau$1) / 3) - a2 / 3, [x1, x2, x3].filter(reduce);
    } else {
      if (discriminant === 0)
        return u1 = q22 < 0 ? crt(-q22) : -crt(q22), x1 = 2 * u1 - a2 / 3, x2 = -u1 - a2 / 3, [x1, x2].filter(reduce);
      {
        const sd = sqrt$1(discriminant);
        return u1 = crt(-q22 + sd), v1 = crt(q22 + sd), [u1 - v1 - a2 / 3].filter(reduce);
      }
    }
  },
  droots: function(p2) {
    if (p2.length === 3) {
      const a2 = p2[0], b2 = p2[1], c = p2[2], d2 = a2 - 2 * b2 + c;
      if (d2 !== 0) {
        const m1 = -sqrt$1(b2 * b2 - a2 * c), m2 = -a2 + b2, v1 = -(m1 + m2) / d2, v2 = -(-m1 + m2) / d2;
        return [v1, v2];
      } else if (b2 !== c && d2 === 0)
        return [(2 * b2 - c) / (2 * (b2 - c))];
      return [];
    }
    if (p2.length === 2) {
      const a2 = p2[0], b2 = p2[1];
      return a2 !== b2 ? [a2 / (a2 - b2)] : [];
    }
    return [];
  },
  curvature: function(t2, d1, d2, _3d, kOnly) {
    let num, dnm, adk, dk, k2 = 0, r2 = 0;
    const d3 = utils.compute(t2, d1), dd = utils.compute(t2, d2), qdsum = d3.x * d3.x + d3.y * d3.y;
    if (_3d ? (num = sqrt$1(
      pow(d3.y * dd.z - dd.y * d3.z, 2) + pow(d3.z * dd.x - dd.z * d3.x, 2) + pow(d3.x * dd.y - dd.x * d3.y, 2)
    ), dnm = pow(qdsum + d3.z * d3.z, 3 / 2)) : (num = d3.x * dd.y - d3.y * dd.x, dnm = pow(qdsum, 3 / 2)), num === 0 || dnm === 0)
      return { k: 0, r: 0 };
    if (k2 = num / dnm, r2 = dnm / num, !kOnly) {
      const pk = utils.curvature(t2 - 1e-3, d1, d2, _3d, !0).k, nk = utils.curvature(t2 + 1e-3, d1, d2, _3d, !0).k;
      dk = (nk - k2 + (k2 - pk)) / 2, adk = (abs$1(nk - k2) + abs$1(k2 - pk)) / 2;
    }
    return { k: k2, r: r2, dk, adk };
  },
  inflections: function(points) {
    if (points.length < 4) return [];
    const p2 = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }), a2 = p2[2].x * p2[1].y, b2 = p2[3].x * p2[1].y, c = p2[1].x * p2[2].y, d2 = p2[3].x * p2[2].y, v1 = 18 * (-3 * a2 + 2 * b2 + 3 * c - d2), v2 = 18 * (3 * a2 - b2 - 3 * c), v3 = 18 * (c - a2);
    if (utils.approximately(v1, 0)) {
      if (!utils.approximately(v2, 0)) {
        let t2 = -v3 / v2;
        if (0 <= t2 && t2 <= 1) return [t2];
      }
      return [];
    }
    const d22 = 2 * v1;
    if (utils.approximately(d22, 0)) return [];
    const trm = v2 * v2 - 4 * v1 * v3;
    if (trm < 0) return [];
    const sq = Math.sqrt(trm);
    return [(sq - v2) / d22, -(v2 + sq) / d22].filter(function(r2) {
      return 0 <= r2 && r2 <= 1;
    });
  },
  bboxoverlap: function(b1, b2) {
    const dims = ["x", "y"], len = dims.length;
    for (let i2 = 0, dim, l2, t2, d2; i2 < len; i2++)
      if (dim = dims[i2], l2 = b1[dim].mid, t2 = b2[dim].mid, d2 = (b1[dim].size + b2[dim].size) / 2, abs$1(l2 - t2) >= d2) return !1;
    return !0;
  },
  expandbox: function(bbox, _bbox) {
    _bbox.x.min < bbox.x.min && (bbox.x.min = _bbox.x.min), _bbox.y.min < bbox.y.min && (bbox.y.min = _bbox.y.min), _bbox.z && _bbox.z.min < bbox.z.min && (bbox.z.min = _bbox.z.min), _bbox.x.max > bbox.x.max && (bbox.x.max = _bbox.x.max), _bbox.y.max > bbox.y.max && (bbox.y.max = _bbox.y.max), _bbox.z && _bbox.z.max > bbox.z.max && (bbox.z.max = _bbox.z.max), bbox.x.mid = (bbox.x.min + bbox.x.max) / 2, bbox.y.mid = (bbox.y.min + bbox.y.max) / 2, bbox.z && (bbox.z.mid = (bbox.z.min + bbox.z.max) / 2), bbox.x.size = bbox.x.max - bbox.x.min, bbox.y.size = bbox.y.max - bbox.y.min, bbox.z && (bbox.z.size = bbox.z.max - bbox.z.min);
  },
  pairiteration: function(c1, c2, curveIntersectionThreshold) {
    const c1b = c1.bbox(), c2b = c2.bbox(), r2 = 1e5, threshold = curveIntersectionThreshold || 0.5;
    if (c1b.x.size + c1b.y.size < threshold && c2b.x.size + c2b.y.size < threshold)
      return [
        (r2 * (c1._t1 + c1._t2) / 2 | 0) / r2 + "/" + (r2 * (c2._t1 + c2._t2) / 2 | 0) / r2
      ];
    let cc1 = c1.split(0.5), cc2 = c2.split(0.5), pairs = [
      { left: cc1.left, right: cc2.left },
      { left: cc1.left, right: cc2.right },
      { left: cc1.right, right: cc2.right },
      { left: cc1.right, right: cc2.left }
    ];
    pairs = pairs.filter(function(pair) {
      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());
    });
    let results = [];
    return pairs.length === 0 || (pairs.forEach(function(pair) {
      results = results.concat(
        utils.pairiteration(pair.left, pair.right, threshold)
      );
    }), results = results.filter(function(v2, i2) {
      return results.indexOf(v2) === i2;
    })), results;
  },
  getccenter: function(p1, p2, p3) {
    const dx1 = p2.x - p1.x, dy1 = p2.y - p1.y, dx2 = p3.x - p2.x, dy2 = p3.y - p2.y, dx1p = dx1 * cos$1(quart) - dy1 * sin$1(quart), dy1p = dx1 * sin$1(quart) + dy1 * cos$1(quart), dx2p = dx2 * cos$1(quart) - dy2 * sin$1(quart), dy2p = dx2 * sin$1(quart) + dy2 * cos$1(quart), mx1 = (p1.x + p2.x) / 2, my1 = (p1.y + p2.y) / 2, mx2 = (p2.x + p3.x) / 2, my2 = (p2.y + p3.y) / 2, mx1n = mx1 + dx1p, my1n = my1 + dy1p, mx2n = mx2 + dx2p, my2n = my2 + dy2p, arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n), r2 = utils.dist(arc, p1);
    let s2 = atan2(p1.y - arc.y, p1.x - arc.x), m2 = atan2(p2.y - arc.y, p2.x - arc.x), e2 = atan2(p3.y - arc.y, p3.x - arc.x), _;
    return s2 < e2 ? ((s2 > m2 || m2 > e2) && (s2 += tau$1), s2 > e2 && (_ = e2, e2 = s2, s2 = _)) : e2 < m2 && m2 < s2 ? (_ = e2, e2 = s2, s2 = _) : e2 += tau$1, arc.s = s2, arc.e = e2, arc.r = r2, arc;
  },
  numberSort: function(a2, b2) {
    return a2 - b2;
  }
};
class PolyBezier {
  constructor(curves) {
    this.curves = [], this._3d = !1, curves && (this.curves = curves, this._3d = this.curves[0]._3d);
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return "[" + this.curves.map(function(curve2) {
      return utils.pointsToString(curve2.points);
    }).join(", ") + "]";
  }
  addCurve(curve2) {
    this.curves.push(curve2), this._3d = this._3d || curve2._3d;
  }
  length() {
    return this.curves.map(function(v2) {
      return v2.length();
    }).reduce(function(a2, b2) {
      return a2 + b2;
    });
  }
  curve(idx) {
    return this.curves[idx];
  }
  bbox() {
    const c = this.curves;
    for (var bbox = c[0].bbox(), i2 = 1; i2 < c.length; i2++)
      utils.expandbox(bbox, c[i2].bbox());
    return bbox;
  }
  offset(d2) {
    const offset2 = [];
    return this.curves.forEach(function(v2) {
      offset2.push(...v2.offset(d2));
    }), new PolyBezier(offset2);
  }
}
const { abs, min, max, cos, sin, acos, sqrt } = Math, pi$1 = Math.PI;
class Bezier {
  constructor(coords) {
    let args = coords && coords.forEach ? coords : Array.from(arguments).slice(), coordlen = !1;
    if (typeof args[0] == "object") {
      coordlen = args.length;
      const newargs = [];
      args.forEach(function(point3) {
        ["x", "y", "z"].forEach(function(d2) {
          typeof point3[d2] < "u" && newargs.push(point3[d2]);
        });
      }), args = newargs;
    }
    let higher = !1;
    const len = args.length;
    if (coordlen) {
      if (coordlen > 4) {
        if (arguments.length !== 1)
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        higher = !0;
      }
    } else if (len !== 6 && len !== 8 && len !== 9 && len !== 12 && arguments.length !== 1)
      throw new Error(
        "Only new Bezier(point[]) is accepted for 4th and higher order curves"
      );
    const _3d = this._3d = !higher && (len === 9 || len === 12) || coords && coords[0] && typeof coords[0].z < "u", points = this.points = [];
    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {
      var point2 = {
        x: args[idx],
        y: args[idx + 1]
      };
      _3d && (point2.z = args[idx + 2]), points.push(point2);
    }
    const order2 = this.order = points.length - 1, dims = this.dims = ["x", "y"];
    _3d && dims.push("z"), this.dimlen = dims.length;
    const aligned = utils.align(points, { p1: points[0], p2: points[order2] }), baselength = utils.dist(points[0], points[order2]);
    this._linear = aligned.reduce((t2, p2) => t2 + abs(p2.y), 0) < baselength / 50, this._lut = [], this._t1 = 0, this._t2 = 1, this.update();
  }
  static quadraticFromPoints(p1, p2, p3, t2) {
    if (typeof t2 > "u" && (t2 = 0.5), t2 === 0)
      return new Bezier(p2, p2, p3);
    if (t2 === 1)
      return new Bezier(p1, p2, p2);
    const abc = Bezier.getABC(2, p1, p2, p3, t2);
    return new Bezier(p1, abc.A, p3);
  }
  static cubicFromPoints(S2, B2, E2, t2, d1) {
    typeof t2 > "u" && (t2 = 0.5);
    const abc = Bezier.getABC(3, S2, B2, E2, t2);
    typeof d1 > "u" && (d1 = utils.dist(B2, abc.C));
    const d2 = d1 * (1 - t2) / t2, selen = utils.dist(S2, E2), lx = (E2.x - S2.x) / selen, ly = (E2.y - S2.y) / selen, bx1 = d1 * lx, by1 = d1 * ly, bx2 = d2 * lx, by2 = d2 * ly, e1 = { x: B2.x - bx1, y: B2.y - by1 }, e2 = { x: B2.x + bx2, y: B2.y + by2 }, A2 = abc.A, v1 = { x: A2.x + (e1.x - A2.x) / (1 - t2), y: A2.y + (e1.y - A2.y) / (1 - t2) }, v2 = { x: A2.x + (e2.x - A2.x) / t2, y: A2.y + (e2.y - A2.y) / t2 }, nc1 = { x: S2.x + (v1.x - S2.x) / t2, y: S2.y + (v1.y - S2.y) / t2 }, nc2 = {
      x: E2.x + (v2.x - E2.x) / (1 - t2),
      y: E2.y + (v2.y - E2.y) / (1 - t2)
    };
    return new Bezier(S2, nc1, nc2, E2);
  }
  static getUtils() {
    return utils;
  }
  getUtils() {
    return Bezier.getUtils();
  }
  static get PolyBezier() {
    return PolyBezier;
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return utils.pointsToString(this.points);
  }
  toSVG() {
    if (this._3d) return !1;
    const p2 = this.points, x2 = p2[0].x, y2 = p2[0].y, s2 = ["M", x2, y2, this.order === 2 ? "Q" : "C"];
    for (let i2 = 1, last = p2.length; i2 < last; i2++)
      s2.push(p2[i2].x), s2.push(p2[i2].y);
    return s2.join(" ");
  }
  setRatios(ratios) {
    if (ratios.length !== this.points.length)
      throw new Error("incorrect number of ratio values");
    this.ratios = ratios, this._lut = [];
  }
  verify() {
    const print = this.coordDigest();
    print !== this._print && (this._print = print, this.update());
  }
  coordDigest() {
    return this.points.map(function(c, pos) {
      return "" + pos + c.x + c.y + (c.z ? c.z : 0);
    }).join("");
  }
  update() {
    this._lut = [], this.dpoints = utils.derive(this.points, this._3d), this.computedirection();
  }
  computedirection() {
    const points = this.points, angle = utils.angle(points[0], points[this.order], points[1]);
    this.clockwise = angle > 0;
  }
  length() {
    return utils.length(this.derivative.bind(this));
  }
  static getABC(order2 = 2, S2, B2, E2, t2 = 0.5) {
    const u2 = utils.projectionratio(t2, order2), um = 1 - u2, C2 = {
      x: u2 * S2.x + um * E2.x,
      y: u2 * S2.y + um * E2.y
    }, s2 = utils.abcratio(t2, order2);
    return { A: {
      x: B2.x + (B2.x - C2.x) / s2,
      y: B2.y + (B2.y - C2.y) / s2
    }, B: B2, C: C2, S: S2, E: E2 };
  }
  getABC(t2, B2) {
    B2 = B2 || this.get(t2);
    let S2 = this.points[0], E2 = this.points[this.order];
    return Bezier.getABC(this.order, S2, B2, E2, t2);
  }
  getLUT(steps) {
    if (this.verify(), steps = steps || 100, this._lut.length === steps + 1)
      return this._lut;
    this._lut = [], steps++, this._lut = [];
    for (let i2 = 0, p2, t2; i2 < steps; i2++)
      t2 = i2 / (steps - 1), p2 = this.compute(t2), p2.t = t2, this._lut.push(p2);
    return this._lut;
  }
  on(point2, error) {
    error = error || 5;
    const lut = this.getLUT(), hits = [];
    for (let i2 = 0, c, t2 = 0; i2 < lut.length; i2++)
      c = lut[i2], utils.dist(c, point2) < error && (hits.push(c), t2 += i2 / lut.length);
    return hits.length ? t /= hits.length : !1;
  }
  project(point2) {
    const LUT = this.getLUT(), l2 = LUT.length - 1, closest = utils.closest(LUT, point2), mpos = closest.mpos, t1 = (mpos - 1) / l2, t2 = (mpos + 1) / l2, step = 0.1 / l2;
    let mdist = closest.mdist, t3 = t1, ft = t3, p2;
    mdist += 1;
    for (let d2; t3 < t2 + step; t3 += step)
      p2 = this.compute(t3), d2 = utils.dist(point2, p2), d2 < mdist && (mdist = d2, ft = t3);
    return ft = ft < 0 ? 0 : ft > 1 ? 1 : ft, p2 = this.compute(ft), p2.t = ft, p2.d = mdist, p2;
  }
  get(t2) {
    return this.compute(t2);
  }
  point(idx) {
    return this.points[idx];
  }
  compute(t2) {
    return this.ratios ? utils.computeWithRatios(t2, this.points, this.ratios, this._3d) : utils.compute(t2, this.points, this._3d, this.ratios);
  }
  raise() {
    const p2 = this.points, np = [p2[0]], k2 = p2.length;
    for (let i2 = 1, pi2, pim; i2 < k2; i2++)
      pi2 = p2[i2], pim = p2[i2 - 1], np[i2] = {
        x: (k2 - i2) / k2 * pi2.x + i2 / k2 * pim.x,
        y: (k2 - i2) / k2 * pi2.y + i2 / k2 * pim.y
      };
    return np[k2] = p2[k2 - 1], new Bezier(np);
  }
  derivative(t2) {
    return utils.compute(t2, this.dpoints[0], this._3d);
  }
  dderivative(t2) {
    return utils.compute(t2, this.dpoints[1], this._3d);
  }
  align() {
    let p2 = this.points;
    return new Bezier(utils.align(p2, { p1: p2[0], p2: p2[p2.length - 1] }));
  }
  curvature(t2) {
    return utils.curvature(t2, this.dpoints[0], this.dpoints[1], this._3d);
  }
  inflections() {
    return utils.inflections(this.points);
  }
  normal(t2) {
    return this._3d ? this.__normal3(t2) : this.__normal2(t2);
  }
  __normal2(t2) {
    const d2 = this.derivative(t2), q2 = sqrt(d2.x * d2.x + d2.y * d2.y);
    return { t: t2, x: -d2.y / q2, y: d2.x / q2 };
  }
  __normal3(t2) {
    const r1 = this.derivative(t2), r2 = this.derivative(t2 + 0.01), q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z), q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);
    r1.x /= q1, r1.y /= q1, r1.z /= q1, r2.x /= q2, r2.y /= q2, r2.z /= q2;
    const c = {
      x: r2.y * r1.z - r2.z * r1.y,
      y: r2.z * r1.x - r2.x * r1.z,
      z: r2.x * r1.y - r2.y * r1.x
    }, m2 = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);
    c.x /= m2, c.y /= m2, c.z /= m2;
    const R = [
      c.x * c.x,
      c.x * c.y - c.z,
      c.x * c.z + c.y,
      c.x * c.y + c.z,
      c.y * c.y,
      c.y * c.z - c.x,
      c.x * c.z - c.y,
      c.y * c.z + c.x,
      c.z * c.z
    ];
    return {
      t: t2,
      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,
      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,
      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z
    };
  }
  hull(t2) {
    let p2 = this.points, _p = [], q2 = [], idx = 0;
    for (q2[idx++] = p2[0], q2[idx++] = p2[1], q2[idx++] = p2[2], this.order === 3 && (q2[idx++] = p2[3]); p2.length > 1; ) {
      _p = [];
      for (let i2 = 0, pt, l2 = p2.length - 1; i2 < l2; i2++)
        pt = utils.lerp(t2, p2[i2], p2[i2 + 1]), q2[idx++] = pt, _p.push(pt);
      p2 = _p;
    }
    return q2;
  }
  split(t1, t2) {
    if (t1 === 0 && t2)
      return this.split(t2).left;
    if (t2 === 1)
      return this.split(t1).right;
    const q2 = this.hull(t1), result = {
      left: this.order === 2 ? new Bezier([q2[0], q2[3], q2[5]]) : new Bezier([q2[0], q2[4], q2[7], q2[9]]),
      right: this.order === 2 ? new Bezier([q2[5], q2[4], q2[2]]) : new Bezier([q2[9], q2[8], q2[6], q2[3]]),
      span: q2
    };
    return result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2), result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2), result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2), result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2), t2 ? (t2 = utils.map(t2, t1, 1, 0, 1), result.right.split(t2).left) : result;
  }
  extrema() {
    const result = {};
    let roots = [];
    return this.dims.forEach(
      (function(dim) {
        let mfn = function(v2) {
          return v2[dim];
        }, p2 = this.dpoints[0].map(mfn);
        result[dim] = utils.droots(p2), this.order === 3 && (p2 = this.dpoints[1].map(mfn), result[dim] = result[dim].concat(utils.droots(p2))), result[dim] = result[dim].filter(function(t2) {
          return t2 >= 0 && t2 <= 1;
        }), roots = roots.concat(result[dim].sort(utils.numberSort));
      }).bind(this)
    ), result.values = roots.sort(utils.numberSort).filter(function(v2, idx) {
      return roots.indexOf(v2) === idx;
    }), result;
  }
  bbox() {
    const extrema = this.extrema(), result = {};
    return this.dims.forEach(
      (function(d2) {
        result[d2] = utils.getminmax(this, d2, extrema[d2]);
      }).bind(this)
    ), result;
  }
  overlaps(curve2) {
    const lbbox = this.bbox(), tbbox = curve2.bbox();
    return utils.bboxoverlap(lbbox, tbbox);
  }
  offset(t2, d2) {
    if (typeof d2 < "u") {
      const c = this.get(t2), n2 = this.normal(t2), ret = {
        c,
        n: n2,
        x: c.x + n2.x * d2,
        y: c.y + n2.y * d2
      };
      return this._3d && (ret.z = c.z + n2.z * d2), ret;
    }
    if (this._linear) {
      const nv = this.normal(0), coords = this.points.map(function(p2) {
        const ret = {
          x: p2.x + t2 * nv.x,
          y: p2.y + t2 * nv.y
        };
        return p2.z && nv.z && (ret.z = p2.z + t2 * nv.z), ret;
      });
      return [new Bezier(coords)];
    }
    return this.reduce().map(function(s2) {
      return s2._linear ? s2.offset(t2)[0] : s2.scale(t2);
    });
  }
  simple() {
    if (this.order === 3) {
      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]), a2 = utils.angle(this.points[0], this.points[3], this.points[2]);
      if (a1 > 0 && a2 < 0 || a1 < 0 && a2 > 0) return !1;
    }
    const n1 = this.normal(0), n2 = this.normal(1);
    let s2 = n1.x * n2.x + n1.y * n2.y;
    return this._3d && (s2 += n1.z * n2.z), abs(acos(s2)) < pi$1 / 3;
  }
  reduce() {
    let i2, t1 = 0, t2 = 0, step = 0.01, segment, pass1 = [], pass2 = [], extrema = this.extrema().values;
    for (extrema.indexOf(0) === -1 && (extrema = [0].concat(extrema)), extrema.indexOf(1) === -1 && extrema.push(1), t1 = extrema[0], i2 = 1; i2 < extrema.length; i2++)
      t2 = extrema[i2], segment = this.split(t1, t2), segment._t1 = t1, segment._t2 = t2, pass1.push(segment), t1 = t2;
    return pass1.forEach(function(p1) {
      for (t1 = 0, t2 = 0; t2 <= 1; )
        for (t2 = t1 + step; t2 <= 1 + step; t2 += step)
          if (segment = p1.split(t1, t2), !segment.simple()) {
            if (t2 -= step, abs(t1 - t2) < step)
              return [];
            segment = p1.split(t1, t2), segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2), segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2), pass2.push(segment), t1 = t2;
            break;
          }
      t1 < 1 && (segment = p1.split(t1, 1), segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2), segment._t2 = p1._t2, pass2.push(segment));
    }), pass2;
  }
  translate(v2, d1, d2) {
    d2 = typeof d2 == "number" ? d2 : d1;
    const o2 = this.order;
    let d3 = this.points.map((_, i2) => (1 - i2 / o2) * d1 + i2 / o2 * d2);
    return new Bezier(
      this.points.map((p2, i2) => ({
        x: p2.x + v2.x * d3[i2],
        y: p2.y + v2.y * d3[i2]
      }))
    );
  }
  scale(d2) {
    const order2 = this.order;
    let distanceFn = !1;
    if (typeof d2 == "function" && (distanceFn = d2), distanceFn && order2 === 2)
      return this.raise().scale(distanceFn);
    const clockwise = this.clockwise, points = this.points;
    if (this._linear)
      return this.translate(
        this.normal(0),
        distanceFn ? distanceFn(0) : d2,
        distanceFn ? distanceFn(1) : d2
      );
    const r1 = distanceFn ? distanceFn(0) : d2, r2 = distanceFn ? distanceFn(1) : d2, v2 = [this.offset(0, 10), this.offset(1, 10)], np = [], o2 = utils.lli4(v2[0], v2[0].c, v2[1], v2[1].c);
    if (!o2)
      throw new Error("cannot scale this curve. Try reducing it first.");
    return [0, 1].forEach(function(t2) {
      const p2 = np[t2 * order2] = utils.copy(points[t2 * order2]);
      p2.x += (t2 ? r2 : r1) * v2[t2].n.x, p2.y += (t2 ? r2 : r1) * v2[t2].n.y;
    }), distanceFn ? ([0, 1].forEach(function(t2) {
      if (!(order2 === 2 && t2)) {
        var p2 = points[t2 + 1], ov = {
          x: p2.x - o2.x,
          y: p2.y - o2.y
        }, rc = distanceFn ? distanceFn((t2 + 1) / order2) : d2;
        distanceFn && !clockwise && (rc = -rc);
        var m2 = sqrt(ov.x * ov.x + ov.y * ov.y);
        ov.x /= m2, ov.y /= m2, np[t2 + 1] = {
          x: p2.x + rc * ov.x,
          y: p2.y + rc * ov.y
        };
      }
    }), new Bezier(np)) : ([0, 1].forEach((t2) => {
      if (order2 === 2 && t2) return;
      const p2 = np[t2 * order2], d3 = this.derivative(t2), p22 = { x: p2.x + d3.x, y: p2.y + d3.y };
      np[t2 + 1] = utils.lli4(p2, p22, o2, points[t2 + 1]);
    }), new Bezier(np));
  }
  outline(d1, d2, d3, d4) {
    if (d2 = d2 === void 0 ? d1 : d2, this._linear) {
      const n2 = this.normal(0), start2 = this.points[0], end = this.points[this.points.length - 1];
      let s2, mid, e2;
      d3 === void 0 && (d3 = d1, d4 = d2), s2 = { x: start2.x + n2.x * d1, y: start2.y + n2.y * d1 }, e2 = { x: end.x + n2.x * d3, y: end.y + n2.y * d3 }, mid = { x: (s2.x + e2.x) / 2, y: (s2.y + e2.y) / 2 };
      const fline = [s2, mid, e2];
      s2 = { x: start2.x - n2.x * d2, y: start2.y - n2.y * d2 }, e2 = { x: end.x - n2.x * d4, y: end.y - n2.y * d4 }, mid = { x: (s2.x + e2.x) / 2, y: (s2.y + e2.y) / 2 };
      const bline = [e2, mid, s2], ls2 = utils.makeline(bline[2], fline[0]), le2 = utils.makeline(fline[2], bline[0]), segments2 = [ls2, new Bezier(fline), le2, new Bezier(bline)];
      return new PolyBezier(segments2);
    }
    const reduced = this.reduce(), len = reduced.length, fcurves = [];
    let bcurves = [], p2, alen = 0, tlen = this.length();
    const graduated = typeof d3 < "u" && typeof d4 < "u";
    function linearDistanceFunction(s2, e2, tlen2, alen2, slen) {
      return function(v2) {
        const f1 = alen2 / tlen2, f2 = (alen2 + slen) / tlen2, d5 = e2 - s2;
        return utils.map(v2, 0, 1, s2 + f1 * d5, s2 + f2 * d5);
      };
    }
    reduced.forEach(function(segment) {
      const slen = segment.length();
      graduated ? (fcurves.push(
        segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))
      ), bcurves.push(
        segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))
      )) : (fcurves.push(segment.scale(d1)), bcurves.push(segment.scale(-d2))), alen += slen;
    }), bcurves = bcurves.map(function(s2) {
      return p2 = s2.points, p2[3] ? s2.points = [p2[3], p2[2], p2[1], p2[0]] : s2.points = [p2[2], p2[1], p2[0]], s2;
    }).reverse();
    const fs = fcurves[0].points[0], fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1], bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1], be = bcurves[0].points[0], ls = utils.makeline(bs, fs), le = utils.makeline(fe, be), segments = [ls].concat(fcurves).concat([le]).concat(bcurves);
    return new PolyBezier(segments);
  }
  outlineshapes(d1, d2, curveIntersectionThreshold) {
    d2 = d2 || d1;
    const outline = this.outline(d1, d2).curves, shapes = [];
    for (let i2 = 1, len = outline.length; i2 < len / 2; i2++) {
      const shape = utils.makeshape(
        outline[i2],
        outline[len - i2],
        curveIntersectionThreshold
      );
      shape.startcap.virtual = i2 > 1, shape.endcap.virtual = i2 < len / 2 - 1, shapes.push(shape);
    }
    return shapes;
  }
  intersects(curve2, curveIntersectionThreshold) {
    return curve2 ? curve2.p1 && curve2.p2 ? this.lineIntersects(curve2) : (curve2 instanceof Bezier && (curve2 = curve2.reduce()), this.curveintersects(
      this.reduce(),
      curve2,
      curveIntersectionThreshold
    )) : this.selfintersects(curveIntersectionThreshold);
  }
  lineIntersects(line) {
    const mx = min(line.p1.x, line.p2.x), my = min(line.p1.y, line.p2.y), MX = max(line.p1.x, line.p2.x), MY = max(line.p1.y, line.p2.y);
    return utils.roots(this.points, line).filter((t2) => {
      var p2 = this.get(t2);
      return utils.between(p2.x, mx, MX) && utils.between(p2.y, my, MY);
    });
  }
  selfintersects(curveIntersectionThreshold) {
    const reduced = this.reduce(), len = reduced.length - 2, results = [];
    for (let i2 = 0, result, left, right; i2 < len; i2++)
      left = reduced.slice(i2, i2 + 1), right = reduced.slice(i2 + 2), result = this.curveintersects(left, right, curveIntersectionThreshold), results.push(...result);
    return results;
  }
  curveintersects(c1, c2, curveIntersectionThreshold) {
    const pairs = [];
    c1.forEach(function(l2) {
      c2.forEach(function(r2) {
        l2.overlaps(r2) && pairs.push({ left: l2, right: r2 });
      });
    });
    let intersections = [];
    return pairs.forEach(function(pair) {
      const result = utils.pairiteration(
        pair.left,
        pair.right,
        curveIntersectionThreshold
      );
      result.length > 0 && (intersections = intersections.concat(result));
    }), intersections;
  }
  arcs(errorThreshold) {
    return errorThreshold = errorThreshold || 0.5, this._iterate(errorThreshold, []);
  }
  _error(pc, np1, s2, e2) {
    const q2 = (e2 - s2) / 4, c1 = this.get(s2 + q2), c2 = this.get(e2 - q2), ref = utils.dist(pc, np1), d1 = utils.dist(pc, c1), d2 = utils.dist(pc, c2);
    return abs(d1 - ref) + abs(d2 - ref);
  }
  _iterate(errorThreshold, circles) {
    let t_s = 0, t_e = 1, safety;
    do {
      safety = 0, t_e = 1;
      let np1 = this.get(t_s), np2, np3, arc, prev_arc, curr_good = !1, prev_good = !1, done, t_m = t_e, prev_e = 1;
      do
        if (prev_good = curr_good, prev_arc = arc, t_m = (t_s + t_e) / 2, np2 = this.get(t_m), np3 = this.get(t_e), arc = utils.getccenter(np1, np2, np3), arc.interval = {
          start: t_s,
          end: t_e
        }, curr_good = this._error(arc, np1, t_s, t_e) <= errorThreshold, done = prev_good && !curr_good, done || (prev_e = t_e), curr_good) {
          if (t_e >= 1) {
            if (arc.interval.end = prev_e = 1, prev_arc = arc, t_e > 1) {
              let d2 = {
                x: arc.x + arc.r * cos(arc.e),
                y: arc.y + arc.r * sin(arc.e)
              };
              arc.e += utils.angle({ x: arc.x, y: arc.y }, d2, this.get(1));
            }
            break;
          }
          t_e = t_e + (t_e - t_s) / 2;
        } else
          t_e = t_m;
      while (!done && safety++ < 100);
      if (safety >= 100)
        break;
      prev_arc = prev_arc || arc, circles.push(prev_arc), t_s = prev_e;
    } while (t_e < 1);
    return circles;
  }
}
function toDomPrecision(v2) {
  return v2 === null ? 0.01 : Math.round(v2 * 100) / 100;
}
const nodeToRect = (nd) => ({
  x: nd.internals.positionAbsolute.x,
  y: nd.internals.positionAbsolute.y,
  width: nd.measured.width ?? nd.width ?? nd.data.element.width,
  height: nd.measured.height ?? nd.height ?? nd.data.element.height
}), isInside = (test2, target) => test2.x >= target.x && test2.y >= target.y && test2.x + test2.width <= target.x + target.width && test2.y + test2.height <= target.y + target.height;
function bezierControlPoints(diagramEdge) {
  let [start2, ...bezierPoints] = diagramEdge.points;
  invariant$1(start2, "start should be defined");
  const handles = [
    // start
  ];
  for (; i$8(bezierPoints, 3); ) {
    const [cp1, cp2, end, ...rest] = bezierPoints, bezier = new Bezier(start2[0], start2[1], cp1[0], cp1[1], cp2[0], cp2[1], end[0], end[1]), inflections = bezier.inflections();
    inflections.length === 0 && inflections.push(0.5), inflections.forEach((t2) => {
      const { x: x2, y: y2 } = bezier.get(t2);
      handles.push({
        x: Math.round(x2),
        y: Math.round(y2)
      });
    }), bezierPoints = rest, start2 = end;
  }
  return invariant$1(bezierPoints.length === 0, "all points should be consumed"), handles;
}
const isClose = (a2, b2) => Math.abs(a2 - b2) < 3.1;
function isSamePoint$1(a2, b2) {
  const [ax, ay] = o$3(a2) ? a2 : [a2.x, a2.y], [bx, by] = o$3(b2) ? b2 : [b2.x, b2.y];
  return isClose(ax, bx) && isClose(ay, by);
}
function stopPropagation$1(e2) {
  return e2.stopPropagation();
}
function centerXYInternalNode(nd) {
  const { width: width2, height } = getNodeDimensions(nd);
  return {
    x: nd.internals.positionAbsolute.x + width2 / 2,
    y: nd.internals.positionAbsolute.y + height / 2
  };
}
function diagramViewToXYFlowData(view, opts) {
  view.__;
  const xynodes = [], xyedges = [], nodeLookup = /* @__PURE__ */ new Map(), traverse = view.nodes.reduce(
    (acc, node2) => (nodeLookup.set(node2.id, node2), node2.parent || acc.push({ node: node2, parent: null }), acc),
    new Array()
  );
  let visiblePredicate = (_nodeOrEdge) => !0;
  if (opts.where)
    try {
      visiblePredicate = whereOperatorAsPredicate(opts.where);
    } catch (e2) {
      console.error("Error in where filter:", e2);
    }
  const ns = "", nodeById = (id2) => nonNullable(nodeLookup.get(id2), `Node not found: ${id2}`);
  let next;
  for (; next = traverse.shift(); ) {
    const { node: node2, parent } = next, isCompound = i$8(node2.children, 1) || node2.kind == ElementKind.Group;
    isCompound && traverse.push(...node2.children.map((child) => ({ node: nodeById(child), parent: node2 })));
    const position2 = {
      x: node2.position[0],
      y: node2.position[1]
    };
    parent && (position2.x -= parent.position[0], position2.y -= parent.position[1]);
    const base = {
      id: ns + node2.id,
      draggable: opts.draggable,
      selectable: opts.selectable && node2.kind !== ElementKind.Group,
      focusable: opts.selectable && !isCompound,
      deletable: !1,
      position: position2,
      zIndex: isCompound ? ZIndexes$2.Compound : ZIndexes$2.Element,
      width: node2.width,
      height: node2.height,
      hidden: node2.kind !== ElementKind.Group && !visiblePredicate(node2),
      ...parent && {
        parentId: ns + parent.id
      }
    };
    xynodes.push(
      isCompound ? {
        ...base,
        type: "compound",
        data: {
          fqn: node2.id,
          isViewGroup: node2.kind === ElementKind.Group,
          element: node2
        },
        dragHandle: ".likec4-compound-title"
      } : {
        ...base,
        type: "element",
        data: {
          fqn: node2.id,
          element: node2
        }
      }
    );
  }
  for (const edge of view.edges) {
    const source = edge.source, target = edge.target, id2 = ns + edge.id;
    if (!i$8(edge.points, 2)) {
      console.error("edge should have at least 2 points", edge);
      continue;
    }
    xyedges.push({
      id: id2,
      type: "relationship",
      source: ns + source,
      target: ns + target,
      zIndex: ZIndexes$2.Edge,
      selectable: opts.selectable,
      hidden: !visiblePredicate(edge),
      deletable: !1,
      data: {
        edge,
        controlPoints: edge.controlPoints || null,
        label: edge.labelBBox ? {
          bbox: edge.labelBBox,
          text: edge.label ?? ""
        } : null
      },
      interactionWidth: 20
    });
  }
  return {
    xynodes,
    xyedges
  };
}
class Aligner {
}
class LinearAligner extends Aligner {
  constructor(getEdgePosition2, computePosition2, propertyToEdit) {
    super();
    __publicField(this, "alignTo");
    this.getEdgePosition = getEdgePosition2, this.computePosition = computePosition2, this.propertyToEdit = propertyToEdit;
  }
  computeLayout(nodes) {
    this.alignTo = this.getEdgePosition(nodes);
  }
  applyPosition(node2) {
    return {
      [this.propertyToEdit]: this.computePosition(this.alignTo, node2)
    };
  }
}
class GridAligner extends Aligner {
  constructor(alignmentMode) {
    super();
    __publicField(this, "layout", /* @__PURE__ */ new Map());
    __publicField(this, "axisPreset");
    this.axisPreset = alignmentMode === "Column" ? {
      primaryAxisDimension: "width",
      secondaryAxisDimension: "height",
      primaryAxisCoord: "x",
      secondaryAxisCoord: "y"
    } : {
      primaryAxisDimension: "height",
      secondaryAxisDimension: "width",
      primaryAxisCoord: "y",
      secondaryAxisCoord: "x"
    };
  }
  get primaryAxisCoord() {
    return this.axisPreset.primaryAxisCoord;
  }
  get secondaryAxisCoord() {
    return this.axisPreset.secondaryAxisCoord;
  }
  get primaryAxisDimension() {
    return this.axisPreset.primaryAxisDimension;
  }
  get secondaryAxisDimension() {
    return this.axisPreset.secondaryAxisDimension;
  }
  applyPosition(node2) {
    var _a4;
    return ((_a4 = this.layout) == null ? void 0 : _a4.get(node2.id)) ?? {};
  }
  computeLayout(nodes) {
    const sortedNodeRects = x$2(
      nodes,
      a$3((r2) => r2[this.primaryAxisCoord])
    ), layoutRect = this.getLayoutRect(sortedNodeRects), layers = this.getLayers(sortedNodeRects);
    this.layout = this.buildLayout(layers, layoutRect, sortedNodeRects);
  }
  getLayoutRect(nodeRects) {
    const x2 = Math.min(...nodeRects.map((n2) => n2.x)), y2 = Math.min(...nodeRects.map((n2) => n2.y)), right = Math.max(...nodeRects.map((n2) => n2.x + n2.width)), bottom = Math.max(...nodeRects.map((n2) => n2.y + n2.height));
    return {
      x: x2,
      y: y2,
      width: right - x2,
      height: bottom - y2
    };
  }
  getLayers(sortedNodeRects) {
    const layers = [];
    let layerEnd = 0, layer = null;
    for (let node2 of sortedNodeRects)
      if (layer && node2[this.primaryAxisCoord] < layerEnd)
        layer.nodes.push(node2), layer.primaryAxisSize = Math.max(layer.primaryAxisSize, node2[this.primaryAxisDimension]), layer.occupiedSpace += node2[this.secondaryAxisDimension], layerEnd = Math.max(
          node2[this.primaryAxisCoord] + node2[this.primaryAxisDimension],
          layerEnd
        );
      else {
        layer = {
          primaryAxisSize: node2[this.primaryAxisDimension],
          nodes: [node2],
          occupiedSpace: node2[this.secondaryAxisDimension],
          layout: null
        }, layers.push(layer), layerEnd = node2[this.primaryAxisCoord] + node2[this.primaryAxisDimension];
        continue;
      }
    return layers.forEach(
      (l2) => l2.nodes.sort((a2, b2) => a2[this.secondaryAxisCoord] - b2[this.secondaryAxisCoord])
    ), layers;
  }
  buildLayout(layers, layoutRect, nodeRects) {
    const nodeMap = new Map(nodeRects.map((n2) => [n2.id, n2])), layout2 = [], occupiedSpace = layers.reduce((a2, b2) => a2 + b2.primaryAxisSize, 0), rowMargin = layers.length > 1 ? (layoutRect[this.primaryAxisDimension] - occupiedSpace) / (layers.length - 1) : 0, baseLayerIndex = layers.reduce(
      (widestLayerIndex, layer, i2) => layers[widestLayerIndex].occupiedSpace < layer.occupiedSpace ? i2 : widestLayerIndex,
      0
    ), baseLayer = layers[baseLayerIndex], baseLayerPosition = layers.slice(0, baseLayerIndex).reduce(
      (a2, layer) => a2 + layer.primaryAxisSize + rowMargin,
      layoutRect[this.primaryAxisCoord]
    ), baseLayerLayout = this.buildLayerLayout(
      baseLayer,
      layoutRect,
      baseLayerPosition,
      nodeMap,
      null
    );
    baseLayer.layout = baseLayerLayout, layout2.push(...baseLayerLayout.nodePositions);
    let placeNextLayerAt = baseLayerPosition + baseLayer.primaryAxisSize + rowMargin, refLayer = baseLayer;
    for (let i2 = baseLayerIndex + 1; i2 < layers.length; i2++) {
      const layer = layers[i2];
      layer.layout = this.buildLayerLayout(layer, layoutRect, placeNextLayerAt, nodeMap, refLayer), layout2.push(...layer.layout.nodePositions), refLayer = layer.layout.refLayer ?? layer, placeNextLayerAt += layer.primaryAxisSize + rowMargin;
    }
    placeNextLayerAt = baseLayerPosition, refLayer = baseLayer;
    for (let i2 = baseLayerIndex - 1; i2 >= 0; i2--) {
      const layer = layers[i2];
      placeNextLayerAt -= layer.primaryAxisSize + rowMargin, layer.layout = this.buildLayerLayout(layer, layoutRect, placeNextLayerAt, nodeMap, refLayer), layout2.push(...layer.layout.nodePositions), refLayer = layer.layout.refLayer ?? layer;
    }
    return new Map(layout2);
  }
  buildLayerLayout(layer, layoutRect, placeNextLayerAt, nodeMap, refLayer) {
    let bestLayerLayout = this.scoreLayout(
      this.spaceAround(layer, layoutRect, placeNextLayerAt),
      nodeMap
    );
    if (layer.nodes.length != 1) {
      const currentlayerLayout = this.scoreLayout(
        this.spaceBetween(layer, layoutRect, placeNextLayerAt),
        nodeMap
      );
      bestLayerLayout = currentlayerLayout[0] < bestLayerLayout[0] ? currentlayerLayout : bestLayerLayout;
    }
    if (refLayer && refLayer.nodes.length - 1 >= layer.nodes.length) {
      const currentlayerLayout = this.scoreLayout(
        this.placeInGaps(layer, placeNextLayerAt, refLayer),
        nodeMap
      );
      bestLayerLayout = currentlayerLayout[0] < bestLayerLayout[0] ? currentlayerLayout : bestLayerLayout;
    }
    if (refLayer && refLayer.nodes.length >= layer.nodes.length) {
      const currentlayerLayout = this.scoreLayout(
        this.placeInCells(layer, placeNextLayerAt, refLayer),
        nodeMap
      );
      bestLayerLayout = currentlayerLayout[0] < bestLayerLayout[0] ? currentlayerLayout : bestLayerLayout;
    }
    return bestLayerLayout[1];
  }
  spaceBetween(layer, layoutRect, placeNextLayerAt) {
    const margin = (layoutRect[this.secondaryAxisDimension] - layer.occupiedSpace) / (layer.nodes.length - 1);
    let placeNextNodeAt = layoutRect[this.secondaryAxisCoord];
    const result = /* @__PURE__ */ new Map();
    for (let node2 of layer.nodes)
      result.set(node2.id, {
        [this.secondaryAxisCoord]: placeNextNodeAt,
        [this.primaryAxisCoord]: placeNextLayerAt
      }), placeNextNodeAt += node2[this.secondaryAxisDimension] + margin;
    return { nodePositions: result, refLayer: null };
  }
  spaceAround(layer, layoutRect, placeNextLayerAt) {
    const margin = (layoutRect[this.secondaryAxisDimension] - layer.occupiedSpace) / (layer.nodes.length + 1);
    let placeNextNodeAt = layoutRect[this.secondaryAxisCoord] + margin;
    const result = /* @__PURE__ */ new Map();
    for (let node2 of a$3(layer.nodes, (n2) => n2[this.secondaryAxisCoord]))
      result.set(node2.id, {
        [this.secondaryAxisCoord]: placeNextNodeAt,
        [this.primaryAxisCoord]: placeNextLayerAt
      }), placeNextNodeAt += node2[this.secondaryAxisDimension] + margin;
    return { nodePositions: result, refLayer: null };
  }
  placeInGaps(layer, placeNextLayerAt, refLayer) {
    const result = /* @__PURE__ */ new Map(), nodes = layer.nodes, placementOptions = this.getGapsPositions(refLayer);
    let optionIndex = 0;
    for (let i2 = 0, node2 = nodes[i2]; i2 < nodes.length; i2++, node2 = nodes[i2]) {
      const nodeCenter = node2[this.secondaryAxisCoord] + node2[this.secondaryAxisDimension] / 2;
      let bestOffset = 1 / 0;
      for (; optionIndex - i2 <= placementOptions.length - nodes.length; ) {
        const offset2 = placementOptions[optionIndex] - nodeCenter;
        if (Math.abs(offset2) < Math.abs(bestOffset))
          bestOffset = offset2, optionIndex++;
        else
          break;
      }
      result.set(node2.id, {
        [this.secondaryAxisCoord]: node2[this.secondaryAxisCoord] + bestOffset,
        [this.primaryAxisCoord]: placeNextLayerAt
      });
    }
    return { nodePositions: result, refLayer };
  }
  placeInCells(layer, placeNextLayerAt, refLayer) {
    const result = /* @__PURE__ */ new Map(), nodes = layer.nodes, placementOptions = this.getNodePositions(refLayer);
    let optionIndex = 0;
    for (let i2 = 0, node2 = nodes[i2]; i2 < nodes.length; i2++, node2 = nodes[i2]) {
      const nodeCenter = node2[this.secondaryAxisCoord] + node2[this.secondaryAxisDimension] / 2;
      let bestOffset = 1 / 0;
      for (; optionIndex - i2 <= placementOptions.length - nodes.length; ) {
        const offset2 = placementOptions[optionIndex] - nodeCenter;
        if (Math.abs(offset2) < Math.abs(bestOffset))
          bestOffset = offset2, optionIndex++;
        else
          break;
      }
      result.set(node2.id, {
        [this.secondaryAxisCoord]: node2[this.secondaryAxisCoord] + bestOffset,
        [this.primaryAxisCoord]: placeNextLayerAt
      });
    }
    return { nodePositions: result, refLayer };
  }
  scoreLayout(layout2, originalRects) {
    return [
      x$2(
        Array.from(layout2.nodePositions),
        m$2(([id2, position2]) => {
          const originalRect = originalRects.get(id2);
          return invariant$1(originalRect, `Could not find original rect for node ${id2}`), [i$6(originalRect, ["x", "y"]), position2];
        }),
        m$2(
          ([original, suggested]) => Math.abs(original[this.secondaryAxisCoord] - suggested[this.secondaryAxisCoord])
        ),
        l$4((a2, b2) => a2 + b2, 0)
      ),
      layout2
    ];
  }
  getGapsPositions(layer) {
    const result = [], { layout: layout2, nodes } = layer;
    invariant$1(layout2, "Layout of the layer must be computed before calling getGapsPositions");
    for (let i2 = 1; i2 < nodes.length; i2++) {
      const previousNode = nodes[i2 - 1], currentNode = nodes[i2], previousNodePosition = layout2.nodePositions.get(previousNode.id), currentNodePosition = layout2.nodePositions.get(currentNode.id);
      result.push(
        (currentNodePosition[this.secondaryAxisCoord] + previousNodePosition[this.secondaryAxisCoord] + previousNode[this.secondaryAxisDimension]) / 2
      );
    }
    return result;
  }
  getNodePositions(layer) {
    const result = [], { layout: layout2, nodes } = layer;
    invariant$1(layout2, "Layout of the layer must be computed before calling getGapsPositions");
    for (let i2 = 0; i2 < nodes.length; i2++) {
      const node2 = nodes[i2], nodePosition = layout2.nodePositions.get(node2.id);
      result.push(
        nodePosition[this.secondaryAxisCoord] + node2[this.secondaryAxisDimension] / 2
      );
    }
    return result;
  }
}
function getLinearAligner(mode) {
  switch (mode) {
    case "Left":
      return new LinearAligner(
        (nodes) => Math.min(...nodes.map((n2) => n2.x)),
        (alignTo, _) => Math.floor(alignTo),
        "x"
      );
    case "Top":
      return new LinearAligner(
        (nodes) => Math.min(...nodes.map((n2) => n2.y)),
        (alignTo, _) => Math.floor(alignTo),
        "y"
      );
    case "Right":
      return new LinearAligner(
        (nodes) => Math.max(...nodes.map((n2) => n2.x + n2.width)),
        (alignTo, node2) => Math.floor(alignTo - node2.width),
        "x"
      );
    case "Bottom":
      return new LinearAligner(
        (nodes) => Math.max(...nodes.map((n2) => n2.y + n2.height)),
        (alignTo, node2) => Math.floor(alignTo - node2.height),
        "y"
      );
    case "Center":
      return new LinearAligner(
        (nodes) => Math.min(...nodes.map((n2) => n2.x + n2.width / 2)),
        (alignTo, node2) => Math.floor(alignTo - node2.width / 2),
        "x"
      );
    case "Middle":
      return new LinearAligner(
        (nodes) => Math.min(...nodes.map((n2) => n2.y + n2.height / 2)),
        (alignTo, node2) => Math.floor(alignTo - node2.height / 2),
        "y"
      );
  }
}
function align(get2) {
  return (mode) => {
    const { scheduleSaveManualLayout, xystore } = get2(), { nodeLookup, parentLookup } = xystore.getState(), nodesToAlign = [...new Set(nodeLookup.values().filter((n2) => n2.selected).map((n2) => n2.id)).difference(new Set(parentLookup.keys()))];
    if (!i$8(nodesToAlign, 2)) {
      console.warn("At least 2 nodes must be selected to align");
      return;
    }
    const constraints = createLayoutConstraints(xystore, nodesToAlign), aligner = getAligner(mode);
    constraints.onMove((nodes) => {
      aligner.computeLayout(nodes.map(({ node: node2 }) => toNodeRect(node2))), nodes.forEach(({ rect, node: node2 }) => {
        rect.positionAbsolute = {
          ...rect.positionAbsolute,
          ...aligner.applyPosition(toNodeRect(node2))
        };
      });
    }), scheduleSaveManualLayout();
  };
}
function toNodeRect(node2) {
  return {
    ...node2.internals.positionAbsolute,
    id: node2.id,
    width: getNodeDimensions(node2).width,
    height: getNodeDimensions(node2).height
  };
}
function getAligner(mode) {
  switch (mode) {
    case "Left":
    case "Right":
    case "Top":
    case "Bottom":
    case "Center":
    case "Middle":
      return getLinearAligner(mode);
    case "Column":
    case "Row":
      return new GridAligner(mode);
    default:
      nonexhaustive(mode);
  }
}
const StringSet = Set, DEFAULT_PROPS = {
  xyedges: [],
  xynodes: [],
  isDynamicView: !1,
  viewSyncDebounceTimeout: null,
  initialized: !1,
  navigationHistoryIndex: 0,
  viewportChanged: !1,
  activeOverlay: null,
  activeWalkthrough: null,
  focusedNodeId: null,
  hoveredNodeId: null,
  hoveredEdgeId: null,
  lastClickedNodeId: null,
  lastClickedEdgeId: null,
  dimmed: new StringSet(),
  lastOnNavigate: null
}, noReplace = !1;
let StoreDevId = 1;
const EmptyStringSet = new StringSet();
function createDiagramStore(props) {
  const storeDevId = "DiagramStore" + String(StoreDevId++).padStart(2, "0"), {
    xynodes,
    xyedges
  } = diagramViewToXYFlowData(props.view, {
    where: props.whereFilter,
    draggable: props.nodesDraggable,
    selectable: props.nodesSelectable
  });
  return createWithEqualityFn(
    subscribeWithSelector(
      devtools(
        (set2, get2) => ({
          ...DEFAULT_PROPS,
          ...props,
          storeDevId,
          isDynamicView: props.view.__ === "dynamic",
          xynodes,
          xyedges,
          navigationHistory: [{
            viewId: props.view.id,
            nodeId: null
          }],
          navigationHistoryIndex: 0,
          onNodesChange: (changes) => {
            set2({
              xynodes: applyNodeChanges(changes, get2().xynodes)
            });
          },
          onEdgesChange: (changes) => {
            set2({
              xyedges: applyEdgeChanges(changes, get2().xyedges)
            });
          },
          updateView: (nextView) => {
            let {
              viewSyncDebounceTimeout,
              xyflow: xyflow2,
              xystore,
              dimmed: dimmed2,
              whereFilter,
              view: current,
              lastOnNavigate,
              navigationHistory,
              navigationHistoryIndex,
              focusedNodeId,
              lastClickedNodeId,
              lastClickedEdgeId,
              activeWalkthrough,
              activeOverlay,
              nodesDraggable,
              nodesSelectable,
              hoveredEdgeId,
              hoveredNodeId,
              xyedges: xyedges2,
              xynodes: xynodes2
            } = get2();
            viewSyncDebounceTimeout !== null && (clearTimeout(viewSyncDebounceTimeout), viewSyncDebounceTimeout = null);
            const isSameView = current.id === nextView.id;
            if (isSameView) {
              const nodeIds = new StringSet(nextView.nodes.map((n2) => n2.id)), edgeIds = new StringSet(nextView.edges.map((e2) => e2.id));
              if (lastClickedNodeId && !nodeIds.has(lastClickedNodeId) && (lastClickedNodeId = null), hoveredNodeId && !nodeIds.has(hoveredNodeId) && (hoveredNodeId = null), focusedNodeId && !nodeIds.has(focusedNodeId) && (focusedNodeId = null, dimmed2 = EmptyStringSet), lastClickedEdgeId && !edgeIds.has(lastClickedEdgeId) && (lastClickedEdgeId = null), hoveredEdgeId && !edgeIds.has(hoveredEdgeId) && (hoveredEdgeId = null), activeWalkthrough && !edgeIds.has(activeWalkthrough.stepId) && (activeWalkthrough = null, dimmed2 = EmptyStringSet), dimmed2.size > 0) {
                let nextDimmed = new StringSet([...dimmed2].filter((id2) => nodeIds.has(id2) || edgeIds.has(id2)));
                nextDimmed.size !== dimmed2.size && (dimmed2 = nextDimmed);
              }
            } else {
              const stepCurrent = nonNullable(navigationHistory[navigationHistoryIndex]);
              stepCurrent.viewId !== nextView.id ? (navigationHistory = [
                ...navigationHistory.slice(0, navigationHistoryIndex + 1),
                {
                  viewId: nextView.id,
                  nodeId: (lastOnNavigate == null ? void 0 : lastOnNavigate.fromNode) || null
                }
              ], navigationHistoryIndex = navigationHistory.length - 1) : stepCurrent.nodeId && (lastOnNavigate ?? (lastOnNavigate = {
                fromView: current.id,
                toView: nextView.id,
                fromNode: stepCurrent.nodeId
              })), lastOnNavigate && lastOnNavigate.toView !== nextView.id && (lastOnNavigate = null);
              const elTo = lastOnNavigate && nextView.nodes.find((n2) => n2.id === (lastOnNavigate == null ? void 0 : lastOnNavigate.fromNode)), xynodeFrom = elTo && xyflow2.getInternalNode(elTo.id);
              if (!lastOnNavigate || n$2(elTo) || n$2(xynodeFrom)) {
                const zoom2 = xyflow2.getZoom(), { x: x2, y: y2 } = getBBoxCenter(nextView.bounds);
                xyflow2.setCenter(x2, y2, { zoom: zoom2 }), lastOnNavigate = null;
              }
              if (lastOnNavigate && elTo && xynodeFrom) {
                const fromPos = xyflow2.flowToScreenPosition({
                  x: xynodeFrom.internals.positionAbsolute.x,
                  // + dimensions.width / 2,
                  y: xynodeFrom.internals.positionAbsolute.y
                  // + dimensions.height / 2
                }), toPos = xyflow2.flowToScreenPosition({
                  x: elTo.position[0],
                  // + elFrom.width / 2,
                  y: elTo.position[1]
                  // + elFrom.height / 2
                }), diff = {
                  x: toDomPrecision(fromPos.x - toPos.x),
                  y: toDomPrecision(fromPos.y - toPos.y)
                };
                xystore.getState().panBy(diff), lastOnNavigate = null;
              }
              lastClickedEdgeId = null, lastClickedNodeId = null, hoveredEdgeId = null, hoveredNodeId = null, focusedNodeId = null, activeWalkthrough = null, activeOverlay = null, dimmed2 = EmptyStringSet;
            }
            const update = diagramViewToXYFlowData(nextView, {
              where: whereFilter,
              draggable: nodesDraggable,
              selectable: nodesSelectable
            });
            update.xynodes = update.xynodes.map((update2) => {
              const existing = xynodes2.find((n2) => n2.id === update2.id);
              return existing && existing.type === update2.type && deepEqual$1(existing.parentId ?? null, update2.parentId ?? null) ? existing.width === update2.width && existing.height === update2.height && deepEqual$1(existing.hidden ?? !1, update2.hidden ?? !1) && deepEqual$1(existing.position, update2.position) && deepEqual$1(existing.data, update2.data) ? existing : {
                ...existing,
                ...update2
              } : update2;
            }), isSameView && !nextView.hasLayoutDrift && (update.xyedges = update.xyedges.map((update2) => {
              const existing = xyedges2.find((n2) => n2.id === update2.id);
              return existing ? deepEqual$1(existing.hidden ?? !1, update2.hidden ?? !1) && deepEqual$1(existing.data.label, update2.data.label) && deepEqual$1(existing.data.controlPoints, update2.data.controlPoints) && deepEqual$1(existing.data.edge, update2.data.edge) ? existing : {
                ...existing,
                ...update2,
                data: {
                  ...existing.data,
                  ...update2.data
                }
              } : update2;
            })), set2(
              {
                isDynamicView: nextView.__ === "dynamic",
                viewSyncDebounceTimeout,
                view: nextView,
                activeWalkthrough,
                activeOverlay,
                lastOnNavigate,
                lastClickedNodeId,
                lastClickedEdgeId,
                focusedNodeId,
                hoveredEdgeId,
                hoveredNodeId,
                navigationHistory,
                navigationHistoryIndex,
                dimmed: dimmed2,
                xynodes: !isSameView || !shallowEqual(update.xynodes, xynodes2) ? update.xynodes : xynodes2,
                xyedges: !isSameView || !shallowEqual(update.xyedges, xyedges2) ? update.xyedges : xyedges2
              },
              noReplace,
              isSameView ? "update-view [same]" : "update-view [another]"
            );
          },
          focusOnNode: (nodeId) => {
            const { focusedNodeId, view, enableFocusMode } = get2();
            if (invariant$1(enableFocusMode, "focus mode is not enabled"), nodeId === !1) {
              set2(
                {
                  activeWalkthrough: null,
                  activeOverlay: null,
                  focusedNodeId: null,
                  dimmed: EmptyStringSet
                },
                noReplace,
                "unfocus"
              );
              return;
            }
            if (nodeId !== focusedNodeId) {
              const notDimmed = new StringSet([nodeId]), dimmed2 = new StringSet();
              for (const edge of view.edges)
                edge.source === nodeId || edge.target === nodeId ? (notDimmed.add(edge.source), notDimmed.add(edge.target)) : dimmed2.add(edge.id);
              for (const node2 of view.nodes)
                notDimmed.has(node2.id) || dimmed2.add(node2.id);
              set2(
                {
                  activeWalkthrough: null,
                  activeOverlay: null,
                  focusedNodeId: nodeId,
                  dimmed: dimmed2
                },
                noReplace,
                `focus on node: ${nodeId}`
              );
            }
          },
          setHoveredNode: (nodeId) => {
            nodeId !== get2().hoveredNodeId && set2({ hoveredNodeId: nodeId });
          },
          setHoveredEdge: (edgeId) => {
            edgeId !== get2().hoveredEdgeId && set2({ hoveredEdgeId: edgeId });
          },
          setLastClickedNode: (nodeId) => {
            nodeId !== get2().lastClickedNodeId && set2({ lastClickedNodeId: nodeId });
          },
          setLastClickedEdge: (edgeId) => {
            edgeId !== get2().lastClickedEdgeId && set2({ lastClickedEdgeId: edgeId });
          },
          resetFocusAndLastClicked: () => {
            set2(
              {
                activeWalkthrough: null,
                activeOverlay: null,
                focusedNodeId: null,
                lastClickedNodeId: null,
                lastClickedEdgeId: null,
                dimmed: EmptyStringSet
              },
              noReplace,
              "resetLastClicked"
            ), get2().xystore.getState().resetSelectedElements();
          },
          getElement: (fqn2) => {
            const { view } = get2();
            return view.nodes.find(({ id: id2 }) => id2 === fqn2) ?? null;
          },
          isEditable: () => {
            const { readonly, onChange } = get2();
            return !readonly && !!onChange;
          },
          triggerChangeElementStyle: (change) => {
            const { view, updateView, onChange } = get2();
            let hasChanges = !1;
            const nodes = view.nodes.map((origin) => {
              var _a4, _b2;
              if (!change.targets.includes(origin.id))
                return origin;
              let element = origin;
              for (const [key, value] of t$2(change.style))
                switch (key) {
                  case "shape":
                    value !== element.shape && (element = {
                      ...element,
                      shape: value
                    });
                    break;
                  case "color":
                    value !== element.color && (element = {
                      ...element,
                      color: value
                    });
                    break;
                  case "opacity":
                    value !== ((_a4 = element.style) == null ? void 0 : _a4.opacity) && (element = {
                      ...element,
                      style: {
                        ...element.style,
                        opacity: value
                      }
                    });
                    break;
                  case "border":
                    value !== ((_b2 = element.style) == null ? void 0 : _b2.border) && (element = {
                      ...element,
                      style: {
                        ...element.style,
                        border: value
                      }
                    });
                    break;
                  default:
                    nonexhaustive(key);
                }
              return element !== origin ? (hasChanges = !0, element) : origin;
            });
            hasChanges && updateView({
              ...view,
              nodes
            }), onChange == null || onChange({ change });
          },
          cancelSaveManualLayout: () => {
            let { viewSyncDebounceTimeout } = get2();
            return viewSyncDebounceTimeout !== null ? (clearTimeout(viewSyncDebounceTimeout), set2({ viewSyncDebounceTimeout: null }), !0) : !1;
          },
          triggerSaveManualLayout: () => {
            const { xyflow: xyflow2, view, onChange, xystore, viewSyncDebounceTimeout } = get2();
            viewSyncDebounceTimeout !== null && (clearTimeout(viewSyncDebounceTimeout), set2({ viewSyncDebounceTimeout: null }));
            const { nodeLookup } = xystore.getState(), movedNodes = new StringSet();
            let bounds = {
              x: 0,
              y: 0,
              width: 1,
              height: 1
            };
            const nodes = l$4([...nodeLookup.values()], (acc, node2) => {
              const dimensions = getNodeDimensions(node2);
              isSamePoint$1(node2.internals.positionAbsolute, node2.data.element.position) || movedNodes.add(node2.id);
              const rect = acc[node2.data.fqn] = {
                isCompound: node2.data.element.children.length > 0,
                x: Math.floor(node2.internals.positionAbsolute.x),
                y: Math.floor(node2.internals.positionAbsolute.y),
                width: Math.ceil(dimensions.width),
                height: Math.ceil(dimensions.height)
              };
              return bounds = getBoundsOfRects(bounds, rect), acc;
            }, {}), edges = l$4(xyflow2.getEdges(), (acc, { source, target, data }) => {
              var _a4;
              let controlPoints = data.controlPoints ?? [];
              const sourceOrTargetMoved = movedNodes.has(source) || movedNodes.has(target);
              if (controlPoints.length === 0 && sourceOrTargetMoved && (controlPoints = bezierControlPoints(data.edge)), data.edge.points.length === 0 && controlPoints.length === 0)
                return acc;
              const _updated = acc[data.edge.id] = {
                points: data.edge.points
              };
              (_a4 = data.label) != null && _a4.bbox && (_updated.labelBBox = data.label.bbox), data.edge.labelBBox && (_updated.labelBBox ?? (_updated.labelBBox = data.edge.labelBBox)), i$8(controlPoints, 1) && (_updated.controlPoints = controlPoints), !sourceOrTargetMoved && data.edge.dotpos && (_updated.dotpos = data.edge.dotpos);
              const allX = [
                ...data.edge.points.map((p2) => p2[0]),
                ...controlPoints.map((p2) => p2.x),
                ..._updated.labelBBox ? [_updated.labelBBox.x, _updated.labelBBox.x + _updated.labelBBox.width] : []
              ], allY = [
                ...data.edge.points.map((p2) => p2[1]),
                ...controlPoints.map((p2) => p2.y),
                ..._updated.labelBBox ? [_updated.labelBBox.y, _updated.labelBBox.y + _updated.labelBBox.height] : []
              ], rect = boxToRect({
                x: Math.floor(Math.min(...allX)),
                y: Math.floor(Math.min(...allY)),
                x2: Math.ceil(Math.max(...allX)),
                y2: Math.ceil(Math.max(...allY))
              });
              return bounds = getBoundsOfRects(bounds, rect), acc;
            }, {}), change = {
              op: "save-manual-layout",
              layout: {
                hash: view.hash,
                autoLayout: view.autoLayout,
                nodes,
                edges,
                ...bounds
              }
            };
            isInside(bounds, view.bounds) || set2(
              {
                view: {
                  ...view,
                  bounds
                }
              },
              noReplace,
              "update view bounds"
            ), onChange == null || onChange({ change });
          },
          scheduleSaveManualLayout: () => {
            clearTimeout(get2().viewSyncDebounceTimeout ?? void 0), set2(
              {
                viewSyncDebounceTimeout: setTimeout(() => {
                  get2().triggerSaveManualLayout();
                }, 1e3)
                // explicit typecast to number to suppress TS error in astro build
              },
              noReplace,
              "debounce sync state"
            );
          },
          triggerOnNavigateTo: (xynodeId, event) => {
            const { view, xynodes: xynodes2, onNavigateTo, cancelSaveManualLayout } = get2();
            if (!onNavigateTo)
              return;
            const xynode = xynodes2.find(({ id: id2 }) => id2 === xynodeId);
            invariant$1(xynode, `xynode not found: ${xynodeId}`);
            const element = xynode.data.element;
            invariant$1(element == null ? void 0 : element.navigateTo, `node is not navigable: ${xynodeId}`), cancelSaveManualLayout(), set2(
              {
                lastClickedNodeId: xynodeId,
                lastOnNavigate: {
                  fromView: view.id,
                  toView: element.navigateTo,
                  fromNode: element.id
                }
              },
              noReplace,
              "triggerOnNavigateTo"
            ), onNavigateTo(
              element.navigateTo,
              event,
              element
            );
          },
          goBack: () => {
            const { navigationHistory, navigationHistoryIndex, onNavigateTo } = get2(), { viewId, nodeId } = nonNullable(navigationHistory[navigationHistoryIndex]), stepBack = navigationHistoryIndex > 0 && navigationHistory[navigationHistoryIndex - 1] || null;
            stepBack && onNavigateTo && (set2(
              {
                lastClickedEdgeId: null,
                lastClickedNodeId: null,
                navigationHistoryIndex: navigationHistoryIndex - 1,
                lastOnNavigate: nodeId ? {
                  fromView: viewId,
                  toView: stepBack.viewId,
                  fromNode: nodeId
                } : null
              },
              noReplace,
              "goBack"
            ), onNavigateTo(stepBack.viewId));
          },
          goForward: () => {
            const { navigationHistory, navigationHistoryIndex, onNavigateTo } = get2(), { viewId } = nonNullable(navigationHistory[navigationHistoryIndex]), stepForward = navigationHistoryIndex < navigationHistory.length - 1 ? navigationHistory[navigationHistoryIndex + 1] : null;
            stepForward && onNavigateTo && (set2(
              {
                lastClickedEdgeId: null,
                lastClickedNodeId: null,
                navigationHistoryIndex: navigationHistoryIndex + 1,
                lastOnNavigate: stepForward.nodeId ? {
                  fromView: viewId,
                  toView: stepForward.viewId,
                  fromNode: stepForward.nodeId
                } : null
              },
              noReplace,
              "goForward"
            ), onNavigateTo(stepForward.viewId));
          },
          openOverlay: (overlay) => {
            deepEqual$1(overlay, get2().activeOverlay) || set2(
              {
                activeWalkthrough: null,
                activeOverlay: overlay
              },
              noReplace,
              "openOverlay"
            );
          },
          closeOverlay: () => {
            get2().activeOverlay !== null && set2(
              {
                activeOverlay: null
              },
              noReplace,
              "closeOverlay"
            );
          },
          fitDiagram: (duration = 500) => {
            const { fitViewPadding, view, xystore } = get2(), { width: width2, height, panZoom, transform: transform2 } = xystore.getState(), bounds = view.bounds, maxZoom = Math.max(1, transform2[2]), viewport = getViewportForBounds(bounds, width2, height, MinZoom, maxZoom, fitViewPadding);
            panZoom == null || panZoom.setViewport(viewport, duration > 0 ? { duration } : void 0);
          },
          nextDynamicStep: (increment = 1) => {
            const { activeWalkthrough, xyedges: xyedges2, activateWalkthrough } = get2(), stepId = activeWalkthrough == null ? void 0 : activeWalkthrough.stepId;
            let nextStep;
            if (stepId) {
              const nextIndex = xyedges2.findIndex(({ id: id2 }) => id2 === stepId) + increment;
              nextStep = xyedges2[nextIndex];
            } else
              nextStep = d$1(xyedges2);
            if (nextStep) {
              activateWalkthrough(nextStep.data.edge.id);
              return;
            }
          },
          activateWalkthrough: (step) => {
            const stepId = typeof step == "string" ? step : step.data.edge.id;
            invariant$1(isStepEdgeId(stepId), `stepId ${stepId} is not a step edge id`);
            let {
              isDynamicView,
              xyflow: xyflow2,
              xyedges: xyedges2,
              xystore,
              fitViewPadding,
              activeWalkthrough
            } = get2();
            invariant$1(isDynamicView, "view is not dynamic");
            const edge = typeof step == "string" ? xyedges2.find(({ id: id2 }) => id2 === stepId) : step;
            invariant$1(edge, `edge not found: ${stepId}`);
            const currentIndex = xyedges2.findIndex(({ id: id2 }) => id2 === stepId);
            activeWalkthrough = {
              stepId,
              hasPrevious: currentIndex > 0,
              hasNext: currentIndex < xyedges2.length - 1,
              parallelPrefix: getParallelStepsPrefix(stepId)
            };
            const dimmed2 = new StringSet(
              xyedges2.filter(
                ({ id: id2 }) => id2 !== stepId && !(activeWalkthrough.parallelPrefix && id2.startsWith(activeWalkthrough.parallelPrefix))
              ).map(({ id: id2 }) => id2)
            ), selected2 = [];
            for (const n2 of xyflow2.getNodes()) {
              if (n2.id === edge.source || n2.id === edge.target) {
                selected2.push(n2);
                continue;
              }
              dimmed2.add(n2.id);
            }
            const { fitView: fitView2, transform: transform2 } = xystore.getState();
            fitView2({
              duration: 400,
              includeHiddenNodes: !0,
              maxZoom: Math.max(1, transform2[2]),
              minZoom: MinZoom,
              padding: Math.max(fitViewPadding, 0.2),
              nodes: selected2
            }), set2(
              {
                focusedNodeId: null,
                activeWalkthrough,
                dimmed: dimmed2
              },
              noReplace,
              "activateWalkthrough"
            );
          },
          stopWalkthrough: () => {
            get2().activeWalkthrough !== null && (set2(
              {
                activeWalkthrough: null,
                focusedNodeId: null,
                dimmed: EmptyStringSet
              },
              noReplace,
              "stopWalkthrough"
            ), get2().fitDiagram());
          },
          onInit: (instance) => {
            const { xyflow: xyflow2, initialized, fitViewEnabled, fitDiagram } = get2();
            (!initialized || xyflow2 !== instance) && (fitViewEnabled && fitDiagram(0), set2(
              {
                xyflow: instance,
                initialized: !0
              },
              noReplace,
              "onInit"
            ));
          },
          highlightByElementNotation: (notation, onlyOfKind) => {
            const { xynodes: xynodes2, xyedges: xyedges2 } = get2(), dimmed2 = new StringSet(m$2(xyedges2, p$4("id")));
            xynodes2.forEach(({ id: id2, data }) => {
              const node2 = data.element;
              (node2.shape !== notation.shape || node2.color !== notation.color || !notation.kinds.includes(node2.kind) || onlyOfKind && node2.kind !== onlyOfKind) && dimmed2.add(id2);
            }), set2({ dimmed: dimmed2 }, noReplace, "highlightByElementNotation");
          },
          resetEdgeControlPoints: () => {
            const { xyflow: xyflow2, scheduleSaveManualLayout, xynodes: xynodes2, xyedges: xyedges2 } = get2();
            xyedges2.forEach((edge) => {
              xyflow2.updateEdgeData(edge.id, {
                controlPoints: getControlPointForEdge(edge)
              });
            }), scheduleSaveManualLayout();
            function getNodeCenter(node2, nodes) {
              const dimensions = vector({ x: node2.width || 0, y: node2.height || 0 });
              let position2 = vector(node2.position).add(dimensions.mul(0.5)), currentNode = node2;
              do {
                const parent = currentNode.parentId && nodes.find((x2) => x2.id == currentNode.parentId);
                if (!parent)
                  break;
                currentNode = parent, position2 = position2.add(parent.position);
              } while (!0);
              return position2;
            }
            function getControlPointForEdge(edge) {
              const source = xynodes2.find((x2) => x2.id == edge.source), target = xynodes2.find((x2) => x2.id == edge.target);
              if (!source || !target)
                return [];
              const sourceCenter = getNodeCenter(source, xynodes2), targetCenter = getNodeCenter(target, xynodes2);
              if (sourceCenter && targetCenter) {
                const sourceToTargetVector = targetCenter.sub(sourceCenter), sourceBorderPoint = getBorderPointOnVector(source, sourceCenter, sourceToTargetVector), targetBorderPoint = getBorderPointOnVector(target, targetCenter, sourceToTargetVector.mul(-1));
                return [sourceBorderPoint.add(targetBorderPoint.sub(sourceBorderPoint).mul(0.3))];
              }
              return [];
            }
            function getBorderPointOnVector(node2, nodeCenter, v2) {
              const xScale = (node2.width || 0) / 2 / v2.x, yScale = (node2.height || 0) / 2 / v2.y, scale2 = Math.min(Math.abs(xScale), Math.abs(yScale));
              return vector(v2).mul(scale2).add(nodeCenter);
            }
          },
          align: align(get2)
        }),
        {
          name: `${storeDevId} - ${props.view.id}`,
          enabled: DEV
        }
      )
    ),
    shallow$1
  );
}
const DiagramContext = createContext(null);
function DiagramContextProvider({
  children: children2,
  view,
  className,
  keepAspectRatio,
  whereFilter,
  ...props
}) {
  const isMotionReduced = useReducedMotion() ?? !1, [scope, animate] = useAnimate(), containerRef = useRef(null), ref = useMergedRef(scope, containerRef), xystore = useXYStoreApi(), xyflow2 = useXYFlow(), store = useRef(), getContainer = useCallback(() => containerRef.current, [containerRef]);
  store.current || (store.current = createDiagramStore({
    xystore,
    xyflow: xyflow2,
    view,
    getContainer,
    whereFilter: p$1(whereFilter),
    ...props
  })), useUpdateEffect(
    () => {
      var _a4;
      return (_a4 = store.current) == null ? void 0 : _a4.setState({ xyflow: xyflow2, xystore, getContainer }, !1, "update xyflow and xystore");
    },
    [xyflow2, xystore, getContainer]
  ), useUpdateEffect(
    () => {
      var _a4;
      return (_a4 = store.current) == null ? void 0 : _a4.setState(props, !1, "update incoming props");
    },
    [props]
  ), useUpdateEffect(
    () => {
      const current = store.current;
      invariant$1(current, "DiagramContext.store.current is not defined"), deepEqual$1(whereFilter, current.getState().whereFilter) || current.setState({ whereFilter: p$1(whereFilter) }, !1, "update where filter"), current.getState().updateView(view);
    },
    [view, whereFilter],
    (a2, b2) => shallowEqual(a2[0], b2[0]) && deepEqual$1(a2[1], b2[1])
  );
  const api = store.current;
  return useEffect(() => {
    if (!isMotionReduced)
      return api.subscribe((s2) => !!s2.activeOverlay, (isActiveOverlay) => {
        animate(".likec4-diagram .react-flow__renderer", {
          opacity: isActiveOverlay ? 0.7 : 1,
          filter: isActiveOverlay ? "grayscale(1)" : "grayscale(0)",
          transform: isActiveOverlay ? "perspective(300px) translateZ(-10px) translateY(2px)" : "translateY(0)"
        }, {
          duration: isActiveOverlay ? 0.4 : 0.2
        });
      }, {
        fireImmediately: !0
      });
  }, [api, isMotionReduced]), /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      className,
      ...keepAspectRatio && {
        style: {
          aspectRatio: `${Math.ceil(view.bounds.width)}/${Math.ceil(view.bounds.height)}`,
          maxHeight: Math.ceil(view.bounds.height)
        }
      },
      children: /* @__PURE__ */ jsx(DiagramContext.Provider, { value: api, children: children2 })
    }
  );
}
DiagramContextProvider.displayName = "DiagramContextProvider";
function useDiagramState(selector2, equalityFn) {
  const store = useContext(DiagramContext);
  if (store === null)
    throw new Error("useDiagramStore could be used only inside DiagramContext");
  return useStoreWithEqualityFn(store, selector2, equalityFn ?? shallowEqual);
}
function useDiagramStoreApi() {
  const store = useContext(DiagramContext);
  if (store === null)
    throw new Error("useDiagramStoreApi could be used only inside DiagramContext");
  return store;
}
function getSizesVariables(theme, themeKey, name) {
  return Object.keys(theme[themeKey]).reduce((acc, size2) => (acc[size2] = `var(--mantine-${name}-${size2})`, acc), {});
}
function getBreakpointValue(value, theme) {
  return value in theme.breakpoints ? theme.breakpoints[value] : em(value);
}
function themeToVars(theme) {
  const mergedTheme = mergeMantineTheme(DEFAULT_THEME, theme), fontSizes = getSizesVariables(mergedTheme, "fontSizes", "font-size"), lineHeights = getSizesVariables(mergedTheme, "lineHeights", "line-height"), shadows = getSizesVariables(mergedTheme, "shadows", "shadow"), radius = getSizesVariables(mergedTheme, "radius", "radius"), spacing = getSizesVariables(mergedTheme, "spacing", "spacing"), headings2 = Object.keys(mergedTheme.headings.sizes).reduce(
    (acc, heading) => (acc[heading] = {
      fontSize: `var(--mantine-${heading}-font-size)`,
      lineHeight: `var(--mantine-${heading}-line-height)`,
      fontWeight: `var(--mantine-${heading}-font-weight)`
    }, acc),
    {}
  ), colors2 = Object.keys(mergedTheme.colors).reduce(
    (acc, color2) => (acc[color2] = {
      0: `var(--mantine-color-${color2}-0)`,
      1: `var(--mantine-color-${color2}-1)`,
      2: `var(--mantine-color-${color2}-2)`,
      3: `var(--mantine-color-${color2}-3)`,
      4: `var(--mantine-color-${color2}-4)`,
      5: `var(--mantine-color-${color2}-5)`,
      6: `var(--mantine-color-${color2}-6)`,
      7: `var(--mantine-color-${color2}-7)`,
      8: `var(--mantine-color-${color2}-8)`,
      9: `var(--mantine-color-${color2}-9)`,
      filled: `var(--mantine-color-${color2}-filled)`,
      filledHover: `var(--mantine-color-${color2}-filled-hover)`,
      light: `var(--mantine-color-${color2}-light)`,
      lightHover: `var(--mantine-color-${color2}-light-hover)`,
      lightColor: `var(--mantine-color-${color2}-light-color)`,
      outline: `var(--mantine-color-${color2}-outline)`,
      outlineHover: `var(--mantine-color-${color2}-outline-hover)`
    }, acc),
    {
      primary: "var(--mantine-primary-color-filled)",
      primaryColors: {
        0: "var(--mantine-primary-color-0)",
        1: "var(--mantine-primary-color-1)",
        2: "var(--mantine-primary-color-2)",
        3: "var(--mantine-primary-color-3)",
        4: "var(--mantine-primary-color-4)",
        5: "var(--mantine-primary-color-5)",
        6: "var(--mantine-primary-color-6)",
        7: "var(--mantine-primary-color-7)",
        8: "var(--mantine-primary-color-8)",
        9: "var(--mantine-primary-color-9)",
        filled: "var(--mantine-primary-color-filled)",
        filledHover: "var(--mantine-primary-color-filled-hover)",
        light: "var(--mantine-primary-color-light)",
        lightHover: "var(--mantine-primary-color-light-hover)",
        lightColor: "var(--mantine-primary-color-light-color)",
        outline: "var(--mantine-primary-color-outline)",
        outlineHover: "var(--mantine-primary-color-outline-hover)"
      },
      white: "var(--mantine-color-white)",
      black: "var(--mantine-color-black)",
      text: "var(--mantine-color-text)",
      body: "var(--mantine-color-body)",
      error: "var(--mantine-color-error)",
      placeholder: "var(--mantine-color-placeholder)",
      anchor: "var(--mantine-color-anchor)",
      default: "var(--mantine-color-default)",
      defaultHover: "var(--mantine-color-default-hover)",
      defaultColor: "var(--mantine-color-default-color)",
      defaultBorder: "var(--mantine-color-default-border)",
      dimmed: "var(--mantine-color-dimmed)"
    }
  );
  return {
    scale: "var(--mantine-scale)",
    cursorType: "var(--mantine-cursor-type)",
    webkitFontSmoothing: "var(--mantine-webkit-font-smoothing)",
    mozFontSmoothing: "var(--mantine-moz-font-smoothing)",
    lineHeight: "var(--mantine-line-height)",
    fontFamily: "var(--mantine-font-family)",
    fontFamilyMonospace: "var(--mantine-font-family-monospace)",
    fontFamilyHeadings: "var(--mantine-font-family-headings)",
    headingFontWeight: "var(--mantine-heading-font-weight)",
    radiusDefault: "var(--mantine-radius-default)",
    breakpoints: mergedTheme.breakpoints,
    fontSizes,
    lineHeights,
    shadows,
    radius,
    headings: headings2,
    spacing,
    colors: colors2,
    rtlSelector: '[dir="rtl"] &',
    darkSelector: '[data-mantine-color-scheme="dark"] &',
    lightSelector: '[data-mantine-color-scheme="light"] &',
    smallerThan: (breakpoint) => `(max-width: ${getBreakpointValue(breakpoint, mergedTheme)})`,
    largerThan: (breakpoint) => `(min-width: ${getBreakpointValue(breakpoint, mergedTheme)})`
  };
}
var stylesheets = {}, injectStyles = (_ref) => {
  var {
    fileScope,
    css
  } = _ref, fileScopeId = fileScope.packageName ? [fileScope.packageName, fileScope.filePath].join("/") : fileScope.filePath, stylesheet = stylesheets[fileScopeId];
  if (!stylesheet) {
    var styleEl = document.createElement("style");
    fileScope.packageName && styleEl.setAttribute("data-package", fileScope.packageName), styleEl.setAttribute("data-file", fileScope.filePath), styleEl.setAttribute("type", "text/css"), stylesheet = stylesheets[fileScopeId] = styleEl, document.head.appendChild(styleEl);
  }
  stylesheet.innerHTML = css;
};
function getVarName(variable) {
  var matches = variable.match(/^var\((.*)\)$/);
  return matches ? matches[1] : variable;
}
function walkObject(obj, fn) {
  var path = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], clone = {};
  for (var key in obj) {
    var _value = obj[key], currentPath = [...path, key];
    typeof _value == "string" || typeof _value == "number" || _value == null ? clone[key] = fn(_value, currentPath) : typeof _value == "object" && !Array.isArray(_value) ? clone[key] = walkObject(_value, fn, currentPath) : console.warn('Skipping invalid key "'.concat(currentPath.join("."), '". Should be a string, number, null or object. Received: "').concat(Array.isArray(_value) ? "Array" : typeof _value, '"'));
  }
  return clone;
}
var object = {}, hasOwnProperty = object.hasOwnProperty, merge = function(options, defaults) {
  if (!options)
    return defaults;
  var result = {};
  for (var key in defaults)
    result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];
  return result;
}, regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/, regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/, regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g, cssesc = function cssesc2(string, options) {
  options = merge(options, cssesc2.options), options.quotes != "single" && options.quotes != "double" && (options.quotes = "single");
  for (var quote = options.quotes == "double" ? '"' : "'", isIdentifier = options.isIdentifier, firstChar = string.charAt(0), output = "", counter = 0, length = string.length; counter < length; ) {
    var character = string.charAt(counter++), codePoint = character.charCodeAt(), value = void 0;
    if (codePoint < 32 || codePoint > 126) {
      if (codePoint >= 55296 && codePoint <= 56319 && counter < length) {
        var extra = string.charCodeAt(counter++);
        (extra & 64512) == 56320 ? codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536 : counter--;
      }
      value = "\\" + codePoint.toString(16).toUpperCase() + " ";
    } else
      options.escapeEverything ? regexAnySingleEscape.test(character) ? value = "\\" + character : value = "\\" + codePoint.toString(16).toUpperCase() + " " : /[\t\n\f\r\x0B]/.test(character) ? value = "\\" + codePoint.toString(16).toUpperCase() + " " : character == "\\" || !isIdentifier && (character == '"' && quote == character || character == "'" && quote == character) || isIdentifier && regexSingleEscape.test(character) ? value = "\\" + character : value = character;
    output += value;
  }
  return isIdentifier && (/^-[-\d]/.test(output) ? output = "\\-" + output.slice(1) : /\d/.test(firstChar) && (output = "\\3" + firstChar + " " + output.slice(1))), output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
    return $1 && $1.length % 2 ? $0 : ($1 || "") + $2;
  }), !isIdentifier && options.wrap ? quote + output + quote : output;
};
cssesc.options = {
  escapeEverything: !1,
  isIdentifier: !1,
  quotes: "single",
  wrap: !1
};
cssesc.version = "3.0.0";
var cssesc_1 = cssesc;
const cssesc$1 = /* @__PURE__ */ getDefaultExportFromCjs(cssesc_1);
class AhoCorasick {
  constructor(keywords) {
    const { failure, gotoFn, output } = this._buildTables(keywords);
    this.gotoFn = gotoFn, this.output = output, this.failure = failure;
  }
  _buildTables(keywords) {
    const gotoFn = {
      0: {}
    }, output = {};
    let state = 0;
    for (const word of keywords) {
      let curr = 0;
      for (const l2 of word)
        gotoFn[curr] && l2 in gotoFn[curr] ? curr = gotoFn[curr][l2] : (state++, gotoFn[curr][l2] = state, gotoFn[state] = {}, curr = state, output[state] = []);
      output[curr].push(word);
    }
    const failure = {}, xs = [];
    for (const l2 in gotoFn[0]) {
      const state2 = gotoFn[0][l2];
      failure[state2] = 0, xs.push(state2);
    }
    for (; xs.length > 0; ) {
      const r2 = xs.shift();
      if (r2 !== void 0)
        for (const l2 in gotoFn[r2]) {
          const s2 = gotoFn[r2][l2];
          xs.push(s2);
          let state2 = failure[r2];
          for (; state2 > 0 && !(l2 in gotoFn[state2]); )
            state2 = failure[state2];
          if (l2 in gotoFn[state2]) {
            const fs = gotoFn[state2][l2];
            failure[s2] = fs, output[s2] = [...output[s2], ...output[fs]];
          } else
            failure[s2] = 0;
        }
    }
    return {
      gotoFn,
      output,
      failure
    };
  }
  search(str) {
    let state = 0;
    const results = [];
    for (let i2 = 0; i2 < str.length; i2++) {
      const l2 = str[i2];
      for (; state > 0 && !(l2 in this.gotoFn[state]); )
        state = this.failure[state];
      if (l2 in this.gotoFn[state] && (state = this.gotoFn[state][l2], this.output[state].length > 0)) {
        const foundStrs = this.output[state];
        results.push([i2, foundStrs]);
      }
    }
    return results;
  }
}
var mockAdapter = {
  appendCss: () => {
  },
  registerClassName: () => {
  },
  onEndFileScope: () => {
  },
  registerComposition: () => {
  },
  markCompositionUsed: () => {
  },
  getIdentOption: () => "short"
}, adapterStack = [mockAdapter], currentAdapter = () => {
  if (adapterStack.length < 1)
    throw new Error("No adapter configured");
  return adapterStack[adapterStack.length - 1];
}, hasConfiguredAdapter = !1, setAdapterIfNotSet = (newAdapter) => {
  hasConfiguredAdapter || setAdapter(newAdapter);
}, setAdapter = (newAdapter) => {
  if (!newAdapter)
    throw new Error('No adapter provided when calling "setAdapter"');
  hasConfiguredAdapter = !0, adapterStack.push(newAdapter);
}, markCompositionUsed = function() {
  return currentAdapter().markCompositionUsed(...arguments);
};
function _taggedTemplateLiteral(strings, raw) {
  return raw || (raw = strings.slice(0)), Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}
var SelectorType;
(function(SelectorType2) {
  SelectorType2.Attribute = "attribute", SelectorType2.Pseudo = "pseudo", SelectorType2.PseudoElement = "pseudo-element", SelectorType2.Tag = "tag", SelectorType2.Universal = "universal", SelectorType2.Adjacent = "adjacent", SelectorType2.Child = "child", SelectorType2.Descendant = "descendant", SelectorType2.Parent = "parent", SelectorType2.Sibling = "sibling", SelectorType2.ColumnCombinator = "column-combinator";
})(SelectorType || (SelectorType = {}));
var AttributeAction;
(function(AttributeAction2) {
  AttributeAction2.Any = "any", AttributeAction2.Element = "element", AttributeAction2.End = "end", AttributeAction2.Equals = "equals", AttributeAction2.Exists = "exists", AttributeAction2.Hyphen = "hyphen", AttributeAction2.Not = "not", AttributeAction2.Start = "start";
})(AttributeAction || (AttributeAction = {}));
const reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/, reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi, actionTypes = /* @__PURE__ */ new Map([
  [126, AttributeAction.Element],
  [94, AttributeAction.Start],
  [36, AttributeAction.End],
  [42, AttributeAction.Any],
  [33, AttributeAction.Not],
  [124, AttributeAction.Hyphen]
]), unpackPseudos = /* @__PURE__ */ new Set([
  "has",
  "not",
  "matches",
  "is",
  "where",
  "host",
  "host-context"
]);
function isTraversal(selector2) {
  switch (selector2.type) {
    case SelectorType.Adjacent:
    case SelectorType.Child:
    case SelectorType.Descendant:
    case SelectorType.Parent:
    case SelectorType.Sibling:
    case SelectorType.ColumnCombinator:
      return !0;
    default:
      return !1;
  }
}
const stripQuotesFromPseudos = /* @__PURE__ */ new Set(["contains", "icontains"]);
function funescape(_, escaped, escapedWhitespace) {
  const high = parseInt(escaped, 16) - 65536;
  return high !== high || escapedWhitespace ? escaped : high < 0 ? (
    // BMP codepoint
    String.fromCharCode(high + 65536)
  ) : (
    // Supplemental Plane codepoint (surrogate pair)
    String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
  );
}
function unescapeCSS(str) {
  return str.replace(reEscape, funescape);
}
function isQuote(c) {
  return c === 39 || c === 34;
}
function isWhitespace(c) {
  return c === 32 || c === 9 || c === 10 || c === 12 || c === 13;
}
function parse(selector2) {
  const subselects = [], endIndex = parseSelector(subselects, `${selector2}`, 0);
  if (endIndex < selector2.length)
    throw new Error(`Unmatched selector: ${selector2.slice(endIndex)}`);
  return subselects;
}
function parseSelector(subselects, selector2, selectorIndex) {
  let tokens = [];
  function getName(offset2) {
    const match = selector2.slice(selectorIndex + offset2).match(reName);
    if (!match)
      throw new Error(`Expected name, found ${selector2.slice(selectorIndex)}`);
    const [name] = match;
    return selectorIndex += offset2 + name.length, unescapeCSS(name);
  }
  function stripWhitespace(offset2) {
    for (selectorIndex += offset2; selectorIndex < selector2.length && isWhitespace(selector2.charCodeAt(selectorIndex)); )
      selectorIndex++;
  }
  function readValueWithParenthesis() {
    selectorIndex += 1;
    const start2 = selectorIndex;
    let counter = 1;
    for (; counter > 0 && selectorIndex < selector2.length; selectorIndex++)
      selector2.charCodeAt(selectorIndex) === 40 && !isEscaped(selectorIndex) ? counter++ : selector2.charCodeAt(selectorIndex) === 41 && !isEscaped(selectorIndex) && counter--;
    if (counter)
      throw new Error("Parenthesis not matched");
    return unescapeCSS(selector2.slice(start2, selectorIndex - 1));
  }
  function isEscaped(pos) {
    let slashCount = 0;
    for (; selector2.charCodeAt(--pos) === 92; )
      slashCount++;
    return (slashCount & 1) === 1;
  }
  function ensureNotTraversal() {
    if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1]))
      throw new Error("Did not expect successive traversals.");
  }
  function addTraversal(type) {
    if (tokens.length > 0 && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens[tokens.length - 1].type = type;
      return;
    }
    ensureNotTraversal(), tokens.push({ type });
  }
  function addSpecialAttribute(name, action) {
    tokens.push({
      type: SelectorType.Attribute,
      name,
      action,
      value: getName(1),
      namespace: null,
      ignoreCase: "quirks"
    });
  }
  function finalizeSubselector() {
    if (tokens.length && tokens[tokens.length - 1].type === SelectorType.Descendant && tokens.pop(), tokens.length === 0)
      throw new Error("Empty sub-selector");
    subselects.push(tokens);
  }
  if (stripWhitespace(0), selector2.length === selectorIndex)
    return selectorIndex;
  loop: for (; selectorIndex < selector2.length; ) {
    const firstChar = selector2.charCodeAt(selectorIndex);
    switch (firstChar) {
      case 32:
      case 9:
      case 10:
      case 12:
      case 13: {
        (tokens.length === 0 || tokens[0].type !== SelectorType.Descendant) && (ensureNotTraversal(), tokens.push({ type: SelectorType.Descendant })), stripWhitespace(1);
        break;
      }
      case 62: {
        addTraversal(SelectorType.Child), stripWhitespace(1);
        break;
      }
      case 60: {
        addTraversal(SelectorType.Parent), stripWhitespace(1);
        break;
      }
      case 126: {
        addTraversal(SelectorType.Sibling), stripWhitespace(1);
        break;
      }
      case 43: {
        addTraversal(SelectorType.Adjacent), stripWhitespace(1);
        break;
      }
      case 46: {
        addSpecialAttribute("class", AttributeAction.Element);
        break;
      }
      case 35: {
        addSpecialAttribute("id", AttributeAction.Equals);
        break;
      }
      case 91: {
        stripWhitespace(1);
        let name, namespace2 = null;
        selector2.charCodeAt(selectorIndex) === 124 ? name = getName(1) : selector2.startsWith("*|", selectorIndex) ? (namespace2 = "*", name = getName(2)) : (name = getName(0), selector2.charCodeAt(selectorIndex) === 124 && selector2.charCodeAt(selectorIndex + 1) !== 61 && (namespace2 = name, name = getName(1))), stripWhitespace(0);
        let action = AttributeAction.Exists;
        const possibleAction = actionTypes.get(selector2.charCodeAt(selectorIndex));
        if (possibleAction) {
          if (action = possibleAction, selector2.charCodeAt(selectorIndex + 1) !== 61)
            throw new Error("Expected `=`");
          stripWhitespace(2);
        } else selector2.charCodeAt(selectorIndex) === 61 && (action = AttributeAction.Equals, stripWhitespace(1));
        let value = "", ignoreCase = null;
        if (action !== "exists") {
          if (isQuote(selector2.charCodeAt(selectorIndex))) {
            const quote = selector2.charCodeAt(selectorIndex);
            let sectionEnd = selectorIndex + 1;
            for (; sectionEnd < selector2.length && (selector2.charCodeAt(sectionEnd) !== quote || isEscaped(sectionEnd)); )
              sectionEnd += 1;
            if (selector2.charCodeAt(sectionEnd) !== quote)
              throw new Error("Attribute value didn't end");
            value = unescapeCSS(selector2.slice(selectorIndex + 1, sectionEnd)), selectorIndex = sectionEnd + 1;
          } else {
            const valueStart = selectorIndex;
            for (; selectorIndex < selector2.length && (!isWhitespace(selector2.charCodeAt(selectorIndex)) && selector2.charCodeAt(selectorIndex) !== 93 || isEscaped(selectorIndex)); )
              selectorIndex += 1;
            value = unescapeCSS(selector2.slice(valueStart, selectorIndex));
          }
          stripWhitespace(0);
          const forceIgnore = selector2.charCodeAt(selectorIndex) | 32;
          forceIgnore === 115 ? (ignoreCase = !1, stripWhitespace(1)) : forceIgnore === 105 && (ignoreCase = !0, stripWhitespace(1));
        }
        if (selector2.charCodeAt(selectorIndex) !== 93)
          throw new Error("Attribute selector didn't terminate");
        selectorIndex += 1;
        const attributeSelector = {
          type: SelectorType.Attribute,
          name,
          action,
          value,
          namespace: namespace2,
          ignoreCase
        };
        tokens.push(attributeSelector);
        break;
      }
      case 58: {
        if (selector2.charCodeAt(selectorIndex + 1) === 58) {
          tokens.push({
            type: SelectorType.PseudoElement,
            name: getName(2).toLowerCase(),
            data: selector2.charCodeAt(selectorIndex) === 40 ? readValueWithParenthesis() : null
          });
          continue;
        }
        const name = getName(1).toLowerCase();
        let data = null;
        if (selector2.charCodeAt(selectorIndex) === 40)
          if (unpackPseudos.has(name)) {
            if (isQuote(selector2.charCodeAt(selectorIndex + 1)))
              throw new Error(`Pseudo-selector ${name} cannot be quoted`);
            if (data = [], selectorIndex = parseSelector(data, selector2, selectorIndex + 1), selector2.charCodeAt(selectorIndex) !== 41)
              throw new Error(`Missing closing parenthesis in :${name} (${selector2})`);
            selectorIndex += 1;
          } else {
            if (data = readValueWithParenthesis(), stripQuotesFromPseudos.has(name)) {
              const quot = data.charCodeAt(0);
              quot === data.charCodeAt(data.length - 1) && isQuote(quot) && (data = data.slice(1, -1));
            }
            data = unescapeCSS(data);
          }
        tokens.push({ type: SelectorType.Pseudo, name, data });
        break;
      }
      case 44: {
        finalizeSubselector(), tokens = [], stripWhitespace(1);
        break;
      }
      default: {
        if (selector2.startsWith("/*", selectorIndex)) {
          const endIndex = selector2.indexOf("*/", selectorIndex + 2);
          if (endIndex < 0)
            throw new Error("Comment was not terminated");
          selectorIndex = endIndex + 2, tokens.length === 0 && stripWhitespace(0);
          break;
        }
        let namespace2 = null, name;
        if (firstChar === 42)
          selectorIndex += 1, name = "*";
        else if (firstChar === 124) {
          if (name = "", selector2.charCodeAt(selectorIndex + 1) === 124) {
            addTraversal(SelectorType.ColumnCombinator), stripWhitespace(2);
            break;
          }
        } else if (reName.test(selector2.slice(selectorIndex)))
          name = getName(0);
        else
          break loop;
        selector2.charCodeAt(selectorIndex) === 124 && selector2.charCodeAt(selectorIndex + 1) !== 124 && (namespace2 = name, selector2.charCodeAt(selectorIndex + 1) === 42 ? (name = "*", selectorIndex += 2) : name = getName(1)), tokens.push(name === "*" ? { type: SelectorType.Universal, namespace: namespace2 } : { type: SelectorType.Tag, name, namespace: namespace2 });
      }
    }
  }
  return finalizeSubselector(), selectorIndex;
}
function ownKeys$1(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    i2 % 2 ? ownKeys$1(Object(source), !0).forEach(function(key) {
      _defineProperty$1(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$1(obj, key, value) {
  return key = _toPropertyKey(key), key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key == "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (typeof input != "object" || input === null) return input;
  var prim2 = input[Symbol.toPrimitive];
  if (prim2 !== void 0) {
    var res = prim2.call(input, hint);
    if (typeof res != "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(input);
}
const dedent = createDedent({});
function createDedent(options) {
  return dedent2.withOptions = (newOptions) => createDedent(_objectSpread(_objectSpread({}, options), newOptions)), dedent2;
  function dedent2(strings, ...values2) {
    const raw = typeof strings == "string" ? [strings] : strings.raw, {
      escapeSpecialCharacters = Array.isArray(strings)
    } = options;
    let result = "";
    for (let i2 = 0; i2 < raw.length; i2++) {
      let next = raw[i2];
      escapeSpecialCharacters && (next = next.replace(/\\\n[ \t]*/g, "").replace(/\\`/g, "`").replace(/\\\$/g, "$").replace(/\\\{/g, "{")), result += next, i2 < values2.length && (result += values2[i2]);
    }
    const lines = result.split(`
`);
    let mindent = null;
    for (const l2 of lines) {
      const m2 = l2.match(/^(\s+)\S+/);
      if (m2) {
        const indent = m2[1].length;
        mindent ? mindent = Math.min(mindent, indent) : mindent = indent;
      }
    }
    if (mindent !== null) {
      const m2 = mindent;
      result = lines.map((l2) => l2[0] === " " || l2[0] === "	" ? l2.slice(m2) : l2).join(`
`);
    }
    return result = result.trim(), escapeSpecialCharacters && (result = result.replace(/\\n/g, `
`)), result;
  }
}
var __assign = function() {
  return __assign = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && (t2[p2] = s2[p2]);
    }
    return t2;
  }, __assign.apply(this, arguments);
};
function __rest(s2, e2) {
  var t2 = {};
  for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0 && (t2[p2] = s2[p2]);
  if (s2 != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++)
      e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]) && (t2[p2[i2]] = s2[p2[i2]]);
  return t2;
}
function __values(o2) {
  var s2 = typeof Symbol == "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2) return m2.call(o2);
  if (o2 && typeof o2.length == "number") return {
    next: function() {
      return o2 && i2 >= o2.length && (o2 = void 0), { value: o2 && o2[i2++], done: !o2 };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o2, n2) {
  var m2 = typeof Symbol == "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    for (; (n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done; ) ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      r2 && !r2.done && (m2 = i2.return) && m2.call(i2);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
}
var weirdNewlines = /(\u000D|\u000C|\u000D\u000A)/g, nullOrSurrogates = /[\u0000\uD800-\uDFFF]/g, commentRegex = /(\/\*)[\s\S]*?(\*\/)/g, lexicalAnalysis = function(str, index2) {
  index2 === void 0 && (index2 = 0), str = str.replace(weirdNewlines, `
`).replace(nullOrSurrogates, "�"), str = str.replace(commentRegex, "");
  for (var tokens = []; index2 < str.length; index2 += 1) {
    var code = str.charCodeAt(index2);
    if (code === 9 || code === 32 || code === 10) {
      for (var code_1 = str.charCodeAt(++index2); code_1 === 9 || code_1 === 32 || code_1 === 10; )
        code_1 = str.charCodeAt(++index2);
      index2 -= 1, tokens.push({
        type: "<whitespace-token>"
      });
    } else if (code === 34) {
      var result = consumeString(str, index2);
      if (result === null)
        return null;
      var _a4 = __read(result, 2), lastIndex = _a4[0], value = _a4[1];
      tokens.push({
        type: "<string-token>",
        value
      }), index2 = lastIndex;
    } else if (code === 35) {
      if (index2 + 1 < str.length) {
        var nextCode = str.charCodeAt(index2 + 1);
        if (nextCode === 95 || nextCode >= 65 && nextCode <= 90 || nextCode >= 97 && nextCode <= 122 || nextCode >= 128 || nextCode >= 48 && nextCode <= 57 || nextCode === 92 && index2 + 2 < str.length && str.charCodeAt(index2 + 2) !== 10) {
          var flag = wouldStartIdentifier(str, index2 + 1) ? "id" : "unrestricted", result = consumeIdentUnsafe(str, index2 + 1);
          if (result !== null) {
            var _b2 = __read(result, 2), lastIndex = _b2[0], value = _b2[1];
            tokens.push({
              type: "<hash-token>",
              value: value.toLowerCase(),
              flag
            }), index2 = lastIndex;
            continue;
          }
        }
      }
      tokens.push({
        type: "<delim-token>",
        value: code
      });
    } else if (code === 39) {
      var result = consumeString(str, index2);
      if (result === null)
        return null;
      var _c = __read(result, 2), lastIndex = _c[0], value = _c[1];
      tokens.push({
        type: "<string-token>",
        value
      }), index2 = lastIndex;
    } else if (code === 40)
      tokens.push({
        type: "<(-token>"
      });
    else if (code === 41)
      tokens.push({
        type: "<)-token>"
      });
    else if (code === 43) {
      var plusNumeric = consumeNumeric(str, index2);
      if (plusNumeric === null)
        tokens.push({
          type: "<delim-token>",
          value: code
        });
      else {
        var _d = __read(plusNumeric, 2), lastIndex = _d[0], tokenTuple = _d[1];
        tokenTuple[0] === "<dimension-token>" ? tokens.push({
          type: "<dimension-token>",
          value: tokenTuple[1],
          unit: tokenTuple[2].toLowerCase(),
          flag: "number"
        }) : tokenTuple[0] === "<number-token>" ? tokens.push({
          type: tokenTuple[0],
          value: tokenTuple[1],
          flag: tokenTuple[2]
        }) : tokens.push({
          type: tokenTuple[0],
          value: tokenTuple[1],
          flag: "number"
        }), index2 = lastIndex;
      }
    } else if (code === 44)
      tokens.push({
        type: "<comma-token>"
      });
    else if (code === 45) {
      var minusNumeric = consumeNumeric(str, index2);
      if (minusNumeric !== null) {
        var _e = __read(minusNumeric, 2), lastIndex = _e[0], tokenTuple = _e[1];
        tokenTuple[0] === "<dimension-token>" ? tokens.push({
          type: "<dimension-token>",
          value: tokenTuple[1],
          unit: tokenTuple[2].toLowerCase(),
          flag: "number"
        }) : tokenTuple[0] === "<number-token>" ? tokens.push({
          type: tokenTuple[0],
          value: tokenTuple[1],
          flag: tokenTuple[2]
        }) : tokens.push({
          type: tokenTuple[0],
          value: tokenTuple[1],
          flag: "number"
        }), index2 = lastIndex;
        continue;
      }
      if (index2 + 2 < str.length) {
        var nextCode = str.charCodeAt(index2 + 1), nextNextCode = str.charCodeAt(index2 + 2);
        if (nextCode === 45 && nextNextCode === 62) {
          tokens.push({
            type: "<CDC-token>"
          }), index2 += 2;
          continue;
        }
      }
      var result = consumeIdentLike(str, index2);
      if (result !== null) {
        var _f = __read(result, 3), lastIndex = _f[0], value = _f[1], type = _f[2];
        tokens.push({
          type,
          value
        }), index2 = lastIndex;
        continue;
      }
      tokens.push({
        type: "<delim-token>",
        value: code
      });
    } else if (code === 46) {
      var minusNumeric = consumeNumeric(str, index2);
      if (minusNumeric === null)
        tokens.push({
          type: "<delim-token>",
          value: code
        });
      else {
        var _g = __read(minusNumeric, 2), lastIndex = _g[0], tokenTuple = _g[1];
        tokenTuple[0] === "<dimension-token>" ? tokens.push({
          type: "<dimension-token>",
          value: tokenTuple[1],
          unit: tokenTuple[2].toLowerCase(),
          flag: "number"
        }) : tokenTuple[0] === "<number-token>" ? tokens.push({
          type: tokenTuple[0],
          value: tokenTuple[1],
          flag: tokenTuple[2]
        }) : tokens.push({
          type: tokenTuple[0],
          value: tokenTuple[1],
          flag: "number"
        }), index2 = lastIndex;
        continue;
      }
    } else if (code === 58)
      tokens.push({
        type: "<colon-token>"
      });
    else if (code === 59)
      tokens.push({
        type: "<semicolon-token>"
      });
    else if (code === 60) {
      if (index2 + 3 < str.length) {
        var nextCode = str.charCodeAt(index2 + 1), nextNextCode = str.charCodeAt(index2 + 2), nextNextNextCode = str.charCodeAt(index2 + 3);
        if (nextCode === 33 && nextNextCode === 45 && nextNextNextCode === 45) {
          tokens.push({
            type: "<CDO-token>"
          }), index2 += 3;
          continue;
        }
      }
      tokens.push({
        type: "<delim-token>",
        value: code
      });
    } else if (code === 64) {
      var result = consumeIdent(str, index2 + 1);
      if (result !== null) {
        var _h = __read(result, 2), lastIndex = _h[0], value = _h[1];
        tokens.push({
          type: "<at-keyword-token>",
          value: value.toLowerCase()
        }), index2 = lastIndex;
        continue;
      }
      tokens.push({
        type: "<delim-token>",
        value: code
      });
    } else if (code === 91)
      tokens.push({
        type: "<[-token>"
      });
    else if (code === 92) {
      var result = consumeEscape(str, index2);
      if (result === null)
        return null;
      var _j = __read(result, 2), lastIndex = _j[0], value = _j[1];
      str = str.slice(0, index2) + value + str.slice(lastIndex + 1), index2 -= 1;
    } else if (code === 93)
      tokens.push({
        type: "<]-token>"
      });
    else if (code === 123)
      tokens.push({
        type: "<{-token>"
      });
    else if (code === 125)
      tokens.push({
        type: "<}-token>"
      });
    else if (code >= 48 && code <= 57) {
      var result = consumeNumeric(str, index2), _k = __read(result, 2), lastIndex = _k[0], tokenTuple = _k[1];
      tokenTuple[0] === "<dimension-token>" ? tokens.push({
        type: "<dimension-token>",
        value: tokenTuple[1],
        unit: tokenTuple[2].toLowerCase(),
        flag: "number"
      }) : tokenTuple[0] === "<number-token>" ? tokens.push({
        type: tokenTuple[0],
        value: tokenTuple[1],
        flag: tokenTuple[2]
      }) : tokens.push({
        type: tokenTuple[0],
        value: tokenTuple[1],
        flag: "number"
      }), index2 = lastIndex;
    } else if (code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122 || code >= 128) {
      var result = consumeIdentLike(str, index2);
      if (result === null)
        return null;
      var _l = __read(result, 3), lastIndex = _l[0], value = _l[1], type = _l[2];
      tokens.push({
        type,
        value
      }), index2 = lastIndex;
    } else
      tokens.push({
        type: "<delim-token>",
        value: code
      });
  }
  return tokens.push({
    type: "<EOF-token>"
  }), tokens;
}, consumeString = function(str, index2) {
  if (str.length <= index2 + 1) return null;
  for (var firstCode = str.charCodeAt(index2), charCodes = [], i2 = index2 + 1; i2 < str.length; i2 += 1) {
    var code = str.charCodeAt(i2);
    if (code === firstCode)
      return [i2, String.fromCharCode.apply(null, charCodes)];
    if (code === 92) {
      var result = consumeEscape(str, i2);
      if (result === null) return null;
      var _a4 = __read(result, 2), lastIndex = _a4[0], charCode = _a4[1];
      charCodes.push(charCode), i2 = lastIndex;
    } else {
      if (code === 10)
        return null;
      charCodes.push(code);
    }
  }
  return null;
}, wouldStartIdentifier = function(str, index2) {
  if (str.length <= index2) return !1;
  var code = str.charCodeAt(index2);
  if (code === 45) {
    if (str.length <= index2 + 1) return !1;
    var nextCode = str.charCodeAt(index2 + 1);
    if (nextCode === 45 || nextCode === 95 || nextCode >= 65 && nextCode <= 90 || nextCode >= 97 && nextCode <= 122 || nextCode >= 128)
      return !0;
    if (nextCode === 92) {
      if (str.length <= index2 + 2) return !1;
      var nextNextCode = str.charCodeAt(index2 + 2);
      return nextNextCode !== 10;
    } else
      return !1;
  } else {
    if (code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122 || code >= 128)
      return !0;
    if (code === 92) {
      if (str.length <= index2 + 1) return !1;
      var nextCode = str.charCodeAt(index2 + 1);
      return nextCode !== 10;
    } else
      return !1;
  }
}, consumeEscape = function(str, index2) {
  if (str.length <= index2 + 1 || str.charCodeAt(index2) !== 92) return null;
  var code = str.charCodeAt(index2 + 1);
  if (code === 10)
    return null;
  if (code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102) {
    for (var hexCharCodes = [code], min2 = Math.min(index2 + 7, str.length), i2 = index2 + 2; i2 < min2; i2 += 1) {
      var code_2 = str.charCodeAt(i2);
      if (code_2 >= 48 && code_2 <= 57 || code_2 >= 65 && code_2 <= 70 || code_2 >= 97 && code_2 <= 102)
        hexCharCodes.push(code_2);
      else
        break;
    }
    if (i2 < str.length) {
      var code_3 = str.charCodeAt(i2);
      (code_3 === 9 || code_3 === 32 || code_3 === 10) && (i2 += 1);
    }
    return [i2 - 1, parseInt(String.fromCharCode.apply(null, hexCharCodes), 16)];
  } else
    return [index2 + 1, code];
}, consumeNumeric = function(str, index2) {
  var numberResult = consumeNumber(str, index2);
  if (numberResult === null) return null;
  var _a4 = __read(numberResult, 3), numberEndIndex = _a4[0], numberValue = _a4[1], numberFlag = _a4[2], identResult = consumeIdent(str, numberEndIndex + 1);
  if (identResult !== null) {
    var _b2 = __read(identResult, 2), identEndIndex = _b2[0], identValue = _b2[1];
    return [identEndIndex, ["<dimension-token>", numberValue, identValue]];
  }
  return numberEndIndex + 1 < str.length && str.charCodeAt(numberEndIndex + 1) === 37 ? [numberEndIndex + 1, ["<percentage-token>", numberValue]] : [numberEndIndex, ["<number-token>", numberValue, numberFlag]];
}, consumeNumber = function(str, index2) {
  if (str.length <= index2) return null;
  var flag = "integer", numberChars = [], firstCode = str.charCodeAt(index2);
  for ((firstCode === 43 || firstCode === 45) && (index2 += 1, firstCode === 45 && numberChars.push(45)); index2 < str.length; ) {
    var code = str.charCodeAt(index2);
    if (code >= 48 && code <= 57)
      numberChars.push(code), index2 += 1;
    else
      break;
  }
  if (index2 + 1 < str.length) {
    var nextCode = str.charCodeAt(index2), nextNextCode = str.charCodeAt(index2 + 1);
    if (nextCode === 46 && nextNextCode >= 48 && nextNextCode <= 57)
      for (numberChars.push(nextCode, nextNextCode), flag = "number", index2 += 2; index2 < str.length; ) {
        var code = str.charCodeAt(index2);
        if (code >= 48 && code <= 57)
          numberChars.push(code), index2 += 1;
        else
          break;
      }
  }
  if (index2 + 1 < str.length) {
    var nextCode = str.charCodeAt(index2), nextNextCode = str.charCodeAt(index2 + 1), nextNextNextCode = str.charCodeAt(index2 + 2);
    if (nextCode === 69 || nextCode === 101) {
      var nextNextIsDigit = nextNextCode >= 48 && nextNextCode <= 57;
      if (nextNextIsDigit || (nextNextCode === 43 || nextNextCode === 45) && nextNextNextCode >= 48 && nextNextNextCode <= 57)
        for (flag = "number", nextNextIsDigit ? (numberChars.push(69, nextNextCode), index2 += 2) : nextNextCode === 45 ? (numberChars.push(69, 45, nextNextNextCode), index2 += 3) : (numberChars.push(69, nextNextNextCode), index2 += 3); index2 < str.length; ) {
          var code = str.charCodeAt(index2);
          if (code >= 48 && code <= 57)
            numberChars.push(code), index2 += 1;
          else
            break;
        }
    }
  }
  var numberString = String.fromCharCode.apply(null, numberChars), value = flag === "number" ? parseFloat(numberString) : parseInt(numberString);
  return value === -0 && (value = 0), Number.isNaN(value) ? null : [index2 - 1, value, flag];
}, consumeIdentUnsafe = function(str, index2) {
  if (str.length <= index2)
    return null;
  for (var identChars = [], code = str.charCodeAt(index2); index2 < str.length; code = str.charCodeAt(++index2)) {
    if (code === 45 || code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122 || code >= 128 || code >= 48 && code <= 57) {
      identChars.push(code);
      continue;
    } else {
      var result = consumeEscape(str, index2);
      if (result !== null) {
        var _a4 = __read(result, 2), lastIndex = _a4[0], code_4 = _a4[1];
        identChars.push(code_4), index2 = lastIndex;
        continue;
      }
    }
    break;
  }
  return index2 === 0 ? null : [index2 - 1, String.fromCharCode.apply(null, identChars)];
}, consumeIdent = function(str, index2) {
  if (str.length <= index2 || !wouldStartIdentifier(str, index2))
    return null;
  for (var identChars = [], code = str.charCodeAt(index2); index2 < str.length; code = str.charCodeAt(++index2)) {
    if (code === 45 || code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122 || code >= 128 || code >= 48 && code <= 57) {
      identChars.push(code);
      continue;
    } else {
      var result = consumeEscape(str, index2);
      if (result !== null) {
        var _a4 = __read(result, 2), lastIndex = _a4[0], code_5 = _a4[1];
        identChars.push(code_5), index2 = lastIndex;
        continue;
      }
    }
    break;
  }
  return [index2 - 1, String.fromCharCode.apply(null, identChars)];
}, consumeUrl = function(str, index2) {
  for (var code = str.charCodeAt(index2); code === 9 || code === 32 || code === 10; )
    code = str.charCodeAt(++index2);
  for (var urlChars = [], hasFinishedWord = !1; index2 < str.length; ) {
    if (code === 41)
      return [index2, String.fromCharCode.apply(null, urlChars)];
    if (code === 34 || code === 39 || code === 40)
      return null;
    if (code === 9 || code === 32 || code === 10)
      !hasFinishedWord && urlChars.length !== 0 && (hasFinishedWord = !0);
    else if (code === 92) {
      var result = consumeEscape(str, index2);
      if (result === null || hasFinishedWord) return null;
      var _a4 = __read(result, 2), lastIndex = _a4[0], value = _a4[1];
      urlChars.push(value), index2 = lastIndex;
    } else {
      if (hasFinishedWord) return null;
      urlChars.push(code);
    }
    code = str.charCodeAt(++index2);
  }
  return null;
}, consumeIdentLike = function(str, index2) {
  var result = consumeIdent(str, index2);
  if (result === null) return null;
  var _a4 = __read(result, 2), lastIndex = _a4[0], value = _a4[1];
  if (value.toLowerCase() === "url") {
    if (str.length > lastIndex + 1) {
      var nextCode = str.charCodeAt(lastIndex + 1);
      if (nextCode === 40) {
        for (var offset2 = 2; lastIndex + offset2 < str.length; offset2 += 1) {
          var nextNextCode = str.charCodeAt(lastIndex + offset2);
          if (nextNextCode === 34 || nextNextCode === 39)
            return [lastIndex + 1, value.toLowerCase(), "<function-token>"];
          if (nextNextCode !== 9 && nextNextCode !== 32 && nextNextCode !== 10) {
            var result_1 = consumeUrl(str, lastIndex + offset2);
            if (result_1 === null) return null;
            var _b2 = __read(result_1, 2), lastUrlIndex = _b2[0], value_1 = _b2[1];
            return [lastUrlIndex, value_1, "<url-token>"];
          }
        }
        return [lastIndex + 1, value.toLowerCase(), "<function-token>"];
      }
    }
  } else if (str.length > lastIndex + 1) {
    var nextCode = str.charCodeAt(lastIndex + 1);
    if (nextCode === 40)
      return [lastIndex + 1, value.toLowerCase(), "<function-token>"];
  }
  return [lastIndex, value.toLowerCase(), "<ident-token>"];
}, simplifyAST = function(ast) {
  for (var i2 = ast.length - 1; i2 >= 0; i2--)
    ast[i2] = simplifyMediaQuery(ast[i2]);
  return ast;
}, simplifyMediaQuery = function(mediaQuery) {
  if (mediaQuery.mediaCondition === null) return mediaQuery;
  var mediaCondition = simplifyMediaCondition(mediaQuery.mediaCondition);
  return mediaCondition.operator === null && mediaCondition.children.length === 1 && "children" in mediaCondition.children[0] && (mediaCondition = mediaCondition.children[0]), {
    mediaPrefix: mediaQuery.mediaPrefix,
    mediaType: mediaQuery.mediaType,
    mediaCondition
  };
}, simplifyMediaCondition = function simplifyMediaCondition2(mediaCondition) {
  for (var i2 = mediaCondition.children.length - 1; i2 >= 0; i2--) {
    var unsimplifiedChild = mediaCondition.children[i2];
    if (!("context" in unsimplifiedChild)) {
      var child = simplifyMediaCondition2(unsimplifiedChild);
      if (child.operator === null && child.children.length === 1)
        mediaCondition.children[i2] = child.children[0];
      else if (child.operator === mediaCondition.operator && (child.operator === "and" || child.operator === "or")) {
        for (var spliceArgs = [i2, 1], i_1 = 0; i_1 < child.children.length; i_1++)
          spliceArgs.push(child.children[i_1]);
        mediaCondition.children.splice.apply(mediaCondition.children, spliceArgs);
      }
    }
  }
  return mediaCondition;
}, createError = function(message, err) {
  return err instanceof Error ? new Error("".concat(err.message.trim(), `
`).concat(message.trim())) : new Error(message.trim());
}, toAST = function(str) {
  return simplifyAST(toUnflattenedAST(str));
}, toUnflattenedAST = function(str) {
  var tokenList = lexicalAnalysis(str.trim());
  if (tokenList === null)
    throw createError("Failed tokenizing");
  var startIndex = 0, endIndex = tokenList.length - 1;
  if (tokenList[0].type === "<at-keyword-token>" && tokenList[0].value === "media") {
    if (tokenList[1].type !== "<whitespace-token>")
      throw createError("Expected whitespace after media");
    startIndex = 2;
    for (var i2 = 2; i2 < tokenList.length - 1; i2++) {
      var token = tokenList[i2];
      if (token.type === "<{-token>") {
        endIndex = i2;
        break;
      } else if (token.type === "<semicolon-token>")
        throw createError("Expected '{' in media query but found ';'");
    }
  }
  return tokenList = tokenList.slice(startIndex, endIndex), syntacticAnalysis(tokenList);
}, removeWhitespace = function(tokenList) {
  for (var newTokenList = [], before = !1, i2 = 0; i2 < tokenList.length; i2++)
    tokenList[i2].type === "<whitespace-token>" ? (before = !0, newTokenList.length > 0 && (newTokenList[newTokenList.length - 1].wsAfter = !0)) : (newTokenList.push(__assign(__assign({}, tokenList[i2]), {
      wsBefore: before,
      wsAfter: !1
    })), before = !1);
  return newTokenList;
}, syntacticAnalysis = function(tokenList) {
  for (var e_1, _a4, mediaQueryList = [[]], i2 = 0; i2 < tokenList.length; i2++) {
    var token = tokenList[i2];
    token.type === "<comma-token>" ? mediaQueryList.push([]) : mediaQueryList[mediaQueryList.length - 1].push(token);
  }
  var mediaQueries = mediaQueryList.map(removeWhitespace);
  if (mediaQueries.length === 1 && mediaQueries[0].length === 0)
    return [{
      mediaCondition: null,
      mediaPrefix: null,
      mediaType: "all"
    }];
  var mediaQueryTokens = mediaQueries.map(function(mediaQueryTokens2) {
    return mediaQueryTokens2.length === 0 ? null : tokenizeMediaQuery(mediaQueryTokens2);
  }), nonNullMediaQueryTokens = [];
  try {
    for (var mediaQueryTokens_1 = __values(mediaQueryTokens), mediaQueryTokens_1_1 = mediaQueryTokens_1.next(); !mediaQueryTokens_1_1.done; mediaQueryTokens_1_1 = mediaQueryTokens_1.next()) {
      var mediaQueryToken = mediaQueryTokens_1_1.value;
      mediaQueryToken !== null && nonNullMediaQueryTokens.push(mediaQueryToken);
    }
  } catch (e_1_1) {
    e_1 = {
      error: e_1_1
    };
  } finally {
    try {
      mediaQueryTokens_1_1 && !mediaQueryTokens_1_1.done && (_a4 = mediaQueryTokens_1.return) && _a4.call(mediaQueryTokens_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
  if (nonNullMediaQueryTokens.length === 0)
    throw createError("No valid media queries");
  return nonNullMediaQueryTokens;
}, tokenizeMediaQuery = function(tokens) {
  var firstToken = tokens[0];
  if (firstToken.type === "<(-token>")
    try {
      return {
        mediaPrefix: null,
        mediaType: "all",
        mediaCondition: tokenizeMediaCondition(tokens, !0)
      };
    } catch (err) {
      throw createError("Expected media condition after '('", err);
    }
  else if (firstToken.type === "<ident-token>") {
    var mediaPrefix = null, mediaType = void 0, value = firstToken.value;
    (value === "only" || value === "not") && (mediaPrefix = value);
    var firstIndex = mediaPrefix === null ? 0 : 1;
    if (tokens.length <= firstIndex)
      throw createError("Expected extra token in media query");
    var firstNonUnaryToken = tokens[firstIndex];
    if (firstNonUnaryToken.type === "<ident-token>") {
      var value_1 = firstNonUnaryToken.value;
      if (value_1 === "all")
        mediaType = "all";
      else if (value_1 === "print" || value_1 === "screen")
        mediaType = value_1;
      else if (value_1 === "tty" || value_1 === "tv" || value_1 === "projection" || value_1 === "handheld" || value_1 === "braille" || value_1 === "embossed" || value_1 === "aural" || value_1 === "speech")
        mediaPrefix = mediaPrefix === "not" ? null : "not", mediaType = "all";
      else
        throw createError("Unknown ident '".concat(value_1, "' in media query"));
    } else if (mediaPrefix === "not" && firstNonUnaryToken.type === "<(-token>") {
      var tokensWithParens = [{
        type: "<(-token>",
        wsBefore: !1,
        wsAfter: !1
      }];
      tokensWithParens.push.apply(tokensWithParens, tokens), tokensWithParens.push({
        type: "<)-token>",
        wsBefore: !1,
        wsAfter: !1
      });
      try {
        return {
          mediaPrefix: null,
          mediaType: "all",
          mediaCondition: tokenizeMediaCondition(tokensWithParens, !0)
        };
      } catch (err) {
        throw createError("Expected media condition after '('", err);
      }
    } else
      throw createError("Invalid media query");
    if (firstIndex + 1 === tokens.length)
      return {
        mediaPrefix,
        mediaType,
        mediaCondition: null
      };
    if (firstIndex + 4 < tokens.length) {
      var secondNonUnaryToken = tokens[firstIndex + 1];
      if (secondNonUnaryToken.type === "<ident-token>" && secondNonUnaryToken.value === "and")
        try {
          return {
            mediaPrefix,
            mediaType,
            mediaCondition: tokenizeMediaCondition(tokens.slice(firstIndex + 2), !1)
          };
        } catch (err) {
          throw createError("Expected media condition after 'and'", err);
        }
      else
        throw createError("Expected 'and' after media prefix");
    } else
      throw createError("Expected media condition after media prefix");
  } else
    throw createError("Expected media condition or media prefix");
}, tokenizeMediaCondition = function tokenizeMediaCondition2(tokens, mayContainOr, previousOperator) {
  if (previousOperator === void 0 && (previousOperator = null), tokens.length < 3 || tokens[0].type !== "<(-token>" || tokens[tokens.length - 1].type !== "<)-token>")
    throw new Error("Invalid media condition");
  for (var endIndexOfFirstFeature = tokens.length - 1, maxDepth = 0, count2 = 0, i2 = 0; i2 < tokens.length; i2++) {
    var token = tokens[i2];
    if (token.type === "<(-token>" ? (count2 += 1, maxDepth = Math.max(maxDepth, count2)) : token.type === "<)-token>" && (count2 -= 1), count2 === 0) {
      endIndexOfFirstFeature = i2;
      break;
    }
  }
  if (count2 !== 0)
    throw new Error(`Mismatched parens
Invalid media condition`);
  var child, featureTokens = tokens.slice(0, endIndexOfFirstFeature + 1);
  if (maxDepth === 1 ? child = tokenizeMediaFeature(featureTokens) : featureTokens[1].type === "<ident-token>" && featureTokens[1].value === "not" ? child = tokenizeMediaCondition2(featureTokens.slice(2, -1), !0, "not") : child = tokenizeMediaCondition2(featureTokens.slice(1, -1), !0), endIndexOfFirstFeature === tokens.length - 1)
    return {
      operator: previousOperator,
      children: [child]
    };
  var nextToken = tokens[endIndexOfFirstFeature + 1];
  if (nextToken.type !== "<ident-token>")
    throw new Error(`Invalid operator
Invalid media condition`);
  if (previousOperator !== null && previousOperator !== nextToken.value)
    throw new Error("'".concat(nextToken.value, "' and '").concat(previousOperator, `' must not be at same level
Invalid media condition`));
  if (nextToken.value === "or" && !mayContainOr)
    throw new Error(`Cannot use 'or' at top level of a media query
Invalid media condition`);
  if (nextToken.value !== "and" && nextToken.value !== "or")
    throw new Error("Invalid operator: '".concat(nextToken.value, `'
Invalid media condition`));
  var siblings = tokenizeMediaCondition2(tokens.slice(endIndexOfFirstFeature + 2), mayContainOr, nextToken.value);
  return {
    operator: nextToken.value,
    children: [child].concat(siblings.children)
  };
}, tokenizeMediaFeature = function(rawTokens) {
  if (rawTokens.length < 3 || rawTokens[0].type !== "<(-token>" || rawTokens[rawTokens.length - 1].type !== "<)-token>")
    throw new Error("Invalid media feature");
  for (var tokens = [rawTokens[0]], i2 = 1; i2 < rawTokens.length; i2++) {
    if (i2 < rawTokens.length - 2) {
      var a2 = rawTokens[i2], b2 = rawTokens[i2 + 1], c = rawTokens[i2 + 2];
      if (a2.type === "<number-token>" && a2.value > 0 && b2.type === "<delim-token>" && b2.value === 47 && c.type === "<number-token>" && c.value > 0) {
        tokens.push({
          type: "<ratio-token>",
          numerator: a2.value,
          denominator: c.value,
          wsBefore: a2.wsBefore,
          wsAfter: c.wsAfter
        }), i2 += 2;
        continue;
      }
    }
    tokens.push(rawTokens[i2]);
  }
  var nextToken = tokens[1];
  if (nextToken.type === "<ident-token>" && tokens.length === 3)
    return {
      context: "boolean",
      feature: nextToken.value
    };
  if (tokens.length === 5 && tokens[1].type === "<ident-token>" && tokens[2].type === "<colon-token>") {
    var valueToken = tokens[3];
    if (valueToken.type === "<number-token>" || valueToken.type === "<dimension-token>" || valueToken.type === "<ratio-token>" || valueToken.type === "<ident-token>") {
      var feature = tokens[1].value, prefix = null, slice = feature.slice(0, 4);
      slice === "min-" ? (prefix = "min", feature = feature.slice(4)) : slice === "max-" && (prefix = "max", feature = feature.slice(4)), valueToken.wsBefore, valueToken.wsAfter;
      var value = __rest(valueToken, ["wsBefore", "wsAfter"]);
      return {
        context: "value",
        prefix,
        feature,
        value
      };
    }
  } else if (tokens.length >= 5)
    try {
      var range2 = tokenizeRange(tokens);
      return {
        context: "range",
        feature: range2.featureName,
        range: range2
      };
    } catch (err) {
      throw createError("Invalid media feature", err);
    }
  throw new Error("Invalid media feature");
}, tokenizeRange = function(tokens) {
  var _a4, _b2, _c, _d;
  if (tokens.length < 5 || tokens[0].type !== "<(-token>" || tokens[tokens.length - 1].type !== "<)-token>")
    throw new Error("Invalid range");
  var range2 = {
    leftToken: null,
    leftOp: null,
    featureName: "",
    rightOp: null,
    rightToken: null
  }, hasLeft = tokens[1].type === "<number-token>" || tokens[1].type === "<dimension-token>" || tokens[1].type === "<ratio-token>" || tokens[1].type === "<ident-token>" && tokens[1].value === "infinite";
  if (tokens[2].type === "<delim-token>") {
    if (tokens[2].value === 60)
      tokens[3].type === "<delim-token>" && tokens[3].value === 61 && !tokens[3].wsBefore ? range2[hasLeft ? "leftOp" : "rightOp"] = "<=" : range2[hasLeft ? "leftOp" : "rightOp"] = "<";
    else if (tokens[2].value === 62)
      tokens[3].type === "<delim-token>" && tokens[3].value === 61 && !tokens[3].wsBefore ? range2[hasLeft ? "leftOp" : "rightOp"] = ">=" : range2[hasLeft ? "leftOp" : "rightOp"] = ">";
    else if (tokens[2].value === 61)
      range2[hasLeft ? "leftOp" : "rightOp"] = "=";
    else
      throw new Error("Invalid range");
    if (hasLeft)
      range2.leftToken = tokens[1];
    else if (tokens[1].type === "<ident-token>")
      range2.featureName = tokens[1].value;
    else
      throw new Error("Invalid range");
    var tokenIndexAfterFirstOp = 2 + ((_b2 = (_a4 = range2[hasLeft ? "leftOp" : "rightOp"]) === null || _a4 === void 0 ? void 0 : _a4.length) !== null && _b2 !== void 0 ? _b2 : 0), tokenAfterFirstOp = tokens[tokenIndexAfterFirstOp];
    if (hasLeft)
      if (tokenAfterFirstOp.type === "<ident-token>") {
        if (range2.featureName = tokenAfterFirstOp.value, tokens.length >= 7) {
          var secondOpToken = tokens[tokenIndexAfterFirstOp + 1], followingToken = tokens[tokenIndexAfterFirstOp + 2];
          if (secondOpToken.type === "<delim-token>") {
            var charCode = secondOpToken.value;
            if (charCode === 60)
              followingToken.type === "<delim-token>" && followingToken.value === 61 && !followingToken.wsBefore ? range2.rightOp = "<=" : range2.rightOp = "<";
            else if (charCode === 62)
              followingToken.type === "<delim-token>" && followingToken.value === 61 && !followingToken.wsBefore ? range2.rightOp = ">=" : range2.rightOp = ">";
            else
              throw new Error("Invalid range");
            var tokenAfterSecondOp = tokens[tokenIndexAfterFirstOp + 1 + ((_d = (_c = range2.rightOp) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0)];
            range2.rightToken = tokenAfterSecondOp;
          } else
            throw new Error("Invalid range");
        } else if (tokenIndexAfterFirstOp + 2 !== tokens.length)
          throw new Error("Invalid range");
      } else
        throw new Error("Invalid range");
    else
      range2.rightToken = tokenAfterFirstOp;
    var validRange = null, lt = range2.leftToken, leftOp = range2.leftOp, featureName = range2.featureName, rightOp = range2.rightOp, rt = range2.rightToken, leftToken = null;
    if (lt !== null) {
      if (lt.type === "<ident-token>") {
        var type = lt.type, value = lt.value;
        value === "infinite" && (leftToken = {
          type,
          value
        });
      } else if (lt.type === "<number-token>" || lt.type === "<dimension-token>" || lt.type === "<ratio-token>") {
        lt.wsBefore, lt.wsAfter;
        var ltNoWS = __rest(lt, ["wsBefore", "wsAfter"]);
        leftToken = ltNoWS;
      }
    }
    var rightToken = null;
    if (rt !== null) {
      if (rt.type === "<ident-token>") {
        var type = rt.type, value = rt.value;
        value === "infinite" && (rightToken = {
          type,
          value
        });
      } else if (rt.type === "<number-token>" || rt.type === "<dimension-token>" || rt.type === "<ratio-token>") {
        rt.wsBefore, rt.wsAfter;
        var rtNoWS = __rest(rt, ["wsBefore", "wsAfter"]);
        rightToken = rtNoWS;
      }
    }
    if (leftToken !== null && rightToken !== null)
      if ((leftOp === "<" || leftOp === "<=") && (rightOp === "<" || rightOp === "<="))
        validRange = {
          leftToken,
          leftOp,
          featureName,
          rightOp,
          rightToken
        };
      else if ((leftOp === ">" || leftOp === ">=") && (rightOp === ">" || rightOp === ">="))
        validRange = {
          leftToken,
          leftOp,
          featureName,
          rightOp,
          rightToken
        };
      else
        throw new Error("Invalid range");
    else leftToken === null && leftOp === null && rightOp !== null && rightToken !== null ? validRange = {
      leftToken,
      leftOp,
      featureName,
      rightOp,
      rightToken
    } : leftToken !== null && leftOp !== null && rightOp === null && rightToken === null && (validRange = {
      leftToken,
      leftOp,
      featureName,
      rightOp,
      rightToken
    });
    return validRange;
  } else
    throw new Error("Invalid range");
};
function toPrimitive(t2, r2) {
  if (typeof t2 != "object" || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (e2 !== void 0) {
    var i2 = e2.call(t2, r2);
    if (typeof i2 != "object") return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t2);
}
function toPropertyKey(t2) {
  var i2 = toPrimitive(t2, "string");
  return typeof i2 == "symbol" ? i2 : String(i2);
}
function _defineProperty(obj, key, value) {
  return key = toPropertyKey(key), key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function ownKeys(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread2(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = arguments[r2] != null ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t2), !0).forEach(function(r3) {
      _defineProperty(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {}, sourceKeys = Object.keys(source), key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++)
    key = sourceKeys[i2], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded), key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++)
      key = sourceSymbolKeys[i2], !(excluded.indexOf(key) >= 0) && Object.prototype.propertyIsEnumerable.call(source, key) && (target[key] = source[key]);
  }
  return target;
}
function forEach(obj, fn) {
  for (var _key in obj)
    fn(obj[_key], _key);
}
function omit(obj, omitKeys) {
  var result = {};
  for (var _key2 in obj)
    omitKeys.indexOf(_key2) === -1 && (result[_key2] = obj[_key2]);
  return result;
}
function mapKeys(obj, fn) {
  var result = {};
  for (var _key3 in obj)
    result[fn(obj[_key3], _key3)] = obj[_key3];
  return result;
}
var _templateObject$1;
function escapeRegex(string) {
  return string.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var validateSelector = (selector2, targetClassName) => {
  var replaceTarget = () => {
    var targetRegex = new RegExp(".".concat(escapeRegex(cssesc$1(targetClassName, {
      isIdentifier: !0
    }))), "g");
    return selector2.replace(targetRegex, "&");
  }, selectorParts;
  try {
    selectorParts = parse(selector2);
  } catch {
    throw new Error("Invalid selector: ".concat(replaceTarget()));
  }
  selectorParts.forEach((tokens) => {
    try {
      for (var i2 = tokens.length - 1; i2 >= -1; i2--) {
        if (!tokens[i2])
          throw new Error();
        var token = tokens[i2];
        if (token.type === "child" || token.type === "parent" || token.type === "sibling" || token.type === "adjacent" || token.type === "descendant")
          throw new Error();
        if (token.type === "attribute" && token.name === "class" && token.value === targetClassName)
          return;
      }
    } catch {
      throw new Error(dedent(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteral([`
        Invalid selector: `, `
    
        Style selectors must target the '&' character (along with any modifiers), e.g. `, " or ", `.
        
        This is to ensure that each style block only affects the styling of a single class.
        
        If your selector is targeting another class, you should move it to the style definition for that class, e.g. given we have styles for 'parent' and 'child' elements, instead of adding a selector of `, ") to 'parent', you should add ", ` to 'child').
        
        If your selector is targeting something global, use the 'globalStyle' function instead, e.g. if you wanted to write `, ", you should instead write 'globalStyle(", `, { ... })'
      `])), replaceTarget(), "`${parent} &`", "`${parent} &:hover`", "`& ${child}`", "`${parent} &`", "`& h1`", "`${parent} h1`"));
    }
  });
};
class ConditionalRuleset {
  /**
   * Stores information about where conditions must be in relation to other conditions
   *
   * e.g. mobile -> tablet, desktop
   */
  constructor() {
    this.ruleset = /* @__PURE__ */ new Map(), this.precedenceLookup = /* @__PURE__ */ new Map();
  }
  findOrCreateCondition(conditionQuery) {
    var targetCondition = this.ruleset.get(conditionQuery);
    return targetCondition || (targetCondition = {
      query: conditionQuery,
      rules: [],
      children: new ConditionalRuleset()
    }, this.ruleset.set(conditionQuery, targetCondition)), targetCondition;
  }
  getConditionalRulesetByPath(conditionPath) {
    var currRuleset = this;
    for (var query of conditionPath) {
      var condition = currRuleset.findOrCreateCondition(query);
      currRuleset = condition.children;
    }
    return currRuleset;
  }
  addRule(rule, conditionQuery, conditionPath) {
    var ruleset = this.getConditionalRulesetByPath(conditionPath), targetCondition = ruleset.findOrCreateCondition(conditionQuery);
    if (!targetCondition)
      throw new Error("Failed to add conditional rule");
    targetCondition.rules.push(rule);
  }
  addConditionPrecedence(conditionPath, conditionOrder) {
    for (var ruleset = this.getConditionalRulesetByPath(conditionPath), i2 = 0; i2 < conditionOrder.length; i2++) {
      var _ruleset$precedenceLo, query = conditionOrder[i2], conditionPrecedence = (_ruleset$precedenceLo = ruleset.precedenceLookup.get(query)) !== null && _ruleset$precedenceLo !== void 0 ? _ruleset$precedenceLo : /* @__PURE__ */ new Set();
      for (var lowerPrecedenceCondition of conditionOrder.slice(i2 + 1))
        conditionPrecedence.add(lowerPrecedenceCondition);
      ruleset.precedenceLookup.set(query, conditionPrecedence);
    }
  }
  isCompatible(incomingRuleset) {
    for (var [condition, orderPrecedence] of this.precedenceLookup.entries())
      for (var lowerPrecedenceCondition of orderPrecedence) {
        var _incomingRuleset$prec;
        if ((_incomingRuleset$prec = incomingRuleset.precedenceLookup.get(lowerPrecedenceCondition)) !== null && _incomingRuleset$prec !== void 0 && _incomingRuleset$prec.has(condition))
          return !1;
      }
    for (var {
      query,
      children: children2
    } of incomingRuleset.ruleset.values()) {
      var matchingCondition = this.ruleset.get(query);
      if (matchingCondition && !matchingCondition.children.isCompatible(children2))
        return !1;
    }
    return !0;
  }
  merge(incomingRuleset) {
    for (var {
      query,
      rules,
      children: children2
    } of incomingRuleset.ruleset.values()) {
      var matchingCondition = this.ruleset.get(query);
      matchingCondition ? (matchingCondition.rules.push(...rules), matchingCondition.children.merge(children2)) : this.ruleset.set(query, {
        query,
        rules,
        children: children2
      });
    }
    for (var [condition, incomingOrderPrecedence] of incomingRuleset.precedenceLookup.entries()) {
      var _this$precedenceLooku, orderPrecedence = (_this$precedenceLooku = this.precedenceLookup.get(condition)) !== null && _this$precedenceLooku !== void 0 ? _this$precedenceLooku : /* @__PURE__ */ new Set();
      this.precedenceLookup.set(condition, /* @__PURE__ */ new Set([...orderPrecedence, ...incomingOrderPrecedence]));
    }
  }
  /**
   * Merge another ConditionalRuleset into this one if they are compatible
   *
   * @returns true if successful, false if the ruleset is incompatible
   */
  mergeIfCompatible(incomingRuleset) {
    return this.isCompatible(incomingRuleset) ? (this.merge(incomingRuleset), !0) : !1;
  }
  getSortedRuleset() {
    var _this = this, sortedRuleset = [], _loop = function(dependents2) {
      var conditionForQuery = _this.ruleset.get(query);
      if (!conditionForQuery)
        throw new Error("Can't find condition for ".concat(query));
      var firstMatchingDependent = sortedRuleset.findIndex((condition) => dependents2.has(condition.query));
      firstMatchingDependent > -1 ? sortedRuleset.splice(firstMatchingDependent, 0, conditionForQuery) : sortedRuleset.push(conditionForQuery);
    };
    for (var [query, dependents] of this.precedenceLookup.entries())
      _loop(dependents);
    return sortedRuleset;
  }
  renderToArray() {
    var arr = [];
    for (var {
      query,
      rules,
      children: children2
    } of this.getSortedRuleset()) {
      var selectors = {};
      for (var rule of rules)
        selectors[rule.selector] = _objectSpread2(_objectSpread2({}, selectors[rule.selector]), rule.rule);
      Object.assign(selectors, ...children2.renderToArray()), arr.push({
        [query]: selectors
      });
    }
    return arr;
  }
}
var simplePseudoMap = {
  ":-moz-any-link": !0,
  ":-moz-full-screen": !0,
  ":-moz-placeholder": !0,
  ":-moz-read-only": !0,
  ":-moz-read-write": !0,
  ":-ms-fullscreen": !0,
  ":-ms-input-placeholder": !0,
  ":-webkit-any-link": !0,
  ":-webkit-full-screen": !0,
  "::-moz-color-swatch": !0,
  "::-moz-list-bullet": !0,
  "::-moz-list-number": !0,
  "::-moz-page-sequence": !0,
  "::-moz-page": !0,
  "::-moz-placeholder": !0,
  "::-moz-progress-bar": !0,
  "::-moz-range-progress": !0,
  "::-moz-range-thumb": !0,
  "::-moz-range-track": !0,
  "::-moz-scrolled-page-sequence": !0,
  "::-moz-selection": !0,
  "::-ms-backdrop": !0,
  "::-ms-browse": !0,
  "::-ms-check": !0,
  "::-ms-clear": !0,
  "::-ms-fill-lower": !0,
  "::-ms-fill-upper": !0,
  "::-ms-fill": !0,
  "::-ms-reveal": !0,
  "::-ms-thumb": !0,
  "::-ms-ticks-after": !0,
  "::-ms-ticks-before": !0,
  "::-ms-tooltip": !0,
  "::-ms-track": !0,
  "::-ms-value": !0,
  "::-webkit-backdrop": !0,
  "::-webkit-calendar-picker-indicator": !0,
  "::-webkit-inner-spin-button": !0,
  "::-webkit-input-placeholder": !0,
  "::-webkit-meter-bar": !0,
  "::-webkit-meter-even-less-good-value": !0,
  "::-webkit-meter-inner-element": !0,
  "::-webkit-meter-optimum-value": !0,
  "::-webkit-meter-suboptimum-value": !0,
  "::-webkit-outer-spin-button": !0,
  "::-webkit-progress-bar": !0,
  "::-webkit-progress-inner-element": !0,
  "::-webkit-progress-inner-value": !0,
  "::-webkit-progress-value": !0,
  "::-webkit-resizer": !0,
  "::-webkit-scrollbar-button": !0,
  "::-webkit-scrollbar-corner": !0,
  "::-webkit-scrollbar-thumb": !0,
  "::-webkit-scrollbar-track-piece": !0,
  "::-webkit-scrollbar-track": !0,
  "::-webkit-scrollbar": !0,
  "::-webkit-search-cancel-button": !0,
  "::-webkit-search-results-button": !0,
  "::-webkit-slider-runnable-track": !0,
  "::-webkit-slider-thumb": !0,
  "::after": !0,
  "::backdrop": !0,
  "::before": !0,
  "::cue": !0,
  "::file-selector-button": !0,
  "::first-letter": !0,
  "::first-line": !0,
  "::grammar-error": !0,
  "::marker": !0,
  "::placeholder": !0,
  "::selection": !0,
  "::spelling-error": !0,
  "::target-text": !0,
  "::view-transition-group": !0,
  "::view-transition-image-pair": !0,
  "::view-transition-new": !0,
  "::view-transition-old": !0,
  "::view-transition": !0,
  ":active": !0,
  ":after": !0,
  ":any-link": !0,
  ":before": !0,
  ":blank": !0,
  ":checked": !0,
  ":default": !0,
  ":defined": !0,
  ":disabled": !0,
  ":empty": !0,
  ":enabled": !0,
  ":first-child": !0,
  ":first-letter": !0,
  ":first-line": !0,
  ":first-of-type": !0,
  ":first": !0,
  ":focus-visible": !0,
  ":focus-within": !0,
  ":focus": !0,
  ":fullscreen": !0,
  ":hover": !0,
  ":in-range": !0,
  ":indeterminate": !0,
  ":invalid": !0,
  ":last-child": !0,
  ":last-of-type": !0,
  ":left": !0,
  ":link": !0,
  ":only-child": !0,
  ":only-of-type": !0,
  ":optional": !0,
  ":out-of-range": !0,
  ":placeholder-shown": !0,
  ":read-only": !0,
  ":read-write": !0,
  ":required": !0,
  ":right": !0,
  ":root": !0,
  ":scope": !0,
  ":target": !0,
  ":valid": !0,
  ":visited": !0
}, simplePseudos = Object.keys(simplePseudoMap), simplePseudoLookup = simplePseudoMap, _templateObject, createMediaQueryError = (mediaQuery, msg) => new Error(dedent(_templateObject || (_templateObject = _taggedTemplateLiteral([`
    Invalid media query: "`, `"

    `, `

    Read more on MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries
  `])), mediaQuery, msg)), validateMediaQuery = (mediaQuery) => {
  if (mediaQuery === "@media ")
    throw createMediaQueryError(mediaQuery, "Query is empty");
  try {
    toAST(mediaQuery);
  } catch (e2) {
    throw createMediaQueryError(mediaQuery, e2.message);
  }
}, _excluded = ["vars"], _excluded2 = ["content"], DECLARATION = "__DECLARATION", UNITLESS = {
  animationIterationCount: !0,
  borderImage: !0,
  borderImageOutset: !0,
  borderImageSlice: !0,
  borderImageWidth: !0,
  boxFlex: !0,
  boxFlexGroup: !0,
  columnCount: !0,
  columns: !0,
  flex: !0,
  flexGrow: !0,
  flexShrink: !0,
  fontWeight: !0,
  gridArea: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnStart: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowStart: !0,
  initialLetter: !0,
  lineClamp: !0,
  lineHeight: !0,
  maxLines: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  scale: !0,
  tabSize: !0,
  WebkitLineClamp: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  // svg properties
  fillOpacity: !0,
  floodOpacity: !0,
  maskBorder: !0,
  maskBorderOutset: !0,
  maskBorderSlice: !0,
  maskBorderWidth: !0,
  shapeImageThreshold: !0,
  stopOpacity: !0,
  strokeDashoffset: !0,
  strokeMiterlimit: !0,
  strokeOpacity: !0,
  strokeWidth: !0
};
function dashify(str) {
  return str.replace(/([A-Z])/g, "-$1").replace(/^ms-/, "-ms-").toLowerCase();
}
function replaceBetweenIndexes(target, startIndex, endIndex, replacement) {
  var start2 = target.slice(0, startIndex), end = target.slice(endIndex);
  return "".concat(start2).concat(replacement).concat(end);
}
var DOUBLE_SPACE = "  ", specialKeys = [...simplePseudos, "@layer", "@media", "@supports", "@container", "selectors"];
class Stylesheet {
  constructor(localClassNames2, composedClassLists2) {
    this.rules = [], this.conditionalRulesets = [new ConditionalRuleset()], this.fontFaceRules = [], this.keyframesRules = [], this.localClassNamesMap = new Map(localClassNames2.map((localClassName) => [localClassName, localClassName])), this.localClassNamesSearch = new AhoCorasick(localClassNames2), this.layers = /* @__PURE__ */ new Map(), this.composedClassLists = composedClassLists2.map((_ref) => {
      var {
        identifier,
        classList: classList2
      } = _ref;
      return {
        identifier,
        regex: RegExp("(".concat(classList2, ")"), "g")
      };
    }).reverse();
  }
  processCssObj(root2) {
    if (root2.type === "fontFace") {
      this.fontFaceRules.push(root2.rule);
      return;
    }
    if (root2.type === "keyframes") {
      root2.rule = Object.fromEntries(Object.entries(root2.rule).map((_ref2) => {
        var [keyframe, rule] = _ref2;
        return [keyframe, this.transformProperties(rule)];
      })), this.keyframesRules.push(root2);
      return;
    }
    if (this.currConditionalRuleset = new ConditionalRuleset(), root2.type === "layer") {
      var layerDefinition = "@layer ".concat(root2.name);
      this.addLayer([layerDefinition]);
    } else {
      var mainRule = omit(root2.rule, specialKeys);
      this.addRule({
        selector: root2.selector,
        rule: mainRule
      }), this.transformLayer(root2, root2.rule["@layer"]), this.transformMedia(root2, root2.rule["@media"]), this.transformSupports(root2, root2.rule["@supports"]), this.transformContainer(root2, root2.rule["@container"]), this.transformSimplePseudos(root2, root2.rule), this.transformSelectors(root2, root2.rule);
    }
    var activeConditionalRuleset = this.conditionalRulesets[this.conditionalRulesets.length - 1];
    activeConditionalRuleset.mergeIfCompatible(this.currConditionalRuleset) || this.conditionalRulesets.push(this.currConditionalRuleset);
  }
  addConditionalRule(cssRule, conditions) {
    var rule = this.transformVars(this.transformProperties(cssRule.rule)), selector2 = this.transformSelector(cssRule.selector);
    if (!this.currConditionalRuleset)
      throw new Error("Couldn't add conditional rule");
    var conditionQuery = conditions[conditions.length - 1], parentConditions = conditions.slice(0, conditions.length - 1);
    this.currConditionalRuleset.addRule({
      selector: selector2,
      rule
    }, conditionQuery, parentConditions);
  }
  addRule(cssRule) {
    var rule = this.transformVars(this.transformProperties(cssRule.rule)), selector2 = this.transformSelector(cssRule.selector);
    this.rules.push({
      selector: selector2,
      rule
    });
  }
  addLayer(layer) {
    var uniqueLayerKey = layer.join(" - ");
    this.layers.set(uniqueLayerKey, layer);
  }
  transformProperties(cssRule) {
    return this.transformContent(this.pixelifyProperties(cssRule));
  }
  pixelifyProperties(cssRule) {
    return forEach(cssRule, (value, key) => {
      typeof value == "number" && value !== 0 && !UNITLESS[key] && (cssRule[key] = "".concat(value, "px"));
    }), cssRule;
  }
  transformVars(_ref3) {
    var {
      vars: vars2
    } = _ref3, rest = _objectWithoutProperties(_ref3, _excluded);
    return vars2 ? _objectSpread2(_objectSpread2({}, mapKeys(vars2, (_value, key) => getVarName(key))), rest) : rest;
  }
  transformContent(_ref4) {
    var {
      content
    } = _ref4, rest = _objectWithoutProperties(_ref4, _excluded2);
    if (typeof content > "u")
      return rest;
    var contentArray = Array.isArray(content) ? content : [content];
    return _objectSpread2({
      content: contentArray.map((value) => (
        // This logic was adapted from Stitches :)
        value && (value.includes('"') || value.includes("'") || /^([A-Za-z\-]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)(\s|$)/.test(value)) ? value : '"'.concat(value, '"')
      ))
    }, rest);
  }
  transformClassname(identifier) {
    return ".".concat(cssesc$1(identifier, {
      isIdentifier: !0
    }));
  }
  transformSelector(selector2) {
    var transformedSelector = selector2, _loop = function(identifier2) {
      transformedSelector = transformedSelector.replace(regex, () => (markCompositionUsed(identifier2), identifier2));
    };
    for (var {
      identifier,
      regex
    } of this.composedClassLists)
      _loop(identifier);
    if (this.localClassNamesMap.has(transformedSelector))
      return this.transformClassname(transformedSelector);
    for (var results = this.localClassNamesSearch.search(transformedSelector), lastReplaceIndex = transformedSelector.length, i2 = results.length - 1; i2 >= 0; i2--) {
      var [endIndex, [firstMatch]] = results[i2], startIndex = endIndex - firstMatch.length + 1, skipReplacement = lastReplaceIndex <= endIndex;
      skipReplacement || (lastReplaceIndex = startIndex, transformedSelector[startIndex - 1] !== "." && (transformedSelector = replaceBetweenIndexes(transformedSelector, startIndex, endIndex + 1, this.transformClassname(firstMatch))));
    }
    return transformedSelector;
  }
  transformSelectors(root2, rule, conditions) {
    forEach(rule.selectors, (selectorRule, selector2) => {
      if (root2.type !== "local")
        throw new Error("Selectors are not allowed within ".concat(root2.type === "global" ? '"globalStyle"' : '"selectors"'));
      var transformedSelector = this.transformSelector(selector2.replace(RegExp("&", "g"), root2.selector));
      validateSelector(transformedSelector, root2.selector);
      var rule2 = {
        selector: transformedSelector,
        rule: omit(selectorRule, specialKeys)
      };
      conditions ? this.addConditionalRule(rule2, conditions) : this.addRule(rule2);
      var selectorRoot = {
        type: "selector",
        selector: transformedSelector,
        rule: selectorRule
      };
      this.transformLayer(selectorRoot, selectorRule["@layer"], conditions), this.transformSupports(selectorRoot, selectorRule["@supports"], conditions), this.transformMedia(selectorRoot, selectorRule["@media"], conditions);
    });
  }
  transformMedia(root2, rules) {
    var parentConditions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    if (rules) {
      var _this$currConditional;
      (_this$currConditional = this.currConditionalRuleset) === null || _this$currConditional === void 0 || _this$currConditional.addConditionPrecedence(parentConditions, Object.keys(rules).map((query2) => "@media ".concat(query2)));
      for (var [query, mediaRule] of Object.entries(rules)) {
        var mediaQuery = "@media ".concat(query);
        validateMediaQuery(mediaQuery);
        var conditions = [...parentConditions, mediaQuery];
        this.addConditionalRule({
          selector: root2.selector,
          rule: omit(mediaRule, specialKeys)
        }, conditions), root2.type === "local" && (this.transformSimplePseudos(root2, mediaRule, conditions), this.transformSelectors(root2, mediaRule, conditions)), this.transformLayer(root2, mediaRule["@layer"], conditions), this.transformSupports(root2, mediaRule["@supports"], conditions), this.transformContainer(root2, mediaRule["@container"], conditions);
      }
    }
  }
  transformContainer(root2, rules) {
    var parentConditions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    if (rules) {
      var _this$currConditional2;
      (_this$currConditional2 = this.currConditionalRuleset) === null || _this$currConditional2 === void 0 || _this$currConditional2.addConditionPrecedence(parentConditions, Object.keys(rules).map((query) => "@container ".concat(query))), forEach(rules, (containerRule, query) => {
        var containerQuery = "@container ".concat(query), conditions = [...parentConditions, containerQuery];
        this.addConditionalRule({
          selector: root2.selector,
          rule: omit(containerRule, specialKeys)
        }, conditions), root2.type === "local" && (this.transformSimplePseudos(root2, containerRule, conditions), this.transformSelectors(root2, containerRule, conditions)), this.transformLayer(root2, containerRule["@layer"], conditions), this.transformSupports(root2, containerRule["@supports"], conditions), this.transformMedia(root2, containerRule["@media"], conditions);
      });
    }
  }
  transformLayer(root2, rules) {
    var parentConditions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    if (rules) {
      var _this$currConditional3;
      (_this$currConditional3 = this.currConditionalRuleset) === null || _this$currConditional3 === void 0 || _this$currConditional3.addConditionPrecedence(parentConditions, Object.keys(rules).map((name) => "@layer ".concat(name))), forEach(rules, (layerRule, name) => {
        var conditions = [...parentConditions, "@layer ".concat(name)];
        this.addLayer(conditions), this.addConditionalRule({
          selector: root2.selector,
          rule: omit(layerRule, specialKeys)
        }, conditions), root2.type === "local" && (this.transformSimplePseudos(root2, layerRule, conditions), this.transformSelectors(root2, layerRule, conditions)), this.transformMedia(root2, layerRule["@media"], conditions), this.transformSupports(root2, layerRule["@supports"], conditions), this.transformContainer(root2, layerRule["@container"], conditions);
      });
    }
  }
  transformSupports(root2, rules) {
    var parentConditions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    if (rules) {
      var _this$currConditional4;
      (_this$currConditional4 = this.currConditionalRuleset) === null || _this$currConditional4 === void 0 || _this$currConditional4.addConditionPrecedence(parentConditions, Object.keys(rules).map((query) => "@supports ".concat(query))), forEach(rules, (supportsRule, query) => {
        var conditions = [...parentConditions, "@supports ".concat(query)];
        this.addConditionalRule({
          selector: root2.selector,
          rule: omit(supportsRule, specialKeys)
        }, conditions), root2.type === "local" && (this.transformSimplePseudos(root2, supportsRule, conditions), this.transformSelectors(root2, supportsRule, conditions)), this.transformLayer(root2, supportsRule["@layer"], conditions), this.transformMedia(root2, supportsRule["@media"], conditions), this.transformContainer(root2, supportsRule["@container"], conditions);
      });
    }
  }
  transformSimplePseudos(root2, rule, conditions) {
    for (var key of Object.keys(rule))
      if (simplePseudoLookup[key]) {
        if (root2.type !== "local")
          throw new Error("Simple pseudos are not valid in ".concat(root2.type === "global" ? '"globalStyle"' : '"selectors"'));
        conditions ? this.addConditionalRule({
          selector: "".concat(root2.selector).concat(key),
          rule: rule[key]
        }, conditions) : this.addRule({
          conditions,
          selector: "".concat(root2.selector).concat(key),
          rule: rule[key]
        });
      }
  }
  toCss() {
    var css = [];
    for (var fontFaceRule of this.fontFaceRules)
      css.push(renderCss({
        "@font-face": fontFaceRule
      }));
    for (var keyframe of this.keyframesRules)
      css.push(renderCss({
        ["@keyframes ".concat(keyframe.name)]: keyframe.rule
      }));
    for (var layer of this.layers.values()) {
      var [definition, ...nesting] = layer.reverse(), cssObj = {
        [definition]: DECLARATION
      };
      for (var part of nesting)
        cssObj = {
          [part]: cssObj
        };
      css.push(renderCss(cssObj));
    }
    for (var rule of this.rules)
      css.push(renderCss({
        [rule.selector]: rule.rule
      }));
    for (var conditionalRuleset of this.conditionalRulesets)
      for (var conditionalRule of conditionalRuleset.renderToArray())
        css.push(renderCss(conditionalRule));
    return css.filter(Boolean);
  }
}
function renderCss(v2) {
  var indent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", rules = [], _loop2 = function(key2) {
    var value = v2[key2];
    if (value && Array.isArray(value))
      rules.push(...value.map((v3) => renderCss({
        [key2]: v3
      }, indent)));
    else if (value && typeof value == "object") {
      var isEmpty = Object.keys(value).length === 0;
      isEmpty || rules.push("".concat(indent).concat(key2, ` {
`).concat(renderCss(value, indent + DOUBLE_SPACE), `
`).concat(indent, "}"));
    } else value === DECLARATION ? rules.push("".concat(indent).concat(key2, ";")) : rules.push("".concat(indent).concat(key2.startsWith("--") ? key2 : dashify(key2), ": ").concat(value, ";"));
  };
  for (var key of Object.keys(v2))
    _loop2(key);
  return rules.join(`
`);
}
function transformCss(_ref5) {
  var {
    localClassNames: localClassNames2,
    cssObjs,
    composedClassLists: composedClassLists2
  } = _ref5, stylesheet = new Stylesheet(localClassNames2, composedClassLists2);
  for (var root2 of cssObjs)
    stylesheet.processCssObj(root2);
  return stylesheet.toCss();
}
const perf = typeof performance == "object" && performance && typeof performance.now == "function" ? performance : Date, warned = /* @__PURE__ */ new Set(), PROCESS = typeof process == "object" && process ? process : {}, emitWarning = (msg, type, code, fn) => {
  typeof PROCESS.emitWarning == "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
};
let AC = globalThis.AbortController, AS = globalThis.AbortSignal;
var _a2;
if (typeof AC > "u") {
  AS = class {
    constructor() {
      __publicField(this, "onabort");
      __publicField(this, "_onabort", []);
      __publicField(this, "reason");
      __publicField(this, "aborted", !1);
    }
    addEventListener(_, fn) {
      this._onabort.push(fn);
    }
  }, AC = class {
    constructor() {
      __publicField(this, "signal", new AS());
      warnACPolyfill();
    }
    abort(reason) {
      var _a4, _b2;
      if (!this.signal.aborted) {
        this.signal.reason = reason, this.signal.aborted = !0;
        for (const fn of this.signal._onabort)
          fn(reason);
        (_b2 = (_a4 = this.signal).onabort) == null || _b2.call(_a4, reason);
      }
    }
  };
  let printACPolyfillWarning = ((_a2 = PROCESS.env) == null ? void 0 : _a2.LRU_CACHE_IGNORE_AC_WARNING) !== "1";
  const warnACPolyfill = () => {
    printACPolyfillWarning && (printACPolyfillWarning = !1, emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill));
  };
}
const shouldWarn = (code) => !warned.has(code), isPosInt = (n2) => n2 && n2 === Math.floor(n2) && n2 > 0 && isFinite(n2), getUintArray = (max2) => isPosInt(max2) ? max2 <= Math.pow(2, 8) ? Uint8Array : max2 <= Math.pow(2, 16) ? Uint16Array : max2 <= Math.pow(2, 32) ? Uint32Array : max2 <= Number.MAX_SAFE_INTEGER ? ZeroArray : null : null;
class ZeroArray extends Array {
  constructor(size2) {
    super(size2), this.fill(0);
  }
}
var _constructing;
const _Stack = class _Stack {
  constructor(max2, HeapCls) {
    __publicField(this, "heap");
    __publicField(this, "length");
    if (!__privateGet(_Stack, _constructing))
      throw new TypeError("instantiate Stack using Stack.create(n)");
    this.heap = new HeapCls(max2), this.length = 0;
  }
  static create(max2) {
    const HeapCls = getUintArray(max2);
    if (!HeapCls)
      return [];
    __privateSet(_Stack, _constructing, !0);
    const s2 = new _Stack(max2, HeapCls);
    return __privateSet(_Stack, _constructing, !1), s2;
  }
  push(n2) {
    this.heap[this.length++] = n2;
  }
  pop() {
    return this.heap[--this.length];
  }
};
_constructing = new WeakMap(), // private constructor
__privateAdd(_Stack, _constructing, !1);
let Stack = _Stack;
var _a3, _b, _max, _maxSize, _dispose, _disposeAfter, _fetchMethod, _memoMethod, _size, _calculatedSize, _keyMap, _keyList, _valList, _next, _prev, _head, _tail, _free, _disposed, _sizes, _starts, _ttls, _hasDispose, _hasFetchMethod, _hasDisposeAfter, _LRUCache_instances, initializeTTLTracking_fn, _updateItemAge, _statusTTL, _setItemTTL, _isStale, initializeSizeTracking_fn, _removeItemSize, _addItemSize, _requireSize, indexes_fn, rindexes_fn, isValidIndex_fn, evict_fn, backgroundFetch_fn, isBackgroundFetch_fn, connect_fn, moveToTail_fn, delete_fn, clear_fn;
const _LRUCache = class _LRUCache {
  constructor(options) {
    __privateAdd(this, _LRUCache_instances);
    // options that cannot be changed without disaster
    __privateAdd(this, _max);
    __privateAdd(this, _maxSize);
    __privateAdd(this, _dispose);
    __privateAdd(this, _disposeAfter);
    __privateAdd(this, _fetchMethod);
    __privateAdd(this, _memoMethod);
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    __publicField(this, "ttl");
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    __publicField(this, "ttlResolution");
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    __publicField(this, "ttlAutopurge");
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    __publicField(this, "updateAgeOnGet");
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    __publicField(this, "updateAgeOnHas");
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    __publicField(this, "allowStale");
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    __publicField(this, "noDisposeOnSet");
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    __publicField(this, "noUpdateTTL");
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    __publicField(this, "maxEntrySize");
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    __publicField(this, "sizeCalculation");
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    __publicField(this, "noDeleteOnFetchRejection");
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    __publicField(this, "noDeleteOnStaleGet");
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    __publicField(this, "allowStaleOnFetchAbort");
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    __publicField(this, "allowStaleOnFetchRejection");
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    __publicField(this, "ignoreFetchAbort");
    // computed properties
    __privateAdd(this, _size);
    __privateAdd(this, _calculatedSize);
    __privateAdd(this, _keyMap);
    __privateAdd(this, _keyList);
    __privateAdd(this, _valList);
    __privateAdd(this, _next);
    __privateAdd(this, _prev);
    __privateAdd(this, _head);
    __privateAdd(this, _tail);
    __privateAdd(this, _free);
    __privateAdd(this, _disposed);
    __privateAdd(this, _sizes);
    __privateAdd(this, _starts);
    __privateAdd(this, _ttls);
    __privateAdd(this, _hasDispose);
    __privateAdd(this, _hasFetchMethod);
    __privateAdd(this, _hasDisposeAfter);
    // conditionally set private methods related to TTL
    __privateAdd(this, _updateItemAge, () => {
    });
    __privateAdd(this, _statusTTL, () => {
    });
    __privateAdd(this, _setItemTTL, () => {
    });
    /* c8 ignore stop */
    __privateAdd(this, _isStale, () => !1);
    __privateAdd(this, _removeItemSize, (_i) => {
    });
    __privateAdd(this, _addItemSize, (_i, _s, _st) => {
    });
    __privateAdd(this, _requireSize, (_k, _v, size2, sizeCalculation) => {
      if (size2 || sizeCalculation)
        throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
      return 0;
    });
    /**
     * A String value that is used in the creation of the default string
     * description of an object. Called by the built-in method
     * `Object.prototype.toString`.
     */
    __publicField(this, _a3, "LRUCache");
    const { max: max2 = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
    if (max2 !== 0 && !isPosInt(max2))
      throw new TypeError("max option must be a nonnegative integer");
    const UintArray = max2 ? getUintArray(max2) : Array;
    if (!UintArray)
      throw new Error("invalid max value: " + max2);
    if (__privateSet(this, _max, max2), __privateSet(this, _maxSize, maxSize), this.maxEntrySize = maxEntrySize || __privateGet(this, _maxSize), this.sizeCalculation = sizeCalculation, this.sizeCalculation) {
      if (!__privateGet(this, _maxSize) && !this.maxEntrySize)
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      if (typeof this.sizeCalculation != "function")
        throw new TypeError("sizeCalculation set to non-function");
    }
    if (memoMethod !== void 0 && typeof memoMethod != "function")
      throw new TypeError("memoMethod must be a function if defined");
    if (__privateSet(this, _memoMethod, memoMethod), fetchMethod !== void 0 && typeof fetchMethod != "function")
      throw new TypeError("fetchMethod must be a function if specified");
    if (__privateSet(this, _fetchMethod, fetchMethod), __privateSet(this, _hasFetchMethod, !!fetchMethod), __privateSet(this, _keyMap, /* @__PURE__ */ new Map()), __privateSet(this, _keyList, new Array(max2).fill(void 0)), __privateSet(this, _valList, new Array(max2).fill(void 0)), __privateSet(this, _next, new UintArray(max2)), __privateSet(this, _prev, new UintArray(max2)), __privateSet(this, _head, 0), __privateSet(this, _tail, 0), __privateSet(this, _free, Stack.create(max2)), __privateSet(this, _size, 0), __privateSet(this, _calculatedSize, 0), typeof dispose == "function" && __privateSet(this, _dispose, dispose), typeof disposeAfter == "function" ? (__privateSet(this, _disposeAfter, disposeAfter), __privateSet(this, _disposed, [])) : (__privateSet(this, _disposeAfter, void 0), __privateSet(this, _disposed, void 0)), __privateSet(this, _hasDispose, !!__privateGet(this, _dispose)), __privateSet(this, _hasDisposeAfter, !!__privateGet(this, _disposeAfter)), this.noDisposeOnSet = !!noDisposeOnSet, this.noUpdateTTL = !!noUpdateTTL, this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection, this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection, this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort, this.ignoreFetchAbort = !!ignoreFetchAbort, this.maxEntrySize !== 0) {
      if (__privateGet(this, _maxSize) !== 0 && !isPosInt(__privateGet(this, _maxSize)))
        throw new TypeError("maxSize must be a positive integer if specified");
      if (!isPosInt(this.maxEntrySize))
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      __privateMethod(this, _LRUCache_instances, initializeSizeTracking_fn).call(this);
    }
    if (this.allowStale = !!allowStale, this.noDeleteOnStaleGet = !!noDeleteOnStaleGet, this.updateAgeOnGet = !!updateAgeOnGet, this.updateAgeOnHas = !!updateAgeOnHas, this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1, this.ttlAutopurge = !!ttlAutopurge, this.ttl = ttl || 0, this.ttl) {
      if (!isPosInt(this.ttl))
        throw new TypeError("ttl must be a positive integer if specified");
      __privateMethod(this, _LRUCache_instances, initializeTTLTracking_fn).call(this);
    }
    if (__privateGet(this, _max) === 0 && this.ttl === 0 && __privateGet(this, _maxSize) === 0)
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    if (!this.ttlAutopurge && !__privateGet(this, _max) && !__privateGet(this, _maxSize)) {
      const code = "LRU_CACHE_UNBOUNDED";
      shouldWarn(code) && (warned.add(code), emitWarning("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", code, _LRUCache));
    }
  }
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(c) {
    return {
      // properties
      starts: __privateGet(c, _starts),
      ttls: __privateGet(c, _ttls),
      sizes: __privateGet(c, _sizes),
      keyMap: __privateGet(c, _keyMap),
      keyList: __privateGet(c, _keyList),
      valList: __privateGet(c, _valList),
      next: __privateGet(c, _next),
      prev: __privateGet(c, _prev),
      get head() {
        return __privateGet(c, _head);
      },
      get tail() {
        return __privateGet(c, _tail);
      },
      free: __privateGet(c, _free),
      // methods
      isBackgroundFetch: (p2) => {
        var _a4;
        return __privateMethod(_a4 = c, _LRUCache_instances, isBackgroundFetch_fn).call(_a4, p2);
      },
      backgroundFetch: (k2, index2, options, context) => {
        var _a4;
        return __privateMethod(_a4 = c, _LRUCache_instances, backgroundFetch_fn).call(_a4, k2, index2, options, context);
      },
      moveToTail: (index2) => {
        var _a4;
        return __privateMethod(_a4 = c, _LRUCache_instances, moveToTail_fn).call(_a4, index2);
      },
      indexes: (options) => {
        var _a4;
        return __privateMethod(_a4 = c, _LRUCache_instances, indexes_fn).call(_a4, options);
      },
      rindexes: (options) => {
        var _a4;
        return __privateMethod(_a4 = c, _LRUCache_instances, rindexes_fn).call(_a4, options);
      },
      isStale: (index2) => {
        var _a4;
        return __privateGet(_a4 = c, _isStale).call(_a4, index2);
      }
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return __privateGet(this, _max);
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return __privateGet(this, _maxSize);
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return __privateGet(this, _calculatedSize);
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return __privateGet(this, _size);
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return __privateGet(this, _fetchMethod);
  }
  get memoMethod() {
    return __privateGet(this, _memoMethod);
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return __privateGet(this, _dispose);
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return __privateGet(this, _disposeAfter);
  }
  /**
   * Return the number of ms left in the item's TTL. If item is not in cache,
   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
   */
  getRemainingTTL(key) {
    return __privateGet(this, _keyMap).has(key) ? 1 / 0 : 0;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const i2 of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this))
      __privateGet(this, _valList)[i2] !== void 0 && __privateGet(this, _keyList)[i2] !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i2]) && (yield [__privateGet(this, _keyList)[i2], __privateGet(this, _valList)[i2]]);
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const i2 of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this))
      __privateGet(this, _valList)[i2] !== void 0 && __privateGet(this, _keyList)[i2] !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i2]) && (yield [__privateGet(this, _keyList)[i2], __privateGet(this, _valList)[i2]]);
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const i2 of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
      const k2 = __privateGet(this, _keyList)[i2];
      k2 !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i2]) && (yield k2);
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const i2 of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
      const k2 = __privateGet(this, _keyList)[i2];
      k2 !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i2]) && (yield k2);
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const i2 of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this))
      __privateGet(this, _valList)[i2] !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i2]) && (yield __privateGet(this, _valList)[i2]);
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const i2 of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this))
      __privateGet(this, _valList)[i2] !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i2]) && (yield __privateGet(this, _valList)[i2]);
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [(_b = Symbol.iterator, _a3 = Symbol.toStringTag, _b)]() {
    return this.entries();
  }
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
   */
  find(fn, getOptions = {}) {
    for (const i2 of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
      const v2 = __privateGet(this, _valList)[i2], value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v2) ? v2.__staleWhileFetching : v2;
      if (value !== void 0 && fn(value, __privateGet(this, _keyList)[i2], this))
        return this.get(__privateGet(this, _keyList)[i2], getOptions);
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from most
   * recently used to least recently used.
   *
   * `fn` is called as `fn(value, key, cache)`.
   *
   * If `thisp` is provided, function will be called in the `this`-context of
   * the provided object, or the cache if no `thisp` object is provided.
   *
   * Does not update age or recenty of use, or iterate over stale values.
   */
  forEach(fn, thisp = this) {
    for (const i2 of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
      const v2 = __privateGet(this, _valList)[i2], value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v2) ? v2.__staleWhileFetching : v2;
      value !== void 0 && fn.call(thisp, value, __privateGet(this, _keyList)[i2], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(fn, thisp = this) {
    for (const i2 of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
      const v2 = __privateGet(this, _valList)[i2], value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v2) ? v2.__staleWhileFetching : v2;
      value !== void 0 && fn.call(thisp, value, __privateGet(this, _keyList)[i2], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let deleted = !1;
    for (const i2 of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this, { allowStale: !0 }))
      __privateGet(this, _isStale).call(this, i2) && (__privateMethod(this, _LRUCache_instances, delete_fn).call(this, __privateGet(this, _keyList)[i2], "expire"), deleted = !0);
    return deleted;
  }
  /**
   * Get the extended info about a given entry, to get its value, size, and
   * TTL info simultaneously. Returns `undefined` if the key is not present.
   *
   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
   * serialization, the `start` value is always the current timestamp, and the
   * `ttl` is a calculated remaining time to live (negative if expired).
   *
   * Always returns stale values, if their info is found in the cache, so be
   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
   * if relevant.
   */
  info(key) {
    const i2 = __privateGet(this, _keyMap).get(key);
    if (i2 === void 0)
      return;
    const v2 = __privateGet(this, _valList)[i2], value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v2) ? v2.__staleWhileFetching : v2;
    if (value === void 0)
      return;
    const entry = { value };
    if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
      const ttl = __privateGet(this, _ttls)[i2], start2 = __privateGet(this, _starts)[i2];
      if (ttl && start2) {
        const remain = ttl - (perf.now() - start2);
        entry.ttl = remain, entry.start = Date.now();
      }
    }
    return __privateGet(this, _sizes) && (entry.size = __privateGet(this, _sizes)[i2]), entry;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to {@link LRLUCache#load}.
   *
   * The `start` fields are calculated relative to a portable `Date.now()`
   * timestamp, even if `performance.now()` is available.
   *
   * Stale entries are always included in the `dump`, even if
   * {@link LRUCache.OptionsBase.allowStale} is false.
   *
   * Note: this returns an actual array, not a generator, so it can be more
   * easily passed around.
   */
  dump() {
    const arr = [];
    for (const i2 of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this, { allowStale: !0 })) {
      const key = __privateGet(this, _keyList)[i2], v2 = __privateGet(this, _valList)[i2], value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v2) ? v2.__staleWhileFetching : v2;
      if (value === void 0 || key === void 0)
        continue;
      const entry = { value };
      if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
        entry.ttl = __privateGet(this, _ttls)[i2];
        const age = perf.now() - __privateGet(this, _starts)[i2];
        entry.start = Math.floor(Date.now() - age);
      }
      __privateGet(this, _sizes) && (entry.size = __privateGet(this, _sizes)[i2]), arr.unshift([key, entry]);
    }
    return arr;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   *
   * The shape of the resulting cache may be different if the same options are
   * not used in both caches.
   *
   * The `start` fields are assumed to be calculated relative to a portable
   * `Date.now()` timestamp, even if `performance.now()` is available.
   */
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  /**
   * Add a value to the cache.
   *
   * Note: if `undefined` is specified as a value, this is an alias for
   * {@link LRUCache#delete}
   *
   * Fields on the {@link LRUCache.SetOptions} options param will override
   * their corresponding values in the constructor options for the scope
   * of this single `set()` operation.
   *
   * If `start` is provided, then that will set the effective start
   * time for the TTL calculation. Note that this must be a previous
   * value of `performance.now()` if supported, or a previous value of
   * `Date.now()` if not.
   *
   * Options object may also include `size`, which will prevent
   * calling the `sizeCalculation` function and just use the specified
   * number if it is a positive integer, and `noDisposeOnSet` which
   * will prevent calling a `dispose` function in the case of
   * overwrites.
   *
   * If the `size` (or return value of `sizeCalculation`) for a given
   * entry is greater than `maxEntrySize`, then the item will not be
   * added to the cache.
   *
   * Will update the recency of the entry.
   *
   * If the value is `undefined`, then this is an alias for
   * `cache.delete(key)`. `undefined` is never stored in the cache.
   */
  set(k2, v2, setOptions = {}) {
    var _a4, _b2, _c, _d, _e;
    if (v2 === void 0)
      return this.delete(k2), this;
    const { ttl = this.ttl, start: start2, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size2 = __privateGet(this, _requireSize).call(this, k2, v2, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size2 > this.maxEntrySize)
      return status && (status.set = "miss", status.maxEntrySizeExceeded = !0), __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k2, "set"), this;
    let index2 = __privateGet(this, _size) === 0 ? void 0 : __privateGet(this, _keyMap).get(k2);
    if (index2 === void 0)
      index2 = __privateGet(this, _size) === 0 ? __privateGet(this, _tail) : __privateGet(this, _free).length !== 0 ? __privateGet(this, _free).pop() : __privateGet(this, _size) === __privateGet(this, _max) ? __privateMethod(this, _LRUCache_instances, evict_fn).call(this, !1) : __privateGet(this, _size), __privateGet(this, _keyList)[index2] = k2, __privateGet(this, _valList)[index2] = v2, __privateGet(this, _keyMap).set(k2, index2), __privateGet(this, _next)[__privateGet(this, _tail)] = index2, __privateGet(this, _prev)[index2] = __privateGet(this, _tail), __privateSet(this, _tail, index2), __privateWrapper(this, _size)._++, __privateGet(this, _addItemSize).call(this, index2, size2, status), status && (status.set = "add"), noUpdateTTL = !1;
    else {
      __privateMethod(this, _LRUCache_instances, moveToTail_fn).call(this, index2);
      const oldVal = __privateGet(this, _valList)[index2];
      if (v2 !== oldVal) {
        if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: s2 } = oldVal;
          s2 !== void 0 && !noDisposeOnSet && (__privateGet(this, _hasDispose) && ((_a4 = __privateGet(this, _dispose)) == null || _a4.call(this, s2, k2, "set")), __privateGet(this, _hasDisposeAfter) && ((_b2 = __privateGet(this, _disposed)) == null || _b2.push([s2, k2, "set"])));
        } else noDisposeOnSet || (__privateGet(this, _hasDispose) && ((_c = __privateGet(this, _dispose)) == null || _c.call(this, oldVal, k2, "set")), __privateGet(this, _hasDisposeAfter) && ((_d = __privateGet(this, _disposed)) == null || _d.push([oldVal, k2, "set"])));
        if (__privateGet(this, _removeItemSize).call(this, index2), __privateGet(this, _addItemSize).call(this, index2, size2, status), __privateGet(this, _valList)[index2] = v2, status) {
          status.set = "replace";
          const oldValue = oldVal && __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, oldVal) ? oldVal.__staleWhileFetching : oldVal;
          oldValue !== void 0 && (status.oldValue = oldValue);
        }
      } else status && (status.set = "update");
    }
    if (ttl !== 0 && !__privateGet(this, _ttls) && __privateMethod(this, _LRUCache_instances, initializeTTLTracking_fn).call(this), __privateGet(this, _ttls) && (noUpdateTTL || __privateGet(this, _setItemTTL).call(this, index2, ttl, start2), status && __privateGet(this, _statusTTL).call(this, status, index2)), !noDisposeOnSet && __privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
      const dt = __privateGet(this, _disposed);
      let task;
      for (; task = dt == null ? void 0 : dt.shift(); )
        (_e = __privateGet(this, _disposeAfter)) == null || _e.call(this, ...task);
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    var _a4;
    try {
      for (; __privateGet(this, _size); ) {
        const val = __privateGet(this, _valList)[__privateGet(this, _head)];
        if (__privateMethod(this, _LRUCache_instances, evict_fn).call(this, !0), __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, val)) {
          if (val.__staleWhileFetching)
            return val.__staleWhileFetching;
        } else if (val !== void 0)
          return val;
      }
    } finally {
      if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
        const dt = __privateGet(this, _disposed);
        let task;
        for (; task = dt == null ? void 0 : dt.shift(); )
          (_a4 = __privateGet(this, _disposeAfter)) == null || _a4.call(this, ...task);
      }
    }
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Check if a key is in the cache, without updating the recency of
   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
   * to `true` in either the options or the constructor.
   *
   * Will return `false` if the item is stale, even though it is technically in
   * the cache. The difference can be determined (if it matters) by using a
   * `status` argument, and inspecting the `has` field.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(k2, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions, index2 = __privateGet(this, _keyMap).get(k2);
    if (index2 !== void 0) {
      const v2 = __privateGet(this, _valList)[index2];
      if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v2) && v2.__staleWhileFetching === void 0)
        return !1;
      if (__privateGet(this, _isStale).call(this, index2))
        status && (status.has = "stale", __privateGet(this, _statusTTL).call(this, status, index2));
      else return updateAgeOnHas && __privateGet(this, _updateItemAge).call(this, index2), status && (status.has = "hit", __privateGet(this, _statusTTL).call(this, status, index2)), !0;
    } else status && (status.has = "miss");
    return !1;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(k2, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions, index2 = __privateGet(this, _keyMap).get(k2);
    if (index2 === void 0 || !allowStale && __privateGet(this, _isStale).call(this, index2))
      return;
    const v2 = __privateGet(this, _valList)[index2];
    return __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v2) ? v2.__staleWhileFetching : v2;
  }
  async fetch(k2, fetchOptions = {}) {
    const {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size: size2 = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = !1,
      status,
      signal
    } = fetchOptions;
    if (!__privateGet(this, _hasFetchMethod))
      return status && (status.fetch = "get"), this.get(k2, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size: size2,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index2 = __privateGet(this, _keyMap).get(k2);
    if (index2 === void 0) {
      status && (status.fetch = "miss");
      const p2 = __privateMethod(this, _LRUCache_instances, backgroundFetch_fn).call(this, k2, index2, options, context);
      return p2.__returned = p2;
    } else {
      const v2 = __privateGet(this, _valList)[index2];
      if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v2)) {
        const stale = allowStale && v2.__staleWhileFetching !== void 0;
        return status && (status.fetch = "inflight", stale && (status.returnedStale = !0)), stale ? v2.__staleWhileFetching : v2.__returned = v2;
      }
      const isStale = __privateGet(this, _isStale).call(this, index2);
      if (!forceRefresh && !isStale)
        return status && (status.fetch = "hit"), __privateMethod(this, _LRUCache_instances, moveToTail_fn).call(this, index2), updateAgeOnGet && __privateGet(this, _updateItemAge).call(this, index2), status && __privateGet(this, _statusTTL).call(this, status, index2), v2;
      const p2 = __privateMethod(this, _LRUCache_instances, backgroundFetch_fn).call(this, k2, index2, options, context), staleVal = p2.__staleWhileFetching !== void 0 && allowStale;
      return status && (status.fetch = isStale ? "stale" : "refresh", staleVal && isStale && (status.returnedStale = !0)), staleVal ? p2.__staleWhileFetching : p2.__returned = p2;
    }
  }
  async forceFetch(k2, fetchOptions = {}) {
    const v2 = await this.fetch(k2, fetchOptions);
    if (v2 === void 0)
      throw new Error("fetch() returned undefined");
    return v2;
  }
  memo(k2, memoOptions = {}) {
    const memoMethod = __privateGet(this, _memoMethod);
    if (!memoMethod)
      throw new Error("no memoMethod provided to constructor");
    const { context, forceRefresh, ...options } = memoOptions, v2 = this.get(k2, options);
    if (!forceRefresh && v2 !== void 0)
      return v2;
    const vv = memoMethod(k2, v2, {
      options,
      context
    });
    return this.set(k2, vv, options), vv;
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(k2, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions, index2 = __privateGet(this, _keyMap).get(k2);
    if (index2 !== void 0) {
      const value = __privateGet(this, _valList)[index2], fetching = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, value);
      return status && __privateGet(this, _statusTTL).call(this, status, index2), __privateGet(this, _isStale).call(this, index2) ? (status && (status.get = "stale"), fetching ? (status && allowStale && value.__staleWhileFetching !== void 0 && (status.returnedStale = !0), allowStale ? value.__staleWhileFetching : void 0) : (noDeleteOnStaleGet || __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k2, "expire"), status && allowStale && (status.returnedStale = !0), allowStale ? value : void 0)) : (status && (status.get = "hit"), fetching ? value.__staleWhileFetching : (__privateMethod(this, _LRUCache_instances, moveToTail_fn).call(this, index2), updateAgeOnGet && __privateGet(this, _updateItemAge).call(this, index2), value));
    } else status && (status.get = "miss");
  }
  /**
   * Deletes a key out of the cache.
   *
   * Returns true if the key was deleted, false otherwise.
   */
  delete(k2) {
    return __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k2, "delete");
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    return __privateMethod(this, _LRUCache_instances, clear_fn).call(this, "delete");
  }
};
_max = new WeakMap(), _maxSize = new WeakMap(), _dispose = new WeakMap(), _disposeAfter = new WeakMap(), _fetchMethod = new WeakMap(), _memoMethod = new WeakMap(), _size = new WeakMap(), _calculatedSize = new WeakMap(), _keyMap = new WeakMap(), _keyList = new WeakMap(), _valList = new WeakMap(), _next = new WeakMap(), _prev = new WeakMap(), _head = new WeakMap(), _tail = new WeakMap(), _free = new WeakMap(), _disposed = new WeakMap(), _sizes = new WeakMap(), _starts = new WeakMap(), _ttls = new WeakMap(), _hasDispose = new WeakMap(), _hasFetchMethod = new WeakMap(), _hasDisposeAfter = new WeakMap(), _LRUCache_instances = new WeakSet(), initializeTTLTracking_fn = function() {
  const ttls = new ZeroArray(__privateGet(this, _max)), starts = new ZeroArray(__privateGet(this, _max));
  __privateSet(this, _ttls, ttls), __privateSet(this, _starts, starts), __privateSet(this, _setItemTTL, (index2, ttl, start2 = perf.now()) => {
    if (starts[index2] = ttl !== 0 ? start2 : 0, ttls[index2] = ttl, ttl !== 0 && this.ttlAutopurge) {
      const t2 = setTimeout(() => {
        __privateGet(this, _isStale).call(this, index2) && __privateMethod(this, _LRUCache_instances, delete_fn).call(this, __privateGet(this, _keyList)[index2], "expire");
      }, ttl + 1);
      t2.unref && t2.unref();
    }
  }), __privateSet(this, _updateItemAge, (index2) => {
    starts[index2] = ttls[index2] !== 0 ? perf.now() : 0;
  }), __privateSet(this, _statusTTL, (status, index2) => {
    if (ttls[index2]) {
      const ttl = ttls[index2], start2 = starts[index2];
      if (!ttl || !start2)
        return;
      status.ttl = ttl, status.start = start2, status.now = cachedNow || getNow();
      const age = status.now - start2;
      status.remainingTTL = ttl - age;
    }
  });
  let cachedNow = 0;
  const getNow = () => {
    const n2 = perf.now();
    if (this.ttlResolution > 0) {
      cachedNow = n2;
      const t2 = setTimeout(() => cachedNow = 0, this.ttlResolution);
      t2.unref && t2.unref();
    }
    return n2;
  };
  this.getRemainingTTL = (key) => {
    const index2 = __privateGet(this, _keyMap).get(key);
    if (index2 === void 0)
      return 0;
    const ttl = ttls[index2], start2 = starts[index2];
    if (!ttl || !start2)
      return 1 / 0;
    const age = (cachedNow || getNow()) - start2;
    return ttl - age;
  }, __privateSet(this, _isStale, (index2) => {
    const s2 = starts[index2], t2 = ttls[index2];
    return !!t2 && !!s2 && (cachedNow || getNow()) - s2 > t2;
  });
}, _updateItemAge = new WeakMap(), _statusTTL = new WeakMap(), _setItemTTL = new WeakMap(), _isStale = new WeakMap(), initializeSizeTracking_fn = function() {
  const sizes = new ZeroArray(__privateGet(this, _max));
  __privateSet(this, _calculatedSize, 0), __privateSet(this, _sizes, sizes), __privateSet(this, _removeItemSize, (index2) => {
    __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) - sizes[index2]), sizes[index2] = 0;
  }), __privateSet(this, _requireSize, (k2, v2, size2, sizeCalculation) => {
    if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v2))
      return 0;
    if (!isPosInt(size2))
      if (sizeCalculation) {
        if (typeof sizeCalculation != "function")
          throw new TypeError("sizeCalculation must be a function");
        if (size2 = sizeCalculation(v2, k2), !isPosInt(size2))
          throw new TypeError("sizeCalculation return invalid (expect positive integer)");
      } else
        throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
    return size2;
  }), __privateSet(this, _addItemSize, (index2, size2, status) => {
    if (sizes[index2] = size2, __privateGet(this, _maxSize)) {
      const maxSize = __privateGet(this, _maxSize) - sizes[index2];
      for (; __privateGet(this, _calculatedSize) > maxSize; )
        __privateMethod(this, _LRUCache_instances, evict_fn).call(this, !0);
    }
    __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) + sizes[index2]), status && (status.entrySize = size2, status.totalCalculatedSize = __privateGet(this, _calculatedSize));
  });
}, _removeItemSize = new WeakMap(), _addItemSize = new WeakMap(), _requireSize = new WeakMap(), indexes_fn = function* ({ allowStale = this.allowStale } = {}) {
  if (__privateGet(this, _size))
    for (let i2 = __privateGet(this, _tail); !(!__privateMethod(this, _LRUCache_instances, isValidIndex_fn).call(this, i2) || ((allowStale || !__privateGet(this, _isStale).call(this, i2)) && (yield i2), i2 === __privateGet(this, _head))); )
      i2 = __privateGet(this, _prev)[i2];
}, rindexes_fn = function* ({ allowStale = this.allowStale } = {}) {
  if (__privateGet(this, _size))
    for (let i2 = __privateGet(this, _head); !(!__privateMethod(this, _LRUCache_instances, isValidIndex_fn).call(this, i2) || ((allowStale || !__privateGet(this, _isStale).call(this, i2)) && (yield i2), i2 === __privateGet(this, _tail))); )
      i2 = __privateGet(this, _next)[i2];
}, isValidIndex_fn = function(index2) {
  return index2 !== void 0 && __privateGet(this, _keyMap).get(__privateGet(this, _keyList)[index2]) === index2;
}, evict_fn = function(free) {
  var _a4, _b2;
  const head = __privateGet(this, _head), k2 = __privateGet(this, _keyList)[head], v2 = __privateGet(this, _valList)[head];
  return __privateGet(this, _hasFetchMethod) && __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v2) ? v2.__abortController.abort(new Error("evicted")) : (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) && (__privateGet(this, _hasDispose) && ((_a4 = __privateGet(this, _dispose)) == null || _a4.call(this, v2, k2, "evict")), __privateGet(this, _hasDisposeAfter) && ((_b2 = __privateGet(this, _disposed)) == null || _b2.push([v2, k2, "evict"]))), __privateGet(this, _removeItemSize).call(this, head), free && (__privateGet(this, _keyList)[head] = void 0, __privateGet(this, _valList)[head] = void 0, __privateGet(this, _free).push(head)), __privateGet(this, _size) === 1 ? (__privateSet(this, _head, __privateSet(this, _tail, 0)), __privateGet(this, _free).length = 0) : __privateSet(this, _head, __privateGet(this, _next)[head]), __privateGet(this, _keyMap).delete(k2), __privateWrapper(this, _size)._--, head;
}, backgroundFetch_fn = function(k2, index2, options, context) {
  const v2 = index2 === void 0 ? void 0 : __privateGet(this, _valList)[index2];
  if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v2))
    return v2;
  const ac = new AC(), { signal } = options;
  signal == null || signal.addEventListener("abort", () => ac.abort(signal.reason), {
    signal: ac.signal
  });
  const fetchOpts = {
    signal: ac.signal,
    options,
    context
  }, cb = (v3, updateCache = !1) => {
    const { aborted } = ac.signal, ignoreAbort = options.ignoreFetchAbort && v3 !== void 0;
    if (options.status && (aborted && !updateCache ? (options.status.fetchAborted = !0, options.status.fetchError = ac.signal.reason, ignoreAbort && (options.status.fetchAbortIgnored = !0)) : options.status.fetchResolved = !0), aborted && !ignoreAbort && !updateCache)
      return fetchFail(ac.signal.reason);
    const bf2 = p2;
    return __privateGet(this, _valList)[index2] === p2 && (v3 === void 0 ? bf2.__staleWhileFetching ? __privateGet(this, _valList)[index2] = bf2.__staleWhileFetching : __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k2, "fetch") : (options.status && (options.status.fetchUpdated = !0), this.set(k2, v3, fetchOpts.options))), v3;
  }, eb = (er) => (options.status && (options.status.fetchRejected = !0, options.status.fetchError = er), fetchFail(er)), fetchFail = (er) => {
    const { aborted } = ac.signal, allowStaleAborted = aborted && options.allowStaleOnFetchAbort, allowStale = allowStaleAborted || options.allowStaleOnFetchRejection, noDelete = allowStale || options.noDeleteOnFetchRejection, bf2 = p2;
    if (__privateGet(this, _valList)[index2] === p2 && (!noDelete || bf2.__staleWhileFetching === void 0 ? __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k2, "fetch") : allowStaleAborted || (__privateGet(this, _valList)[index2] = bf2.__staleWhileFetching)), allowStale)
      return options.status && bf2.__staleWhileFetching !== void 0 && (options.status.returnedStale = !0), bf2.__staleWhileFetching;
    if (bf2.__returned === bf2)
      throw er;
  }, pcall = (res, rej) => {
    var _a4;
    const fmp = (_a4 = __privateGet(this, _fetchMethod)) == null ? void 0 : _a4.call(this, k2, v2, fetchOpts);
    fmp && fmp instanceof Promise && fmp.then((v3) => res(v3 === void 0 ? void 0 : v3), rej), ac.signal.addEventListener("abort", () => {
      (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) && (res(void 0), options.allowStaleOnFetchAbort && (res = (v3) => cb(v3, !0)));
    });
  };
  options.status && (options.status.fetchDispatched = !0);
  const p2 = new Promise(pcall).then(cb, eb), bf = Object.assign(p2, {
    __abortController: ac,
    __staleWhileFetching: v2,
    __returned: void 0
  });
  return index2 === void 0 ? (this.set(k2, bf, { ...fetchOpts.options, status: void 0 }), index2 = __privateGet(this, _keyMap).get(k2)) : __privateGet(this, _valList)[index2] = bf, bf;
}, isBackgroundFetch_fn = function(p2) {
  if (!__privateGet(this, _hasFetchMethod))
    return !1;
  const b2 = p2;
  return !!b2 && b2 instanceof Promise && b2.hasOwnProperty("__staleWhileFetching") && b2.__abortController instanceof AC;
}, connect_fn = function(p2, n2) {
  __privateGet(this, _prev)[n2] = p2, __privateGet(this, _next)[p2] = n2;
}, moveToTail_fn = function(index2) {
  index2 !== __privateGet(this, _tail) && (index2 === __privateGet(this, _head) ? __privateSet(this, _head, __privateGet(this, _next)[index2]) : __privateMethod(this, _LRUCache_instances, connect_fn).call(this, __privateGet(this, _prev)[index2], __privateGet(this, _next)[index2]), __privateMethod(this, _LRUCache_instances, connect_fn).call(this, __privateGet(this, _tail), index2), __privateSet(this, _tail, index2));
}, delete_fn = function(k2, reason) {
  var _a4, _b2, _c, _d;
  let deleted = !1;
  if (__privateGet(this, _size) !== 0) {
    const index2 = __privateGet(this, _keyMap).get(k2);
    if (index2 !== void 0)
      if (deleted = !0, __privateGet(this, _size) === 1)
        __privateMethod(this, _LRUCache_instances, clear_fn).call(this, reason);
      else {
        __privateGet(this, _removeItemSize).call(this, index2);
        const v2 = __privateGet(this, _valList)[index2];
        if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v2) ? v2.__abortController.abort(new Error("deleted")) : (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) && (__privateGet(this, _hasDispose) && ((_a4 = __privateGet(this, _dispose)) == null || _a4.call(this, v2, k2, reason)), __privateGet(this, _hasDisposeAfter) && ((_b2 = __privateGet(this, _disposed)) == null || _b2.push([v2, k2, reason]))), __privateGet(this, _keyMap).delete(k2), __privateGet(this, _keyList)[index2] = void 0, __privateGet(this, _valList)[index2] = void 0, index2 === __privateGet(this, _tail))
          __privateSet(this, _tail, __privateGet(this, _prev)[index2]);
        else if (index2 === __privateGet(this, _head))
          __privateSet(this, _head, __privateGet(this, _next)[index2]);
        else {
          const pi2 = __privateGet(this, _prev)[index2];
          __privateGet(this, _next)[pi2] = __privateGet(this, _next)[index2];
          const ni = __privateGet(this, _next)[index2];
          __privateGet(this, _prev)[ni] = __privateGet(this, _prev)[index2];
        }
        __privateWrapper(this, _size)._--, __privateGet(this, _free).push(index2);
      }
  }
  if (__privateGet(this, _hasDisposeAfter) && ((_c = __privateGet(this, _disposed)) != null && _c.length)) {
    const dt = __privateGet(this, _disposed);
    let task;
    for (; task = dt == null ? void 0 : dt.shift(); )
      (_d = __privateGet(this, _disposeAfter)) == null || _d.call(this, ...task);
  }
  return deleted;
}, clear_fn = function(reason) {
  var _a4, _b2, _c;
  for (const index2 of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this, { allowStale: !0 })) {
    const v2 = __privateGet(this, _valList)[index2];
    if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v2))
      v2.__abortController.abort(new Error("deleted"));
    else {
      const k2 = __privateGet(this, _keyList)[index2];
      __privateGet(this, _hasDispose) && ((_a4 = __privateGet(this, _dispose)) == null || _a4.call(this, v2, k2, reason)), __privateGet(this, _hasDisposeAfter) && ((_b2 = __privateGet(this, _disposed)) == null || _b2.push([v2, k2, reason]));
    }
  }
  if (__privateGet(this, _keyMap).clear(), __privateGet(this, _valList).fill(void 0), __privateGet(this, _keyList).fill(void 0), __privateGet(this, _ttls) && __privateGet(this, _starts) && (__privateGet(this, _ttls).fill(0), __privateGet(this, _starts).fill(0)), __privateGet(this, _sizes) && __privateGet(this, _sizes).fill(0), __privateSet(this, _head, 0), __privateSet(this, _tail, 0), __privateGet(this, _free).length = 0, __privateSet(this, _calculatedSize, 0), __privateSet(this, _size, 0), __privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
    const dt = __privateGet(this, _disposed);
    let task;
    for (; task = dt == null ? void 0 : dt.shift(); )
      (_c = __privateGet(this, _disposeAfter)) == null || _c.call(this, ...task);
  }
};
let LRUCache = _LRUCache;
var isMergeableObject = function(value) {
  return isNonNullObject(value) && !isSpecial(value);
};
function isNonNullObject(value) {
  return !!value && typeof value == "object";
}
function isSpecial(value) {
  var stringValue = Object.prototype.toString.call(value);
  return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
}
var canUseSymbol = typeof Symbol == "function" && Symbol.for, REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
function isReactElement(value) {
  return value.$$typeof === REACT_ELEMENT_TYPE;
}
function emptyTarget(val) {
  return Array.isArray(val) ? [] : {};
}
function cloneUnlessOtherwiseSpecified(value, options) {
  return options.clone !== !1 && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
}
function defaultArrayMerge(target, source, options) {
  return target.concat(source).map(function(element) {
    return cloneUnlessOtherwiseSpecified(element, options);
  });
}
function getMergeFunction(key, options) {
  if (!options.customMerge)
    return deepmerge;
  var customMerge = options.customMerge(key);
  return typeof customMerge == "function" ? customMerge : deepmerge;
}
function getEnumerableOwnPropertySymbols(target) {
  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
    return Object.propertyIsEnumerable.call(target, symbol);
  }) : [];
}
function getKeys(target) {
  return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
}
function propertyIsOnObject(object2, property) {
  try {
    return property in object2;
  } catch {
    return !1;
  }
}
function propertyIsUnsafe(target, key) {
  return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
}
function mergeObject(target, source, options) {
  var destination = {};
  return options.isMergeableObject(target) && getKeys(target).forEach(function(key) {
    destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
  }), getKeys(source).forEach(function(key) {
    propertyIsUnsafe(target, key) || (propertyIsOnObject(target, key) && options.isMergeableObject(source[key]) ? destination[key] = getMergeFunction(key, options)(target[key], source[key], options) : destination[key] = cloneUnlessOtherwiseSpecified(source[key], options));
  }), destination;
}
function deepmerge(target, source, options) {
  options = options || {}, options.arrayMerge = options.arrayMerge || defaultArrayMerge, options.isMergeableObject = options.isMergeableObject || isMergeableObject, options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
  var sourceIsArray = Array.isArray(source), targetIsArray = Array.isArray(target), sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
  return sourceAndTargetTypesMatch ? sourceIsArray ? options.arrayMerge(target, source, options) : mergeObject(target, source, options) : cloneUnlessOtherwiseSpecified(source, options);
}
deepmerge.all = function(array2, options) {
  if (!Array.isArray(array2))
    throw new Error("first argument should be an array");
  return array2.reduce(function(prev, next) {
    return deepmerge(prev, next, options);
  }, {});
};
var localClassNames = /* @__PURE__ */ new Set(), composedClassLists = [], bufferedCSSObjs = [], browserRuntimeAdapter = {
  appendCss: (cssObj) => {
    bufferedCSSObjs.push(cssObj);
  },
  registerClassName: (className) => {
    localClassNames.add(className);
  },
  registerComposition: (composition) => {
    composedClassLists.push(composition);
  },
  markCompositionUsed: () => {
  },
  onEndFileScope: (fileScope) => {
    var css = transformCss({
      localClassNames: Array.from(localClassNames),
      composedClassLists,
      cssObjs: bufferedCSSObjs
    }).join(`
`);
    injectStyles({
      fileScope,
      css
    }), bufferedCSSObjs = [];
  },
  getIdentOption: () => "short"
};
setAdapterIfNotSet(browserRuntimeAdapter);
var getLastSlashBeforeIndex = (path, index2) => {
  for (var pathIndex = index2 - 1; pathIndex >= 0; ) {
    if (path[pathIndex] === "/")
      return pathIndex;
    pathIndex--;
  }
  return -1;
}, _getDebugFileName = (path) => {
  var file, lastIndexOfDotCss = path.lastIndexOf(".css");
  if (lastIndexOfDotCss === -1)
    return "";
  var lastSlashIndex = getLastSlashBeforeIndex(path, lastIndexOfDotCss);
  if (file = path.slice(lastSlashIndex + 1, lastIndexOfDotCss), lastSlashIndex === -1)
    return file;
  var secondLastSlashIndex = getLastSlashBeforeIndex(path, lastSlashIndex - 1), dir = path.slice(secondLastSlashIndex + 1, lastSlashIndex), debugFileName = file !== "index" ? file : dir;
  return debugFileName;
}, memoizedGetDebugFileName = () => {
  var cache = new LRUCache({
    max: 500
  });
  return (path) => {
    var cachedResult = cache.get(path);
    if (cachedResult)
      return cachedResult;
    var result = _getDebugFileName(path);
    return cache.set(path, result), result;
  };
};
memoizedGetDebugFileName();
function createGlobalThemeContract(tokens, mapFn) {
  return walkObject(tokens, (value, path) => {
    var rawVarName = typeof mapFn == "function" ? mapFn(value, path) : value, varName = typeof rawVarName == "string" ? rawVarName.replace(/^\-\-/, "") : null;
    if (typeof varName != "string" || varName !== cssesc$1(varName, {
      isIdentifier: !0
    }))
      throw new Error('Invalid variable name for "'.concat(path.join("."), '": ').concat(varName));
    return "var(--".concat(varName, ")");
  });
}
const vars = createGlobalThemeContract({
  safariAnimationHook: "safari-animation-hook",
  default: {
    font: "default-font-family"
  },
  likec4: {
    font: "font-family",
    background: {
      color: "background-color",
      pattern: {
        color: "background-pattern-color"
      }
    }
  },
  compound: {
    font: "compound-font-family",
    titleColor: "compound-title-color"
  },
  element: {
    font: "element-font-family",
    fill: "element-fill",
    stroke: "element-stroke",
    hiContrast: "element-hiContrast",
    loContrast: "element-loContrast"
  },
  relation: {
    lineColor: "relation-lineColor",
    labelColor: "relation-labelColor",
    labelBgColor: "relation-labelBg"
  },
  optionsPanel: {
    top: "options-webview-top",
    right: "options-webview-right"
  },
  navigationPanel: {
    top: "navigation-webview-top",
    left: "navigation-webview-left"
  }
}, (value) => `likec4-${value}`);
createGlobalThemeContract({
  background: {
    color: "background-color",
    pattern: {
      color: "background-pattern-color"
      // dots: 'background-pattern-dots-color',
      // lines: 'background-pattern-lines-color',
      // cross: 'background-pattern-cross-color'
    }
  },
  edge: {
    stroke: "edge-stroke",
    strokeSelected: "edge-stroke-selected",
    labelColor: "edge-label-color",
    labelBgColor: "edge-label-background-color",
    strokeWidth: "edge-stroke-width"
  },
  node: {
    color: "node-color",
    border: "node-border",
    backgroundColor: "node-background-color",
    groupBackgroundColor: "node-group-background-color",
    boxshadowHover: "node-boxshadow-hover",
    boxshadowSelected: "node-boxshadow-selected",
    borderRadius: "node-border-radius"
  }
}, (value) => `xy-${value}`);
const mantine = themeToVars({});
function toStyle(name, colorValues) {
  const rules = [
    ...t$2(colorValues.elements).map(([key, value]) => `${stripCssVarReference(vars.element[key])}: ${value};`),
    ...t$2(colorValues.relationships).map(([key, value]) => `${stripCssVarReference(vars.relation[key])}: ${value};`)
  ].join(`
`);
  return `:where([data-likec4-color=${name}]) {
  ${rules}
}`;
}
function stripCssVarReference(ref) {
  const end = ref.indexOf(",");
  return ref.substring(4, end == -1 ? ref.length - 1 : end);
}
const LikeC4CustomColors = memo$1(({ customColors }) => {
  var _a4;
  const styles = t$2(customColors).map(([name, color2]) => toStyle(name, color2)).join(`
`), nonce = (_a4 = useMantineStyleNonce()) == null ? void 0 : _a4();
  return /* @__PURE__ */ jsx(Fragment, { children: /* @__PURE__ */ jsx("style", { type: "text/css", dangerouslySetInnerHTML: { __html: styles }, nonce }) });
}, deepEqual$1);
LikeC4CustomColors.displayName = "LikeC4CustomColors";
var cssReactFlow = "_16viy560", notInitialized = "_16viy561", cssDisablePan = "_16viy562", cssTransparentBg = "_16viy563", cssNoControls = "_16viy564";
const LikeC4ModelContext = createContext(null);
function useLikeC4Model(strict, type) {
  const model = useContext(LikeC4ModelContext);
  if (t$4(type) && l$2(model) && model.type !== type)
    throw new Error(`Invalid LikeC4ModelContext, expected "${type}" but got "${model.type}" in context`);
  if (n$1(strict) && strict === !0 && !model)
    throw new Error("No LikeC4Model found in context");
  return model;
}
function useLikeC4Views() {
  return useLikeC4Model(!0).sourcemodel.views;
}
function useLikeC4ViewModel(viewId) {
  return useLikeC4Model(!0).view(viewId);
}
function useLikeC4View(viewId) {
  const model = useLikeC4Model(!0);
  try {
    return model.view(viewId).view;
  } catch (error) {
    return console.warn(error), null;
  }
}
function useLikeC4DiagramView(viewId) {
  const model = useLikeC4Model(!0, "layouted");
  try {
    return model.view(viewId).view;
  } catch (error) {
    return console.warn(error), null;
  }
}
const sortByLabel = (a2, b2) => compareNatural(a2.label, b2.label);
function buildNode(element) {
  return {
    label: element.title,
    value: element.id,
    children: element.children().map(buildNode).sort(sortByLabel)
  };
}
function useLikeC4ElementsTree(viewId) {
  const model = useLikeC4Model(!0);
  return useMemo(() => viewId ? model.view(viewId).roots().map(buildNode).sort(sortByLabel) : model.roots().map(buildNode).sort(sortByLabel), [model, viewId ?? null]);
}
function createStore(initialState) {
  let state = initialState, initialized = !1;
  const listeners = /* @__PURE__ */ new Set();
  return {
    getState() {
      return state;
    },
    updateState(value) {
      state = typeof value == "function" ? value(state) : value;
    },
    setState(value) {
      this.updateState(value), listeners.forEach((listener) => listener(state));
    },
    initialize(value) {
      initialized || (state = value, initialized = !0);
    },
    subscribe(callback) {
      return listeners.add(callback), () => listeners.delete(callback);
    }
  };
}
function useStore$1(store) {
  return useSyncExternalStore(
    store.subscribe,
    () => store.getState(),
    () => store.getState()
  );
}
const createSpotlightStore = () => createStore({
  opened: !1,
  empty: !1,
  selected: -1,
  listId: "",
  query: "",
  registeredActions: /* @__PURE__ */ new Set()
}), useSpotlight = (store) => useStore$1(store);
function updateSpotlightStateAction(update, store) {
  const state = store.getState();
  store.setState({ ...state, ...update(store.getState()) });
}
function openSpotlightAction(store) {
  updateSpotlightStateAction(() => ({ opened: !0, selected: -1 }), store);
}
function closeSpotlightAction(store) {
  updateSpotlightStateAction(() => ({ opened: !1 }), store);
}
function toggleSpotlightAction(store) {
  updateSpotlightStateAction(
    (state) => ({ opened: !state.opened, selected: state.opened ? state.selected : -1 }),
    store
  );
}
function setSelectedAction(index2, store) {
  store.updateState((state) => ({ ...state, selected: index2 }));
}
function setListId(id2, store) {
  store.updateState((state) => ({ ...state, listId: id2 }));
}
function findElementByQuerySelector(selector2, root2 = document) {
  const element = root2.querySelector(selector2);
  if (element)
    return element;
  const children2 = root2 instanceof ShadowRoot ? root2.host.children : root2.children;
  for (let i2 = 0; i2 < children2.length; i2 += 1) {
    const child = children2[i2];
    if (child.shadowRoot) {
      const shadowElement = findElementByQuerySelector(selector2, child.shadowRoot);
      if (shadowElement)
        return shadowElement;
    }
    const nestedElement = findElementByQuerySelector(selector2, child);
    if (nestedElement)
      return nestedElement;
  }
  return null;
}
function selectAction(index2, store) {
  var _a4, _b2;
  const state = store.getState(), actionsList = state.listId ? findElementByQuerySelector(`#${state.listId}`) : null, selected2 = actionsList == null ? void 0 : actionsList.querySelector("[data-selected]"), actions = (actionsList == null ? void 0 : actionsList.querySelectorAll("[data-action]")) ?? [], nextIndex = index2 === -1 ? actions.length - 1 : index2 === actions.length ? 0 : index2, selectedIndex = clamp$3(nextIndex, 0, actions.length - 1);
  return selected2 == null || selected2.removeAttribute("data-selected"), (_a4 = actions[selectedIndex]) == null || _a4.scrollIntoView({ block: "nearest" }), (_b2 = actions[selectedIndex]) == null || _b2.setAttribute("data-selected", "true"), setSelectedAction(selectedIndex, store), selectedIndex;
}
function selectNextAction(store) {
  return selectAction(store.getState().selected + 1, store);
}
function selectPreviousAction(store) {
  return selectAction(store.getState().selected - 1, store);
}
function triggerSelectedAction(store) {
  const state = store.getState(), selected2 = findElementByQuerySelector(
    `#${state.listId} [data-selected]`
  );
  selected2 == null || selected2.click();
}
function registerAction(id2, store) {
  const state = store.getState();
  return state.registeredActions.add(id2), () => {
    state.registeredActions.delete(id2);
  };
}
function setQuery(query, store) {
  updateSpotlightStateAction(() => ({ query }), store), Promise.resolve().then(() => {
    selectAction(0, store), updateSpotlightStateAction(
      (state) => ({
        empty: state.query.trim().length > 0 && state.registeredActions.size === 0 || !1
      }),
      store
    );
  });
}
function clearSpotlightState({ clearQuery }, store) {
  store.updateState((state) => ({
    ...state,
    selected: -1,
    query: clearQuery ? "" : state.query,
    empty: clearQuery ? !1 : state.empty
  }));
}
const spotlightActions = {
  open: openSpotlightAction,
  close: closeSpotlightAction,
  toggle: toggleSpotlightAction,
  updateState: updateSpotlightStateAction,
  setSelectedAction,
  setListId,
  selectAction,
  selectNextAction,
  selectPreviousAction,
  triggerSelectedAction,
  registerAction,
  setQuery,
  clearSpotlightState
};
function createSpotlight() {
  const store = createSpotlightStore();
  return [store, {
    open: () => openSpotlightAction(store),
    close: () => closeSpotlightAction(store),
    toggle: () => toggleSpotlightAction(store)
  }];
}
const [spotlightStore, spotlight] = createSpotlight(), { open: openSpotlight, close: closeSpotlight, toggle: toggleSpotlight } = spotlight;
function isActionsGroup(item) {
  const _item = item;
  return _item.group !== void 0 && Array.isArray(_item.actions);
}
function getKeywords(keywords) {
  return Array.isArray(keywords) ? keywords.map((keyword) => keyword.trim()).join(",").toLowerCase().trim() : typeof keywords == "string" ? keywords.toLowerCase().trim() : "";
}
function getFlatActions(data) {
  return data.reduce((acc, item) => "actions" in item ? [...acc, ...item.actions.map((action) => ({ ...action, group: item.group }))] : [...acc, item], []);
}
function flatActionsToGroups(data) {
  const groups = {}, result = [];
  return data.forEach((action) => {
    action.group ? (groups[action.group] || (groups[action.group] = { pushed: !1, data: { group: action.group, actions: [] } }), groups[action.group].data.actions.push(action), groups[action.group].pushed || (groups[action.group].pushed = !0, result.push(groups[action.group].data))) : result.push(action);
  }), result;
}
const defaultSpotlightFilter = (_query, data) => {
  const query = _query.trim().toLowerCase(), priorityMatrix = [[], []];
  return getFlatActions(data).forEach((item) => {
    var _a4, _b2;
    (_a4 = item.label) != null && _a4.toLowerCase().includes(query) ? priorityMatrix[0].push(item) : ((_b2 = item.description) != null && _b2.toLowerCase().includes(query) || getKeywords(item.keywords).includes(query)) && priorityMatrix[1].push(item);
  }), flatActionsToGroups(priorityMatrix.flat());
};
function limitActions(actions, limit) {
  if (!Array.isArray(actions))
    return [];
  let count2 = 0;
  return actions.reduce((acc, item) => {
    if (count2 >= limit)
      return acc;
    if (isActionsGroup(item)) {
      const groupActions = limitActions(item.actions, limit - count2);
      acc.push({
        group: item.group,
        actions: groupActions
      }), count2 += groupActions.length;
    } else
      acc.push(item), count2 += 1;
    return acc;
  }, []);
}
const [SpotlightProvider, useSpotlightContext] = createSafeContext(
  "Spotlight component was not found in tree"
);
var __default__ = { root: "m_d2b315db", content: "m_3cd250e0", body: "m_d2abce9b", search: "m_f366a061", actionsList: "m_6e463822", action: "m_d49bb8ef", actionBody: "m_3d475731", actionSection: "m_832642f6", actionLabel: "m_6c2a1345", actionDescription: "m_a6d9d78d", empty: "m_82f78f74", footer: "m_ddcaf054", actionsGroup: "m_5a3e5f7b" };
const classes$1 = __default__, defaultProps$7 = {
  dimmedSections: !0,
  highlightQuery: !1
}, SpotlightAction = factory((_props, ref) => {
  const props = useProps("SpotlightAction", defaultProps$7, _props), {
    className,
    style: style2,
    classNames,
    styles,
    id: id2,
    description: description2,
    label: label2,
    leftSection,
    rightSection,
    children: children2,
    dimmedSections,
    highlightQuery,
    highlightColor,
    closeSpotlightOnTrigger,
    onClick,
    onMouseDown,
    keywords,
    vars: vars2,
    ...others
  } = props, ctx = useSpotlightContext(), stylesApi = { classNames, styles }, labelNode = highlightQuery && typeof label2 == "string" ? /* @__PURE__ */ jsx(
    Highlight,
    {
      component: "span",
      highlight: ctx.query,
      color: highlightColor,
      ...ctx.getStyles("actionLabel", stylesApi),
      children: label2
    }
  ) : /* @__PURE__ */ jsx("span", { ...ctx.getStyles("actionLabel", stylesApi), children: label2 });
  return /* @__PURE__ */ jsx(
    UnstyledButton,
    {
      ref,
      "data-action": !0,
      ...ctx.getStyles("action", { className, style: style2, ...stylesApi }),
      ...others,
      onMouseDown: (event) => {
        event.preventDefault(), onMouseDown == null || onMouseDown(event);
      },
      onClick: (event) => {
        onClick == null || onClick(event), (closeSpotlightOnTrigger ?? ctx.closeOnActionTrigger) && spotlightActions.close(ctx.store);
      },
      tabIndex: -1,
      children: children2 || /* @__PURE__ */ jsxs(Fragment, { children: [
        leftSection && /* @__PURE__ */ jsx(
          Box,
          {
            component: "span",
            mod: { position: "left", dimmed: dimmedSections },
            ...ctx.getStyles("actionSection", stylesApi),
            children: leftSection
          }
        ),
        /* @__PURE__ */ jsxs("span", { ...ctx.getStyles("actionBody", stylesApi), children: [
          labelNode,
          /* @__PURE__ */ jsx("span", { ...ctx.getStyles("actionDescription", stylesApi), children: description2 })
        ] }),
        rightSection && /* @__PURE__ */ jsx(
          Box,
          {
            component: "span",
            mod: { position: "right", dimmed: dimmedSections },
            ...ctx.getStyles("actionSection", stylesApi),
            children: rightSection
          }
        )
      ] })
    }
  );
});
SpotlightAction.classes = classes$1;
SpotlightAction.displayName = "@mantine/spotlight/SpotlightAction";
const defaultProps$6 = {}, SpotlightActionsGroup = factory((props, ref) => {
  const { className, style: style2, styles, classNames, label: label2, children: children2, ...others } = useProps(
    "SpotlightActionsGroup",
    defaultProps$6,
    props
  ), ctx = useSpotlightContext();
  return /* @__PURE__ */ jsx(
    Box,
    {
      ...ctx.getStyles("actionsGroup", { className, style: style2, classNames, styles }),
      ref,
      ...others,
      __vars: { "--spotlight-label": `'${label2}'` },
      children: children2
    }
  );
});
SpotlightActionsGroup.classes = classes$1;
SpotlightActionsGroup.displayName = "@mantine/core/SpotlightActionsGroup";
const defaultProps$5 = {}, SpotlightActionsList = factory((props, ref) => {
  const { className, style: style2, id: id2, children: children2, vars: vars2, classNames, styles, ...others } = useProps(
    "SpotlightActionsList",
    defaultProps$5,
    props
  ), ctx = useSpotlightContext(), generatedId = `mantine-${useId$2().replace(/:/g, "")}`, listId = id2 || generatedId;
  return useEffect(() => (spotlightActions.setListId(listId, ctx.store), () => spotlightActions.setListId("", ctx.store)), []), /* @__PURE__ */ jsx(
    ScrollArea.Autosize,
    {
      ...ctx.getStyles("actionsList", { className, style: style2, classNames, styles }),
      ref,
      type: "scroll",
      scrollbarSize: "var(--spotlight-actions-list-padding)",
      offsetScrollbars: "y",
      id: listId,
      ...others,
      children: children2
    }
  );
});
SpotlightActionsList.classes = classes$1;
SpotlightActionsList.displayName = "@mantine/spotlight/SpotlightActionsList";
const defaultProps$4 = {}, SpotlightEmpty = factory((props, ref) => {
  const { className, style: style2, classNames, styles, ...others } = useProps(
    "SpotlightEmpty",
    defaultProps$4,
    props
  ), ctx = useSpotlightContext();
  return /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      ...ctx.getStyles("empty", { classNames, styles, className, style: style2 }),
      ...others
    }
  );
});
SpotlightEmpty.classes = classes$1;
SpotlightEmpty.displayName = "@mantine/spotlight/SpotlightEmpty";
const defaultProps$3 = {}, SpotlightFooter = factory((props, ref) => {
  const { className, style: style2, classNames, styles, ...others } = useProps(
    "SpotlightFooter",
    defaultProps$3,
    props
  ), ctx = useSpotlightContext();
  return /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      ...ctx.getStyles("footer", { className, classNames, style: style2, styles }),
      ...others
    }
  );
});
SpotlightFooter.classes = classes$1;
SpotlightFooter.displayName = "@mantine/spotlight/SpotlightFooter";
function getHotkeys(hotkeys, store) {
  if (!hotkeys)
    return [];
  const open = () => spotlightActions.open(store);
  return Array.isArray(hotkeys) ? hotkeys.map((hotkey) => [hotkey, open]) : [[hotkeys, open]];
}
const defaultProps$2 = {
  size: 600,
  yOffset: 80,
  zIndex: getDefaultZIndex("max"),
  overlayProps: { backgroundOpacity: 0.35, blur: 7 },
  transitionProps: { duration: 200, transition: "pop" },
  store: spotlightStore,
  clearQueryOnClose: !0,
  closeOnActionTrigger: !0,
  shortcut: "mod + K",
  maxHeight: 400,
  scrollable: !1
}, SpotlightRoot = factory((_props, ref) => {
  const props = useProps("SpotlightRoot", defaultProps$2, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars: vars2,
    store,
    children: children2,
    query,
    onQueryChange,
    transitionProps,
    clearQueryOnClose,
    shortcut,
    tagsToIgnore,
    triggerOnContentEditable,
    disabled,
    onSpotlightOpen,
    onSpotlightClose,
    forceOpened,
    closeOnActionTrigger,
    maxHeight,
    scrollable,
    ...others
  } = props, theme = useMantineTheme(), { opened, query: storeQuery } = useSpotlight(store), _query = query || storeQuery, setQuery2 = (q2) => {
    onQueryChange == null || onQueryChange(q2), spotlightActions.setQuery(q2, store);
  }, getStyles2 = useStyles({
    name: "Spotlight",
    classes: classes$1,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled
  });
  return useHotkeys(getHotkeys(shortcut, store), tagsToIgnore, triggerOnContentEditable), useDidUpdate(() => {
    opened ? onSpotlightOpen == null || onSpotlightOpen() : onSpotlightClose == null || onSpotlightClose();
  }, [opened]), disabled ? null : /* @__PURE__ */ jsx(
    SpotlightProvider,
    {
      value: {
        getStyles: getStyles2,
        query: _query,
        setQuery: setQuery2,
        store,
        closeOnActionTrigger
      },
      children: /* @__PURE__ */ jsx(
        Modal,
        {
          ref,
          ...others,
          withCloseButton: !1,
          opened: opened || !!forceOpened,
          padding: 0,
          onClose: () => spotlightActions.close(store),
          className,
          style: style2,
          classNames: resolveClassNames({
            theme,
            classNames: [classes$1, classNames],
            props,
            stylesCtx: void 0
          }),
          styles: resolveStyles({ theme, styles, props, stylesCtx: void 0 }),
          transitionProps: {
            ...transitionProps,
            onExited: () => {
              var _a4;
              clearQueryOnClose && setQuery2(""), spotlightActions.clearSpotlightState({ clearQuery: clearQueryOnClose }, store), (_a4 = transitionProps == null ? void 0 : transitionProps.onExited) == null || _a4.call(transitionProps);
            }
          },
          __vars: { "--spotlight-max-height": scrollable ? rem(maxHeight) : void 0 },
          __staticSelector: "Spotlight",
          "data-scrollable": scrollable || void 0,
          children: children2
        }
      )
    }
  );
});
SpotlightRoot.classes = classes$1;
SpotlightRoot.displayName = "@mantine/spotlight/SpotlightRoot";
const defaultProps$1 = {
  size: "lg"
}, SpotlightSearch = factory((props, ref) => {
  const { classNames, styles, onKeyDown, onChange, vars: vars2, value, ...others } = useProps(
    "SpotlightSearch",
    defaultProps$1,
    props
  ), ctx = useSpotlightContext(), inputStyles = ctx.getStyles("search"), [isComposing, setIsComposing] = useState(!1), handleKeyDown = (event) => {
    onKeyDown == null || onKeyDown(event), !isComposing && (event.nativeEvent.code === "ArrowDown" && (event.preventDefault(), spotlightActions.selectNextAction(ctx.store)), event.nativeEvent.code === "ArrowUp" && (event.preventDefault(), spotlightActions.selectPreviousAction(ctx.store)), (event.nativeEvent.code === "Enter" || event.nativeEvent.code === "NumpadEnter") && (event.preventDefault(), spotlightActions.triggerSelectedAction(ctx.store)));
  };
  return /* @__PURE__ */ jsx(
    Input,
    {
      ref,
      classNames: [{ input: inputStyles.className }, classNames],
      styles: [{ input: inputStyles.style }, styles],
      ...others,
      value: value ?? ctx.query,
      onChange: (event) => {
        ctx.setQuery(event.currentTarget.value), onChange == null || onChange(event);
      },
      onKeyDown: handleKeyDown,
      onCompositionStart: () => setIsComposing(!0),
      onCompositionEnd: () => setIsComposing(!1)
    }
  );
});
SpotlightSearch.classes = classes$1;
SpotlightSearch.displayName = "@mantine/spotlight/SpotlightSearch";
const defaultProps = {
  size: 600,
  yOffset: 80,
  limit: 1 / 0,
  zIndex: getDefaultZIndex("max"),
  overlayProps: { backgroundOpacity: 0.35, blur: 7 },
  transitionProps: { duration: 200, transition: "pop" },
  store: spotlightStore,
  filter: defaultSpotlightFilter,
  clearQueryOnClose: !0,
  closeOnActionTrigger: !0,
  shortcut: "mod + K",
  highlightQuery: !1
}, Spotlight = factory((_props, ref) => {
  const props = useProps("Spotlight", defaultProps, _props), {
    searchProps,
    filter: filter2,
    query,
    onQueryChange,
    actions,
    nothingFound,
    highlightQuery,
    limit,
    ...others
  } = props, [_query, setQuery2] = useUncontrolled({
    value: query,
    defaultValue: "",
    finalValue: "",
    onChange: onQueryChange
  }), filteredActions = limitActions(filter2(_query, actions), limit).map((item) => {
    if (isActionsGroup(item)) {
      const items = item.actions.map(({ id: id2, ...actionData }) => /* @__PURE__ */ jsx(SpotlightAction, { highlightQuery, ...actionData }, id2));
      return /* @__PURE__ */ jsx(SpotlightActionsGroup, { label: item.group, children: items }, item.group);
    }
    return /* @__PURE__ */ jsx(SpotlightAction, { highlightQuery, ...item }, item.id);
  });
  return /* @__PURE__ */ jsxs(SpotlightRoot, { ...others, query: _query, onQueryChange: setQuery2, ref, children: [
    /* @__PURE__ */ jsx(SpotlightSearch, { ...searchProps }),
    /* @__PURE__ */ jsxs(SpotlightActionsList, { children: [
      filteredActions,
      filteredActions.length === 0 && nothingFound && /* @__PURE__ */ jsx(SpotlightEmpty, { children: nothingFound })
    ] })
  ] });
});
Spotlight.classes = classes$1;
Spotlight.displayName = "@mantine/spotlight/Spotlight";
Spotlight.Search = SpotlightSearch;
Spotlight.ActionsList = SpotlightActionsList;
Spotlight.Action = SpotlightAction;
Spotlight.Empty = SpotlightEmpty;
Spotlight.ActionsGroup = SpotlightActionsGroup;
Spotlight.Footer = SpotlightFooter;
Spotlight.Root = SpotlightRoot;
Spotlight.open = spotlight.open;
Spotlight.close = spotlight.close;
Spotlight.toggle = spotlight.toggle;
var defaultAttributes = {
  outline: {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  },
  filled: {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    stroke: "none"
  }
};
const createReactComponent = (type, iconName, iconNamePascal, iconNode) => {
  const Component2 = forwardRef(
    ({ color: color2 = "currentColor", size: size2 = 24, stroke = 2, title: title2, className, children: children2, ...rest }, ref) => createElement(
      "svg",
      {
        ref,
        ...defaultAttributes[type],
        width: size2,
        height: size2,
        className: ["tabler-icon", `tabler-icon-${iconName}`, className].join(" "),
        ...type === "filled" ? {
          fill: color2
        } : {
          strokeWidth: stroke,
          stroke: color2
        },
        ...rest
      },
      [
        title2 && createElement("title", { key: "svg-title" }, title2),
        ...iconNode.map(([tag, attrs]) => createElement(tag, attrs)),
        ...Array.isArray(children2) ? children2 : [children2]
      ]
    )
  );
  return Component2.displayName = `${iconNamePascal}`, Component2;
};
var IconAlertTriangle = createReactComponent("outline", "alert-triangle", "IconAlertTriangle", [["path", { d: "M12 9v4", key: "svg-0" }], ["path", { d: "M10.363 3.591l-8.106 13.534a1.914 1.914 0 0 0 1.636 2.871h16.214a1.914 1.914 0 0 0 1.636 -2.87l-8.106 -13.536a1.914 1.914 0 0 0 -3.274 0z", key: "svg-1" }], ["path", { d: "M12 16h.01", key: "svg-2" }]]);
var IconArrowDownRight = createReactComponent("outline", "arrow-down-right", "IconArrowDownRight", [["path", { d: "M7 7l10 10", key: "svg-0" }], ["path", { d: "M17 8l0 9l-9 0", key: "svg-1" }]]);
var IconArrowLeft = createReactComponent("outline", "arrow-left", "IconArrowLeft", [["path", { d: "M5 12l14 0", key: "svg-0" }], ["path", { d: "M5 12l6 6", key: "svg-1" }], ["path", { d: "M5 12l6 -6", key: "svg-2" }]]);
var IconArrowRight = createReactComponent("outline", "arrow-right", "IconArrowRight", [["path", { d: "M5 12l14 0", key: "svg-0" }], ["path", { d: "M13 18l6 -6", key: "svg-1" }], ["path", { d: "M13 6l6 6", key: "svg-2" }]]);
var IconCheck = createReactComponent("outline", "check", "IconCheck", [["path", { d: "M5 12l5 5l10 -10", key: "svg-0" }]]);
var IconChevronLeft = createReactComponent("outline", "chevron-left", "IconChevronLeft", [["path", { d: "M15 6l-6 6l6 6", key: "svg-0" }]]);
var IconChevronRight = createReactComponent("outline", "chevron-right", "IconChevronRight", [["path", { d: "M9 6l6 6l-6 6", key: "svg-0" }]]);
var IconCopy = createReactComponent("outline", "copy", "IconCopy", [["path", { d: "M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z", key: "svg-0" }], ["path", { d: "M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1", key: "svg-1" }]]);
var IconExternalLink = createReactComponent("outline", "external-link", "IconExternalLink", [["path", { d: "M12 6h-6a2 2 0 0 0 -2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-6", key: "svg-0" }], ["path", { d: "M11 13l9 -9", key: "svg-1" }], ["path", { d: "M15 4h5v5", key: "svg-2" }]]);
var IconFileSymlink = createReactComponent("outline", "file-symlink", "IconFileSymlink", [["path", { d: "M4 21v-4a3 3 0 0 1 3 -3h5", key: "svg-0" }], ["path", { d: "M9 17l3 -3l-3 -3", key: "svg-1" }], ["path", { d: "M14 3v4a1 1 0 0 0 1 1h4", key: "svg-2" }], ["path", { d: "M5 11v-6a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2h-9.5", key: "svg-3" }]]);
var IconFocusCentered = createReactComponent("outline", "focus-centered", "IconFocusCentered", [["path", { d: "M12 12m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0", key: "svg-0" }], ["path", { d: "M4 8v-2a2 2 0 0 1 2 -2h2", key: "svg-1" }], ["path", { d: "M4 16v2a2 2 0 0 0 2 2h2", key: "svg-2" }], ["path", { d: "M16 4h2a2 2 0 0 1 2 2v2", key: "svg-3" }], ["path", { d: "M16 20h2a2 2 0 0 0 2 -2v-2", key: "svg-4" }]]);
var IconHelpCircle = createReactComponent("outline", "help-circle", "IconHelpCircle", [["path", { d: "M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0", key: "svg-0" }], ["path", { d: "M12 16v.01", key: "svg-1" }], ["path", { d: "M12 13a2 2 0 0 0 .914 -3.782a1.98 1.98 0 0 0 -2.414 .483", key: "svg-2" }]]);
var IconId = createReactComponent("outline", "id", "IconId", [["path", { d: "M3 4m0 3a3 3 0 0 1 3 -3h12a3 3 0 0 1 3 3v10a3 3 0 0 1 -3 3h-12a3 3 0 0 1 -3 -3z", key: "svg-0" }], ["path", { d: "M9 10m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0", key: "svg-1" }], ["path", { d: "M15 8l2 0", key: "svg-2" }], ["path", { d: "M15 12l2 0", key: "svg-3" }], ["path", { d: "M7 16l10 0", key: "svg-4" }]]);
var IconInfoCircle = createReactComponent("outline", "info-circle", "IconInfoCircle", [["path", { d: "M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0", key: "svg-0" }], ["path", { d: "M12 9h.01", key: "svg-1" }], ["path", { d: "M11 12h1v4h1", key: "svg-2" }]]);
var IconLayoutAlignBottom = createReactComponent("outline", "layout-align-bottom", "IconLayoutAlignBottom", [["path", { d: "M4 20l16 0", key: "svg-0" }], ["path", { d: "M9 4m0 2a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-2a2 2 0 0 1 -2 -2z", key: "svg-1" }]]);
var IconLayoutAlignCenter = createReactComponent("outline", "layout-align-center", "IconLayoutAlignCenter", [["path", { d: "M12 4l0 5", key: "svg-0" }], ["path", { d: "M12 15l0 5", key: "svg-1" }], ["path", { d: "M6 9m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v2a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z", key: "svg-2" }]]);
var IconLayoutAlignLeft = createReactComponent("outline", "layout-align-left", "IconLayoutAlignLeft", [["path", { d: "M4 4l0 16", key: "svg-0" }], ["path", { d: "M8 9m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v2a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z", key: "svg-1" }]]);
var IconLayoutAlignMiddle = createReactComponent("outline", "layout-align-middle", "IconLayoutAlignMiddle", [["path", { d: "M4 12l5 0", key: "svg-0" }], ["path", { d: "M15 12l5 0", key: "svg-1" }], ["path", { d: "M9 6m0 2a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-2a2 2 0 0 1 -2 -2z", key: "svg-2" }]]);
var IconLayoutAlignRight = createReactComponent("outline", "layout-align-right", "IconLayoutAlignRight", [["path", { d: "M20 4l0 16", key: "svg-0" }], ["path", { d: "M4 9m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v2a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z", key: "svg-1" }]]);
var IconLayoutAlignTop = createReactComponent("outline", "layout-align-top", "IconLayoutAlignTop", [["path", { d: "M4 4l16 0", key: "svg-0" }], ["path", { d: "M9 8m0 2a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-2a2 2 0 0 1 -2 -2z", key: "svg-1" }]]);
var IconLayoutBoardSplit = createReactComponent("outline", "layout-board-split", "IconLayoutBoardSplit", [["path", { d: "M4 4m0 2a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v12a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2z", key: "svg-0" }], ["path", { d: "M4 12h8", key: "svg-1" }], ["path", { d: "M12 15h8", key: "svg-2" }], ["path", { d: "M12 9h8", key: "svg-3" }], ["path", { d: "M12 4v16", key: "svg-4" }]]);
var IconLayoutCollage = createReactComponent("outline", "layout-collage", "IconLayoutCollage", [["path", { d: "M4 4m0 2a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v12a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2z", key: "svg-0" }], ["path", { d: "M10 4l4 16", key: "svg-1" }], ["path", { d: "M12 12l-8 2", key: "svg-2" }]]);
var IconLayoutDashboard = createReactComponent("outline", "layout-dashboard", "IconLayoutDashboard", [["path", { d: "M5 4h4a1 1 0 0 1 1 1v6a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1v-6a1 1 0 0 1 1 -1", key: "svg-0" }], ["path", { d: "M5 16h4a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1v-2a1 1 0 0 1 1 -1", key: "svg-1" }], ["path", { d: "M15 12h4a1 1 0 0 1 1 1v6a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1v-6a1 1 0 0 1 1 -1", key: "svg-2" }], ["path", { d: "M15 4h4a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1v-2a1 1 0 0 1 1 -1", key: "svg-3" }]]);
var IconMenu2 = createReactComponent("outline", "menu-2", "IconMenu2", [["path", { d: "M4 6l16 0", key: "svg-0" }], ["path", { d: "M4 12l16 0", key: "svg-1" }], ["path", { d: "M4 18l16 0", key: "svg-2" }]]);
var IconMenu = createReactComponent("outline", "menu", "IconMenu", [["path", { d: "M4 8l16 0", key: "svg-0" }], ["path", { d: "M4 16l16 0", key: "svg-1" }]]);
var IconRectangularPrism = createReactComponent("outline", "rectangular-prism", "IconRectangularPrism", [["path", { d: "M21 14.008v-5.018a1.98 1.98 0 0 0 -1 -1.717l-4 -2.008a2.016 2.016 0 0 0 -2 0l-10 5.008c-.619 .355 -1 1.01 -1 1.718v5.018c0 .709 .381 1.363 1 1.717l4 2.008a2.016 2.016 0 0 0 2 0l10 -5.008c.619 -.355 1 -1.01 1 -1.718z", key: "svg-0" }], ["path", { d: "M9 21v-7.5", key: "svg-1" }], ["path", { d: "M9 13.5l11.5 -5.5", key: "svg-2" }], ["path", { d: "M3.5 11l5.5 2.5", key: "svg-3" }]]);
var IconRouteOff = createReactComponent("outline", "route-off", "IconRouteOff", [["path", { d: "M6 19m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0", key: "svg-0" }], ["path", { d: "M18 5m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0", key: "svg-1" }], ["path", { d: "M12 19h4.5c.71 0 1.372 -.212 1.924 -.576m1.545 -2.459a3.5 3.5 0 0 0 -3.469 -3.965h-.499m-4 0h-3.501a3.5 3.5 0 0 1 -2.477 -5.972m2.477 -1.028h3.5", key: "svg-2" }], ["path", { d: "M3 3l18 18", key: "svg-3" }]]);
var IconSearch = createReactComponent("outline", "search", "IconSearch", [["path", { d: "M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0", key: "svg-0" }], ["path", { d: "M21 21l-6 -6", key: "svg-1" }]]);
var IconSelector = createReactComponent("outline", "selector", "IconSelector", [["path", { d: "M8 9l4 -4l4 4", key: "svg-0" }], ["path", { d: "M16 15l-4 4l-4 -4", key: "svg-1" }]]);
var IconSitemap = createReactComponent("outline", "sitemap", "IconSitemap", [["path", { d: "M3 15m0 2a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v2a2 2 0 0 1 -2 2h-2a2 2 0 0 1 -2 -2z", key: "svg-0" }], ["path", { d: "M15 15m0 2a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v2a2 2 0 0 1 -2 2h-2a2 2 0 0 1 -2 -2z", key: "svg-1" }], ["path", { d: "M9 3m0 2a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v2a2 2 0 0 1 -2 2h-2a2 2 0 0 1 -2 -2z", key: "svg-2" }], ["path", { d: "M6 15v-1a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v1", key: "svg-3" }], ["path", { d: "M12 9l0 3", key: "svg-4" }]]);
var IconTransform = createReactComponent("outline", "transform", "IconTransform", [["path", { d: "M3 6a3 3 0 1 0 6 0a3 3 0 0 0 -6 0", key: "svg-0" }], ["path", { d: "M21 11v-3a2 2 0 0 0 -2 -2h-6l3 3m0 -6l-3 3", key: "svg-1" }], ["path", { d: "M3 13v3a2 2 0 0 0 2 2h6l-3 -3m0 6l3 -3", key: "svg-2" }], ["path", { d: "M15 18a3 3 0 1 0 6 0a3 3 0 0 0 -6 0", key: "svg-3" }]]);
var IconX = createReactComponent("outline", "x", "IconX", [["path", { d: "M18 6l-12 12", key: "svg-0" }], ["path", { d: "M6 6l12 12", key: "svg-1" }]]);
var IconZoomScan = createReactComponent("outline", "zoom-scan", "IconZoomScan", [["path", { d: "M4 8v-2a2 2 0 0 1 2 -2h2", key: "svg-0" }], ["path", { d: "M4 16v2a2 2 0 0 0 2 2h2", key: "svg-1" }], ["path", { d: "M16 4h2a2 2 0 0 1 2 2v2", key: "svg-2" }], ["path", { d: "M16 20h2a2 2 0 0 0 2 -2v-2", key: "svg-3" }], ["path", { d: "M8 11a3 3 0 1 0 6 0a3 3 0 0 0 -6 0", key: "svg-4" }], ["path", { d: "M16 16l-2.5 -2.5", key: "svg-5" }]]);
var IconBoxMultipleFilled = createReactComponent("filled", "box-multiple-filled", "IconBoxMultipleFilled", [["path", { d: "M6 5.667a3.667 3.667 0 0 1 3.667 -3.667h8.666a3.667 3.667 0 0 1 3.667 3.667v8.666a3.667 3.667 0 0 1 -3.667 3.667h-8.666a3.667 3.667 0 0 1 -3.667 -3.667z", key: "svg-0" }], ["path", { d: "M2 9c0 -1.094 .533 -1.828 1.514 -2.374a1 1 0 1 1 .972 1.748c-.398 .221 -.486 .342 -.486 .626v10c0 .548 .452 1 1 1h9.998c.32 0 .618 -.154 .805 -.407l.065 -.1a1 1 0 1 1 1.738 .99a3 3 0 0 1 -2.606 1.517h-10c-1.652 0 -3 -1.348 -3 -3z", key: "svg-1" }]]);
var IconPlayerPlayFilled = createReactComponent("filled", "player-play-filled", "IconPlayerPlayFilled", [["path", { d: "M6 4v16a1 1 0 0 0 1.524 .852l13 -8a1 1 0 0 0 0 -1.704l-13 -8a1 1 0 0 0 -1.524 .852z", key: "svg-0" }]]);
var IconPlayerSkipBackFilled = createReactComponent("filled", "player-skip-back-filled", "IconPlayerSkipBackFilled", [["path", { d: "M19.496 4.136l-12 7a1 1 0 0 0 0 1.728l12 7a1 1 0 0 0 1.504 -.864v-14a1 1 0 0 0 -1.504 -.864z", key: "svg-0" }], ["path", { d: "M4 4a1 1 0 0 1 .993 .883l.007 .117v14a1 1 0 0 1 -1.993 .117l-.007 -.117v-14a1 1 0 0 1 1 -1z", key: "svg-1" }]]);
var IconPlayerSkipForwardFilled = createReactComponent("filled", "player-skip-forward-filled", "IconPlayerSkipForwardFilled", [["path", { d: "M3 5v14a1 1 0 0 0 1.504 .864l12 -7a1 1 0 0 0 0 -1.728l-12 -7a1 1 0 0 0 -1.504 .864z", key: "svg-0" }], ["path", { d: "M20 4a1 1 0 0 1 .993 .883l.007 .117v14a1 1 0 0 1 -1.993 .117l-.007 -.117v-14a1 1 0 0 1 1 -1z", key: "svg-1" }]]);
var IconPlayerStopFilled = createReactComponent("filled", "player-stop-filled", "IconPlayerStopFilled", [["path", { d: "M17 4h-10a3 3 0 0 0 -3 3v10a3 3 0 0 0 3 3h10a3 3 0 0 0 3 -3v-10a3 3 0 0 0 -3 -3z", key: "svg-0" }]]);
function filterAction(actionData, query) {
  const queryLower = query.toLowerCase(), keywordMatch = (Array.isArray(actionData.keywords) ? actionData.keywords : []).map((keyword) => {
    const index2 = keyword.toLowerCase().indexOf(queryLower);
    return index2 !== -1 ? {
      keyword,
      match: keyword.substring(index2, index2 + query.length)
    } : null;
  }).find((match) => !!match);
  return keywordMatch ? {
    data: actionData,
    keyword: keywordMatch.keyword,
    match: keywordMatch.match
  } : void 0;
}
function buildFilteredActions(actionsData, query) {
  return x$2(
    actionsData,
    m$2((a2) => filterAction(a2, query)),
    T$1((qm) => !!qm),
    m$2((qm) => buildSpotlightAction(qm))
  );
}
function highlightMatch(match) {
  return /* @__PURE__ */ jsx(Highlight, { highlight: match.match, children: match.keyword });
}
function buildSpotlightAction(matchedAction) {
  const isMatchInLabel = matchedAction.keyword == matchedAction.data.label;
  return /* @__PURE__ */ jsxs(Spotlight.Action, { onClick: matchedAction.data.onClick, children: [
    /* @__PURE__ */ jsx(Center, { style: { marginRight: "8px " }, children: matchedAction.data.leftSection }),
    /* @__PURE__ */ jsx(Group, { wrap: "nowrap", w: "100%", children: /* @__PURE__ */ jsxs("div", { style: { flex: 1 }, children: [
      /* @__PURE__ */ jsx(Text$6, { children: isMatchInLabel ? highlightMatch(matchedAction) : matchedAction.data.label }),
      !isMatchInLabel && /* @__PURE__ */ jsx(Text$6, { opacity: 0.6, size: "xs", children: highlightMatch(matchedAction) })
    ] }) })
  ] });
}
const LikeC4Search = memo$1(() => {
  const view = useDiagramState((s2) => s2.view), model = useLikeC4Model(!0), store = useDiagramStoreApi(), [query, setQuery2] = useState(""), getNodeActionsData = () => {
    const { focusOnNode } = store.getState();
    return x$2(
      view.nodes,
      T$1((n2) => !!n2.title),
      m$2((n2) => ({
        id: n2.id,
        label: n2.title,
        keywords: [
          n2.title,
          ...(n2.tags ?? []).map((t2) => `#${t2}`),
          ...n2.description ? [n2.description] : []
        ].filter((k2) => k2.toLowerCase()),
        onClick: () => focusOnNode(n2.id),
        leftSection: /* @__PURE__ */ jsx(IconRectangularPrism, {})
      }))
    );
  }, getViewActionsData = () => {
    const { onNavigateTo } = store.getState(), views = model.views();
    return m$2(views, (v2) => ({
      id: v2.id,
      label: v2.title ?? v2.id,
      keywords: [
        v2.title ?? v2.id,
        ...v2.tags ?? [],
        ...v2.view.description ? [v2.view.description] : []
      ],
      onClick: () => {
        store.setState({
          hoveredNodeId: null,
          lastOnNavigate: {
            fromView: view.id,
            toView: v2.id,
            fromNode: null
          }
        }), onNavigateTo == null || onNavigateTo(v2.id);
      },
      leftSection: /* @__PURE__ */ jsx(IconSitemap, {})
    }));
  }, { nodeActions, viewActions } = useMemo(
    () => ({
      nodeActions: buildFilteredActions(getNodeActionsData(), query),
      viewActions: buildFilteredActions(getViewActionsData(), query)
    }),
    [model, store, view, query]
  ), portalProps = useMantinePortalProps();
  return /* @__PURE__ */ jsxs(
    Spotlight.Root,
    {
      ...portalProps,
      shortcut: ["mod + f", "mod + k"],
      query,
      onQueryChange: setQuery2,
      scrollable: !0,
      maxHeight: "calc(100vh - 100px)",
      children: [
        /* @__PURE__ */ jsx(
          Spotlight.Search,
          {
            placeholder: "Search elements in current view and other views...",
            leftSection: /* @__PURE__ */ jsx(IconSearch, { stroke: 1.5 })
          }
        ),
        /* @__PURE__ */ jsxs(Spotlight.ActionsList, { children: [
          nodeActions.length > 0 && /* @__PURE__ */ jsx(SpotlightActionsGroup, { label: "Elements", children: nodeActions }),
          viewActions.length > 0 && /* @__PURE__ */ jsx(SpotlightActionsGroup, { label: "Views", children: viewActions }),
          nodeActions.length == 0 && viewActions.length == 0 && /* @__PURE__ */ jsx(Spotlight.Empty, { children: "Nothing found..." })
        ] })
      ]
    }
  );
}), OverlayContext = createContext({});
function useOverlayDialog() {
  return useContext(OverlayContext);
}
var edgeSource = "_13zcbbh1 _13zcbbh0", edgeArrow = "_13zcbbh2 _13zcbbh0", edgeTarget = "_13zcbbh3 _13zcbbh0", edgeLabel$3 = "_13zcbbh4", edgeRow = "_13zcbbh5", edgeGrid = "_13zcbbh6", edgeDataGrid = "_13zcbbh7";
const SelectEdge = ({
  edge,
  view
}) => {
  const overlay = useOverlayDialog(), viewport = useRef(null), theme = useComputedColorScheme(), edgeSource$1 = view.nodes.find((n2) => n2.id === edge.source), edgeTarget$1 = view.nodes.find((n2) => n2.id === edge.target), edges = view.edges.map((edge2) => {
    const source = view.nodes.find((n2) => n2.id === edge2.source), target = view.nodes.find((n2) => n2.id === edge2.target);
    return {
      id: edge2.id,
      source,
      target,
      label: edge2.label
    };
  });
  return /* @__PURE__ */ jsxs(
    Popover,
    {
      position: "bottom",
      shadow: "md",
      keepMounted: !0,
      withinPortal: !1,
      closeOnClickOutside: !0,
      clickOutsideEvents: ["pointerdown", "mousedown", "click"],
      onOpen: () => {
        setTimeout(() => {
          var _a4;
          const item = (_a4 = viewport.current) == null ? void 0 : _a4.querySelector(`[data-edge-id="${edge.id}"]`);
          item == null || item.scrollIntoView({ behavior: "instant", block: "nearest" });
        }, 100);
      },
      children: [
        /* @__PURE__ */ jsx(PopoverTarget, { children: /* @__PURE__ */ jsxs(
          Button,
          {
            size: "xs",
            variant: "light",
            color: theme === "light" ? "dark" : "gray",
            fw: "500",
            style: { padding: "0.25rem 0.75rem" },
            rightSection: /* @__PURE__ */ jsx(IconSelector, { size: 16 }),
            children: [
              /* @__PURE__ */ jsx(
                Box,
                {
                  className: edgeSource,
                  maw: 160,
                  p: 0,
                  mod: {
                    "likec4-color": edgeSource$1.color
                  },
                  children: /* @__PURE__ */ jsx(Text$6, { component: "span", truncate: !0, children: edgeSource$1.title })
                }
              ),
              /* @__PURE__ */ jsx(ThemeIcon, { color: "dark", variant: "transparent", size: "xs", children: /* @__PURE__ */ jsx(IconArrowRight, { style: { width: "80%" } }) }),
              /* @__PURE__ */ jsx(
                Box,
                {
                  className: edgeTarget,
                  maw: 160,
                  p: 0,
                  mod: {
                    "likec4-color": edgeTarget$1.color
                  },
                  children: /* @__PURE__ */ jsx(Text$6, { component: "span", truncate: !0, children: edgeTarget$1.title })
                }
              )
            ]
          }
        ) }),
        /* @__PURE__ */ jsx(PopoverDropdown, { p: 0, miw: 250, maw: 420, children: /* @__PURE__ */ jsx(ScrollAreaAutosize, { mah: "70vh", scrollbars: "y", type: "never", viewportRef: viewport, children: /* @__PURE__ */ jsx(Box, { className: edgeGrid, p: "xs", children: edges.map((e2) => /* @__PURE__ */ jsxs(
          "div",
          {
            className: edgeRow,
            "data-selected": e2.id === edge.id,
            onClick: (event) => {
              event.stopPropagation(), overlay.openOverlay({
                edgeDetails: e2.id
              });
            },
            children: [
              /* @__PURE__ */ jsx(
                Box,
                {
                  className: edgeSource,
                  maw: 160,
                  mod: {
                    "edge-id": e2.id,
                    "likec4-color": e2.source.color
                  },
                  children: /* @__PURE__ */ jsx(Text$6, { component: "span", truncate: !0, children: e2.source.title })
                }
              ),
              /* @__PURE__ */ jsx(Box, { className: edgeArrow, children: /* @__PURE__ */ jsx(ThemeIcon, { color: "dark", variant: "transparent", size: "xs", children: /* @__PURE__ */ jsx(IconArrowRight, { style: { width: "80%" } }) }) }),
              /* @__PURE__ */ jsx(
                Box,
                {
                  className: edgeTarget,
                  maw: 160,
                  mod: {
                    "likec4-color": e2.target.color
                  },
                  children: /* @__PURE__ */ jsx(Text$6, { component: "span", truncate: !0, children: e2.target.title })
                }
              ),
              /* @__PURE__ */ jsx(Box, { className: edgeLabel$3, children: /* @__PURE__ */ jsx(Text$6, { component: "span", truncate: !0, children: e2.label || "untitled" }) })
            ]
          },
          e2.id
        )) }) }) })
      ]
    }
  );
};
var DEFAULT_EDGE_NAME = "\0", GRAPH_NODE = "\0", EDGE_KEY_DELIM = "";
let Graph$a = class {
  constructor(opts) {
    __publicField(this, "_isDirected", !0);
    __publicField(this, "_isMultigraph", !1);
    __publicField(this, "_isCompound", !1);
    // Label for the graph itself
    __publicField(this, "_label");
    // Defaults to be set when creating a new node
    __publicField(this, "_defaultNodeLabelFn", () => {
    });
    // Defaults to be set when creating a new edge
    __publicField(this, "_defaultEdgeLabelFn", () => {
    });
    // v -> label
    __publicField(this, "_nodes", {});
    // v -> edgeObj
    __publicField(this, "_in", {});
    // u -> v -> Number
    __publicField(this, "_preds", {});
    // v -> edgeObj
    __publicField(this, "_out", {});
    // v -> w -> Number
    __publicField(this, "_sucs", {});
    // e -> edgeObj
    __publicField(this, "_edgeObjs", {});
    // e -> label
    __publicField(this, "_edgeLabels", {});
    /* Number of nodes in the graph. Should only be changed by the implementation. */
    __publicField(this, "_nodeCount", 0);
    /* Number of edges in the graph. Should only be changed by the implementation. */
    __publicField(this, "_edgeCount", 0);
    __publicField(this, "_parent");
    __publicField(this, "_children");
    opts && (this._isDirected = Object.hasOwn(opts, "directed") ? opts.directed : !0, this._isMultigraph = Object.hasOwn(opts, "multigraph") ? opts.multigraph : !1, this._isCompound = Object.hasOwn(opts, "compound") ? opts.compound : !1), this._isCompound && (this._parent = {}, this._children = {}, this._children[GRAPH_NODE] = {});
  }
  /* === Graph functions ========= */
  /**
   * Whether graph was created with 'directed' flag set to true or not.
   */
  isDirected() {
    return this._isDirected;
  }
  /**
   * Whether graph was created with 'multigraph' flag set to true or not.
   */
  isMultigraph() {
    return this._isMultigraph;
  }
  /**
   * Whether graph was created with 'compound' flag set to true or not.
   */
  isCompound() {
    return this._isCompound;
  }
  /**
   * Sets the label of the graph.
   */
  setGraph(label2) {
    return this._label = label2, this;
  }
  /**
   * Gets the graph label.
   */
  graph() {
    return this._label;
  }
  /* === Node functions ========== */
  /**
   * Sets the default node label. If newDefault is a function, it will be
   * invoked ach time when setting a label for a node. Otherwise, this label
   * will be assigned as default label in case if no label was specified while
   * setting a node.
   * Complexity: O(1).
   */
  setDefaultNodeLabel(newDefault) {
    return this._defaultNodeLabelFn = newDefault, typeof newDefault != "function" && (this._defaultNodeLabelFn = () => newDefault), this;
  }
  /**
   * Gets the number of nodes in the graph.
   * Complexity: O(1).
   */
  nodeCount() {
    return this._nodeCount;
  }
  /**
   * Gets all nodes of the graph. Note, the in case of compound graph subnodes are
   * not included in list.
   * Complexity: O(1).
   */
  nodes() {
    return Object.keys(this._nodes);
  }
  /**
   * Gets list of nodes without in-edges.
   * Complexity: O(|V|).
   */
  sources() {
    var self2 = this;
    return this.nodes().filter((v2) => Object.keys(self2._in[v2]).length === 0);
  }
  /**
   * Gets list of nodes without out-edges.
   * Complexity: O(|V|).
   */
  sinks() {
    var self2 = this;
    return this.nodes().filter((v2) => Object.keys(self2._out[v2]).length === 0);
  }
  /**
   * Invokes setNode method for each node in names list.
   * Complexity: O(|names|).
   */
  setNodes(vs, value) {
    var args = arguments, self2 = this;
    return vs.forEach(function(v2) {
      args.length > 1 ? self2.setNode(v2, value) : self2.setNode(v2);
    }), this;
  }
  /**
   * Creates or updates the value for the node v in the graph. If label is supplied
   * it is set as the value for the node. If label is not supplied and the node was
   * created by this call then the default node label will be assigned.
   * Complexity: O(1).
   */
  setNode(v2, value) {
    return Object.hasOwn(this._nodes, v2) ? (arguments.length > 1 && (this._nodes[v2] = value), this) : (this._nodes[v2] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v2), this._isCompound && (this._parent[v2] = GRAPH_NODE, this._children[v2] = {}, this._children[GRAPH_NODE][v2] = !0), this._in[v2] = {}, this._preds[v2] = {}, this._out[v2] = {}, this._sucs[v2] = {}, ++this._nodeCount, this);
  }
  /**
   * Gets the label of node with specified name.
   * Complexity: O(|V|).
   */
  node(v2) {
    return this._nodes[v2];
  }
  /**
   * Detects whether graph has a node with specified name or not.
   */
  hasNode(v2) {
    return Object.hasOwn(this._nodes, v2);
  }
  /**
   * Remove the node with the name from the graph or do nothing if the node is not in
   * the graph. If the node was removed this function also removes any incident
   * edges.
   * Complexity: O(1).
   */
  removeNode(v2) {
    var self2 = this;
    if (Object.hasOwn(this._nodes, v2)) {
      var removeEdge = (e2) => self2.removeEdge(self2._edgeObjs[e2]);
      delete this._nodes[v2], this._isCompound && (this._removeFromParentsChildList(v2), delete this._parent[v2], this.children(v2).forEach(function(child) {
        self2.setParent(child);
      }), delete this._children[v2]), Object.keys(this._in[v2]).forEach(removeEdge), delete this._in[v2], delete this._preds[v2], Object.keys(this._out[v2]).forEach(removeEdge), delete this._out[v2], delete this._sucs[v2], --this._nodeCount;
    }
    return this;
  }
  /**
   * Sets node p as a parent for node v if it is defined, or removes the
   * parent for v if p is undefined. Method throws an exception in case of
   * invoking it in context of noncompound graph.
   * Average-case complexity: O(1).
   */
  setParent(v2, parent) {
    if (!this._isCompound)
      throw new Error("Cannot set parent in a non-compound graph");
    if (parent === void 0)
      parent = GRAPH_NODE;
    else {
      parent += "";
      for (var ancestor = parent; ancestor !== void 0; ancestor = this.parent(ancestor))
        if (ancestor === v2)
          throw new Error("Setting " + parent + " as parent of " + v2 + " would create a cycle");
      this.setNode(parent);
    }
    return this.setNode(v2), this._removeFromParentsChildList(v2), this._parent[v2] = parent, this._children[parent][v2] = !0, this;
  }
  _removeFromParentsChildList(v2) {
    delete this._children[this._parent[v2]][v2];
  }
  /**
   * Gets parent node for node v.
   * Complexity: O(1).
   */
  parent(v2) {
    if (this._isCompound) {
      var parent = this._parent[v2];
      if (parent !== GRAPH_NODE)
        return parent;
    }
  }
  /**
   * Gets list of direct children of node v.
   * Complexity: O(1).
   */
  children(v2 = GRAPH_NODE) {
    if (this._isCompound) {
      var children2 = this._children[v2];
      if (children2)
        return Object.keys(children2);
    } else {
      if (v2 === GRAPH_NODE)
        return this.nodes();
      if (this.hasNode(v2))
        return [];
    }
  }
  /**
   * Return all nodes that are predecessors of the specified node or undefined if node v is not in
   * the graph. Behavior is undefined for undirected graphs - use neighbors instead.
   * Complexity: O(|V|).
   */
  predecessors(v2) {
    var predsV = this._preds[v2];
    if (predsV)
      return Object.keys(predsV);
  }
  /**
   * Return all nodes that are successors of the specified node or undefined if node v is not in
   * the graph. Behavior is undefined for undirected graphs - use neighbors instead.
   * Complexity: O(|V|).
   */
  successors(v2) {
    var sucsV = this._sucs[v2];
    if (sucsV)
      return Object.keys(sucsV);
  }
  /**
   * Return all nodes that are predecessors or successors of the specified node or undefined if
   * node v is not in the graph.
   * Complexity: O(|V|).
   */
  neighbors(v2) {
    var preds = this.predecessors(v2);
    if (preds) {
      const union = new Set(preds);
      for (var succ of this.successors(v2))
        union.add(succ);
      return Array.from(union.values());
    }
  }
  isLeaf(v2) {
    var neighbors;
    return this.isDirected() ? neighbors = this.successors(v2) : neighbors = this.neighbors(v2), neighbors.length === 0;
  }
  /**
   * Creates new graph with nodes filtered via filter. Edges incident to rejected node
   * are also removed. In case of compound graph, if parent is rejected by filter,
   * than all its children are rejected too.
   * Average-case complexity: O(|E|+|V|).
   */
  filterNodes(filter2) {
    var copy = new this.constructor({
      directed: this._isDirected,
      multigraph: this._isMultigraph,
      compound: this._isCompound
    });
    copy.setGraph(this.graph());
    var self2 = this;
    Object.entries(this._nodes).forEach(function([v2, value]) {
      filter2(v2) && copy.setNode(v2, value);
    }), Object.values(this._edgeObjs).forEach(function(e2) {
      copy.hasNode(e2.v) && copy.hasNode(e2.w) && copy.setEdge(e2, self2.edge(e2));
    });
    var parents = {};
    function findParent(v2) {
      var parent = self2.parent(v2);
      return parent === void 0 || copy.hasNode(parent) ? (parents[v2] = parent, parent) : parent in parents ? parents[parent] : findParent(parent);
    }
    return this._isCompound && copy.nodes().forEach((v2) => copy.setParent(v2, findParent(v2))), copy;
  }
  /* === Edge functions ========== */
  /**
   * Sets the default edge label or factory function. This label will be
   * assigned as default label in case if no label was specified while setting
   * an edge or this function will be invoked each time when setting an edge
   * with no label specified and returned value * will be used as a label for edge.
   * Complexity: O(1).
   */
  setDefaultEdgeLabel(newDefault) {
    return this._defaultEdgeLabelFn = newDefault, typeof newDefault != "function" && (this._defaultEdgeLabelFn = () => newDefault), this;
  }
  /**
   * Gets the number of edges in the graph.
   * Complexity: O(1).
   */
  edgeCount() {
    return this._edgeCount;
  }
  /**
   * Gets edges of the graph. In case of compound graph subgraphs are not considered.
   * Complexity: O(|E|).
   */
  edges() {
    return Object.values(this._edgeObjs);
  }
  /**
   * Establish an edges path over the nodes in nodes list. If some edge is already
   * exists, it will update its label, otherwise it will create an edge between pair
   * of nodes with label provided or default label if no label provided.
   * Complexity: O(|nodes|).
   */
  setPath(vs, value) {
    var self2 = this, args = arguments;
    return vs.reduce(function(v2, w2) {
      return args.length > 1 ? self2.setEdge(v2, w2, value) : self2.setEdge(v2, w2), w2;
    }), this;
  }
  /**
   * Creates or updates the label for the edge (v, w) with the optionally supplied
   * name. If label is supplied it is set as the value for the edge. If label is not
   * supplied and the edge was created by this call then the default edge label will
   * be assigned. The name parameter is only useful with multigraphs.
   */
  setEdge() {
    var v2, w2, name, value, valueSpecified = !1, arg0 = arguments[0];
    typeof arg0 == "object" && arg0 !== null && "v" in arg0 ? (v2 = arg0.v, w2 = arg0.w, name = arg0.name, arguments.length === 2 && (value = arguments[1], valueSpecified = !0)) : (v2 = arg0, w2 = arguments[1], name = arguments[3], arguments.length > 2 && (value = arguments[2], valueSpecified = !0)), v2 = "" + v2, w2 = "" + w2, name !== void 0 && (name = "" + name);
    var e2 = edgeArgsToId(this._isDirected, v2, w2, name);
    if (Object.hasOwn(this._edgeLabels, e2))
      return valueSpecified && (this._edgeLabels[e2] = value), this;
    if (name !== void 0 && !this._isMultigraph)
      throw new Error("Cannot set a named edge when isMultigraph = false");
    this.setNode(v2), this.setNode(w2), this._edgeLabels[e2] = valueSpecified ? value : this._defaultEdgeLabelFn(v2, w2, name);
    var edgeObj = edgeArgsToObj(this._isDirected, v2, w2, name);
    return v2 = edgeObj.v, w2 = edgeObj.w, Object.freeze(edgeObj), this._edgeObjs[e2] = edgeObj, incrementOrInitEntry(this._preds[w2], v2), incrementOrInitEntry(this._sucs[v2], w2), this._in[w2][e2] = edgeObj, this._out[v2][e2] = edgeObj, this._edgeCount++, this;
  }
  /**
   * Gets the label for the specified edge.
   * Complexity: O(1).
   */
  edge(v2, w2, name) {
    var e2 = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v2, w2, name);
    return this._edgeLabels[e2];
  }
  /**
   * Gets the label for the specified edge and converts it to an object.
   * Complexity: O(1)
   */
  edgeAsObj() {
    const edge = this.edge(...arguments);
    return typeof edge != "object" ? { label: edge } : edge;
  }
  /**
   * Detects whether the graph contains specified edge or not. No subgraphs are considered.
   * Complexity: O(1).
   */
  hasEdge(v2, w2, name) {
    var e2 = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v2, w2, name);
    return Object.hasOwn(this._edgeLabels, e2);
  }
  /**
   * Removes the specified edge from the graph. No subgraphs are considered.
   * Complexity: O(1).
   */
  removeEdge(v2, w2, name) {
    var e2 = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v2, w2, name), edge = this._edgeObjs[e2];
    return edge && (v2 = edge.v, w2 = edge.w, delete this._edgeLabels[e2], delete this._edgeObjs[e2], decrementOrRemoveEntry(this._preds[w2], v2), decrementOrRemoveEntry(this._sucs[v2], w2), delete this._in[w2][e2], delete this._out[v2][e2], this._edgeCount--), this;
  }
  /**
   * Return all edges that point to the node v. Optionally filters those edges down to just those
   * coming from node u. Behavior is undefined for undirected graphs - use nodeEdges instead.
   * Complexity: O(|E|).
   */
  inEdges(v2, u2) {
    var inV = this._in[v2];
    if (inV) {
      var edges = Object.values(inV);
      return u2 ? edges.filter((edge) => edge.v === u2) : edges;
    }
  }
  /**
   * Return all edges that are pointed at by node v. Optionally filters those edges down to just
   * those point to w. Behavior is undefined for undirected graphs - use nodeEdges instead.
   * Complexity: O(|E|).
   */
  outEdges(v2, w2) {
    var outV = this._out[v2];
    if (outV) {
      var edges = Object.values(outV);
      return w2 ? edges.filter((edge) => edge.w === w2) : edges;
    }
  }
  /**
   * Returns all edges to or from node v regardless of direction. Optionally filters those edges
   * down to just those between nodes v and w regardless of direction.
   * Complexity: O(|E|).
   */
  nodeEdges(v2, w2) {
    var inEdges = this.inEdges(v2, w2);
    if (inEdges)
      return inEdges.concat(this.outEdges(v2, w2));
  }
};
function incrementOrInitEntry(map2, k2) {
  map2[k2] ? map2[k2]++ : map2[k2] = 1;
}
function decrementOrRemoveEntry(map2, k2) {
  --map2[k2] || delete map2[k2];
}
function edgeArgsToId(isDirected, v_, w_, name) {
  var v2 = "" + v_, w2 = "" + w_;
  if (!isDirected && v2 > w2) {
    var tmp = v2;
    v2 = w2, w2 = tmp;
  }
  return v2 + EDGE_KEY_DELIM + w2 + EDGE_KEY_DELIM + (name === void 0 ? DEFAULT_EDGE_NAME : name);
}
function edgeArgsToObj(isDirected, v_, w_, name) {
  var v2 = "" + v_, w2 = "" + w_;
  if (!isDirected && v2 > w2) {
    var tmp = v2;
    v2 = w2, w2 = tmp;
  }
  var edgeObj = { v: v2, w: w2 };
  return name && (edgeObj.name = name), edgeObj;
}
function edgeObjToId(isDirected, edgeObj) {
  return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
}
var graph = Graph$a, version$1 = "2.2.4", lib$1 = {
  Graph: graph,
  version: version$1
}, Graph$9 = graph, json = {
  write,
  read
};
function write(g2) {
  var json2 = {
    options: {
      directed: g2.isDirected(),
      multigraph: g2.isMultigraph(),
      compound: g2.isCompound()
    },
    nodes: writeNodes(g2),
    edges: writeEdges(g2)
  };
  return g2.graph() !== void 0 && (json2.value = structuredClone(g2.graph())), json2;
}
function writeNodes(g2) {
  return g2.nodes().map(function(v2) {
    var nodeValue = g2.node(v2), parent = g2.parent(v2), node2 = { v: v2 };
    return nodeValue !== void 0 && (node2.value = nodeValue), parent !== void 0 && (node2.parent = parent), node2;
  });
}
function writeEdges(g2) {
  return g2.edges().map(function(e2) {
    var edgeValue = g2.edge(e2), edge = { v: e2.v, w: e2.w };
    return e2.name !== void 0 && (edge.name = e2.name), edgeValue !== void 0 && (edge.value = edgeValue), edge;
  });
}
function read(json2) {
  var g2 = new Graph$9(json2.options).setGraph(json2.value);
  return json2.nodes.forEach(function(entry) {
    g2.setNode(entry.v, entry.value), entry.parent && g2.setParent(entry.v, entry.parent);
  }), json2.edges.forEach(function(entry) {
    g2.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);
  }), g2;
}
var components_1 = components;
function components(g2) {
  var visited = {}, cmpts = [], cmpt;
  function dfs2(v2) {
    Object.hasOwn(visited, v2) || (visited[v2] = !0, cmpt.push(v2), g2.successors(v2).forEach(dfs2), g2.predecessors(v2).forEach(dfs2));
  }
  return g2.nodes().forEach(function(v2) {
    cmpt = [], dfs2(v2), cmpt.length && cmpts.push(cmpt);
  }), cmpts;
}
let PriorityQueue$2 = class {
  constructor() {
    __publicField(this, "_arr", []);
    __publicField(this, "_keyIndices", {});
  }
  /**
   * Returns the number of elements in the queue. Takes `O(1)` time.
   */
  size() {
    return this._arr.length;
  }
  /**
   * Returns the keys that are in the queue. Takes `O(n)` time.
   */
  keys() {
    return this._arr.map(function(x2) {
      return x2.key;
    });
  }
  /**
   * Returns `true` if **key** is in the queue and `false` if not.
   */
  has(key) {
    return Object.hasOwn(this._keyIndices, key);
  }
  /**
   * Returns the priority for **key**. If **key** is not present in the queue
   * then this function returns `undefined`. Takes `O(1)` time.
   *
   * @param {Object} key
   */
  priority(key) {
    var index2 = this._keyIndices[key];
    if (index2 !== void 0)
      return this._arr[index2].priority;
  }
  /**
   * Returns the key for the minimum element in this queue. If the queue is
   * empty this function throws an Error. Takes `O(1)` time.
   */
  min() {
    if (this.size() === 0)
      throw new Error("Queue underflow");
    return this._arr[0].key;
  }
  /**
   * Inserts a new key into the priority queue. If the key already exists in
   * the queue this function returns `false`; otherwise it will return `true`.
   * Takes `O(n)` time.
   *
   * @param {Object} key the key to add
   * @param {Number} priority the initial priority for the key
   */
  add(key, priority) {
    var keyIndices = this._keyIndices;
    if (key = String(key), !Object.hasOwn(keyIndices, key)) {
      var arr = this._arr, index2 = arr.length;
      return keyIndices[key] = index2, arr.push({ key, priority }), this._decrease(index2), !0;
    }
    return !1;
  }
  /**
   * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
   */
  removeMin() {
    this._swap(0, this._arr.length - 1);
    var min2 = this._arr.pop();
    return delete this._keyIndices[min2.key], this._heapify(0), min2.key;
  }
  /**
   * Decreases the priority for **key** to **priority**. If the new priority is
   * greater than the previous priority, this function will throw an Error.
   *
   * @param {Object} key the key for which to raise priority
   * @param {Number} priority the new priority for the key
   */
  decrease(key, priority) {
    var index2 = this._keyIndices[key];
    if (priority > this._arr[index2].priority)
      throw new Error("New priority is greater than current priority. Key: " + key + " Old: " + this._arr[index2].priority + " New: " + priority);
    this._arr[index2].priority = priority, this._decrease(index2);
  }
  _heapify(i2) {
    var arr = this._arr, l2 = 2 * i2, r2 = l2 + 1, largest = i2;
    l2 < arr.length && (largest = arr[l2].priority < arr[largest].priority ? l2 : largest, r2 < arr.length && (largest = arr[r2].priority < arr[largest].priority ? r2 : largest), largest !== i2 && (this._swap(i2, largest), this._heapify(largest)));
  }
  _decrease(index2) {
    for (var arr = this._arr, priority = arr[index2].priority, parent; index2 !== 0 && (parent = index2 >> 1, !(arr[parent].priority < priority)); )
      this._swap(index2, parent), index2 = parent;
  }
  _swap(i2, j2) {
    var arr = this._arr, keyIndices = this._keyIndices, origArrI = arr[i2], origArrJ = arr[j2];
    arr[i2] = origArrJ, arr[j2] = origArrI, keyIndices[origArrJ.key] = i2, keyIndices[origArrI.key] = j2;
  }
};
var priorityQueue = PriorityQueue$2, PriorityQueue$1 = priorityQueue, dijkstra_1 = dijkstra$1, DEFAULT_WEIGHT_FUNC$1 = () => 1;
function dijkstra$1(g2, source, weightFn, edgeFn) {
  return runDijkstra(
    g2,
    String(source),
    weightFn || DEFAULT_WEIGHT_FUNC$1,
    edgeFn || function(v2) {
      return g2.outEdges(v2);
    }
  );
}
function runDijkstra(g2, source, weightFn, edgeFn) {
  var results = {}, pq = new PriorityQueue$1(), v2, vEntry, updateNeighbors = function(edge) {
    var w2 = edge.v !== v2 ? edge.v : edge.w, wEntry = results[w2], weight = weightFn(edge), distance2 = vEntry.distance + weight;
    if (weight < 0)
      throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + edge + " Weight: " + weight);
    distance2 < wEntry.distance && (wEntry.distance = distance2, wEntry.predecessor = v2, pq.decrease(w2, distance2));
  };
  for (g2.nodes().forEach(function(v3) {
    var distance2 = v3 === source ? 0 : Number.POSITIVE_INFINITY;
    results[v3] = { distance: distance2 }, pq.add(v3, distance2);
  }); pq.size() > 0 && (v2 = pq.removeMin(), vEntry = results[v2], vEntry.distance !== Number.POSITIVE_INFINITY); )
    edgeFn(v2).forEach(updateNeighbors);
  return results;
}
var dijkstra = dijkstra_1, dijkstraAll_1 = dijkstraAll;
function dijkstraAll(g2, weightFunc, edgeFunc) {
  return g2.nodes().reduce(function(acc, v2) {
    return acc[v2] = dijkstra(g2, v2, weightFunc, edgeFunc), acc;
  }, {});
}
var tarjan_1 = tarjan$1;
function tarjan$1(g2) {
  var index2 = 0, stack = [], visited = {}, results = [];
  function dfs2(v2) {
    var entry = visited[v2] = {
      onStack: !0,
      lowlink: index2,
      index: index2++
    };
    if (stack.push(v2), g2.successors(v2).forEach(function(w3) {
      Object.hasOwn(visited, w3) ? visited[w3].onStack && (entry.lowlink = Math.min(entry.lowlink, visited[w3].index)) : (dfs2(w3), entry.lowlink = Math.min(entry.lowlink, visited[w3].lowlink));
    }), entry.lowlink === entry.index) {
      var cmpt = [], w2;
      do
        w2 = stack.pop(), visited[w2].onStack = !1, cmpt.push(w2);
      while (v2 !== w2);
      results.push(cmpt);
    }
  }
  return g2.nodes().forEach(function(v2) {
    Object.hasOwn(visited, v2) || dfs2(v2);
  }), results;
}
var tarjan = tarjan_1, findCycles_1 = findCycles;
function findCycles(g2) {
  return tarjan(g2).filter(function(cmpt) {
    return cmpt.length > 1 || cmpt.length === 1 && g2.hasEdge(cmpt[0], cmpt[0]);
  });
}
var floydWarshall_1 = floydWarshall, DEFAULT_WEIGHT_FUNC = () => 1;
function floydWarshall(g2, weightFn, edgeFn) {
  return runFloydWarshall(
    g2,
    weightFn || DEFAULT_WEIGHT_FUNC,
    edgeFn || function(v2) {
      return g2.outEdges(v2);
    }
  );
}
function runFloydWarshall(g2, weightFn, edgeFn) {
  var results = {}, nodes = g2.nodes();
  return nodes.forEach(function(v2) {
    results[v2] = {}, results[v2][v2] = { distance: 0 }, nodes.forEach(function(w2) {
      v2 !== w2 && (results[v2][w2] = { distance: Number.POSITIVE_INFINITY });
    }), edgeFn(v2).forEach(function(edge) {
      var w2 = edge.v === v2 ? edge.w : edge.v, d2 = weightFn(edge);
      results[v2][w2] = { distance: d2, predecessor: v2 };
    });
  }), nodes.forEach(function(k2) {
    var rowK = results[k2];
    nodes.forEach(function(i2) {
      var rowI = results[i2];
      nodes.forEach(function(j2) {
        var ik = rowI[k2], kj = rowK[j2], ij = rowI[j2], altDistance = ik.distance + kj.distance;
        altDistance < ij.distance && (ij.distance = altDistance, ij.predecessor = kj.predecessor);
      });
    });
  }), results;
}
function topsort$1(g2) {
  var visited = {}, stack = {}, results = [];
  function visit(node2) {
    if (Object.hasOwn(stack, node2))
      throw new CycleException();
    Object.hasOwn(visited, node2) || (stack[node2] = !0, visited[node2] = !0, g2.predecessors(node2).forEach(visit), delete stack[node2], results.push(node2));
  }
  if (g2.sinks().forEach(visit), Object.keys(visited).length !== g2.nodeCount())
    throw new CycleException();
  return results;
}
class CycleException extends Error {
  constructor() {
    super(...arguments);
  }
}
var topsort_1 = topsort$1;
topsort$1.CycleException = CycleException;
var topsort = topsort_1, isAcyclic_1 = isAcyclic;
function isAcyclic(g2) {
  try {
    topsort(g2);
  } catch (e2) {
    if (e2 instanceof topsort.CycleException)
      return !1;
    throw e2;
  }
  return !0;
}
var dfs_1 = dfs$3;
function dfs$3(g2, vs, order2) {
  Array.isArray(vs) || (vs = [vs]);
  var navigation = g2.isDirected() ? (v2) => g2.successors(v2) : (v2) => g2.neighbors(v2), orderFunc = order2 === "post" ? postOrderDfs : preOrderDfs, acc = [], visited = {};
  return vs.forEach((v2) => {
    if (!g2.hasNode(v2))
      throw new Error("Graph does not have node: " + v2);
    orderFunc(v2, navigation, visited, acc);
  }), acc;
}
function postOrderDfs(v2, navigation, visited, acc) {
  for (var stack = [[v2, !1]]; stack.length > 0; ) {
    var curr = stack.pop();
    curr[1] ? acc.push(curr[0]) : Object.hasOwn(visited, curr[0]) || (visited[curr[0]] = !0, stack.push([curr[0], !0]), forEachRight(navigation(curr[0]), (w2) => stack.push([w2, !1])));
  }
}
function preOrderDfs(v2, navigation, visited, acc) {
  for (var stack = [v2]; stack.length > 0; ) {
    var curr = stack.pop();
    Object.hasOwn(visited, curr) || (visited[curr] = !0, acc.push(curr), forEachRight(navigation(curr), (w2) => stack.push(w2)));
  }
}
function forEachRight(array2, iteratee) {
  for (var length = array2.length; length--; )
    iteratee(array2[length], length, array2);
  return array2;
}
var dfs$2 = dfs_1, postorder_1 = postorder$2;
function postorder$2(g2, vs) {
  return dfs$2(g2, vs, "post");
}
var dfs$1 = dfs_1, preorder_1 = preorder$1;
function preorder$1(g2, vs) {
  return dfs$1(g2, vs, "pre");
}
var Graph$8 = graph, PriorityQueue2 = priorityQueue, prim_1 = prim;
function prim(g2, weightFunc) {
  var result = new Graph$8(), parents = {}, pq = new PriorityQueue2(), v2;
  function updateNeighbors(edge) {
    var w2 = edge.v === v2 ? edge.w : edge.v, pri = pq.priority(w2);
    if (pri !== void 0) {
      var edgeWeight = weightFunc(edge);
      edgeWeight < pri && (parents[w2] = v2, pq.decrease(w2, edgeWeight));
    }
  }
  if (g2.nodeCount() === 0)
    return result;
  g2.nodes().forEach(function(v3) {
    pq.add(v3, Number.POSITIVE_INFINITY), result.setNode(v3);
  }), pq.decrease(g2.nodes()[0], 0);
  for (var init2 = !1; pq.size() > 0; ) {
    if (v2 = pq.removeMin(), Object.hasOwn(parents, v2))
      result.setEdge(v2, parents[v2]);
    else {
      if (init2)
        throw new Error("Input graph is not connected: " + g2);
      init2 = !0;
    }
    g2.nodeEdges(v2).forEach(updateNeighbors);
  }
  return result;
}
var alg = {
  components: components_1,
  dijkstra: dijkstra_1,
  dijkstraAll: dijkstraAll_1,
  findCycles: findCycles_1,
  floydWarshall: floydWarshall_1,
  isAcyclic: isAcyclic_1,
  postorder: postorder_1,
  preorder: preorder_1,
  prim: prim_1,
  tarjan: tarjan_1,
  topsort: topsort_1
}, lib = lib$1, graphlib = {
  Graph: lib.Graph,
  json,
  alg,
  version: lib.version
};
let List$1 = class {
  constructor() {
    let sentinel = {};
    sentinel._next = sentinel._prev = sentinel, this._sentinel = sentinel;
  }
  dequeue() {
    let sentinel = this._sentinel, entry = sentinel._prev;
    if (entry !== sentinel)
      return unlink(entry), entry;
  }
  enqueue(entry) {
    let sentinel = this._sentinel;
    entry._prev && entry._next && unlink(entry), entry._next = sentinel._next, sentinel._next._prev = entry, sentinel._next = entry, entry._prev = sentinel;
  }
  toString() {
    let strs = [], sentinel = this._sentinel, curr = sentinel._prev;
    for (; curr !== sentinel; )
      strs.push(JSON.stringify(curr, filterOutLinks)), curr = curr._prev;
    return "[" + strs.join(", ") + "]";
  }
};
function unlink(entry) {
  entry._prev._next = entry._next, entry._next._prev = entry._prev, delete entry._next, delete entry._prev;
}
function filterOutLinks(k2, v2) {
  if (k2 !== "_next" && k2 !== "_prev")
    return v2;
}
var list = List$1;
let Graph$7 = graphlib.Graph, List2 = list;
var greedyFas = greedyFAS$1;
let DEFAULT_WEIGHT_FN = () => 1;
function greedyFAS$1(g2, weightFn) {
  if (g2.nodeCount() <= 1)
    return [];
  let state = buildState(g2, weightFn || DEFAULT_WEIGHT_FN);
  return doGreedyFAS(state.graph, state.buckets, state.zeroIdx).flatMap((e2) => g2.outEdges(e2.v, e2.w));
}
function doGreedyFAS(g2, buckets, zeroIdx) {
  let results = [], sources = buckets[buckets.length - 1], sinks = buckets[0], entry;
  for (; g2.nodeCount(); ) {
    for (; entry = sinks.dequeue(); )
      removeNode(g2, buckets, zeroIdx, entry);
    for (; entry = sources.dequeue(); )
      removeNode(g2, buckets, zeroIdx, entry);
    if (g2.nodeCount()) {
      for (let i2 = buckets.length - 2; i2 > 0; --i2)
        if (entry = buckets[i2].dequeue(), entry) {
          results = results.concat(removeNode(g2, buckets, zeroIdx, entry, !0));
          break;
        }
    }
  }
  return results;
}
function removeNode(g2, buckets, zeroIdx, entry, collectPredecessors) {
  let results = collectPredecessors ? [] : void 0;
  return g2.inEdges(entry.v).forEach((edge) => {
    let weight = g2.edge(edge), uEntry = g2.node(edge.v);
    collectPredecessors && results.push({ v: edge.v, w: edge.w }), uEntry.out -= weight, assignBucket(buckets, zeroIdx, uEntry);
  }), g2.outEdges(entry.v).forEach((edge) => {
    let weight = g2.edge(edge), w2 = edge.w, wEntry = g2.node(w2);
    wEntry.in -= weight, assignBucket(buckets, zeroIdx, wEntry);
  }), g2.removeNode(entry.v), results;
}
function buildState(g2, weightFn) {
  let fasGraph = new Graph$7(), maxIn = 0, maxOut = 0;
  g2.nodes().forEach((v2) => {
    fasGraph.setNode(v2, { v: v2, in: 0, out: 0 });
  }), g2.edges().forEach((e2) => {
    let prevWeight = fasGraph.edge(e2.v, e2.w) || 0, weight = weightFn(e2), edgeWeight = prevWeight + weight;
    fasGraph.setEdge(e2.v, e2.w, edgeWeight), maxOut = Math.max(maxOut, fasGraph.node(e2.v).out += weight), maxIn = Math.max(maxIn, fasGraph.node(e2.w).in += weight);
  });
  let buckets = range$1(maxOut + maxIn + 3).map(() => new List2()), zeroIdx = maxIn + 1;
  return fasGraph.nodes().forEach((v2) => {
    assignBucket(buckets, zeroIdx, fasGraph.node(v2));
  }), { graph: fasGraph, buckets, zeroIdx };
}
function assignBucket(buckets, zeroIdx, entry) {
  entry.out ? entry.in ? buckets[entry.out - entry.in + zeroIdx].enqueue(entry) : buckets[buckets.length - 1].enqueue(entry) : buckets[0].enqueue(entry);
}
function range$1(limit) {
  const range2 = [];
  for (let i2 = 0; i2 < limit; i2++)
    range2.push(i2);
  return range2;
}
let Graph$6 = graphlib.Graph;
var util$d = {
  addBorderNode: addBorderNode$1,
  addDummyNode,
  applyWithChunking: applyWithChunking$1,
  asNonCompoundGraph,
  buildLayerMatrix,
  intersectRect,
  mapValues,
  maxRank,
  normalizeRanks: normalizeRanks$1,
  notime,
  partition,
  pick,
  predecessorWeights,
  range,
  removeEmptyRanks: removeEmptyRanks$1,
  simplify: simplify$1,
  successorWeights,
  time,
  uniqueId: uniqueId$1,
  zipObject: zipObject$1
};
function addDummyNode(g2, type, attrs, name) {
  let v2;
  do
    v2 = uniqueId$1(name);
  while (g2.hasNode(v2));
  return attrs.dummy = type, g2.setNode(v2, attrs), v2;
}
function simplify$1(g2) {
  let simplified = new Graph$6().setGraph(g2.graph());
  return g2.nodes().forEach((v2) => simplified.setNode(v2, g2.node(v2))), g2.edges().forEach((e2) => {
    let simpleLabel = simplified.edge(e2.v, e2.w) || { weight: 0, minlen: 1 }, label2 = g2.edge(e2);
    simplified.setEdge(e2.v, e2.w, {
      weight: simpleLabel.weight + label2.weight,
      minlen: Math.max(simpleLabel.minlen, label2.minlen)
    });
  }), simplified;
}
function asNonCompoundGraph(g2) {
  let simplified = new Graph$6({ multigraph: g2.isMultigraph() }).setGraph(g2.graph());
  return g2.nodes().forEach((v2) => {
    g2.children(v2).length || simplified.setNode(v2, g2.node(v2));
  }), g2.edges().forEach((e2) => {
    simplified.setEdge(e2, g2.edge(e2));
  }), simplified;
}
function successorWeights(g2) {
  let weightMap = g2.nodes().map((v2) => {
    let sucs = {};
    return g2.outEdges(v2).forEach((e2) => {
      sucs[e2.w] = (sucs[e2.w] || 0) + g2.edge(e2).weight;
    }), sucs;
  });
  return zipObject$1(g2.nodes(), weightMap);
}
function predecessorWeights(g2) {
  let weightMap = g2.nodes().map((v2) => {
    let preds = {};
    return g2.inEdges(v2).forEach((e2) => {
      preds[e2.v] = (preds[e2.v] || 0) + g2.edge(e2).weight;
    }), preds;
  });
  return zipObject$1(g2.nodes(), weightMap);
}
function intersectRect(rect, point2) {
  let x2 = rect.x, y2 = rect.y, dx = point2.x - x2, dy = point2.y - y2, w2 = rect.width / 2, h2 = rect.height / 2;
  if (!dx && !dy)
    throw new Error("Not possible to find intersection inside of the rectangle");
  let sx, sy;
  return Math.abs(dy) * w2 > Math.abs(dx) * h2 ? (dy < 0 && (h2 = -h2), sx = h2 * dx / dy, sy = h2) : (dx < 0 && (w2 = -w2), sx = w2, sy = w2 * dy / dx), { x: x2 + sx, y: y2 + sy };
}
function buildLayerMatrix(g2) {
  let layering = range(maxRank(g2) + 1).map(() => []);
  return g2.nodes().forEach((v2) => {
    let node2 = g2.node(v2), rank2 = node2.rank;
    rank2 !== void 0 && (layering[rank2][node2.order] = v2);
  }), layering;
}
function normalizeRanks$1(g2) {
  let nodeRanks = g2.nodes().map((v2) => {
    let rank2 = g2.node(v2).rank;
    return rank2 === void 0 ? Number.MAX_VALUE : rank2;
  }), min2 = applyWithChunking$1(Math.min, nodeRanks);
  g2.nodes().forEach((v2) => {
    let node2 = g2.node(v2);
    Object.hasOwn(node2, "rank") && (node2.rank -= min2);
  });
}
function removeEmptyRanks$1(g2) {
  let nodeRanks = g2.nodes().map((v2) => g2.node(v2).rank), offset2 = applyWithChunking$1(Math.min, nodeRanks), layers = [];
  g2.nodes().forEach((v2) => {
    let rank2 = g2.node(v2).rank - offset2;
    layers[rank2] || (layers[rank2] = []), layers[rank2].push(v2);
  });
  let delta = 0, nodeRankFactor = g2.graph().nodeRankFactor;
  Array.from(layers).forEach((vs, i2) => {
    vs === void 0 && i2 % nodeRankFactor !== 0 ? --delta : vs !== void 0 && delta && vs.forEach((v2) => g2.node(v2).rank += delta);
  });
}
function addBorderNode$1(g2, prefix, rank2, order2) {
  let node2 = {
    width: 0,
    height: 0
  };
  return arguments.length >= 4 && (node2.rank = rank2, node2.order = order2), addDummyNode(g2, "border", node2, prefix);
}
function splitToChunks(array2, chunkSize = CHUNKING_THRESHOLD) {
  const chunks = [];
  for (let i2 = 0; i2 < array2.length; i2 += chunkSize) {
    const chunk = array2.slice(i2, i2 + chunkSize);
    chunks.push(chunk);
  }
  return chunks;
}
const CHUNKING_THRESHOLD = 65535;
function applyWithChunking$1(fn, argsArray) {
  if (argsArray.length > CHUNKING_THRESHOLD) {
    const chunks = splitToChunks(argsArray);
    return fn.apply(null, chunks.map((chunk) => fn.apply(null, chunk)));
  } else
    return fn.apply(null, argsArray);
}
function maxRank(g2) {
  const nodeRanks = g2.nodes().map((v2) => {
    let rank2 = g2.node(v2).rank;
    return rank2 === void 0 ? Number.MIN_VALUE : rank2;
  });
  return applyWithChunking$1(Math.max, nodeRanks);
}
function partition(collection, fn) {
  let result = { lhs: [], rhs: [] };
  return collection.forEach((value) => {
    fn(value) ? result.lhs.push(value) : result.rhs.push(value);
  }), result;
}
function time(name, fn) {
  let start2 = Date.now();
  try {
    return fn();
  } finally {
    console.log(name + " time: " + (Date.now() - start2) + "ms");
  }
}
function notime(name, fn) {
  return fn();
}
let idCounter = 0;
function uniqueId$1(prefix) {
  var id2 = ++idCounter;
  return toString(prefix) + id2;
}
function range(start2, limit, step = 1) {
  limit == null && (limit = start2, start2 = 0);
  let endCon = (i2) => i2 < limit;
  step < 0 && (endCon = (i2) => limit < i2);
  const range2 = [];
  for (let i2 = start2; endCon(i2); i2 += step)
    range2.push(i2);
  return range2;
}
function pick(source, keys2) {
  const dest = {};
  for (const key of keys2)
    source[key] !== void 0 && (dest[key] = source[key]);
  return dest;
}
function mapValues(obj, funcOrProp) {
  let func = funcOrProp;
  return typeof funcOrProp == "string" && (func = (val) => val[funcOrProp]), Object.entries(obj).reduce((acc, [k2, v2]) => (acc[k2] = func(v2, k2), acc), {});
}
function zipObject$1(props, values2) {
  return props.reduce((acc, key, i2) => (acc[key] = values2[i2], acc), {});
}
let greedyFAS = greedyFas, uniqueId = util$d.uniqueId;
var acyclic$1 = {
  run: run$2,
  undo: undo$2
};
function run$2(g2) {
  (g2.graph().acyclicer === "greedy" ? greedyFAS(g2, weightFn(g2)) : dfsFAS(g2)).forEach((e2) => {
    let label2 = g2.edge(e2);
    g2.removeEdge(e2), label2.forwardName = e2.name, label2.reversed = !0, g2.setEdge(e2.w, e2.v, label2, uniqueId("rev"));
  });
  function weightFn(g3) {
    return (e2) => g3.edge(e2).weight;
  }
}
function dfsFAS(g2) {
  let fas = [], stack = {}, visited = {};
  function dfs2(v2) {
    Object.hasOwn(visited, v2) || (visited[v2] = !0, stack[v2] = !0, g2.outEdges(v2).forEach((e2) => {
      Object.hasOwn(stack, e2.w) ? fas.push(e2) : dfs2(e2.w);
    }), delete stack[v2]);
  }
  return g2.nodes().forEach(dfs2), fas;
}
function undo$2(g2) {
  g2.edges().forEach((e2) => {
    let label2 = g2.edge(e2);
    if (label2.reversed) {
      g2.removeEdge(e2);
      let forwardName = label2.forwardName;
      delete label2.reversed, delete label2.forwardName, g2.setEdge(e2.w, e2.v, label2, forwardName);
    }
  });
}
let util$c = util$d;
var normalize$1 = {
  run: run$1,
  undo: undo$1
};
function run$1(g2) {
  g2.graph().dummyChains = [], g2.edges().forEach((edge) => normalizeEdge(g2, edge));
}
function normalizeEdge(g2, e2) {
  let v2 = e2.v, vRank = g2.node(v2).rank, w2 = e2.w, wRank = g2.node(w2).rank, name = e2.name, edgeLabel2 = g2.edge(e2), labelRank = edgeLabel2.labelRank;
  if (wRank === vRank + 1) return;
  g2.removeEdge(e2);
  let dummy, attrs, i2;
  for (i2 = 0, ++vRank; vRank < wRank; ++i2, ++vRank)
    edgeLabel2.points = [], attrs = {
      width: 0,
      height: 0,
      edgeLabel: edgeLabel2,
      edgeObj: e2,
      rank: vRank
    }, dummy = util$c.addDummyNode(g2, "edge", attrs, "_d"), vRank === labelRank && (attrs.width = edgeLabel2.width, attrs.height = edgeLabel2.height, attrs.dummy = "edge-label", attrs.labelpos = edgeLabel2.labelpos), g2.setEdge(v2, dummy, { weight: edgeLabel2.weight }, name), i2 === 0 && g2.graph().dummyChains.push(dummy), v2 = dummy;
  g2.setEdge(v2, w2, { weight: edgeLabel2.weight }, name);
}
function undo$1(g2) {
  g2.graph().dummyChains.forEach((v2) => {
    let node2 = g2.node(v2), origLabel = node2.edgeLabel, w2;
    for (g2.setEdge(node2.edgeObj, origLabel); node2.dummy; )
      w2 = g2.successors(v2)[0], g2.removeNode(v2), origLabel.points.push({ x: node2.x, y: node2.y }), node2.dummy === "edge-label" && (origLabel.x = node2.x, origLabel.y = node2.y, origLabel.width = node2.width, origLabel.height = node2.height), v2 = w2, node2 = g2.node(v2);
  });
}
const { applyWithChunking } = util$d;
var util$b = {
  longestPath: longestPath$1,
  slack: slack$2
};
function longestPath$1(g2) {
  var visited = {};
  function dfs2(v2) {
    var label2 = g2.node(v2);
    if (Object.hasOwn(visited, v2))
      return label2.rank;
    visited[v2] = !0;
    let outEdgesMinLens = g2.outEdges(v2).map((e2) => e2 == null ? Number.POSITIVE_INFINITY : dfs2(e2.w) - g2.edge(e2).minlen);
    var rank2 = applyWithChunking(Math.min, outEdgesMinLens);
    return rank2 === Number.POSITIVE_INFINITY && (rank2 = 0), label2.rank = rank2;
  }
  g2.sources().forEach(dfs2);
}
function slack$2(g2, e2) {
  return g2.node(e2.w).rank - g2.node(e2.v).rank - g2.edge(e2).minlen;
}
var Graph$5 = graphlib.Graph, slack$1 = util$b.slack, feasibleTree_1 = feasibleTree$2;
function feasibleTree$2(g2) {
  var t2 = new Graph$5({ directed: !1 }), start2 = g2.nodes()[0], size2 = g2.nodeCount();
  t2.setNode(start2, {});
  for (var edge, delta; tightTree(t2, g2) < size2; )
    edge = findMinSlackEdge(t2, g2), delta = t2.hasNode(edge.v) ? slack$1(g2, edge) : -slack$1(g2, edge), shiftRanks(t2, g2, delta);
  return t2;
}
function tightTree(t2, g2) {
  function dfs2(v2) {
    g2.nodeEdges(v2).forEach((e2) => {
      var edgeV = e2.v, w2 = v2 === edgeV ? e2.w : edgeV;
      !t2.hasNode(w2) && !slack$1(g2, e2) && (t2.setNode(w2, {}), t2.setEdge(v2, w2, {}), dfs2(w2));
    });
  }
  return t2.nodes().forEach(dfs2), t2.nodeCount();
}
function findMinSlackEdge(t2, g2) {
  return g2.edges().reduce((acc, edge) => {
    let edgeSlack = Number.POSITIVE_INFINITY;
    return t2.hasNode(edge.v) !== t2.hasNode(edge.w) && (edgeSlack = slack$1(g2, edge)), edgeSlack < acc[0] ? [edgeSlack, edge] : acc;
  }, [Number.POSITIVE_INFINITY, null])[1];
}
function shiftRanks(t2, g2, delta) {
  t2.nodes().forEach((v2) => g2.node(v2).rank += delta);
}
var feasibleTree$1 = feasibleTree_1, slack = util$b.slack, initRank = util$b.longestPath, preorder = graphlib.alg.preorder, postorder$1 = graphlib.alg.postorder, simplify = util$d.simplify, networkSimplex_1 = networkSimplex$1;
networkSimplex$1.initLowLimValues = initLowLimValues;
networkSimplex$1.initCutValues = initCutValues;
networkSimplex$1.calcCutValue = calcCutValue;
networkSimplex$1.leaveEdge = leaveEdge;
networkSimplex$1.enterEdge = enterEdge;
networkSimplex$1.exchangeEdges = exchangeEdges;
function networkSimplex$1(g2) {
  g2 = simplify(g2), initRank(g2);
  var t2 = feasibleTree$1(g2);
  initLowLimValues(t2), initCutValues(t2, g2);
  for (var e2, f2; e2 = leaveEdge(t2); )
    f2 = enterEdge(t2, g2, e2), exchangeEdges(t2, g2, e2, f2);
}
function initCutValues(t2, g2) {
  var vs = postorder$1(t2, t2.nodes());
  vs = vs.slice(0, vs.length - 1), vs.forEach((v2) => assignCutValue(t2, g2, v2));
}
function assignCutValue(t2, g2, child) {
  var childLab = t2.node(child), parent = childLab.parent;
  t2.edge(child, parent).cutvalue = calcCutValue(t2, g2, child);
}
function calcCutValue(t2, g2, child) {
  var childLab = t2.node(child), parent = childLab.parent, childIsTail = !0, graphEdge = g2.edge(child, parent), cutValue = 0;
  return graphEdge || (childIsTail = !1, graphEdge = g2.edge(parent, child)), cutValue = graphEdge.weight, g2.nodeEdges(child).forEach((e2) => {
    var isOutEdge = e2.v === child, other = isOutEdge ? e2.w : e2.v;
    if (other !== parent) {
      var pointsToHead = isOutEdge === childIsTail, otherWeight = g2.edge(e2).weight;
      if (cutValue += pointsToHead ? otherWeight : -otherWeight, isTreeEdge(t2, child, other)) {
        var otherCutValue = t2.edge(child, other).cutvalue;
        cutValue += pointsToHead ? -otherCutValue : otherCutValue;
      }
    }
  }), cutValue;
}
function initLowLimValues(tree, root2) {
  arguments.length < 2 && (root2 = tree.nodes()[0]), dfsAssignLowLim(tree, {}, 1, root2);
}
function dfsAssignLowLim(tree, visited, nextLim, v2, parent) {
  var low = nextLim, label2 = tree.node(v2);
  return visited[v2] = !0, tree.neighbors(v2).forEach((w2) => {
    Object.hasOwn(visited, w2) || (nextLim = dfsAssignLowLim(tree, visited, nextLim, w2, v2));
  }), label2.low = low, label2.lim = nextLim++, parent ? label2.parent = parent : delete label2.parent, nextLim;
}
function leaveEdge(tree) {
  return tree.edges().find((e2) => tree.edge(e2).cutvalue < 0);
}
function enterEdge(t2, g2, edge) {
  var v2 = edge.v, w2 = edge.w;
  g2.hasEdge(v2, w2) || (v2 = edge.w, w2 = edge.v);
  var vLabel = t2.node(v2), wLabel = t2.node(w2), tailLabel = vLabel, flip2 = !1;
  vLabel.lim > wLabel.lim && (tailLabel = wLabel, flip2 = !0);
  var candidates = g2.edges().filter((edge2) => flip2 === isDescendant(t2, t2.node(edge2.v), tailLabel) && flip2 !== isDescendant(t2, t2.node(edge2.w), tailLabel));
  return candidates.reduce((acc, edge2) => slack(g2, edge2) < slack(g2, acc) ? edge2 : acc);
}
function exchangeEdges(t2, g2, e2, f2) {
  var v2 = e2.v, w2 = e2.w;
  t2.removeEdge(v2, w2), t2.setEdge(f2.v, f2.w, {}), initLowLimValues(t2), initCutValues(t2, g2), updateRanks(t2, g2);
}
function updateRanks(t2, g2) {
  var root2 = t2.nodes().find((v2) => !g2.node(v2).parent), vs = preorder(t2, root2);
  vs = vs.slice(1), vs.forEach((v2) => {
    var parent = t2.node(v2).parent, edge = g2.edge(v2, parent), flipped = !1;
    edge || (edge = g2.edge(parent, v2), flipped = !0), g2.node(v2).rank = g2.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
  });
}
function isTreeEdge(tree, u2, v2) {
  return tree.hasEdge(u2, v2);
}
function isDescendant(tree, vLabel, rootLabel) {
  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
}
var rankUtil = util$b, longestPath = rankUtil.longestPath, feasibleTree = feasibleTree_1, networkSimplex = networkSimplex_1, rank_1 = rank$1;
function rank$1(g2) {
  switch (g2.graph().ranker) {
    case "network-simplex":
      networkSimplexRanker(g2);
      break;
    case "tight-tree":
      tightTreeRanker(g2);
      break;
    case "longest-path":
      longestPathRanker(g2);
      break;
    default:
      networkSimplexRanker(g2);
  }
}
var longestPathRanker = longestPath;
function tightTreeRanker(g2) {
  longestPath(g2), feasibleTree(g2);
}
function networkSimplexRanker(g2) {
  networkSimplex(g2);
}
var parentDummyChains_1 = parentDummyChains$1;
function parentDummyChains$1(g2) {
  let postorderNums = postorder(g2);
  g2.graph().dummyChains.forEach((v2) => {
    let node2 = g2.node(v2), edgeObj = node2.edgeObj, pathData = findPath(g2, postorderNums, edgeObj.v, edgeObj.w), path = pathData.path, lca = pathData.lca, pathIdx = 0, pathV = path[pathIdx], ascending2 = !0;
    for (; v2 !== edgeObj.w; ) {
      if (node2 = g2.node(v2), ascending2) {
        for (; (pathV = path[pathIdx]) !== lca && g2.node(pathV).maxRank < node2.rank; )
          pathIdx++;
        pathV === lca && (ascending2 = !1);
      }
      if (!ascending2) {
        for (; pathIdx < path.length - 1 && g2.node(pathV = path[pathIdx + 1]).minRank <= node2.rank; )
          pathIdx++;
        pathV = path[pathIdx];
      }
      g2.setParent(v2, pathV), v2 = g2.successors(v2)[0];
    }
  });
}
function findPath(g2, postorderNums, v2, w2) {
  let vPath = [], wPath = [], low = Math.min(postorderNums[v2].low, postorderNums[w2].low), lim = Math.max(postorderNums[v2].lim, postorderNums[w2].lim), parent, lca;
  parent = v2;
  do
    parent = g2.parent(parent), vPath.push(parent);
  while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
  for (lca = parent, parent = w2; (parent = g2.parent(parent)) !== lca; )
    wPath.push(parent);
  return { path: vPath.concat(wPath.reverse()), lca };
}
function postorder(g2) {
  let result = {}, lim = 0;
  function dfs2(v2) {
    let low = lim;
    g2.children(v2).forEach(dfs2), result[v2] = { low, lim: lim++ };
  }
  return g2.children().forEach(dfs2), result;
}
let util$a = util$d;
var nestingGraph$1 = {
  run,
  cleanup
};
function run(g2) {
  let root2 = util$a.addDummyNode(g2, "root", {}, "_root"), depths = treeDepths(g2), depthsArr = Object.values(depths), height = util$a.applyWithChunking(Math.max, depthsArr) - 1, nodeSep = 2 * height + 1;
  g2.graph().nestingRoot = root2, g2.edges().forEach((e2) => g2.edge(e2).minlen *= nodeSep);
  let weight = sumWeights(g2) + 1;
  g2.children().forEach((child) => dfs(g2, root2, nodeSep, weight, height, depths, child)), g2.graph().nodeRankFactor = nodeSep;
}
function dfs(g2, root2, nodeSep, weight, height, depths, v2) {
  let children2 = g2.children(v2);
  if (!children2.length) {
    v2 !== root2 && g2.setEdge(root2, v2, { weight: 0, minlen: nodeSep });
    return;
  }
  let top = util$a.addBorderNode(g2, "_bt"), bottom = util$a.addBorderNode(g2, "_bb"), label2 = g2.node(v2);
  g2.setParent(top, v2), label2.borderTop = top, g2.setParent(bottom, v2), label2.borderBottom = bottom, children2.forEach((child) => {
    dfs(g2, root2, nodeSep, weight, height, depths, child);
    let childNode = g2.node(child), childTop = childNode.borderTop ? childNode.borderTop : child, childBottom = childNode.borderBottom ? childNode.borderBottom : child, thisWeight = childNode.borderTop ? weight : 2 * weight, minlen = childTop !== childBottom ? 1 : height - depths[v2] + 1;
    g2.setEdge(top, childTop, {
      weight: thisWeight,
      minlen,
      nestingEdge: !0
    }), g2.setEdge(childBottom, bottom, {
      weight: thisWeight,
      minlen,
      nestingEdge: !0
    });
  }), g2.parent(v2) || g2.setEdge(root2, top, { weight: 0, minlen: height + depths[v2] });
}
function treeDepths(g2) {
  var depths = {};
  function dfs2(v2, depth) {
    var children2 = g2.children(v2);
    children2 && children2.length && children2.forEach((child) => dfs2(child, depth + 1)), depths[v2] = depth;
  }
  return g2.children().forEach((v2) => dfs2(v2, 1)), depths;
}
function sumWeights(g2) {
  return g2.edges().reduce((acc, e2) => acc + g2.edge(e2).weight, 0);
}
function cleanup(g2) {
  var graphLabel = g2.graph();
  g2.removeNode(graphLabel.nestingRoot), delete graphLabel.nestingRoot, g2.edges().forEach((e2) => {
    var edge = g2.edge(e2);
    edge.nestingEdge && g2.removeEdge(e2);
  });
}
let util$9 = util$d;
var addBorderSegments_1 = addBorderSegments$1;
function addBorderSegments$1(g2) {
  function dfs2(v2) {
    let children2 = g2.children(v2), node2 = g2.node(v2);
    if (children2.length && children2.forEach(dfs2), Object.hasOwn(node2, "minRank")) {
      node2.borderLeft = [], node2.borderRight = [];
      for (let rank2 = node2.minRank, maxRank2 = node2.maxRank + 1; rank2 < maxRank2; ++rank2)
        addBorderNode(g2, "borderLeft", "_bl", v2, node2, rank2), addBorderNode(g2, "borderRight", "_br", v2, node2, rank2);
    }
  }
  g2.children().forEach(dfs2);
}
function addBorderNode(g2, prop, prefix, sg, sgNode, rank2) {
  let label2 = { width: 0, height: 0, rank: rank2, borderType: prop }, prev = sgNode[prop][rank2 - 1], curr = util$9.addDummyNode(g2, "border", label2, prefix);
  sgNode[prop][rank2] = curr, g2.setParent(curr, sg), prev && g2.setEdge(prev, curr, { weight: 1 });
}
var coordinateSystem$1 = {
  adjust,
  undo
};
function adjust(g2) {
  let rankDir = g2.graph().rankdir.toLowerCase();
  (rankDir === "lr" || rankDir === "rl") && swapWidthHeight(g2);
}
function undo(g2) {
  let rankDir = g2.graph().rankdir.toLowerCase();
  (rankDir === "bt" || rankDir === "rl") && reverseY(g2), (rankDir === "lr" || rankDir === "rl") && (swapXY(g2), swapWidthHeight(g2));
}
function swapWidthHeight(g2) {
  g2.nodes().forEach((v2) => swapWidthHeightOne(g2.node(v2))), g2.edges().forEach((e2) => swapWidthHeightOne(g2.edge(e2)));
}
function swapWidthHeightOne(attrs) {
  let w2 = attrs.width;
  attrs.width = attrs.height, attrs.height = w2;
}
function reverseY(g2) {
  g2.nodes().forEach((v2) => reverseYOne(g2.node(v2))), g2.edges().forEach((e2) => {
    let edge = g2.edge(e2);
    edge.points.forEach(reverseYOne), Object.hasOwn(edge, "y") && reverseYOne(edge);
  });
}
function reverseYOne(attrs) {
  attrs.y = -attrs.y;
}
function swapXY(g2) {
  g2.nodes().forEach((v2) => swapXYOne(g2.node(v2))), g2.edges().forEach((e2) => {
    let edge = g2.edge(e2);
    edge.points.forEach(swapXYOne), Object.hasOwn(edge, "x") && swapXYOne(edge);
  });
}
function swapXYOne(attrs) {
  let x2 = attrs.x;
  attrs.x = attrs.y, attrs.y = x2;
}
let util$8 = util$d;
var initOrder_1 = initOrder$1;
function initOrder$1(g2) {
  let visited = {}, simpleNodes = g2.nodes().filter((v2) => !g2.children(v2).length), simpleNodesRanks = simpleNodes.map((v2) => g2.node(v2).rank), maxRank2 = util$8.applyWithChunking(Math.max, simpleNodesRanks), layers = util$8.range(maxRank2 + 1).map(() => []);
  function dfs2(v2) {
    if (visited[v2]) return;
    visited[v2] = !0;
    let node2 = g2.node(v2);
    layers[node2.rank].push(v2), g2.successors(v2).forEach(dfs2);
  }
  return simpleNodes.sort((a2, b2) => g2.node(a2).rank - g2.node(b2).rank).forEach(dfs2), layers;
}
let zipObject = util$d.zipObject;
var crossCount_1 = crossCount$1;
function crossCount$1(g2, layering) {
  let cc2 = 0;
  for (let i2 = 1; i2 < layering.length; ++i2)
    cc2 += twoLayerCrossCount(g2, layering[i2 - 1], layering[i2]);
  return cc2;
}
function twoLayerCrossCount(g2, northLayer, southLayer) {
  let southPos = zipObject(southLayer, southLayer.map((v2, i2) => i2)), southEntries = northLayer.flatMap((v2) => g2.outEdges(v2).map((e2) => ({ pos: southPos[e2.w], weight: g2.edge(e2).weight })).sort((a2, b2) => a2.pos - b2.pos)), firstIndex = 1;
  for (; firstIndex < southLayer.length; ) firstIndex <<= 1;
  let treeSize = 2 * firstIndex - 1;
  firstIndex -= 1;
  let tree = new Array(treeSize).fill(0), cc2 = 0;
  return southEntries.forEach((entry) => {
    let index2 = entry.pos + firstIndex;
    tree[index2] += entry.weight;
    let weightSum = 0;
    for (; index2 > 0; )
      index2 % 2 && (weightSum += tree[index2 + 1]), index2 = index2 - 1 >> 1, tree[index2] += entry.weight;
    cc2 += entry.weight * weightSum;
  }), cc2;
}
var barycenter_1 = barycenter$1;
function barycenter$1(g2, movable = []) {
  return movable.map((v2) => {
    let inV = g2.inEdges(v2);
    if (inV.length) {
      let result = inV.reduce((acc, e2) => {
        let edge = g2.edge(e2), nodeU = g2.node(e2.v);
        return {
          sum: acc.sum + edge.weight * nodeU.order,
          weight: acc.weight + edge.weight
        };
      }, { sum: 0, weight: 0 });
      return {
        v: v2,
        barycenter: result.sum / result.weight,
        weight: result.weight
      };
    } else
      return { v: v2 };
  });
}
let util$7 = util$d;
var resolveConflicts_1 = resolveConflicts$1;
function resolveConflicts$1(entries, cg) {
  let mappedEntries = {};
  entries.forEach((entry, i2) => {
    let tmp = mappedEntries[entry.v] = {
      indegree: 0,
      in: [],
      out: [],
      vs: [entry.v],
      i: i2
    };
    entry.barycenter !== void 0 && (tmp.barycenter = entry.barycenter, tmp.weight = entry.weight);
  }), cg.edges().forEach((e2) => {
    let entryV = mappedEntries[e2.v], entryW = mappedEntries[e2.w];
    entryV !== void 0 && entryW !== void 0 && (entryW.indegree++, entryV.out.push(mappedEntries[e2.w]));
  });
  let sourceSet = Object.values(mappedEntries).filter((entry) => !entry.indegree);
  return doResolveConflicts(sourceSet);
}
function doResolveConflicts(sourceSet) {
  let entries = [];
  function handleIn(vEntry) {
    return (uEntry) => {
      uEntry.merged || (uEntry.barycenter === void 0 || vEntry.barycenter === void 0 || uEntry.barycenter >= vEntry.barycenter) && mergeEntries(vEntry, uEntry);
    };
  }
  function handleOut(vEntry) {
    return (wEntry) => {
      wEntry.in.push(vEntry), --wEntry.indegree === 0 && sourceSet.push(wEntry);
    };
  }
  for (; sourceSet.length; ) {
    let entry = sourceSet.pop();
    entries.push(entry), entry.in.reverse().forEach(handleIn(entry)), entry.out.forEach(handleOut(entry));
  }
  return entries.filter((entry) => !entry.merged).map((entry) => util$7.pick(entry, ["vs", "i", "barycenter", "weight"]));
}
function mergeEntries(target, source) {
  let sum = 0, weight = 0;
  target.weight && (sum += target.barycenter * target.weight, weight += target.weight), source.weight && (sum += source.barycenter * source.weight, weight += source.weight), target.vs = source.vs.concat(target.vs), target.barycenter = sum / weight, target.weight = weight, target.i = Math.min(source.i, target.i), source.merged = !0;
}
let util$6 = util$d;
var sort_1 = sort$1;
function sort$1(entries, biasRight) {
  let parts = util$6.partition(entries, (entry) => Object.hasOwn(entry, "barycenter")), sortable = parts.lhs, unsortable = parts.rhs.sort((a2, b2) => b2.i - a2.i), vs = [], sum = 0, weight = 0, vsIndex = 0;
  sortable.sort(compareWithBias(!!biasRight)), vsIndex = consumeUnsortable(vs, unsortable, vsIndex), sortable.forEach((entry) => {
    vsIndex += entry.vs.length, vs.push(entry.vs), sum += entry.barycenter * entry.weight, weight += entry.weight, vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
  });
  let result = { vs: vs.flat(!0) };
  return weight && (result.barycenter = sum / weight, result.weight = weight), result;
}
function consumeUnsortable(vs, unsortable, index2) {
  let last;
  for (; unsortable.length && (last = unsortable[unsortable.length - 1]).i <= index2; )
    unsortable.pop(), vs.push(last.vs), index2++;
  return index2;
}
function compareWithBias(bias) {
  return (entryV, entryW) => entryV.barycenter < entryW.barycenter ? -1 : entryV.barycenter > entryW.barycenter ? 1 : bias ? entryW.i - entryV.i : entryV.i - entryW.i;
}
let barycenter = barycenter_1, resolveConflicts = resolveConflicts_1, sort = sort_1;
var sortSubgraph_1 = sortSubgraph$1;
function sortSubgraph$1(g2, v2, cg, biasRight) {
  let movable = g2.children(v2), node2 = g2.node(v2), bl = node2 ? node2.borderLeft : void 0, br = node2 ? node2.borderRight : void 0, subgraphs = {};
  bl && (movable = movable.filter((w2) => w2 !== bl && w2 !== br));
  let barycenters = barycenter(g2, movable);
  barycenters.forEach((entry) => {
    if (g2.children(entry.v).length) {
      let subgraphResult = sortSubgraph$1(g2, entry.v, cg, biasRight);
      subgraphs[entry.v] = subgraphResult, Object.hasOwn(subgraphResult, "barycenter") && mergeBarycenters(entry, subgraphResult);
    }
  });
  let entries = resolveConflicts(barycenters, cg);
  expandSubgraphs(entries, subgraphs);
  let result = sort(entries, biasRight);
  if (bl && (result.vs = [bl, result.vs, br].flat(!0), g2.predecessors(bl).length)) {
    let blPred = g2.node(g2.predecessors(bl)[0]), brPred = g2.node(g2.predecessors(br)[0]);
    Object.hasOwn(result, "barycenter") || (result.barycenter = 0, result.weight = 0), result.barycenter = (result.barycenter * result.weight + blPred.order + brPred.order) / (result.weight + 2), result.weight += 2;
  }
  return result;
}
function expandSubgraphs(entries, subgraphs) {
  entries.forEach((entry) => {
    entry.vs = entry.vs.flatMap((v2) => subgraphs[v2] ? subgraphs[v2].vs : v2);
  });
}
function mergeBarycenters(target, other) {
  target.barycenter !== void 0 ? (target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight), target.weight += other.weight) : (target.barycenter = other.barycenter, target.weight = other.weight);
}
let Graph$4 = graphlib.Graph, util$5 = util$d;
var buildLayerGraph_1 = buildLayerGraph$1;
function buildLayerGraph$1(g2, rank2, relationship) {
  let root2 = createRootNode(g2), result = new Graph$4({ compound: !0 }).setGraph({ root: root2 }).setDefaultNodeLabel((v2) => g2.node(v2));
  return g2.nodes().forEach((v2) => {
    let node2 = g2.node(v2), parent = g2.parent(v2);
    (node2.rank === rank2 || node2.minRank <= rank2 && rank2 <= node2.maxRank) && (result.setNode(v2), result.setParent(v2, parent || root2), g2[relationship](v2).forEach((e2) => {
      let u2 = e2.v === v2 ? e2.w : e2.v, edge = result.edge(u2, v2), weight = edge !== void 0 ? edge.weight : 0;
      result.setEdge(u2, v2, { weight: g2.edge(e2).weight + weight });
    }), Object.hasOwn(node2, "minRank") && result.setNode(v2, {
      borderLeft: node2.borderLeft[rank2],
      borderRight: node2.borderRight[rank2]
    }));
  }), result;
}
function createRootNode(g2) {
  for (var v2; g2.hasNode(v2 = util$5.uniqueId("_root")); ) ;
  return v2;
}
var addSubgraphConstraints_1 = addSubgraphConstraints$1;
function addSubgraphConstraints$1(g2, cg, vs) {
  let prev = {}, rootPrev;
  vs.forEach((v2) => {
    let child = g2.parent(v2), parent, prevChild;
    for (; child; ) {
      if (parent = g2.parent(child), parent ? (prevChild = prev[parent], prev[parent] = child) : (prevChild = rootPrev, rootPrev = child), prevChild && prevChild !== child) {
        cg.setEdge(prevChild, child);
        return;
      }
      child = parent;
    }
  });
}
let initOrder = initOrder_1, crossCount = crossCount_1, sortSubgraph = sortSubgraph_1, buildLayerGraph = buildLayerGraph_1, addSubgraphConstraints = addSubgraphConstraints_1, Graph$3 = graphlib.Graph, util$4 = util$d;
var order_1 = order$1;
function order$1(g2, opts) {
  if (opts && typeof opts.customOrder == "function") {
    opts.customOrder(g2, order$1);
    return;
  }
  let maxRank2 = util$4.maxRank(g2), downLayerGraphs = buildLayerGraphs(g2, util$4.range(1, maxRank2 + 1), "inEdges"), upLayerGraphs = buildLayerGraphs(g2, util$4.range(maxRank2 - 1, -1, -1), "outEdges"), layering = initOrder(g2);
  if (assignOrder(g2, layering), opts && opts.disableOptimalOrderHeuristic)
    return;
  let bestCC = Number.POSITIVE_INFINITY, best;
  for (let i2 = 0, lastBest = 0; lastBest < 4; ++i2, ++lastBest) {
    sweepLayerGraphs(i2 % 2 ? downLayerGraphs : upLayerGraphs, i2 % 4 >= 2), layering = util$4.buildLayerMatrix(g2);
    let cc2 = crossCount(g2, layering);
    cc2 < bestCC && (lastBest = 0, best = Object.assign({}, layering), bestCC = cc2);
  }
  assignOrder(g2, best);
}
function buildLayerGraphs(g2, ranks, relationship) {
  return ranks.map(function(rank2) {
    return buildLayerGraph(g2, rank2, relationship);
  });
}
function sweepLayerGraphs(layerGraphs, biasRight) {
  let cg = new Graph$3();
  layerGraphs.forEach(function(lg) {
    let root2 = lg.graph().root, sorted = sortSubgraph(lg, root2, cg, biasRight);
    sorted.vs.forEach((v2, i2) => lg.node(v2).order = i2), addSubgraphConstraints(lg, cg, sorted.vs);
  });
}
function assignOrder(g2, layering) {
  Object.values(layering).forEach((layer) => layer.forEach((v2, i2) => g2.node(v2).order = i2));
}
let Graph$2 = graphlib.Graph, util$3 = util$d;
var bk = {
  positionX: positionX$1,
  findType1Conflicts,
  findType2Conflicts,
  addConflict,
  hasConflict,
  verticalAlignment,
  horizontalCompaction,
  alignCoordinates,
  findSmallestWidthAlignment,
  balance
};
function findType1Conflicts(g2, layering) {
  let conflicts = {};
  function visitLayer(prevLayer, layer) {
    let k0 = 0, scanPos = 0, prevLayerLength = prevLayer.length, lastNode = layer[layer.length - 1];
    return layer.forEach((v2, i2) => {
      let w2 = findOtherInnerSegmentNode(g2, v2), k1 = w2 ? g2.node(w2).order : prevLayerLength;
      (w2 || v2 === lastNode) && (layer.slice(scanPos, i2 + 1).forEach((scanNode) => {
        g2.predecessors(scanNode).forEach((u2) => {
          let uLabel = g2.node(u2), uPos = uLabel.order;
          (uPos < k0 || k1 < uPos) && !(uLabel.dummy && g2.node(scanNode).dummy) && addConflict(conflicts, u2, scanNode);
        });
      }), scanPos = i2 + 1, k0 = k1);
    }), layer;
  }
  return layering.length && layering.reduce(visitLayer), conflicts;
}
function findType2Conflicts(g2, layering) {
  let conflicts = {};
  function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
    let v2;
    util$3.range(southPos, southEnd).forEach((i2) => {
      v2 = south[i2], g2.node(v2).dummy && g2.predecessors(v2).forEach((u2) => {
        let uNode = g2.node(u2);
        uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder) && addConflict(conflicts, u2, v2);
      });
    });
  }
  function visitLayer(north, south) {
    let prevNorthPos = -1, nextNorthPos, southPos = 0;
    return south.forEach((v2, southLookahead) => {
      if (g2.node(v2).dummy === "border") {
        let predecessors = g2.predecessors(v2);
        predecessors.length && (nextNorthPos = g2.node(predecessors[0]).order, scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos), southPos = southLookahead, prevNorthPos = nextNorthPos);
      }
      scan(south, southPos, south.length, nextNorthPos, north.length);
    }), south;
  }
  return layering.length && layering.reduce(visitLayer), conflicts;
}
function findOtherInnerSegmentNode(g2, v2) {
  if (g2.node(v2).dummy)
    return g2.predecessors(v2).find((u2) => g2.node(u2).dummy);
}
function addConflict(conflicts, v2, w2) {
  if (v2 > w2) {
    let tmp = v2;
    v2 = w2, w2 = tmp;
  }
  let conflictsV = conflicts[v2];
  conflictsV || (conflicts[v2] = conflictsV = {}), conflictsV[w2] = !0;
}
function hasConflict(conflicts, v2, w2) {
  if (v2 > w2) {
    let tmp = v2;
    v2 = w2, w2 = tmp;
  }
  return !!conflicts[v2] && Object.hasOwn(conflicts[v2], w2);
}
function verticalAlignment(g2, layering, conflicts, neighborFn) {
  let root2 = {}, align2 = {}, pos = {};
  return layering.forEach((layer) => {
    layer.forEach((v2, order2) => {
      root2[v2] = v2, align2[v2] = v2, pos[v2] = order2;
    });
  }), layering.forEach((layer) => {
    let prevIdx = -1;
    layer.forEach((v2) => {
      let ws = neighborFn(v2);
      if (ws.length) {
        ws = ws.sort((a2, b2) => pos[a2] - pos[b2]);
        let mp = (ws.length - 1) / 2;
        for (let i2 = Math.floor(mp), il = Math.ceil(mp); i2 <= il; ++i2) {
          let w2 = ws[i2];
          align2[v2] === v2 && prevIdx < pos[w2] && !hasConflict(conflicts, v2, w2) && (align2[w2] = v2, align2[v2] = root2[v2] = root2[w2], prevIdx = pos[w2]);
        }
      }
    });
  }), { root: root2, align: align2 };
}
function horizontalCompaction(g2, layering, root2, align2, reverseSep) {
  let xs = {}, blockG = buildBlockGraph(g2, layering, root2, reverseSep), borderType = reverseSep ? "borderLeft" : "borderRight";
  function iterate(setXsFunc, nextNodesFunc) {
    let stack = blockG.nodes(), elem = stack.pop(), visited = {};
    for (; elem; )
      visited[elem] ? setXsFunc(elem) : (visited[elem] = !0, stack.push(elem), stack = stack.concat(nextNodesFunc(elem))), elem = stack.pop();
  }
  function pass1(elem) {
    xs[elem] = blockG.inEdges(elem).reduce((acc, e2) => Math.max(acc, xs[e2.v] + blockG.edge(e2)), 0);
  }
  function pass2(elem) {
    let min2 = blockG.outEdges(elem).reduce((acc, e2) => Math.min(acc, xs[e2.w] - blockG.edge(e2)), Number.POSITIVE_INFINITY), node2 = g2.node(elem);
    min2 !== Number.POSITIVE_INFINITY && node2.borderType !== borderType && (xs[elem] = Math.max(xs[elem], min2));
  }
  return iterate(pass1, blockG.predecessors.bind(blockG)), iterate(pass2, blockG.successors.bind(blockG)), Object.keys(align2).forEach((v2) => xs[v2] = xs[root2[v2]]), xs;
}
function buildBlockGraph(g2, layering, root2, reverseSep) {
  let blockGraph = new Graph$2(), graphLabel = g2.graph(), sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);
  return layering.forEach((layer) => {
    let u2;
    layer.forEach((v2) => {
      let vRoot = root2[v2];
      if (blockGraph.setNode(vRoot), u2) {
        var uRoot = root2[u2], prevMax = blockGraph.edge(uRoot, vRoot);
        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g2, v2, u2), prevMax || 0));
      }
      u2 = v2;
    });
  }), blockGraph;
}
function findSmallestWidthAlignment(g2, xss) {
  return Object.values(xss).reduce((currentMinAndXs, xs) => {
    let max2 = Number.NEGATIVE_INFINITY, min2 = Number.POSITIVE_INFINITY;
    Object.entries(xs).forEach(([v2, x2]) => {
      let halfWidth = width(g2, v2) / 2;
      max2 = Math.max(x2 + halfWidth, max2), min2 = Math.min(x2 - halfWidth, min2);
    });
    const newMin = max2 - min2;
    return newMin < currentMinAndXs[0] && (currentMinAndXs = [newMin, xs]), currentMinAndXs;
  }, [Number.POSITIVE_INFINITY, null])[1];
}
function alignCoordinates(xss, alignTo) {
  let alignToVals = Object.values(alignTo), alignToMin = util$3.applyWithChunking(Math.min, alignToVals), alignToMax = util$3.applyWithChunking(Math.max, alignToVals);
  ["u", "d"].forEach((vert) => {
    ["l", "r"].forEach((horiz) => {
      let alignment = vert + horiz, xs = xss[alignment];
      if (xs === alignTo) return;
      let xsVals = Object.values(xs), delta = alignToMin - util$3.applyWithChunking(Math.min, xsVals);
      horiz !== "l" && (delta = alignToMax - util$3.applyWithChunking(Math.max, xsVals)), delta && (xss[alignment] = util$3.mapValues(xs, (x2) => x2 + delta));
    });
  });
}
function balance(xss, align2) {
  return util$3.mapValues(xss.ul, (num, v2) => {
    if (align2)
      return xss[align2.toLowerCase()][v2];
    {
      let xs = Object.values(xss).map((xs2) => xs2[v2]).sort((a2, b2) => a2 - b2);
      return (xs[1] + xs[2]) / 2;
    }
  });
}
function positionX$1(g2) {
  let layering = util$3.buildLayerMatrix(g2), conflicts = Object.assign(
    findType1Conflicts(g2, layering),
    findType2Conflicts(g2, layering)
  ), xss = {}, adjustedLayering;
  ["u", "d"].forEach((vert) => {
    adjustedLayering = vert === "u" ? layering : Object.values(layering).reverse(), ["l", "r"].forEach((horiz) => {
      horiz === "r" && (adjustedLayering = adjustedLayering.map((inner) => Object.values(inner).reverse()));
      let neighborFn = (vert === "u" ? g2.predecessors : g2.successors).bind(g2), align2 = verticalAlignment(g2, adjustedLayering, conflicts, neighborFn), xs = horizontalCompaction(
        g2,
        adjustedLayering,
        align2.root,
        align2.align,
        horiz === "r"
      );
      horiz === "r" && (xs = util$3.mapValues(xs, (x2) => -x2)), xss[vert + horiz] = xs;
    });
  });
  let smallestWidth = findSmallestWidthAlignment(g2, xss);
  return alignCoordinates(xss, smallestWidth), balance(xss, g2.graph().align);
}
function sep(nodeSep, edgeSep, reverseSep) {
  return (g2, v2, w2) => {
    let vLabel = g2.node(v2), wLabel = g2.node(w2), sum = 0, delta;
    if (sum += vLabel.width / 2, Object.hasOwn(vLabel, "labelpos"))
      switch (vLabel.labelpos.toLowerCase()) {
        case "l":
          delta = -vLabel.width / 2;
          break;
        case "r":
          delta = vLabel.width / 2;
          break;
      }
    if (delta && (sum += reverseSep ? delta : -delta), delta = 0, sum += (vLabel.dummy ? edgeSep : nodeSep) / 2, sum += (wLabel.dummy ? edgeSep : nodeSep) / 2, sum += wLabel.width / 2, Object.hasOwn(wLabel, "labelpos"))
      switch (wLabel.labelpos.toLowerCase()) {
        case "l":
          delta = wLabel.width / 2;
          break;
        case "r":
          delta = -wLabel.width / 2;
          break;
      }
    return delta && (sum += reverseSep ? delta : -delta), delta = 0, sum;
  };
}
function width(g2, v2) {
  return g2.node(v2).width;
}
let util$2 = util$d, positionX = bk.positionX;
var position_1 = position$1;
function position$1(g2) {
  g2 = util$2.asNonCompoundGraph(g2), positionY(g2), Object.entries(positionX(g2)).forEach(([v2, x2]) => g2.node(v2).x = x2);
}
function positionY(g2) {
  let layering = util$2.buildLayerMatrix(g2), rankSep = g2.graph().ranksep, prevY = 0;
  layering.forEach((layer) => {
    const maxHeight = layer.reduce((acc, v2) => {
      const height = g2.node(v2).height;
      return acc > height ? acc : height;
    }, 0);
    layer.forEach((v2) => g2.node(v2).y = prevY + maxHeight / 2), prevY += maxHeight + rankSep;
  });
}
let acyclic = acyclic$1, normalize = normalize$1, rank = rank_1, normalizeRanks = util$d.normalizeRanks, parentDummyChains = parentDummyChains_1, removeEmptyRanks = util$d.removeEmptyRanks, nestingGraph = nestingGraph$1, addBorderSegments = addBorderSegments_1, coordinateSystem = coordinateSystem$1, order = order_1, position = position_1, util$1 = util$d, Graph$1 = graphlib.Graph;
var layout_1 = layout$2;
function layout$2(g2, opts) {
  let time2 = opts && opts.debugTiming ? util$1.time : util$1.notime;
  time2("layout", () => {
    let layoutGraph = time2("  buildLayoutGraph", () => buildLayoutGraph(g2));
    time2("  runLayout", () => runLayout(layoutGraph, time2, opts)), time2("  updateInputGraph", () => updateInputGraph(g2, layoutGraph));
  });
}
function runLayout(g2, time2, opts) {
  time2("    makeSpaceForEdgeLabels", () => makeSpaceForEdgeLabels(g2)), time2("    removeSelfEdges", () => removeSelfEdges(g2)), time2("    acyclic", () => acyclic.run(g2)), time2("    nestingGraph.run", () => nestingGraph.run(g2)), time2("    rank", () => rank(util$1.asNonCompoundGraph(g2))), time2("    injectEdgeLabelProxies", () => injectEdgeLabelProxies(g2)), time2("    removeEmptyRanks", () => removeEmptyRanks(g2)), time2("    nestingGraph.cleanup", () => nestingGraph.cleanup(g2)), time2("    normalizeRanks", () => normalizeRanks(g2)), time2("    assignRankMinMax", () => assignRankMinMax(g2)), time2("    removeEdgeLabelProxies", () => removeEdgeLabelProxies(g2)), time2("    normalize.run", () => normalize.run(g2)), time2("    parentDummyChains", () => parentDummyChains(g2)), time2("    addBorderSegments", () => addBorderSegments(g2)), time2("    order", () => order(g2, opts)), time2("    insertSelfEdges", () => insertSelfEdges(g2)), time2("    adjustCoordinateSystem", () => coordinateSystem.adjust(g2)), time2("    position", () => position(g2)), time2("    positionSelfEdges", () => positionSelfEdges(g2)), time2("    removeBorderNodes", () => removeBorderNodes(g2)), time2("    normalize.undo", () => normalize.undo(g2)), time2("    fixupEdgeLabelCoords", () => fixupEdgeLabelCoords(g2)), time2("    undoCoordinateSystem", () => coordinateSystem.undo(g2)), time2("    translateGraph", () => translateGraph(g2)), time2("    assignNodeIntersects", () => assignNodeIntersects(g2)), time2("    reversePoints", () => reversePointsForReversedEdges(g2)), time2("    acyclic.undo", () => acyclic.undo(g2));
}
function updateInputGraph(inputGraph, layoutGraph) {
  inputGraph.nodes().forEach((v2) => {
    let inputLabel = inputGraph.node(v2), layoutLabel = layoutGraph.node(v2);
    inputLabel && (inputLabel.x = layoutLabel.x, inputLabel.y = layoutLabel.y, inputLabel.rank = layoutLabel.rank, layoutGraph.children(v2).length && (inputLabel.width = layoutLabel.width, inputLabel.height = layoutLabel.height));
  }), inputGraph.edges().forEach((e2) => {
    let inputLabel = inputGraph.edge(e2), layoutLabel = layoutGraph.edge(e2);
    inputLabel.points = layoutLabel.points, Object.hasOwn(layoutLabel, "x") && (inputLabel.x = layoutLabel.x, inputLabel.y = layoutLabel.y);
  }), inputGraph.graph().width = layoutGraph.graph().width, inputGraph.graph().height = layoutGraph.graph().height;
}
let graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"], graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" }, graphAttrs = ["acyclicer", "ranker", "rankdir", "align"], nodeNumAttrs = ["width", "height"], nodeDefaults = { width: 0, height: 0 }, edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"], edgeDefaults = {
  minlen: 1,
  weight: 1,
  width: 0,
  height: 0,
  labeloffset: 10,
  labelpos: "r"
}, edgeAttrs = ["labelpos"];
function buildLayoutGraph(inputGraph) {
  let g2 = new Graph$1({ multigraph: !0, compound: !0 }), graph2 = canonicalize(inputGraph.graph());
  return g2.setGraph(Object.assign(
    {},
    graphDefaults,
    selectNumberAttrs(graph2, graphNumAttrs),
    util$1.pick(graph2, graphAttrs)
  )), inputGraph.nodes().forEach((v2) => {
    let node2 = canonicalize(inputGraph.node(v2));
    const newNode = selectNumberAttrs(node2, nodeNumAttrs);
    Object.keys(nodeDefaults).forEach((k2) => {
      newNode[k2] === void 0 && (newNode[k2] = nodeDefaults[k2]);
    }), g2.setNode(v2, newNode), g2.setParent(v2, inputGraph.parent(v2));
  }), inputGraph.edges().forEach((e2) => {
    let edge = canonicalize(inputGraph.edge(e2));
    g2.setEdge(e2, Object.assign(
      {},
      edgeDefaults,
      selectNumberAttrs(edge, edgeNumAttrs),
      util$1.pick(edge, edgeAttrs)
    ));
  }), g2;
}
function makeSpaceForEdgeLabels(g2) {
  let graph2 = g2.graph();
  graph2.ranksep /= 2, g2.edges().forEach((e2) => {
    let edge = g2.edge(e2);
    edge.minlen *= 2, edge.labelpos.toLowerCase() !== "c" && (graph2.rankdir === "TB" || graph2.rankdir === "BT" ? edge.width += edge.labeloffset : edge.height += edge.labeloffset);
  });
}
function injectEdgeLabelProxies(g2) {
  g2.edges().forEach((e2) => {
    let edge = g2.edge(e2);
    if (edge.width && edge.height) {
      let v2 = g2.node(e2.v), label2 = { rank: (g2.node(e2.w).rank - v2.rank) / 2 + v2.rank, e: e2 };
      util$1.addDummyNode(g2, "edge-proxy", label2, "_ep");
    }
  });
}
function assignRankMinMax(g2) {
  let maxRank2 = 0;
  g2.nodes().forEach((v2) => {
    let node2 = g2.node(v2);
    node2.borderTop && (node2.minRank = g2.node(node2.borderTop).rank, node2.maxRank = g2.node(node2.borderBottom).rank, maxRank2 = Math.max(maxRank2, node2.maxRank));
  }), g2.graph().maxRank = maxRank2;
}
function removeEdgeLabelProxies(g2) {
  g2.nodes().forEach((v2) => {
    let node2 = g2.node(v2);
    node2.dummy === "edge-proxy" && (g2.edge(node2.e).labelRank = node2.rank, g2.removeNode(v2));
  });
}
function translateGraph(g2) {
  let minX = Number.POSITIVE_INFINITY, maxX = 0, minY = Number.POSITIVE_INFINITY, maxY = 0, graphLabel = g2.graph(), marginX = graphLabel.marginx || 0, marginY = graphLabel.marginy || 0;
  function getExtremes(attrs) {
    let x2 = attrs.x, y2 = attrs.y, w2 = attrs.width, h2 = attrs.height;
    minX = Math.min(minX, x2 - w2 / 2), maxX = Math.max(maxX, x2 + w2 / 2), minY = Math.min(minY, y2 - h2 / 2), maxY = Math.max(maxY, y2 + h2 / 2);
  }
  g2.nodes().forEach((v2) => getExtremes(g2.node(v2))), g2.edges().forEach((e2) => {
    let edge = g2.edge(e2);
    Object.hasOwn(edge, "x") && getExtremes(edge);
  }), minX -= marginX, minY -= marginY, g2.nodes().forEach((v2) => {
    let node2 = g2.node(v2);
    node2.x -= minX, node2.y -= minY;
  }), g2.edges().forEach((e2) => {
    let edge = g2.edge(e2);
    edge.points.forEach((p2) => {
      p2.x -= minX, p2.y -= minY;
    }), Object.hasOwn(edge, "x") && (edge.x -= minX), Object.hasOwn(edge, "y") && (edge.y -= minY);
  }), graphLabel.width = maxX - minX + marginX, graphLabel.height = maxY - minY + marginY;
}
function assignNodeIntersects(g2) {
  g2.edges().forEach((e2) => {
    let edge = g2.edge(e2), nodeV = g2.node(e2.v), nodeW = g2.node(e2.w), p1, p2;
    edge.points ? (p1 = edge.points[0], p2 = edge.points[edge.points.length - 1]) : (edge.points = [], p1 = nodeW, p2 = nodeV), edge.points.unshift(util$1.intersectRect(nodeV, p1)), edge.points.push(util$1.intersectRect(nodeW, p2));
  });
}
function fixupEdgeLabelCoords(g2) {
  g2.edges().forEach((e2) => {
    let edge = g2.edge(e2);
    if (Object.hasOwn(edge, "x"))
      switch ((edge.labelpos === "l" || edge.labelpos === "r") && (edge.width -= edge.labeloffset), edge.labelpos) {
        case "l":
          edge.x -= edge.width / 2 + edge.labeloffset;
          break;
        case "r":
          edge.x += edge.width / 2 + edge.labeloffset;
          break;
      }
  });
}
function reversePointsForReversedEdges(g2) {
  g2.edges().forEach((e2) => {
    let edge = g2.edge(e2);
    edge.reversed && edge.points.reverse();
  });
}
function removeBorderNodes(g2) {
  g2.nodes().forEach((v2) => {
    if (g2.children(v2).length) {
      let node2 = g2.node(v2), t2 = g2.node(node2.borderTop), b2 = g2.node(node2.borderBottom), l2 = g2.node(node2.borderLeft[node2.borderLeft.length - 1]), r2 = g2.node(node2.borderRight[node2.borderRight.length - 1]);
      node2.width = Math.abs(r2.x - l2.x), node2.height = Math.abs(b2.y - t2.y), node2.x = l2.x + node2.width / 2, node2.y = t2.y + node2.height / 2;
    }
  }), g2.nodes().forEach((v2) => {
    g2.node(v2).dummy === "border" && g2.removeNode(v2);
  });
}
function removeSelfEdges(g2) {
  g2.edges().forEach((e2) => {
    if (e2.v === e2.w) {
      var node2 = g2.node(e2.v);
      node2.selfEdges || (node2.selfEdges = []), node2.selfEdges.push({ e: e2, label: g2.edge(e2) }), g2.removeEdge(e2);
    }
  });
}
function insertSelfEdges(g2) {
  var layers = util$1.buildLayerMatrix(g2);
  layers.forEach((layer) => {
    var orderShift = 0;
    layer.forEach((v2, i2) => {
      var node2 = g2.node(v2);
      node2.order = i2 + orderShift, (node2.selfEdges || []).forEach((selfEdge) => {
        util$1.addDummyNode(g2, "selfedge", {
          width: selfEdge.label.width,
          height: selfEdge.label.height,
          rank: node2.rank,
          order: i2 + ++orderShift,
          e: selfEdge.e,
          label: selfEdge.label
        }, "_se");
      }), delete node2.selfEdges;
    });
  });
}
function positionSelfEdges(g2) {
  g2.nodes().forEach((v2) => {
    var node2 = g2.node(v2);
    if (node2.dummy === "selfedge") {
      var selfNode = g2.node(node2.e.v), x2 = selfNode.x + selfNode.width / 2, y2 = selfNode.y, dx = node2.x - x2, dy = selfNode.height / 2;
      g2.setEdge(node2.e, node2.label), g2.removeNode(v2), node2.label.points = [
        { x: x2 + 2 * dx / 3, y: y2 - dy },
        { x: x2 + 5 * dx / 6, y: y2 - dy },
        { x: x2 + dx, y: y2 },
        { x: x2 + 5 * dx / 6, y: y2 + dy },
        { x: x2 + 2 * dx / 3, y: y2 + dy }
      ], node2.label.x = node2.x, node2.label.y = node2.y;
    }
  });
}
function selectNumberAttrs(obj, attrs) {
  return util$1.mapValues(util$1.pick(obj, attrs), Number);
}
function canonicalize(attrs) {
  var newAttrs = {};
  return attrs && Object.entries(attrs).forEach(([k2, v2]) => {
    typeof k2 == "string" && (k2 = k2.toLowerCase()), newAttrs[k2] = v2;
  }), newAttrs;
}
let util = util$d, Graph2 = graphlib.Graph;
var debug = {
  debugOrdering
};
function debugOrdering(g2) {
  let layerMatrix = util.buildLayerMatrix(g2), h2 = new Graph2({ compound: !0, multigraph: !0 }).setGraph({});
  return g2.nodes().forEach((v2) => {
    h2.setNode(v2, { label: v2 }), h2.setParent(v2, "layer" + g2.node(v2).rank);
  }), g2.edges().forEach((e2) => h2.setEdge(e2.v, e2.w, {}, e2.name)), layerMatrix.forEach((layer, i2) => {
    let layerV = "layer" + i2;
    h2.setNode(layerV, { rank: "same" }), layer.reduce((u2, v2) => (h2.setEdge(u2, v2, { style: "invis" }), v2));
  }), h2;
}
var version = "1.1.4", dagre = {
  graphlib,
  layout: layout_1,
  debug,
  util: {
    time: util$d.time,
    notime: util$d.notime
  },
  version
};
const dagre$1 = /* @__PURE__ */ getDefaultExportFromCjs(dagre), Sizes$1 = {
  dagre: {
    ranksep: 40,
    nodesep: 25,
    edgesep: 15
  },
  edgeLabel: {
    width: 120
  },
  nodeWidth: 270,
  hodeHeight: 160,
  // Spacer between elements in a compound node
  // 0 means no spacer
  spacerHeight: 0,
  compoundLabelHeight: 5
}, ZIndexes$1 = {
  compound: 2,
  edge: 3,
  element: 4,
  max: 5
};
function createGraph$1() {
  const g2 = new dagre$1.graphlib.Graph({
    directed: !0,
    compound: !0
  });
  return g2.setGraph({
    ...Sizes$1.dagre,
    rankdir: "LR"
  }), g2.setDefaultEdgeLabel(() => ({ ...Sizes$1.edgeLabel })), g2.setDefaultNodeLabel(() => ({})), g2;
}
const sized$1 = (height = Sizes$1.hodeHeight) => ({
  width: Sizes$1.nodeWidth,
  height
}), graphId$1 = (node2) => ({
  id: node2.id,
  port: node2.type === "compound" ? `${node2.id}::port` : node2.id,
  body: `${node2.id}`,
  spacer: `${node2.id}:spacer`
});
function nodeData$1(element, ctx) {
  var _a4;
  let diagramNode = ctx.diagramNodes.get(element.id);
  const ancestor = diagramNode ?? x$2(
    element.ancestors(),
    m$2((ancestor2) => ctx.diagramNodes.get(ancestor2.id)),
    T$1(n$4),
    d$1()
  );
  return {
    fqn: element.id,
    element: {
      kind: element.kind,
      title: (diagramNode == null ? void 0 : diagramNode.title) ?? element.title,
      description: (diagramNode == null ? void 0 : diagramNode.description) ?? element.element.description,
      color: (diagramNode == null ? void 0 : diagramNode.color) ?? (ancestor == null ? void 0 : ancestor.color) ?? element.color,
      shape: (diagramNode == null ? void 0 : diagramNode.shape) ?? element.shape
    },
    navigateTo: (diagramNode == null ? void 0 : diagramNode.navigateTo) ?? ((_a4 = d$1(element.viewsOf())) == null ? void 0 : _a4.id) ?? null,
    ports: {
      in: [],
      out: []
    }
  };
}
function createNode$1(nodeType, element, ctx) {
  let node2 = ctx.xynodes.get(element.id);
  if (node2)
    return node2;
  const g2 = ctx.g, parent = x$2(
    element.ancestors(),
    u$7((ancestor) => !isAncestor(ancestor.id, ctx.edge.source) && !isAncestor(ancestor.id, ctx.edge.target)),
    d$1(),
    (found) => found ? createNode$1("compound", found, ctx) : null
  ), xynode = {
    type: nodeType,
    id: element.id,
    position: { x: 0, y: 0 },
    data: {
      ...nodeData$1(element, ctx)
    },
    zIndex: ZIndexes$1[nodeType],
    ...!!parent && { parentId: parent.id }
  };
  ctx.xynodes.set(element.id, xynode);
  const k2 = graphId$1(xynode);
  if (g2.setNode(k2.id, sized$1()), xynode.type === "compound" && (g2.setNode(k2.port, {
    width: Sizes$1.nodeWidth - Sizes$1.dagre.ranksep,
    height: Sizes$1.compoundLabelHeight
  }), g2.setParent(k2.port, k2.id)), parent) {
    const parentGraphId = graphId$1(parent).body;
    g2.setParent(k2.id, parentGraphId);
  }
  return xynode;
}
function applyDagreLayout$1(g2) {
  return dagre$1.layout(g2), function nodeBounds(nodeId, relativeTo) {
    const { x: x2, y: y2, width: width2, height } = g2.node(nodeId), pos = {
      position: {
        x: x2 - Math.round(width2 / 2),
        y: y2 - Math.round(height / 2)
      },
      width: width2,
      height
    };
    if (!relativeTo)
      return pos;
    const offset2 = nodeBounds(relativeTo).position;
    return {
      position: {
        x: pos.position.x - offset2.x,
        y: pos.position.y - offset2.y
      },
      width: pos.width,
      height: pos.height
    };
  };
}
function layout$1(edgeId, view, likec4model) {
  const edge = view.edges.find((e2) => e2.id === edgeId);
  invariant$1(edge, "edge not found");
  const all = /* @__PURE__ */ new Set([edge.source, edge.target]), relations = edge.relations.map((r2) => {
    const relation = likec4model.relationship(r2).relationship;
    return all.add(relation.source), all.add(relation.target), relation;
  }).sort(compareRelations).reverse(), diagramNodes = new Map(view.nodes.map((n2) => [n2.id, n2])), g2 = createGraph$1(), ctx = {
    g: g2,
    xynodes: /* @__PURE__ */ new Map(),
    edge,
    diagramNodes,
    edges: []
  };
  x$2(
    [...all],
    m$3(compareFqnHierarchically),
    t$7(),
    u$4((id2) => {
      const element = likec4model.element(id2);
      createNode$1("element", element, ctx);
    })
  ), relations.length === 1 && all.size < 4 && g2.setDefaultEdgeLabel(() => ({ width: 250 }));
  for (const relation of relations) {
    const source = ctx.xynodes.get(relation.source);
    invariant$1(source, "source node not found");
    const target = ctx.xynodes.get(relation.target);
    invariant$1(target, "target node not found"), source.data.ports.out.push(target.id), target.data.ports.in.push(source.id), g2.setEdge(graphId$1(source).port, graphId$1(target).port);
    const edge2 = {
      id: relation.id,
      type: "relation",
      source: source.id,
      target: target.id,
      sourceHandle: target.id,
      targetHandle: source.id,
      data: {
        relation
      },
      label: relation.title,
      zIndex: ZIndexes$1.edge,
      markerEnd: {
        type: MarkerType.ArrowClosed,
        width: 10
      },
      style: {
        strokeWidth: 2.2,
        strokeDasharray: "5, 5"
      }
    };
    ctx.edges.push(edge2);
  }
  const nodebounds = applyDagreLayout$1(ctx.g), sortedPorts = (ports) => ports.length < 2 ? ports : x$2(
    ports,
    m$2((port) => ({
      port,
      topY: nodebounds(port).position.y
    })),
    a$3(p$4("topY")),
    m$2(p$4("port"))
  ), xynodes = [...ctx.xynodes.values()].map((node2) => (node2.data.ports.in.length > 1 && (node2.data.ports.in = sortedPorts(node2.data.ports.in)), node2.data.ports.out.length > 1 && (node2.data.ports.out = sortedPorts(node2.data.ports.out)), {
    ...node2,
    ...nodebounds(node2.id, node2.parentId)
  }));
  return {
    view,
    edge,
    edges: ctx.edges,
    nodes: xynodes,
    bounds: {
      x: 0,
      y: 0,
      width: g2.graph().width ?? 0,
      height: g2.graph().height ?? 0
    }
  };
}
function useLayoutedEdgeDetails(edgeId) {
  const view = useDiagramState((s2) => s2.view), likec4model = useLikeC4Model(!0);
  return useMemo(() => layout$1(
    edgeId,
    view,
    likec4model
  ), [
    edgeId,
    view,
    likec4model,
    layout$1
  ]);
}
var elementNode$1 = "_7mnxci0", elementNodeContent$1 = "_7mnxci1", elementNodeTitle$1 = "_7mnxci2", elementNodeDescription$1 = "_7mnxci3", compoundNodeBody$1 = "_7mnxci4", compoundNodeTitle$1 = "_7mnxci5", cssShapeSvg$1 = "_7mnxci6", edgeContainer$1 = "_7mnxci7", edgeLabel$2 = "_7mnxci8 _7mnxci7", edgeLabelText$2 = "_7mnxci9", edgeLabelTechnology$1 = "_7mnxcia", navigateBtnBox$2 = "_7mnxcib", navigateBtn$3 = "_7mnxcic";
const Text$5 = Text$6.withProps({
  component: "div"
});
function CompoundNode$1({
  data: {
    element,
    ports,
    ...data
  },
  width: width2 = 200,
  selectable = !0
}) {
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      m$1.div,
      {
        className: clsx([
          compoundNodeBody$1,
          "likec4-compound-node"
        ]),
        "data-compound-depth": 3,
        "data-likec4-color": element.color,
        animate: {
          opacity: data.dimmed ? 0.15 : 1,
          transition: {
            delay: data.dimmed === !0 ? 0.4 : 0
          }
        },
        ...selectable && {
          whileHover: {
            scale: 1.04,
            transition: {
              delay: 0.15
            }
          },
          whileTap: {
            scale: 1
          }
        },
        children: /* @__PURE__ */ jsx(Text$5, { className: compoundNodeTitle$1, maw: width2 - 20, children: element.title })
      }
    ),
    ports.out.map((id2, i2) => /* @__PURE__ */ jsx(
      Handle,
      {
        id: id2,
        type: "source",
        position: Position.Right,
        style: {
          visibility: "hidden",
          top: `${16 + 20 * i2}px`
        }
      },
      id2
    )),
    ports.in.map((id2, i2) => /* @__PURE__ */ jsx(
      Handle,
      {
        id: id2,
        type: "target",
        position: Position.Left,
        style: {
          visibility: "hidden",
          top: `${16 + 20 * i2}px`
        }
      },
      id2
    ))
  ] });
}
var container$6 = "lnegrx1", handleCenter = "lnegrx2", containerAnimated = "lnegrx3", dimmed$2 = "lnegrx4", indicator$1 = "lnegrx7", fillElementFill = "lnegrx8", fillMixStroke = "lnegrxa", hasIcon = "lnegrxb", title$4 = "lnegrxe", description$1 = "lnegrxf", technology = "lnegrxg", elementDataContainer = "lnegrxh", elementTextData = "lnegrxi", elementIcon$2 = "lnegrxj", shapeSvg$1 = "lnegrxm", navigateBtnBox$1 = "lnegrxo", navigateBtn$2 = "lnegrxp lnegrxn", detailsBtn$1 = "lnegrxq lnegrxn";
function cylinderSVGPath(diameter, height, tilt = 0.065) {
  const radius = Math.round(diameter / 2), rx = radius, ry = toDomPrecision(tilt * radius), tiltAdjustedHeight = height - 2 * ry;
  return {
    path: `  M ${diameter},${ry}
        a ${rx},${ry} 0,0,0 ${-diameter} 0
        l 0,${tiltAdjustedHeight}
        a ${rx},${ry} 0,0,0 ${diameter} 0
        l 0,${-tiltAdjustedHeight}
        z
        `.replace(/\s+/g, " ").trim(),
    ry,
    rx
  };
}
function queueSVGPath(width2, height, tilt = 0.185) {
  const diameter = height, ry = Math.round(diameter / 2), rx = toDomPrecision(diameter / 2 * tilt), tiltAdjustedWidth = width2 - 2 * rx;
  return {
    path: `
    M ${rx},0
    a ${rx},${ry} 0,0,0 0 ${diameter}
    l ${tiltAdjustedWidth},0
    a ${rx},${ry} 0,0,0 0 ${-diameter}
    z`.replace(/\s+/g, " ").trim(),
    ry,
    rx
  };
}
const PersonIcon = {
  width: 115,
  height: 120,
  path: "M57.9197 0C10.9124 0 33.5766 54.75 33.5766 54.75C38.6131 62.25 45.3285 60.75 45.3285 66C45.3285 70.5 39.4526 72 33.5766 72.75C24.3431 72.75 15.9489 71.25 7.55474 84.75C2.51825 93 0 120 0 120H115C115 120 112.482 93 108.285 84.75C99.8905 70.5 91.4963 72.75 82.2628 72C76.3869 71.25 70.5109 69.75 70.5109 65.25C70.5109 60.75 77.2263 62.25 82.2628 54C82.2628 54.75 104.927 0 57.9197 0V0Z"
};
function ElementShapeSvg({ shape, w: w2, h: h2 }) {
  switch (shape) {
    case "mobile":
      return /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx(
          "rect",
          {
            width: w2,
            height: h2,
            rx: 6,
            className: fillMixStroke,
            strokeWidth: 0
          }
        ),
        /* @__PURE__ */ jsxs("g", { className: fillElementFill, strokeWidth: 0, children: [
          /* @__PURE__ */ jsx("circle", { cx: 17, cy: h2 / 2, r: 12 }),
          /* @__PURE__ */ jsx("rect", { x: 33, y: 12, width: w2 - 44, height: h2 - 24, rx: 5 })
        ] })
      ] });
    case "browser":
      return /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx(
          "rect",
          {
            width: w2,
            height: h2,
            rx: 6,
            className: fillMixStroke,
            strokeWidth: 0
          }
        ),
        /* @__PURE__ */ jsxs("g", { className: fillElementFill, strokeWidth: 0, children: [
          /* @__PURE__ */ jsx("circle", { cx: 16, cy: 17, r: 7 }),
          /* @__PURE__ */ jsx("circle", { cx: 36, cy: 17, r: 7 }),
          /* @__PURE__ */ jsx("circle", { cx: 56, cy: 17, r: 7 }),
          /* @__PURE__ */ jsx("rect", { x: 70, y: 8, width: w2 - 80, height: 17, rx: 4 }),
          /* @__PURE__ */ jsx("rect", { x: 10, y: 32, width: w2 - 20, height: h2 - 42, rx: 4 })
        ] })
      ] });
    case "person":
      return /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx(
          "rect",
          {
            width: w2,
            height: h2,
            rx: 6,
            strokeWidth: 0
          }
        ),
        /* @__PURE__ */ jsx(
          "svg",
          {
            x: w2 - PersonIcon.width - 6,
            y: h2 - PersonIcon.height,
            width: PersonIcon.width,
            height: PersonIcon.height,
            viewBox: `0 0 ${PersonIcon.width} ${PersonIcon.height}`,
            className: fillMixStroke,
            children: /* @__PURE__ */ jsx(
              "path",
              {
                strokeWidth: 0,
                d: PersonIcon.path
              }
            )
          }
        )
      ] });
    case "queue": {
      const { path, rx, ry } = queueSVGPath(w2, h2);
      return /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx("path", { d: path, strokeWidth: 2 }),
        /* @__PURE__ */ jsx("ellipse", { cx: rx, cy: ry, ry: ry - 0.75, rx, className: fillMixStroke, strokeWidth: 2 })
      ] });
    }
    case "storage":
    case "cylinder": {
      const { path, rx, ry } = cylinderSVGPath(w2, h2);
      return /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx("path", { d: path, strokeWidth: 2 }),
        /* @__PURE__ */ jsx("ellipse", { cx: rx, cy: ry, ry, rx: rx - 0.75, className: fillMixStroke, strokeWidth: 2 })
      ] });
    }
    case "rectangle":
      return /* @__PURE__ */ jsx(
        "rect",
        {
          width: w2,
          height: h2,
          rx: 6,
          strokeWidth: 0
        }
      );
    default:
      return nonexhaustive(shape);
  }
}
function SelectedIndicator({ shape, w: w2, h: h2 }) {
  switch (shape) {
    case "queue":
      return /* @__PURE__ */ jsx("path", { d: queueSVGPath(w2, h2).path });
    case "storage":
    case "cylinder":
      return /* @__PURE__ */ jsx("path", { d: cylinderSVGPath(w2, h2).path });
    default:
      return /* @__PURE__ */ jsx(
        "rect",
        {
          x: -1,
          y: -1,
          width: w2 + 2,
          height: h2 + 2,
          rx: 6
        }
      );
  }
}
const Action$2 = ActionIcon$1.withProps({
  className: "nodrag nopan " + navigateBtn$3,
  radius: "md",
  role: "button",
  onDoubleClick: stopPropagation$1,
  onPointerDownCapture: stopPropagation$1
}), Text$4 = Text$6.withProps({
  component: "div"
});
function selector$6(s2) {
  return {
    currentViewId: s2.view.id,
    enableRelationshipBrowser: s2.enableRelationshipBrowser,
    onNavigateTo: s2.onNavigateTo,
    onOpenSource: s2.onOpenSourceElement
  };
}
function ElementNode$1({
  data: {
    element,
    ports,
    navigateTo,
    ...data
  },
  selectable = !0,
  width: w2 = 100,
  height: h2 = 100
}) {
  const overlay = useOverlayDialog(), {
    currentViewId,
    onNavigateTo,
    onOpenSource,
    enableRelationshipBrowser
  } = useDiagramState(selector$6);
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsxs(
      m$1.div,
      {
        className: clsx([
          elementNode$1,
          "likec4-element-node"
        ]),
        "data-likec4-color": element.color,
        "data-likec4-shape": element.shape,
        animate: {
          opacity: data.dimmed ? 0.15 : 1,
          transition: {
            delay: data.dimmed === !0 ? 0.4 : 0
          }
        },
        ...selectable && {
          whileHover: {
            scale: 1.045,
            transition: {
              delay: 0.15
            }
          },
          whileTap: {
            scale: 0.97
          }
        },
        children: [
          /* @__PURE__ */ jsx(
            "svg",
            {
              className: clsx(
                cssShapeSvg$1
              ),
              viewBox: `0 0 ${w2} ${h2}`,
              width: w2,
              height: h2,
              children: /* @__PURE__ */ jsx(ElementShapeSvg, { shape: element.shape, w: w2, h: h2 })
            }
          ),
          /* @__PURE__ */ jsxs(Box, { className: elementNodeContent$1, children: [
            /* @__PURE__ */ jsx(Text$4, { className: elementNodeTitle$1, lineClamp: 2, children: element.title }),
            element.description && /* @__PURE__ */ jsx(Text$4, { className: elementNodeDescription$1, lineClamp: 4, children: element.description })
          ] }),
          /* @__PURE__ */ jsxs(Group, { className: navigateBtnBox$2, children: [
            navigateTo && onNavigateTo && navigateTo !== currentViewId && /* @__PURE__ */ jsx(
              Action$2,
              {
                onClick: (event) => {
                  event.stopPropagation(), overlay.close(() => onNavigateTo(navigateTo));
                },
                children: /* @__PURE__ */ jsx(IconZoomScan, { stroke: 1.8, style: { width: "75%" } })
              }
            ),
            enableRelationshipBrowser && /* @__PURE__ */ jsx(
              Action$2,
              {
                onClick: (event) => {
                  event.stopPropagation(), overlay.openOverlay({
                    relationshipsOf: data.fqn
                  });
                },
                children: /* @__PURE__ */ jsx(IconTransform, { stroke: 1.8, style: { width: "72%" } })
              }
            ),
            onOpenSource && /* @__PURE__ */ jsx(
              Action$2,
              {
                onClick: (event) => {
                  event.stopPropagation(), onOpenSource(data.fqn);
                },
                children: /* @__PURE__ */ jsx(IconFileSymlink, { stroke: 1.8, style: { width: "72%" } })
              }
            )
          ] })
        ]
      }
    ),
    ports.out.map((id2, i2) => /* @__PURE__ */ jsx(
      Handle,
      {
        id: id2,
        type: "source",
        position: Position.Right,
        style: {
          visibility: "hidden",
          top: `${15 + (i2 + 1) * ((h2 - 30) / (ports.out.length + 1))}px`
        }
      },
      id2
    )),
    ports.in.map((id2, i2) => /* @__PURE__ */ jsx(
      Handle,
      {
        id: id2,
        type: "target",
        position: Position.Left,
        style: {
          visibility: "hidden",
          top: `${15 + (i2 + 1) * ((h2 - 30) / (ports.in.length + 1))}px`
        }
      },
      id2
    ))
  ] });
}
function RelationshipEdge$2({
  data,
  label: label2,
  ...props
}) {
  const overlay = useOverlayDialog(), onNavigateTo = useDiagramState((s2) => s2.onNavigateTo), [edgePath, labelX, labelY] = getBezierPath(props), navigateTo = data.relation.navigateTo;
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      "g",
      {
        className: edgeContainer$1,
        "data-edge-dimmed": data.dimmed,
        "data-edge-hovered": data.hovered,
        children: /* @__PURE__ */ jsx(
          BaseEdge,
          {
            path: edgePath,
            ...props
          }
        )
      }
    ),
    /* @__PURE__ */ jsx(EdgeLabelRenderer, { children: /* @__PURE__ */ jsxs(
      Stack$1,
      {
        gap: 2,
        style: {
          position: "absolute",
          transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,
          maxWidth: Math.abs(props.targetX - props.sourceX - 40),
          zIndex: ZIndexes$1.max
        },
        className: clsx([
          edgeLabel$2,
          "nodrag nopan"
        ]),
        "data-edge-dimmed": data.dimmed,
        "data-edge-hovered": data.hovered,
        children: [
          label2 && /* @__PURE__ */ jsx(Text$6, { component: "div", className: edgeLabelText$2, lineClamp: 3, children: label2 }),
          data.relation.technology && /* @__PURE__ */ jsxs(Text$6, { component: "div", className: edgeLabelTechnology$1, children: [
            "[ ",
            data.relation.technology,
            " ]"
          ] }),
          navigateTo && onNavigateTo && /* @__PURE__ */ jsx(Box, { ta: "center", mt: 4, children: /* @__PURE__ */ jsx(
            ActionIcon$1,
            {
              variant: "default",
              size: "sm",
              radius: "sm",
              onPointerDownCapture: stopPropagation$1,
              onClick: (event) => {
                event.stopPropagation(), overlay.close(() => {
                  onNavigateTo(navigateTo);
                });
              },
              role: "button",
              onDoubleClick: stopPropagation$1,
              children: /* @__PURE__ */ jsx(IconZoomScan, {})
            }
          ) })
        ]
      }
    ) })
  ] });
}
const nodeTypes$2 = {
  element: ElementNode$1,
  compound: CompoundNode$1
}, edgeTypes$2 = {
  relation: RelationshipEdge$2
}, resetDimmedAndHovered$1 = (xyflow2) => {
  xyflow2.setEdges(
    (edges) => edges.map((edge) => ({
      ...edge,
      data: {
        ...edge.data,
        dimmed: !1,
        hovered: !1
      },
      animated: !1
    }))
  ), xyflow2.setNodes(
    (nodes) => nodes.map(
      (n2) => ({
        ...n2,
        data: {
          ...n2.data,
          dimmed: !1,
          hovered: !1
        }
      })
    )
  );
}, EdgeDetailsXYFlow = memo$1(function({ edgeId }) {
  const diagramStore = useDiagramStoreApi(), {
    view,
    edge,
    edges,
    nodes,
    bounds
  } = useLayoutedEdgeDetails(edgeId), boundsRef = useSyncedRef(bounds), xyflow2 = useReactFlow(), xystore = useStoreApi(), fitview = useDebouncedCallback(
    () => {
      const {
        width: width2,
        height
      } = xystore.getState(), viewport = getViewportForBounds(
        {
          ...boundsRef.current,
          height: Math.max(boundsRef.current.height + 100, height - 200)
          // Add some padding to the bottom
        },
        width2,
        height,
        0.2,
        1,
        0.2
      );
      xyflow2.setViewport(viewport, { duration: 350 });
    },
    [xyflow2],
    150
  );
  useEffect(() => {
    xyflow2.setNodes(nodes), xyflow2.setEdges(edges);
  }, [nodes, edges]);
  const zoomable = !0;
  return useUpdateEffect$1(() => fitview(), [edge.id]), /* @__PURE__ */ jsxs(
    index$2,
    {
      defaultEdges: [],
      defaultNodes: [],
      nodeTypes: nodeTypes$2,
      edgeTypes: edgeTypes$2,
      defaultMarkerColor: "var(--xy-edge-stroke)",
      zoomOnPinch: zoomable,
      zoomOnScroll: !1,
      zoomOnDoubleClick: !1,
      maxZoom: 1.5,
      minZoom: 0.1,
      fitView: !0,
      fitViewOptions: {
        padding: 0.2,
        maxZoom: 1,
        minZoom: 0.1,
        includeHiddenNodes: !0
      },
      preventScrolling: !0,
      noDragClassName: "nodrag",
      noPanClassName: "nopan",
      panOnScroll: !0,
      panOnDrag: !0,
      elementsSelectable: !0,
      nodesFocusable: !1,
      edgesFocusable: !1,
      nodesDraggable: !1,
      onEdgeMouseEnter: (_, edge2) => {
        xyflow2.setEdges(
          (edges2) => edges2.map((e2) => ({
            ...e2,
            data: {
              ...e2.data,
              dimmed: e2.id !== edge2.id,
              hovered: e2.id === edge2.id
            },
            zIndex: e2.id === edge2.id ? ZIndexes$1.max : ZIndexes$1.edge,
            animated: e2.id === edge2.id
          }))
        ), xyflow2.setNodes(
          (nodes2) => nodes2.map((n2) => ({
            ...n2,
            data: {
              ...n2.data,
              dimmed: n2.id !== edge2.source && n2.id !== edge2.target
            }
          }))
        );
      },
      onEdgeMouseLeave: () => {
        resetDimmedAndHovered$1(xyflow2);
      },
      onEdgeClick: (e2, edge2) => {
        var _a4, _b2;
        e2.stopPropagation(), (_b2 = (_a4 = diagramStore.getState()).onOpenSourceRelation) == null || _b2.call(_a4, edge2.data.relation.id);
      },
      children: [
        /* @__PURE__ */ jsx(Panel, { position: "top-center", children: /* @__PURE__ */ jsx(Group, { gap: "xs", wrap: "nowrap", children: /* @__PURE__ */ jsx(
          SelectEdge,
          {
            view,
            edge
          }
        ) }) }),
        /* @__PURE__ */ jsx(EdgeData, { edge, top: bounds.height, width: bounds.width })
      ]
    }
  );
}), EdgeData = ({ edge, top, width: width2 }) => /* @__PURE__ */ jsx(ViewportPortal, { children: /* @__PURE__ */ jsx(
  Box,
  {
    maw: width2,
    style: {
      transform: `translate(100px, ${top + 32}px)`
    },
    children: /* @__PURE__ */ jsxs(Box, { className: edgeDataGrid, children: [
      /* @__PURE__ */ jsx(Text$6, { size: "xs", fw: 500, c: "dimmed", children: "technology" }),
      /* @__PURE__ */ jsx(Text$6, { children: edge.technology || "unknown" }),
      /* @__PURE__ */ jsx(Text$6, { size: "xs", fw: 500, c: "dimmed", children: "description" }),
      /* @__PURE__ */ jsx(Text$6, { children: edge.description || "no description" })
    ] })
  }
) });
var dialog = "oztqew2", card$2 = "oztqew3", cardHeader = "oztqew4", title$3 = "oztqew5", elementIcon$1 = "oztqew6", viewButton = "oztqew9", viewButtonTitle = "oztqewa", tabsRoot = "oztqewb", tabsList = "oztqewc", tabsTab = "oztqewd", tabsPanel = "oztqewe", propertiesGrid = "oztqewf", propertyLabel = "oztqewg", elementLink = "oztqewh", resizeHandle = "oztqewi", container$5 = "q4g2qb1", cssReactflowMarker = "q4g2qb2", node = "esyd460", label = "esyd461";
const classes = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, get label() {
  return label;
}, get node() {
  return node;
} }, Symbol.toStringTag, { value: "Module" })), SelectElement = ({
  subject,
  viewId,
  scope,
  onSelect
}) => {
  const viewport = useRef(null), data = useLikeC4ElementsTree(scope === "view" ? viewId : void 0), tree = useTree({
    multiple: !1
  });
  useEffect(() => {
    ancestorsFqn(subject.id).reverse().forEach((id2) => {
      tree.expand(id2);
    }), tree.select(subject.id);
  }, [subject.id]);
  const theme = useComputedColorScheme();
  return /* @__PURE__ */ jsxs(
    Popover,
    {
      position: "bottom",
      shadow: "md",
      keepMounted: !0,
      withinPortal: !1,
      closeOnClickOutside: !0,
      clickOutsideEvents: ["pointerdown", "mousedown", "click"],
      onOpen: () => {
        setTimeout(() => {
          var _a4;
          const item = (_a4 = viewport.current) == null ? void 0 : _a4.querySelector(`[data-value="${subject.id}"]`);
          console.log("item", item), item == null || item.scrollIntoView({ behavior: "instant", block: "nearest" });
        }, 100);
      },
      children: [
        /* @__PURE__ */ jsx(PopoverTarget, { children: /* @__PURE__ */ jsx(
          Button,
          {
            size: "xs",
            variant: "light",
            color: theme === "light" ? "dark" : "gray",
            fw: "500",
            maw: 250,
            style: { padding: "0.25rem 0.75rem" },
            rightSection: /* @__PURE__ */ jsx(IconSelector, { size: 16 }),
            children: subject.title
          }
        ) }),
        /* @__PURE__ */ jsx(PopoverDropdown, { p: 0, miw: 250, maw: 400, children: /* @__PURE__ */ jsx(ScrollAreaAutosize, { mah: "70vh", scrollbars: "y", type: "never", viewportRef: viewport, children: /* @__PURE__ */ jsx(
          Tree,
          {
            allowRangeSelection: !1,
            selectOnClick: !1,
            tree,
            data,
            classNames: classes,
            levelOffset: 8,
            styles: {
              label: {
                paddingTop: 5,
                paddingBottom: 6
              }
            },
            renderNode: ({ node: node2, selected: selected2, expanded, elementProps, hasChildren }) => /* @__PURE__ */ jsxs(Group, { gap: 2, wrap: "nowrap", ...elementProps, py: "3", children: [
              /* @__PURE__ */ jsx(
                ActionIcon$1,
                {
                  variant: "subtle",
                  size: 18,
                  c: "dimmed",
                  style: {
                    visibility: hasChildren ? "visible" : "hidden"
                  },
                  children: /* @__PURE__ */ jsx(
                    IconChevronRight,
                    {
                      stroke: 3.5,
                      style: {
                        transition: "transform 150ms ease",
                        transform: `rotate(${expanded ? "90deg" : "0"})`,
                        width: "80%"
                      }
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsx(
                Box,
                {
                  flex: "1 1 100%",
                  w: "100%",
                  onClick: (e2) => {
                    e2.stopPropagation(), onSelect(node2.value), tree.select(node2.value), tree.expand(node2.value);
                  },
                  children: /* @__PURE__ */ jsx(
                    Text$6,
                    {
                      fz: "sm",
                      fw: selected2 ? "600" : "400",
                      truncate: "end",
                      children: node2.label
                    }
                  )
                }
              )
            ] })
          }
        ) }) })
      ]
    }
  );
}, columns = ["incomers", "subjects", "outgoers"], Sizes = {
  dagre: {
    ranksep: 60,
    nodesep: 35,
    edgesep: 25
  },
  edgeLabel: {
    width: 120,
    height: 10,
    minlen: 1,
    weight: 1
  },
  emptyNodeOffset: 120,
  nodeWidth: 320,
  hodeHeight: 180,
  // Spacer between elements in a compound node
  // 0 means no spacer
  spacerHeight: 0,
  compound: {
    labelHeight: 1,
    paddingTop: 50,
    paddingBottom: 32
  }
}, ZIndexes = {
  empty: 2,
  compound: 2,
  edge: 3,
  element: 4,
  max: 5
};
function createGraph() {
  const g2 = new dagre$1.graphlib.Graph({
    directed: !0,
    compound: !0
  });
  return g2.setGraph({
    ...Sizes.dagre,
    rankdir: "LR"
  }), g2.setDefaultEdgeLabel(() => ({ ...Sizes.edgeLabel })), g2.setDefaultNodeLabel(() => ({})), g2;
}
const sized = (height = Sizes.hodeHeight) => ({
  width: Sizes.nodeWidth,
  height
}), graphId = (node2) => ({
  id: node2.id,
  port: node2.type === "compound" ? `${node2.id}::port` : node2.id,
  body: `${node2.id}`,
  spacer: `${node2.id}:spacer`
});
function nodeData(element, ctx) {
  var _a4;
  let diagramNode = ctx.diagramNodes.get(element.id);
  const ancestor = diagramNode ?? (ctx.scope === "view" ? x$2(
    element.ancestors(),
    m$2((ancestor2) => ctx.diagramNodes.get(ancestor2.id)),
    T$1(n$4),
    d$1()
  ) : void 0);
  return {
    fqn: element.id,
    existsInCurrentView: ctx.diagramNodes.has(element.id),
    element: {
      kind: element.kind,
      title: (diagramNode == null ? void 0 : diagramNode.title) ?? element.title,
      description: (diagramNode == null ? void 0 : diagramNode.description) ?? element.element.description,
      color: (diagramNode == null ? void 0 : diagramNode.color) ?? (ancestor == null ? void 0 : ancestor.color) ?? element.color,
      shape: (diagramNode == null ? void 0 : diagramNode.shape) ?? element.shape
    },
    navigateTo: (diagramNode == null ? void 0 : diagramNode.navigateTo) ?? ((_a4 = d$1(element.viewsOf())) == null ? void 0 : _a4.id) ?? null,
    ports: {
      left: [],
      right: []
    }
  };
}
function createEmptyNode(column, ctx) {
  const id2 = `${column}__empty`, xynodes = ctx.columns[column];
  let node2 = xynodes.get(id2);
  if (node2)
    return invariant$1(node2.type === "empty", "Node is not empty"), node2;
  const xynode = {
    type: "empty",
    id: id2,
    position: { x: 0, y: 0 },
    data: {
      column
    },
    zIndex: ZIndexes.empty
  };
  xynodes.set(id2, xynode);
  const k2 = graphId(xynode), emptyContainer = id2 + "__container";
  return ctx.g.setNode(emptyContainer, {}), ctx.g.setNode(k2.id, {
    width: Sizes.nodeWidth - 20,
    height: Sizes.hodeHeight
  }), ctx.g.setParent(k2.id, emptyContainer), xynode;
}
function createNode(column, nodeType, element, ctx, depth = 0) {
  const xynodes = ctx.columns[column];
  let node2 = xynodes.get(element.id);
  if (node2) {
    if (invariant$1(node2.type !== "empty", `Unexpected empty Node type ${element.id}: ${node2.type}, expect ${nodeType}`), node2.type === "element" && nodeType === "compound")
      throw new Error(`Unexpected Node type ${element.id}: ${node2.type}, expect ${nodeType}`);
    return node2;
  }
  const g2 = ctx.g, parent = x$2(
    element.ancestors(),
    u$7((ancestor) => !isAncestor(ancestor.id, ctx.subjectId)),
    f$1(
      (ancestor) => ctx.diagramNodes.has(ancestor.id) || ctx.connected[column].has(ancestor.id) || ctx.scope === "global" && ctx.subjectElement.ascendingSiblings().some((s2) => s2.id === ancestor.id)
    ),
    (found) => found ? createNode(column, "compound", found, ctx, depth + 2) : null
  ), xynode = {
    type: nodeType,
    id: `${column}::${element.id}`,
    position: { x: 0, y: 0 },
    data: {
      ...nodeData(element, ctx),
      column
    },
    zIndex: ZIndexes[nodeType],
    ...!!parent && { parentId: parent.id }
  };
  xynodes.set(element.id, xynode);
  const k2 = graphId(xynode);
  return g2.setNode(k2.id, sized()), xynode.type === "compound" && (g2.setNode(k2.port, {
    width: Sizes.nodeWidth - Sizes.dagre.ranksep,
    height: Sizes.compound.labelHeight
  }), g2.setParent(k2.port, k2.id)), parent && (parent.data.depth = Math.min(Math.max(parent.data.depth ?? 0, depth + 1), 6), g2.setParent(k2.id, graphId(parent).body)), xynode;
}
function applyDagreLayout(g2) {
  return dagre$1.layout(g2), function(nodeId) {
    const { x: x2, y: y2, width: width2, height } = g2.node(nodeId);
    return {
      position: {
        x: x2 - Math.round(width2 / 2),
        y: y2 - Math.round(height / 2)
      },
      width: width2,
      height
    };
  };
}
function addEdge(ctx, props) {
  var _a4;
  const { source, target, relations, includedInCurrentView } = props, ids = relations.map((r2) => r2.id).join("_"), label2 = ((_a4 = t$5(relations)) == null ? void 0 : _a4.title) ?? "untitled", isMultiple = relations.length > 1, edge = {
    id: `rel${ctx.edges.length + 1}_${ids}`,
    type: "relation",
    source,
    target,
    sourceHandle: target,
    targetHandle: source,
    data: {
      includedInCurrentView,
      relations
    },
    label: isMultiple ? `${relations.length} relationships` : label2,
    zIndex: ZIndexes.edge,
    markerEnd: {
      type: MarkerType.ArrowClosed,
      width: isMultiple ? 7 : 9
    },
    style: {
      strokeWidth: isMultiple ? 5 : 2.8,
      strokeDasharray: isMultiple ? void 0 : "5, 5"
    }
  };
  ctx.edges.push(edge);
}
function findNodeOrFirstAncestor(fqn2, nodes) {
  let node2 = nodes.get(fqn2), parent = fqn2;
  for (; !node2 && (parent = parentFqn(parent)); )
    node2 = nodes.get(parent);
  return node2;
}
function layout(subjectId, view, likec4model, scope) {
  const diagramNodes = new Map(view.nodes.map((n2) => [n2.id, n2])), subjectElement = likec4model.element(subjectId), viewIncludesSubject = diagramNodes.has(subjectId), viewRelationships = new Set(
    view.edges.flatMap((e2) => e2.relations)
  ), notIncludedRelations = /* @__PURE__ */ new Set();
  viewIncludesSubject ? u$4([
    ...subjectElement.incoming().map((r2) => r2.id),
    ...subjectElement.outgoing().map((r2) => r2.id)
  ], (relationId) => {
    viewRelationships.has(relationId) || notIncludedRelations.add(relationId);
  }) : scope = "global";
  let relationships;
  if (scope === "global")
    relationships = {
      incoming: subjectElement.incoming().map((r2) => r2.relationship),
      outgoing: subjectElement.outgoing().map((r2) => r2.relationship)
    };
  else {
    const subjectViewModel = likec4model.view(view.id).element(subjectId);
    relationships = {
      incoming: subjectViewModel.incoming().flatMap((c) => c.relationships().map((r2) => r2.relationship)),
      outgoing: subjectViewModel.outgoing().flatMap((c) => c.relationships().map((r2) => r2.relationship))
    };
  }
  const g2 = createGraph(), ctx = {
    scope,
    g: g2,
    diagramNodes,
    subjectElement,
    subjectId,
    connected: {
      incomers: /* @__PURE__ */ new Set(),
      outgoers: /* @__PURE__ */ new Set(),
      subjects: /* @__PURE__ */ new Set([subjectId])
    },
    columns: {
      incomers: /* @__PURE__ */ new Map(),
      subjects: /* @__PURE__ */ new Map(),
      outgoers: /* @__PURE__ */ new Map()
    },
    edges: []
  };
  if (relationships.incoming.forEach((incoming) => {
    ctx.connected.incomers.add(incoming.source), ctx.connected.subjects.add(incoming.target);
  }), relationships.outgoing.forEach((outgoing) => {
    ctx.connected.subjects.add(outgoing.source), ctx.connected.outgoers.add(outgoing.target);
  }), viewIncludesSubject) {
    const subjectViewModel = likec4model.view(view.id).element(subjectId);
    subjectViewModel.incomers().forEach((incomer) => {
      ctx.connected.incomers.add(incomer.id);
    }), subjectViewModel.outgoers().forEach((outgoer) => {
      ctx.connected.outgoers.add(outgoer.id);
    });
  }
  columns.forEach((column) => {
    x$2(
      [...ctx.connected[column].values()],
      m$2((id2) => likec4model.element(id2)),
      m$3((a2, b2) => -1 * compareNatural(a2.title, b2.title)),
      m$3(compareByFqnHierarchically),
      t$7(),
      u$4((element) => {
        createNode(column, "element", element, ctx);
      })
    );
  }), x$2(
    [
      // Process incoming
      {
        sources: ctx.columns.incomers,
        targets: ctx.columns.subjects,
        relationships: relationships.incoming.sort(compareRelations).reverse()
      },
      // Process outgoing
      {
        sources: ctx.columns.subjects,
        targets: ctx.columns.outgoers,
        relationships: relationships.outgoing.sort(compareRelations).reverse()
      }
    ],
    /**
     * We select relationships, sources and targets
     * If sourece or target of the relationship is not found - take first ancestor
     */
    u$5(({ sources, targets, relationships: relationships2 }) => relationships2.map((relation) => {
      const source = findNodeOrFirstAncestor(relation.source, sources);
      if (!source || source.type === "empty")
        return null;
      const target = findNodeOrFirstAncestor(relation.target, targets);
      return !target || target.type === "empty" ? null : {
        relation,
        source,
        target,
        includedInCurrentView: viewRelationships.has(relation.id),
        id: `${source.id}:${target.id}`
      };
    })),
    T$1(l$2),
    // Group relations with saame source and target - make them one edge
    i$2(p$4("id")),
    i$3((grouped) => {
      const { source, target } = grouped[0], relations = m$2(grouped, (g22) => g22.relation);
      source.data.ports.right.push({
        id: target.id,
        type: "out"
      }), target.data.ports.left.push({
        id: source.id,
        type: "in"
      }), source.type === "compound" || target.type, g2.setEdge(graphId(source).port, graphId(target).port, {
        ...Sizes.edgeLabel
        // weight: isAnyCompound ? 1 : 2
      }), addEdge(ctx, {
        // if view does not include subject - do not highlight
        includedInCurrentView: !viewIncludesSubject || grouped.every((g22) => g22.includedInCurrentView),
        source: source.id,
        target: target.id,
        relations
      });
    })
  );
  const subjectPort = graphId(ctx.columns.subjects.get(subjectId)).port;
  if (ctx.columns.incomers.size == 0) {
    const source = createEmptyNode("incomers", ctx);
    g2.setEdge(graphId(source).port, subjectPort);
  }
  if (ctx.columns.outgoers.size == 0) {
    const target = createEmptyNode("outgoers", ctx);
    g2.setEdge(subjectPort, graphId(target).port);
  }
  for (const subject of ctx.columns.subjects.values()) {
    if (subject.type !== "element")
      continue;
    const subjectPortsCount = Math.max(subject.data.ports.left.length, subject.data.ports.right.length);
    subjectPortsCount > 2 && (g2.node(subject.id).height = Sizes.hodeHeight + (subjectPortsCount - 3) * 14);
  }
  const dagreBounds = applyDagreLayout(ctx.g), xynodes = [
    ...ctx.columns.incomers.values(),
    ...ctx.columns.subjects.values(),
    ...ctx.columns.outgoers.values()
  ], _calculatedNodeBounds = x$2(
    xynodes,
    T$1((n2) => n2.type !== "compound"),
    l$3((n2) => [n2.id, dagreBounds(n2.id)])
  );
  function nodeBounds(nodeId) {
    return _calculatedNodeBounds[nodeId] ?? (_calculatedNodeBounds[nodeId] = x$2(
      xynodes,
      T$1((n2) => n2.parentId === nodeId),
      m$2((n2) => nodeBounds(n2.id)),
      r$4((bounds) => {
        invariant$1(bounds.length > 0, `Node ${nodeId} has no nested nodes`);
      }),
      l$4((acc, bounds) => ({
        minY: Math.min(acc.minY, bounds.position.y),
        maxY: Math.max(acc.maxY, bounds.position.y + bounds.height)
      }), { minY: 1 / 0, maxY: -1 / 0 }),
      ({ minY, maxY }) => {
        const {
          position: { x: x2 },
          width: width2
        } = dagreBounds(nodeId);
        return minY = minY - Sizes.compound.paddingTop, maxY = maxY + Sizes.compound.paddingBottom, {
          position: {
            x: x2,
            y: minY
          },
          width: width2,
          height: maxY - minY
        };
      }
    ));
  }
  for (const node2 of xynodes) {
    const { position: position2, width: width2, height } = nodeBounds(node2.id);
    if (node2.width = width2, node2.height = height, node2.position = position2, node2.parentId) {
      const parentPos = nodeBounds(node2.parentId).position;
      node2.position = {
        x: position2.x - parentPos.x,
        y: position2.y - parentPos.y
      };
    }
  }
  const sortedPorts = (ports) => x$2(
    ports,
    m$2((port) => ({
      port,
      topY: nodeBounds(port.id).position.y
    })),
    a$3(p$4("topY")),
    m$2(p$4("port"))
  );
  for (const node2 of xynodes) {
    if (node2.type === "empty") {
      const subjectBounds = nodeBounds(nonNullable(ctx.columns.subjects.get(subjectId), "Subject node is missing").id);
      if (node2.height = Math.min(subjectBounds.height, 300), node2.position.y = subjectBounds.position.y + subjectBounds.height / 2 - node2.height / 2, node2.data.column === "incomers")
        node2.width = subjectBounds.position.x - Sizes.emptyNodeOffset - node2.position.x;
      else {
        const rightX = node2.position.x + node2.width;
        node2.position.x = subjectBounds.position.x + subjectBounds.width + Sizes.emptyNodeOffset, node2.width = rightX - node2.position.x;
      }
      continue;
    }
    node2.data.ports.left.length > 1 && (node2.data.ports.left = sortedPorts(node2.data.ports.left)), node2.data.ports.right.length > 1 && (node2.data.ports.right = sortedPorts(node2.data.ports.right));
  }
  return {
    viewIncludesSubject,
    notIncludedRelations: notIncludedRelations.size,
    subject: subjectElement,
    edges: ctx.edges,
    nodes: xynodes,
    bounds: {
      x: 0,
      y: 0,
      width: g2.graph().width ?? 100,
      height: g2.graph().height ?? 100
    }
  };
}
function useLayoutedRelationships(subjectId, view, scope) {
  const likec4model = useLikeC4Model(!0);
  return useMemo(() => layout(
    subjectId,
    view,
    likec4model,
    scope
  ), [
    subjectId,
    view,
    likec4model,
    layout,
    scope
  ]);
}
var elementNode = "_17dfyw90", elementNodeContent = "_17dfyw91", elementNodeTitle = "_17dfyw92", elementNodeDescription = "_17dfyw93", compoundNodeBody = "_17dfyw94", compoundNodeTitle = "_17dfyw95", cssShapeSvg = "_17dfyw96", edgeContainer = "_17dfyw97", edgeLabel$1 = "_17dfyw98 _17dfyw97", edgeLabelText$1 = "_17dfyw99", edgeLabelTechnology = "_17dfyw9a", emptyNode = "_17dfyw9b", navigateBtnBox = "_17dfyw9c", navigateBtn$1 = "_17dfyw9d";
const Text$3 = Text$6.withProps({
  component: "div"
}), CompoundNode = memo$1(({
  id: id2,
  data: {
    element,
    ports,
    layoutId = id2,
    leaving = !1,
    initialAnimation = !0,
    ...data
  },
  width: width2 = 200,
  height = 100,
  ...props
}) => {
  const scale2 = (diff) => ({
    scaleX: (width2 + diff) / width2,
    scaleY: (height + diff) / height
  });
  let opacity = 1;
  data.dimmed && (opacity = data.dimmed === "immediate" ? 0.05 : 0.15), leaving && (opacity = 0);
  const {
    elementsSelectable
  } = useStore$2(
    useCallback((s2) => ({
      elementsSelectable: s2.elementsSelectable
    }), []),
    shallowEqual
  ), selectable = props.selectable ?? elementsSelectable;
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      m$1.div,
      {
        className: clsx([
          compoundNodeBody,
          "likec4-compound-node"
        ]),
        layoutId,
        "data-compound-depth": data.depth ?? 1,
        "data-likec4-color": element.color,
        initial: layoutId === id2 && initialAnimation ? {
          ...scale2(-20),
          opacity: 0,
          width: width2,
          height
        } : !1,
        animate: {
          ...scale2(0),
          opacity,
          width: width2,
          height,
          transition: {
            opacity: {
              delay: !leaving && data.dimmed === !0 ? 0.4 : 0,
              ...(leaving || data.dimmed === "immediate") && {
                duration: 0.09
              }
            }
          }
        },
        ...selectable && {
          whileHover: {
            ...scale2(12),
            scaleX: (width2 + 12) / width2,
            scaleY: (height + 12) / height,
            transition: {
              delay: 0.1
            }
          },
          whileTap: {
            ...scale2(-12)
          }
        },
        children: /* @__PURE__ */ jsx(Text$3, { className: compoundNodeTitle, maw: width2 - 20, children: element.title })
      }
    ),
    ports.left.map(({ id: id22, type }, i2) => /* @__PURE__ */ jsx(
      Handle,
      {
        id: id22,
        type: type === "in" ? "target" : "source",
        position: Position.Left,
        style: {
          visibility: "hidden",
          top: `${20 * (i2 + 1)}px`
        }
      },
      id22
    )),
    ports.right.map(({ id: id22, type }, i2) => /* @__PURE__ */ jsx(
      Handle,
      {
        id: id22,
        type: type === "in" ? "target" : "source",
        position: Position.Right,
        style: {
          visibility: "hidden",
          top: `${20 * (i2 + 1)}px`
        }
      },
      id22
    ))
  ] });
}, (prev, next) => deepEqual$1(prev.data, next.data)), Action$1 = ActionIcon$1.withProps({
  className: "nodrag nopan " + navigateBtn$1,
  radius: "md",
  role: "button",
  onDoubleClick: stopPropagation$1,
  onPointerDownCapture: stopPropagation$1
}), Text$2 = Text$6.withProps({
  component: "div"
});
function selector$5(s2) {
  return {
    currentViewId: s2.view.id,
    onNavigateTo: s2.onNavigateTo,
    onOpenSource: s2.onOpenSourceElement
  };
}
const ElementNode = memo$1(({
  id: id2,
  data: {
    element,
    ports,
    navigateTo,
    layoutId = id2,
    leaving = !1,
    initialAnimation = !0,
    ...data
  },
  selectable = !0,
  width: w2 = 100,
  height: h2 = 100
}) => {
  const overlay = useOverlayDialog(), {
    currentViewId,
    onNavigateTo,
    onOpenSource
  } = useDiagramState(selector$5), scale2 = (diff) => ({
    scaleX: (w2 + diff) / w2,
    scaleY: (h2 + diff) / h2
  });
  let opacity = 1;
  return data.dimmed && (opacity = data.dimmed === "immediate" ? 0.05 : 0.15), leaving && (opacity = 0), /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsxs(
      m$1.div,
      {
        className: clsx([
          elementNode,
          "likec4-element-node"
        ]),
        layoutId,
        "data-likec4-color": element.color,
        initial: layoutId === id2 && initialAnimation ? {
          ...scale2(-20),
          opacity: 0,
          width: w2,
          height: h2
        } : !1,
        animate: {
          ...scale2(0),
          opacity,
          width: w2,
          height: h2,
          transition: {
            opacity: {
              delay: !leaving && data.dimmed === !0 ? 0.4 : 0,
              ...(leaving || data.dimmed === "immediate") && {
                duration: 0.09
              }
            }
          }
        },
        ...selectable && {
          whileHover: {
            ...scale2(16)
            // transition: {
            //   delay: 0.1
            // }
          },
          whileTap: {
            ...scale2(-8)
          }
        },
        children: [
          /* @__PURE__ */ jsx(
            "svg",
            {
              className: clsx(
                cssShapeSvg
              ),
              viewBox: `0 0 ${w2} ${h2}`,
              width: w2,
              height: h2,
              children: /* @__PURE__ */ jsx(ElementShapeSvg, { shape: element.shape, w: w2, h: h2 })
            }
          ),
          /* @__PURE__ */ jsxs(Box, { className: elementNodeContent, children: [
            /* @__PURE__ */ jsx(Text$2, { className: elementNodeTitle, lineClamp: 2, children: element.title }),
            element.description && /* @__PURE__ */ jsx(Text$2, { className: elementNodeDescription, lineClamp: 4, children: element.description })
          ] }),
          /* @__PURE__ */ jsxs(Group, { className: navigateBtnBox, children: [
            navigateTo && onNavigateTo && navigateTo !== currentViewId && /* @__PURE__ */ jsx(
              Action$1,
              {
                onClick: (event) => {
                  event.stopPropagation(), overlay.close(() => onNavigateTo(navigateTo));
                },
                children: /* @__PURE__ */ jsx(IconZoomScan, { stroke: 1.8, style: { width: "75%" } })
              }
            ),
            data.column !== "subjects" && /* @__PURE__ */ jsx(
              Action$1,
              {
                onClick: (event) => {
                  event.stopPropagation(), overlay.openOverlay({
                    relationshipsOf: data.fqn
                  });
                },
                children: /* @__PURE__ */ jsx(IconTransform, { stroke: 1.8, style: { width: "72%" } })
              }
            ),
            onOpenSource && /* @__PURE__ */ jsx(
              Action$1,
              {
                onClick: (event) => {
                  event.stopPropagation(), onOpenSource(data.fqn);
                },
                children: /* @__PURE__ */ jsx(IconFileSymlink, { stroke: 1.8, style: { width: "72%" } })
              }
            )
          ] })
        ]
      }
    ),
    ports.left.map(({ id: id22, type }, i2) => /* @__PURE__ */ jsx(
      Handle,
      {
        id: id22,
        type: type === "in" ? "target" : "source",
        position: Position.Left,
        style: {
          visibility: "hidden",
          top: `${15 + (i2 + 1) * ((h2 - 30) / (ports.left.length + 1))}px`
        }
      },
      id22
    )),
    ports.right.map(({ id: id22, type }, i2) => /* @__PURE__ */ jsx(
      Handle,
      {
        id: id22,
        type: type === "in" ? "target" : "source",
        position: Position.Right,
        style: {
          visibility: "hidden",
          top: `${15 + (i2 + 1) * ((h2 - 30) / (ports.right.length + 1))}px`
        }
      },
      id22
    ))
  ] });
}, (prev, next) => deepEqual$1(prev.data, next.data)), Text$1 = Text$6.withProps({
  component: "div"
});
function EmptyNode({
  data: {
    column
  }
}) {
  return /* @__PURE__ */ jsx(Box, { className: emptyNode, children: /* @__PURE__ */ jsxs(Text$1, { c: "dimmed", fz: "lg", fw: 500, children: [
    "No ",
    column === "incomers" ? "incoming" : "outgoing"
  ] }) });
}
const Tooltip$4 = Tooltip$5.withProps({
  color: "dark",
  fz: "sm",
  openDelay: 400,
  closeDelay: 150,
  withinPortal: !1,
  label: "",
  children: null,
  offset: 4
});
function RelationshipEdge$1({
  data,
  label: label2,
  ...props
}) {
  var _a4, _b2;
  const {
    viewId,
    onNavigateTo
  } = useDiagramState((s2) => ({
    viewId: s2.view.id,
    onNavigateTo: s2.onNavigateTo
  })), overlay = useOverlayDialog(), [edgePath, labelX, labelY] = getBezierPath(props), navigateTo = onNavigateTo ? (_a4 = t$5(data.relations)) == null ? void 0 : _a4.navigateTo : void 0, isMultiRelation = data.relations.length > 1, technology2 = (_b2 = t$5(data.relations)) == null ? void 0 : _b2.technology;
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      "g",
      {
        className: edgeContainer,
        "data-edge-dimmed": data.dimmed,
        "data-edge-hovered": data.hovered,
        "data-likec4-color": data.includedInCurrentView ? "gray" : "amber",
        children: /* @__PURE__ */ jsx(
          BaseEdge,
          {
            path: edgePath,
            ...props
          }
        )
      }
    ),
    /* @__PURE__ */ jsx(EdgeLabelRenderer, { children: /* @__PURE__ */ jsxs(
      Stack$1,
      {
        gap: 2,
        style: {
          position: "absolute",
          transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,
          maxWidth: Math.abs(props.targetX - props.sourceX - 70),
          zIndex: ZIndexes.max
        },
        className: clsx([
          edgeLabel$1,
          "nodrag nopan"
        ]),
        "data-edge-dimmed": data.dimmed,
        "data-edge-hovered": data.hovered,
        "data-likec4-color": data.includedInCurrentView ? "gray" : "amber",
        children: [
          label2 && /* @__PURE__ */ jsx(Tooltip$4, { label: "Not included in current view", disabled: data.includedInCurrentView, color: "orange", children: /* @__PURE__ */ jsxs(Group, { gap: 6, wrap: "nowrap", children: [
            isMultiRelation && /* @__PURE__ */ jsx(ThemeIcon, { size: "sm", variant: "transparent", color: "orange", children: /* @__PURE__ */ jsx(IconBoxMultipleFilled, { style: { width: "80%" } }) }),
            /* @__PURE__ */ jsx(
              Text$6,
              {
                fw: isMultiRelation ? "500" : "400",
                style: {
                  whiteSpace: isMultiRelation ? "nowrap" : void 0
                },
                component: "div",
                className: edgeLabelText$1,
                lineClamp: 3,
                children: label2
              }
            )
          ] }) }),
          technology2 && /* @__PURE__ */ jsxs(Text$6, { component: "div", className: edgeLabelTechnology, children: [
            "[ ",
            technology2,
            " ]"
          ] }),
          navigateTo && viewId !== navigateTo && /* @__PURE__ */ jsx(Box, { ta: "center", mt: 4, children: /* @__PURE__ */ jsx(
            ActionIcon$1,
            {
              variant: "default",
              size: "sm",
              radius: "sm",
              onPointerDownCapture: stopPropagation$1,
              onClick: (event) => {
                event.stopPropagation(), overlay.close(() => {
                  onNavigateTo == null || onNavigateTo(navigateTo, event);
                });
              },
              role: "button",
              onDoubleClick: stopPropagation$1,
              children: /* @__PURE__ */ jsx(IconZoomScan, {})
            }
          ) })
        ]
      }
    ) })
  ] });
}
const nodeTypes$1 = {
  element: ElementNode,
  compound: CompoundNode,
  empty: EmptyNode
}, edgeTypes$1 = {
  relation: RelationshipEdge$1
}, findRootSubject = (nodes) => nodes.find((n2) => n2.data.column === "subjects" && n$2(n2.parentId)), resetDimmedAndHovered = (xyflow2) => {
  xyflow2.setEdges(
    (edges) => edges.map((edge) => ({
      ...edge,
      data: {
        ...edge.data,
        dimmed: !1,
        hovered: !1
      },
      animated: !1
    }))
  ), xyflow2.setNodes(
    (nodes) => nodes.map(
      (n2) => ({
        ...n2,
        data: {
          ...n2.data,
          dimmed: !1,
          hovered: !1
        }
      })
    )
  );
}, animateEdge = (node2, animated = !0) => (edges) => edges.map((edge) => {
  const isConnected = edge.source === node2.id || edge.target === node2.id || isAncestor(node2.id, edge.source) || isAncestor(node2.id, edge.target);
  return {
    ...edge,
    animated: animated && isConnected
  };
}), selectContainerViewport = (s2) => `${s2.width}x${s2.height}`;
function RelationshipsXYFlowWrapped({
  subjectId,
  view,
  nodes,
  edges,
  bounds,
  children: children2,
  maxZoom = 2,
  minZoom = 0.05,
  viewportPadding = 0.1,
  ...rest
}) {
  const id2 = useId$1(), lastClickedNodeRef = useRef(null), xyflow2 = useReactFlow(), xystore = useStoreApi(), [zoomOnDoubleClick, setZoomOnDoubleClick] = useState(!0), containerviewport = useStore$2(selectContainerViewport);
  useOnViewportChange({
    onEnd: ({ x: x2, y: y2, zoom: zoom2 }) => {
      const roundedX = Math.round(x2), roundedY = Math.round(y2);
      (x2 !== roundedX || y2 !== roundedY) && xystore.setState({ transform: [roundedX, roundedY, zoom2] }), setZoomOnDoubleClick(zoom2 < 0.7);
    }
  });
  const initialFitviewFlagRef = useRef(!1), viewBoundsRef = useSyncedRef(bounds), fitview = useDebouncedCallback(
    () => {
      const { width: width2, height } = xystore.getState();
      xyflow2.setViewport(
        getViewportForBounds(viewBoundsRef.current, width2, height, minZoom, maxZoom, viewportPadding),
        initialFitviewFlagRef.current ? { duration: 500 } : void 0
      ), initialFitviewFlagRef.current = !0;
    },
    [xyflow2, minZoom, maxZoom, viewportPadding],
    100
  );
  return useUpdateEffect(() => {
    fitview();
  }, [containerviewport]), useDeepCompareEffect(() => {
    const {
      nodes: _nodes,
      edges: _edges,
      setNodes,
      setEdges,
      width: width2,
      height
    } = xystore.getState(), nextSubjectNode = findRootSubject(nodes), currentSubjectNode = findRootSubject(_nodes);
    if (currentSubjectNode && (nextSubjectNode == null ? void 0 : nextSubjectNode.data.fqn) === currentSubjectNode.data.fqn) {
      setNodes(m$2(nodes, s$2(["data", "initialAnimation"], !1))), setEdges(edges), fitview();
      return;
    }
    nextSubjectNode ? nextSubjectNode.data.fqn !== subjectId && console.error(`Subject node mismatch, expected: ${subjectId} got: ${nextSubjectNode.data.fqn}`) : console.error("Subject node not found");
    const nextzoom = getViewportForBounds(bounds, width2, height, minZoom, maxZoom, viewportPadding).zoom, nextSubjectCenter = nextSubjectNode && {
      x: nextSubjectNode.position.x + (nextSubjectNode.width ?? 0) / 2,
      y: nextSubjectNode.position.y + (nextSubjectNode.height ?? 0) / 2
    }, existingNode = lastClickedNodeRef.current ?? xyflow2.getNodes().find((n2) => n2.type !== "empty" && n2.data.column !== "subjects" && n2.data.fqn === subjectId);
    if (lastClickedNodeRef.current = null, nextSubjectCenter && existingNode && currentSubjectNode) {
      const currentSubjectInternalNode = xyflow2.getInternalNode(currentSubjectNode.id), currentSubjectCenter = centerXYInternalNode(currentSubjectInternalNode), existingInternalNode = xyflow2.getInternalNode(existingNode.id), existingDimensions = getNodeDimensions(existingInternalNode);
      nextSubjectNode.data.layoutId = existingNode.id, setNodes(_nodes.map((n2) => n2.id !== existingNode.id ? {
        ...n2,
        data: {
          ...n2.data,
          leaving: n2.data.column === "subjects",
          dimmed: n2.data.column === "subjects" ? "immediate" : !1
        }
        // hidden: n.data.column === 'subjects'
      } : {
        ...y$5(n2, ["parentId"]),
        position: {
          x: currentSubjectCenter.x - existingDimensions.width / 2,
          y: currentSubjectCenter.y - existingDimensions.height / 2
        },
        zIndex: ZIndexes.max,
        data: {
          ...n2.data,
          leaving: !1,
          dimmed: !1
        }
      })), setEdges(_edges.map((e2) => ({
        ...e2,
        data: {
          ...e2.data,
          dimmed: "immediate"
        },
        hidden: e2.source === existingNode.id || e2.target === existingNode.id || isAncestor(existingNode.id, e2.source) || isAncestor(existingNode.id, e2.target)
      })));
      const zoom2 = Math.min(
        xyflow2.getViewport().zoom,
        nextzoom
      );
      let isCancelled = !1;
      return requestAnimationFrame(async () => {
        await delay$1(150), !isCancelled && (await xyflow2.setCenter(currentSubjectCenter.x, currentSubjectCenter.y, { zoom: zoom2, duration: 250 }), requestAnimationFrame(() => {
          isCancelled || (xyflow2.setCenter(nextSubjectCenter.x, nextSubjectCenter.y, { zoom: zoom2 }), setNodes(nodes), setEdges(edges), fitview());
        }));
      }), () => {
        isCancelled = !0;
      };
    }
    setNodes(m$2(nodes, s$2(["data", "initialAnimation"], !1))), setEdges(edges), fitview();
  }, [nodes, edges, subjectId]), /* @__PURE__ */ jsx(
    index$2,
    {
      id: id2,
      defaultEdges: [],
      defaultNodes: [],
      nodeTypes: nodeTypes$1,
      edgeTypes: edgeTypes$1,
      defaultMarkerColor: "var(--likec4-relation-lineColor)",
      className: cssReactflowMarker,
      zoomOnPinch: !0,
      zoomOnScroll: !1,
      zoomOnDoubleClick,
      maxZoom,
      minZoom,
      fitView: !0,
      fitViewOptions: {
        padding: viewportPadding,
        maxZoom,
        minZoom,
        includeHiddenNodes: !0
      },
      preventScrolling: !0,
      noDragClassName: "nodrag",
      noPanClassName: "nopan",
      panOnScroll: !0,
      panOnDrag: !0,
      nodesFocusable: !1,
      edgesFocusable: !1,
      nodesDraggable: !1,
      onNodeMouseEnter: (_, node2) => {
        node2.type !== "empty" && xyflow2.setEdges(animateEdge(node2, !0));
      },
      onNodeMouseLeave: () => {
        resetDimmedAndHovered(xyflow2);
      },
      onEdgeMouseEnter: (_, edge) => {
        xyflow2.setEdges(
          (edges2) => edges2.map((e2) => ({
            ...e2,
            data: {
              ...e2.data,
              dimmed: e2.id !== edge.id,
              hovered: e2.id === edge.id
            },
            zIndex: e2.id === edge.id ? ZIndexes.max : ZIndexes.edge,
            animated: e2.id === edge.id
          }))
        ), xyflow2.setNodes(
          (nodes2) => nodes2.map((n2) => ({
            ...n2,
            data: {
              ...n2.data,
              dimmed: n2.id !== edge.source && n2.id !== edge.target
            }
          }))
        );
      },
      onEdgeMouseLeave: () => {
        resetDimmedAndHovered(xyflow2);
      },
      onNodeDoubleClick: (e2) => {
        e2.stopPropagation();
      },
      ...!zoomOnDoubleClick && {
        onDoubleClick: (e2) => {
          e2.stopPropagation(), fitview();
        }
      },
      ...rest,
      children: children2
    }
  );
}
function RelationshipsXYFlow(props) {
  return /* @__PURE__ */ jsx(
    ReactFlowProvider,
    {
      defaultNodes: [],
      defaultEdges: [],
      children: /* @__PURE__ */ jsx(RelationshipsXYFlowWrapped, { ...props })
    }
  );
}
var fqn = "_6mj0ef0", relationshipStat = "_6mj0ef1", xyflow = "_6mj0ef2", panelScope = "_6mj0ef3";
function TabPanelRelationships({
  currentView,
  element
}) {
  const layoutId = useId$1(), enableRelationshipBrowser = useDiagramState((s2) => s2.enableRelationshipBrowser), overlay = useOverlayDialog(), [scope, setScope] = useState("view"), node2 = nonNullable(currentView.nodes.find((n2) => n2.id === element.id)), incoming = element.incoming().map((r2) => r2.id), outgoing = element.outgoing().map((r2) => r2.id), findRelationIds = (edgeId) => {
    var _a4;
    return ((_a4 = currentView.edges.find((edge) => edge.id === edgeId)) == null ? void 0 : _a4.relations) ?? [];
  }, incomingInView = i$9(node2.inEdges.flatMap(findRelationIds)), outgoingInView = i$9(node2.outEdges.flatMap(findRelationIds)), notIncludedRelations = [
    ...incoming,
    ...outgoing
  ].filter((r2) => !incomingInView.includes(r2) && !outgoingInView.includes(r2)).length, {
    edges,
    nodes,
    bounds
  } = useLayoutedRelationships(element.id, currentView, scope);
  return /* @__PURE__ */ jsxs(Stack$1, { gap: "xs", pos: "relative", w: "100%", h: "100%", children: [
    incoming.length + outgoing.length > 0 && /* @__PURE__ */ jsxs(Group, { gap: "xs", wrap: "nowrap", align: "center", children: [
      /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsxs(Group, { gap: 8, mb: 4, wrap: "nowrap", children: [
        /* @__PURE__ */ jsx(
          RelationshipsStat,
          {
            title: "incoming",
            total: incoming.length,
            included: incomingInView.length
          }
        ),
        /* @__PURE__ */ jsx(ThemeIcon, { size: "sm", variant: "transparent", c: "dimmed", children: /* @__PURE__ */ jsx(IconArrowRight, { style: { width: 16 } }) }),
        /* @__PURE__ */ jsx(Text$6, { className: fqn, children: nameFromFqn(element.id) }),
        /* @__PURE__ */ jsx(ThemeIcon, { size: "sm", variant: "transparent", c: "dimmed", children: /* @__PURE__ */ jsx(IconArrowRight, { style: { width: 16 } }) }),
        /* @__PURE__ */ jsx(
          RelationshipsStat,
          {
            title: "outgoing",
            total: outgoing.length,
            included: outgoingInView.length
          }
        )
      ] }) }),
      notIncludedRelations > 0 && /* @__PURE__ */ jsxs(
        Group,
        {
          mt: "xs",
          gap: 6,
          c: "orange",
          style: { cursor: "pointer" },
          children: [
            /* @__PURE__ */ jsx(IconInfoCircle, { style: { width: 14 } }),
            /* @__PURE__ */ jsxs(Text$6, { fz: "sm", children: [
              notIncludedRelations,
              " relationship",
              notIncludedRelations > 1 ? "s are" : " is",
              " hidden"
            ] })
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsx(Box, { className: xyflow, children: /* @__PURE__ */ jsx(LayoutGroup, { id: layoutId, children: /* @__PURE__ */ jsxs(
      RelationshipsXYFlow,
      {
        subjectId: element.id,
        bounds,
        nodes,
        edges,
        view: currentView,
        elementsSelectable: !1,
        children: [
          /* @__PURE__ */ jsx(Panel, { position: "top-left", className: panelScope, children: /* @__PURE__ */ jsx(
            SegmentedControl,
            {
              size: "xs",
              withItemsBorders: !1,
              value: scope,
              onChange: setScope,
              data: [
                { label: "Global", value: "global" },
                { label: "View", value: "view" }
              ]
            }
          ) }),
          enableRelationshipBrowser && /* @__PURE__ */ jsx(Panel, { position: "top-right", children: /* @__PURE__ */ jsx(
            Button,
            {
              size: "compact-sm",
              variant: "default",
              fz: "xs",
              fw: 500,
              rightSection: /* @__PURE__ */ jsx(IconExternalLink, { stroke: 1.6, style: { width: 16 } }),
              onClick: (e2) => {
                e2.stopPropagation(), overlay.close(() => {
                  overlay.openOverlay({
                    relationshipsOf: element.id
                  });
                });
              },
              children: "Open"
            }
          ) })
        ]
      }
    ) }) })
  ] });
}
function RelationshipsStat({
  title: title2,
  total,
  included
}) {
  return /* @__PURE__ */ jsx(
    Paper,
    {
      withBorder: !0,
      shadow: "none",
      className: relationshipStat,
      px: "md",
      py: "xs",
      radius: "md",
      mod: {
        zero: total === 0,
        missing: total !== included
      },
      children: /* @__PURE__ */ jsxs(Stack$1, { gap: 4, align: "flex-end", children: [
        /* @__PURE__ */ jsx(Text$6, { component: "div", c: total !== included ? "orange" : "dimmed", tt: "uppercase", fw: 600, fz: 10, lh: 1, children: title2 }),
        /* @__PURE__ */ jsx(Text$6, { fw: 600, fz: "xl", component: "div", lh: 1, children: total !== included ? /* @__PURE__ */ jsxs(Fragment, { children: [
          included,
          " / ",
          total
        ] }) : /* @__PURE__ */ jsx(Fragment, { children: total }) })
      ] })
    }
  );
}
var treeNodeLabel = "_14so4380", elementLabel = "_14so4381";
const ElementLabel = ({
  element
}) => /* @__PURE__ */ jsx(Box, { className: elementLabel, children: /* @__PURE__ */ jsx(Text$6, { component: "div", fz: "sm", fw: "500", children: element.title }) });
function TabElementStructure({
  element
}) {
  const tree = useTree({
    multiple: !1
  }), data = useMemo(() => {
    let seq = 1;
    const messageNode = (label2) => ({
      label: label2,
      value: `msg${seq++}`,
      type: "message",
      children: []
    }), current = {
      label: /* @__PURE__ */ jsx(ElementLabel, { type: "current", element }),
      value: element.id,
      element,
      type: "current",
      children: element.children().map((child) => ({
        label: /* @__PURE__ */ jsx(ElementLabel, { type: "descedant", element: child }),
        value: child.id,
        element: child,
        type: "descedant",
        children: []
      }))
    };
    return current.children.length === 0 && current.children.push(
      messageNode(/* @__PURE__ */ jsx(Pill, { radius: "sm", children: "no nested" }))
    ), [
      element.ancestors().reduce((acc, parent) => ({
        label: /* @__PURE__ */ jsx(ElementLabel, { type: "ancestor", element: parent }),
        value: parent.id,
        element: parent,
        type: "ancestor",
        children: [acc]
      }), current)
    ];
  }, [element]);
  return useEffect(() => {
    tree.expandAllNodes();
  }, [data]), /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsxs(Alert, { variant: "light", color: "orange", title: "In development", icon: /* @__PURE__ */ jsx(IconInfoCircle, {}), children: [
      "We need your feedback. Share your thoughts and ideas -",
      " ",
      /* @__PURE__ */ jsx(
        Anchor,
        {
          fz: "sm",
          fw: 500,
          underline: "hover",
          c: "orange",
          href: "https://github.com/likec4/likec4/discussions/",
          target: "_blank",
          children: "GitHub discussions"
        }
      )
    ] }),
    /* @__PURE__ */ jsx(
      Tree,
      {
        levelOffset: "xl",
        allowRangeSelection: !1,
        expandOnClick: !1,
        expandOnSpace: !1,
        classNames: {
          label: treeNodeLabel
        },
        data,
        tree
      }
    )
  ] });
}
const Divider = Divider$1.withProps({
  mb: 8,
  labelPosition: "left",
  variant: "dashed"
}), Tooltip$3 = Tooltip$5.withProps({
  color: "dark",
  fz: "xs",
  openDelay: 400,
  closeDelay: 150,
  label: "",
  children: null,
  offset: 4
}), SmallLabel = Text$6.withProps({
  component: "div",
  fz: 11,
  fw: 500,
  c: "dimmed",
  lh: 1
}), PropertyLabel = Text$6.withProps({
  component: "div",
  fz: "xs",
  c: "dimmed",
  className: propertyLabel
}), MIN_PADDING = 24;
function ElementDetailsCard({ fqn: fqn2 }) {
  var _a4;
  const windowSize = useViewportSize(), windowWidth = windowSize.width || window.innerWidth || 1200, windowHeight = windowSize.height || window.innerHeight || 800, xyflow2 = useXYFlow(), xynode = useInternalNode(fqn2);
  invariant$1(xynode, `XYNode with id ${fqn2} not found`);
  const overlay = useOverlayDialog(), [activeTab, setActiveTab] = useState("Properties"), diagramApi = useDiagramStoreApi(), {
    view: currentView,
    renderIcon,
    onNavigateTo,
    onOpenSourceElement: onOpenSource
  } = useDiagramState(i$6(["view", "renderIcon", "onNavigateTo", "onOpenSourceElement"])), element = currentView.nodes.find((n2) => n2.id === fqn2);
  invariant$1(element, `DiagramNode with fqn ${fqn2} not found`);
  const likec4Model = useLikeC4Model(!0), elementModel = likec4Model.element(fqn2), viewId = currentView.id, elementIcon2 = ElementIcon$1({
    element,
    viewId,
    renderIcon
  }), incoming = elementModel.incoming().map((r2) => r2.id), outgoing = elementModel.outgoing().map((r2) => r2.id), findRelationIds = (edgeId) => {
    var _a5;
    return ((_a5 = currentView.edges.find((edge) => edge.id === edgeId)) == null ? void 0 : _a5.relations) ?? [];
  }, incomingInView = i$9(element.inEdges.flatMap(findRelationIds)), outgoingInView = i$9(element.outEdges.flatMap(findRelationIds));
  [
    ...incoming,
    ...outgoing
  ].filter((r2) => !incomingInView.includes(r2) && !outgoingInView.includes(r2)).length;
  const [viewsOf, otherViews] = x$2(
    elementModel.views(),
    m$2((v2) => v2.view),
    d$3((v2) => v2.__ !== "dynamic" && v2.viewOf === fqn2)
  ), defaultView2 = element.navigateTo ? likec4Model.view(element.navigateTo).view : f$1(viewsOf, (v2) => v2.id !== currentView.id) ?? null, defaultLink = element.links && t$5(element.links), onNavigateToCb = useCallback((toView, e2) => {
    e2 == null || e2.stopPropagation();
    const { onNavigateTo: onNavigateTo2 } = diagramApi.getState();
    onNavigateTo2 && overlay.close(() => {
      diagramApi.setState({
        lastOnNavigate: {
          fromView: currentView.id,
          toView,
          fromNode: fqn2
        }
      }), onNavigateTo2(toView);
    });
  }, [fqn2, currentView.id]), controls = useDragControls(), isCompound = element.children.length > 0, fromPositon = xyflow2.flowToScreenPosition({
    x: xynode.internals.positionAbsolute.x + element.width / 2,
    y: xynode.internals.positionAbsolute.y + (isCompound ? 0 : element.height / 2)
  }), _width = Math.min(700, windowWidth - MIN_PADDING * 2), _height = Math.min(650, windowHeight - MIN_PADDING * 2), left = Math.round(
    u(fromPositon.x - _width / 2, {
      min: MIN_PADDING,
      max: windowWidth - _width - MIN_PADDING
    })
  ), top = Math.round(
    u(fromPositon.y - (isCompound ? 0 : 60), {
      min: MIN_PADDING,
      max: windowHeight - _height - MIN_PADDING
    })
  ), width2 = useMotionValue(_width), height = useMotionValue(_height), handleDrag = useCallback((_, info) => {
    width2.set(Math.max(width2.get() + info.delta.x, 320)), height.set(Math.max(height.get() + info.delta.y, 300));
  }, []), ref = useRef(null);
  return useEffect(() => {
    var _a5;
    (_a5 = ref.current) == null || _a5.showModal();
  }, []), /* @__PURE__ */ jsx(
    m$1.dialog,
    {
      ref,
      className: dialog,
      initial: {
        "--backdrop-blur": "0px",
        "--backdrop-opacity": "0%"
      },
      animate: {
        "--backdrop-blur": "1px",
        "--backdrop-opacity": "50%"
      },
      exit: {
        "--backdrop-blur": "0px",
        "--backdrop-opacity": "0%"
      },
      onClick: (e2) => {
        var _a5, _b2;
        ((_b2 = (_a5 = e2.target) == null ? void 0 : _a5.nodeName) == null ? void 0 : _b2.toUpperCase()) === "DIALOG" && (e2.stopPropagation(), overlay.close());
      },
      onClose: (e2) => {
        e2.stopPropagation(), overlay.close();
      },
      children: /* @__PURE__ */ jsx(RemoveScroll, { forwardProps: !0, children: /* @__PURE__ */ jsx(
        Card,
        {
          drag: !0,
          dragElastic: 0,
          dragMomentum: !1,
          dragListener: !1,
          dragControls: controls,
          withBorder: !0,
          shadow: "md",
          component: m$1.div,
          className: card$2,
          layoutId: `${viewId}:element:${fqn2}`,
          initial: {
            top,
            left,
            width: _width,
            height: _height,
            opacity: 0
          },
          animate: {
            opacity: 1
          },
          exit: {
            opacity: 0
          },
          style: {
            // `style` prop in Mantine doesn't accept motion values
            width: width2,
            height
          },
          onKeyDown: (e2) => {
            e2.key === "Escape" && (e2.preventDefault(), e2.stopPropagation(), overlay.close());
          },
          "data-likec4-color": element.color,
          children: /* @__PURE__ */ jsxs(FocusTrap, { children: [
            /* @__PURE__ */ jsx(FocusTrapInitialFocus, {}),
            /* @__PURE__ */ jsxs(
              Box,
              {
                className: cardHeader,
                onPointerDown: (e2) => controls.start(e2),
                children: [
                  /* @__PURE__ */ jsxs(Group, { align: "start", justify: "space-between", gap: "sm", mb: "sm", wrap: "nowrap", children: [
                    /* @__PURE__ */ jsxs(Group, { align: "start", gap: "sm", style: { cursor: "default" }, wrap: "nowrap", children: [
                      elementIcon2,
                      /* @__PURE__ */ jsxs(Box, { children: [
                        /* @__PURE__ */ jsx(
                          Text$6,
                          {
                            component: m$1.div,
                            layout: "position",
                            layoutId: `${viewId}:element:title:${fqn2}`,
                            className: title$3,
                            children: elementModel.title
                          }
                        ),
                        element.notation && /* @__PURE__ */ jsx(Text$6, { component: "div", c: "dimmed", fz: "sm", fw: 500, lh: 1.3, lineClamp: 1, children: element.notation })
                      ] })
                    ] }),
                    /* @__PURE__ */ jsx(
                      CloseButton,
                      {
                        size: "lg",
                        onClick: (e2) => {
                          e2.stopPropagation(), overlay.close();
                        }
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxs(Group, { align: "baseline", gap: "sm", wrap: "nowrap", children: [
                    /* @__PURE__ */ jsxs(Box, { children: [
                      /* @__PURE__ */ jsx(SmallLabel, { children: "kind" }),
                      /* @__PURE__ */ jsx(Badge, { radius: "sm", size: "sm", fw: 600, color: "gray", children: element.kind })
                    ] }),
                    /* @__PURE__ */ jsxs(Box, { flex: 1, children: [
                      /* @__PURE__ */ jsx(SmallLabel, { children: "tags" }),
                      /* @__PURE__ */ jsxs(Flex, { gap: 4, flex: 1, mt: 6, children: [
                        (_a4 = element.tags) == null ? void 0 : _a4.map((tag) => /* @__PURE__ */ jsxs(Badge, { radius: "sm", size: "sm", fw: 600, variant: "gradient", children: [
                          "#",
                          tag
                        ] }, tag)),
                        !element.tags && /* @__PURE__ */ jsx(Badge, { radius: "sm", size: "sm", fw: 600, color: "gray", children: "—" })
                      ] })
                    ] }),
                    /* @__PURE__ */ jsxs(
                      ActionIconGroup,
                      {
                        style: {
                          alignSelf: "flex-end"
                        },
                        children: [
                          defaultLink && /* @__PURE__ */ jsx(
                            ActionIcon$1,
                            {
                              component: "a",
                              href: defaultLink.url,
                              target: "_blank",
                              size: "lg",
                              variant: "default",
                              radius: "sm",
                              children: /* @__PURE__ */ jsx(IconExternalLink, { stroke: 1.6, style: { width: "65%" } })
                            }
                          ),
                          onOpenSource && /* @__PURE__ */ jsx(Tooltip$3, { label: "Open source", children: /* @__PURE__ */ jsx(
                            ActionIcon$1,
                            {
                              size: "lg",
                              variant: "default",
                              radius: "sm",
                              onClick: (e2) => {
                                var _a5, _b2;
                                e2.stopPropagation(), (_b2 = (_a5 = diagramApi.getState()).onOpenSourceElement) == null || _b2.call(_a5, fqn2);
                              },
                              children: /* @__PURE__ */ jsx(IconFileSymlink, { stroke: 1.8, style: { width: "62%" } })
                            }
                          ) }),
                          defaultView2 && /* @__PURE__ */ jsx(Tooltip$3, { label: "Open default view", children: /* @__PURE__ */ jsx(
                            ActionIcon$1,
                            {
                              size: "lg",
                              variant: "default",
                              radius: "sm",
                              onClick: (e2) => {
                                onNavigateToCb(defaultView2.id, e2);
                              },
                              children: /* @__PURE__ */ jsx(IconZoomScan, { style: { width: "70%" } })
                            }
                          ) })
                        ]
                      }
                    )
                  ] })
                ]
              }
            ),
            /* @__PURE__ */ jsxs(
              Tabs,
              {
                value: activeTab,
                onChange: (v2) => setActiveTab(v2),
                variant: "none",
                classNames: {
                  root: tabsRoot,
                  list: tabsList,
                  tab: tabsTab,
                  panel: tabsPanel
                },
                children: [
                  /* @__PURE__ */ jsxs(TabsList, { children: [
                    /* @__PURE__ */ jsx(TabsTab, { value: "Properties", children: "Properties" }),
                    /* @__PURE__ */ jsx(TabsTab, { value: "Relationships", children: "Relationships" }),
                    /* @__PURE__ */ jsx(TabsTab, { value: "Views", children: "Views" }),
                    /* @__PURE__ */ jsx(TabsTab, { value: "Structure", children: "Structure" })
                  ] }),
                  /* @__PURE__ */ jsx(TabsPanel, { value: "Properties", children: /* @__PURE__ */ jsx(ScrollArea, { scrollbars: "y", type: "auto", children: /* @__PURE__ */ jsxs(Box, { className: propertiesGrid, pt: "xs", children: [
                    /* @__PURE__ */ jsx(ElementProperty, { title: "description", emptyValue: "no description", children: element.description }),
                    element.technology && /* @__PURE__ */ jsx(ElementProperty, { title: "technology", children: element.technology }),
                    element.links && /* @__PURE__ */ jsxs(Fragment, { children: [
                      /* @__PURE__ */ jsx(PropertyLabel, { children: "links" }),
                      /* @__PURE__ */ jsx(Stack$1, { gap: "xs", align: "flex-start", children: element.links.map((link, i2) => /* @__PURE__ */ jsx(ElementLink, { value: link }, i2)) })
                    ] }),
                    elementModel.element.metadata && /* @__PURE__ */ jsx(ElementMetata, { value: elementModel.element.metadata })
                  ] }) }) }),
                  /* @__PURE__ */ jsx(TabsPanel, { value: "Relationships", children: activeTab === "Relationships" && /* @__PURE__ */ jsx(
                    TabPanelRelationships,
                    {
                      element: elementModel,
                      currentView
                    }
                  ) }),
                  /* @__PURE__ */ jsx(TabsPanel, { value: "Views", children: /* @__PURE__ */ jsx(ScrollArea, { scrollbars: "y", type: "auto", children: /* @__PURE__ */ jsxs(Stack$1, { gap: "lg", children: [
                    viewsOf.length > 0 && /* @__PURE__ */ jsxs(Box, { children: [
                      /* @__PURE__ */ jsx(Divider, { label: "views of the element (scoped)" }),
                      /* @__PURE__ */ jsx(Stack$1, { gap: "sm", children: viewsOf.map((view) => /* @__PURE__ */ jsx(
                        ViewButton,
                        {
                          view,
                          onNavigateTo: onNavigateToCb
                        },
                        view.id
                      )) })
                    ] }),
                    otherViews.length > 0 && /* @__PURE__ */ jsxs(Box, { children: [
                      /* @__PURE__ */ jsx(Divider, { label: "views including this element" }),
                      /* @__PURE__ */ jsx(Stack$1, { gap: "sm", children: otherViews.map((view) => /* @__PURE__ */ jsx(
                        ViewButton,
                        {
                          view,
                          onNavigateTo: onNavigateToCb
                        },
                        view.id
                      )) })
                    ] })
                  ] }) }) }),
                  /* @__PURE__ */ jsx(TabsPanel, { value: "Structure", children: /* @__PURE__ */ jsx(ScrollArea, { scrollbars: "y", type: "auto", children: /* @__PURE__ */ jsx(TabElementStructure, { element: elementModel }) }) })
                ]
              }
            ),
            /* @__PURE__ */ jsx(
              m$1.div,
              {
                className: resizeHandle,
                drag: !0,
                dragElastic: 0,
                dragMomentum: !1,
                onDrag: handleDrag,
                dragConstraints: { top: 0, left: 0, right: 0, bottom: 0 }
              }
            )
          ] })
        }
      ) })
    }
  );
}
const ElementIcon$1 = ({ element, viewId, renderIcon: RenderIcon }) => {
  if (!element.icon)
    return null;
  let icon = null;
  return element.icon.startsWith("http://") || element.icon.startsWith("https://") ? icon = /* @__PURE__ */ jsx("img", { src: element.icon, alt: element.title }) : RenderIcon && (icon = /* @__PURE__ */ jsx(RenderIcon, { node: element })), icon ? /* @__PURE__ */ jsx(
    m$1.div,
    {
      layoutId: `${viewId}:element:icon:${element.id}`,
      className: clsx(
        elementIcon$1,
        "likec4-element-icon"
      ),
      "data-likec4-icon": element.icon,
      children: icon
    }
  ) : null;
}, ViewButton = ({
  view,
  onNavigateTo
}) => /* @__PURE__ */ jsx(UnstyledButton, { className: viewButton, onClick: (e2) => onNavigateTo(view.id, e2), children: /* @__PURE__ */ jsxs(Group, { gap: 6, align: "start", wrap: "nowrap", children: [
  /* @__PURE__ */ jsx(ThemeIcon, { size: "sm", variant: "transparent", children: /* @__PURE__ */ jsx(IconZoomScan, { stroke: 1.8 }) }),
  /* @__PURE__ */ jsxs(Box, { children: [
    /* @__PURE__ */ jsx(Text$6, { component: "div", className: viewButtonTitle, lineClamp: 1, children: view.title || "untitled" }),
    view.description && /* @__PURE__ */ jsx(Text$6, { component: "div", mt: 2, fz: "xs", c: "dimmed", lh: 1.4, lineClamp: 1, children: view.description })
  ] })
] }) });
function ElementProperty({
  title: title2,
  emptyValue = "undefined",
  children: children2,
  style: style2,
  ...props
}) {
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(PropertyLabel, { children: title2 }),
    /* @__PURE__ */ jsx(
      Text$6,
      {
        component: "div",
        ...n$2(children2) && { c: "dimmed" },
        fz: "md",
        style: {
          whiteSpace: "preserve-breaks",
          ...style2
        },
        ...props,
        children: children2 || emptyValue
      }
    )
  ] });
}
function ElementLink({
  value
}) {
  const url = new URL(value.url, window.location.href).toString();
  return /* @__PURE__ */ jsx(CopyButton, { value: url, children: ({ copied, copy }) => /* @__PURE__ */ jsx(Anchor, { href: url, target: "_blank", underline: "never", className: elementLink, children: /* @__PURE__ */ jsxs(Group, { gap: 4, align: "center", wrap: "nowrap", children: [
    /* @__PURE__ */ jsx(
      ActionIcon$1,
      {
        tabIndex: -1,
        size: 24,
        variant: copied ? "light" : "subtle",
        color: copied ? "teal" : "gray",
        onClick: (e2) => {
          e2.stopPropagation(), e2.preventDefault(), copy();
        },
        children: copied ? /* @__PURE__ */ jsx(IconCheck, {}) : /* @__PURE__ */ jsx(IconCopy, { style: { width: "65%", opacity: 0.8 } })
      }
    ),
    /* @__PURE__ */ jsxs(Box, { flex: 1, children: [
      /* @__PURE__ */ jsx(Text$6, { fz: "sm", truncate: !0, lh: 1.3, fw: value.title ? 500 : 400, children: value.title || url }),
      value.title && /* @__PURE__ */ jsx(Text$6, { component: "div", fz: 10, c: "dimmed", lh: 1.2, truncate: !0, children: url })
    ] })
  ] }) }) });
}
function ElementMetata({
  value
}) {
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(PropertyLabel, { children: "metadata" }),
    /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(Code, { block: !0, children: JSON.stringify(value, null, 2) }) })
  ] });
}
const RelationshipsOverlay = memo$1(function({ subjectId }) {
  const view = useDiagramState((s2) => s2.view), [_scope, setScope] = useLocalStorage({
    key: "likec4:scope-relationships-of",
    getInitialValueInEffect: !1,
    defaultValue: "view"
  }), {
    notIncludedRelations,
    viewIncludesSubject,
    edges,
    nodes,
    subject,
    bounds
  } = useLayoutedRelationships(subjectId, view, _scope), scope = viewIncludesSubject ? _scope : "global", showSubjectWarning = !viewIncludesSubject && _scope === "view", [historySubjectId, historyOps, { history, current }] = useStateHistory(subjectId), overlay = useOverlayDialog();
  return useEffect(() => {
    historySubjectId !== subjectId && historyOps.set(subjectId);
  }, [subjectId]), useEffect(() => {
    historySubjectId !== subjectId && overlay.openOverlay({
      relationshipsOf: historySubjectId
    });
  }, [historySubjectId]), /* @__PURE__ */ jsx(
    RelationshipsXYFlow,
    {
      nodes,
      edges,
      bounds,
      view,
      subjectId,
      viewportPadding: 0.2,
      onNodeClick: (e2, node2) => {
        e2.stopPropagation(), node2.type !== "empty" && overlay.openOverlay({
          relationshipsOf: node2.data.fqn
        });
      },
      children: /* @__PURE__ */ jsx(Panel, { position: "top-center", children: /* @__PURE__ */ jsxs(Group, { gap: "xs", wrap: "nowrap", children: [
        /* @__PURE__ */ jsx(
          Button,
          {
            leftSection: /* @__PURE__ */ jsx(IconArrowLeft, { stroke: 3, size: 14 }),
            color: "dimmed",
            variant: "subtle",
            style: {
              visibility: current > 0 ? "visible" : "hidden",
              padding: "0.25rem 0.75rem"
            },
            styles: {
              label: {
                fontWeight: 400
              },
              section: {
                marginInlineEnd: 6
              }
            },
            size: "sm",
            onClick: (e2) => {
              e2.stopPropagation(), historyOps.back();
            },
            children: "Back"
          }
        ),
        /* @__PURE__ */ jsx(Space, { w: 2 }),
        /* @__PURE__ */ jsxs(Group, { gap: "xs", pos: "relative", wrap: "nowrap", flex: "1 0 auto", children: [
          /* @__PURE__ */ jsx(Box, { fz: "sm", fw: "400", style: { whiteSpace: "nowrap", userSelect: "none" }, children: "Relationships of" }),
          /* @__PURE__ */ jsx(Box, { flex: "1 0 auto", children: /* @__PURE__ */ jsx(
            SelectElement,
            {
              scope,
              subject: subject.element,
              onSelect: (fqn2) => overlay.openOverlay({
                relationshipsOf: fqn2
              }),
              viewId: view.id
            }
          ) }),
          /* @__PURE__ */ jsx(
            SegmentedControl,
            {
              flex: "1 0 auto",
              size: "xs",
              withItemsBorders: !1,
              value: scope,
              onChange: setScope,
              data: [
                { label: "Global", value: "global" },
                { label: "Current view", value: "view", disabled: !viewIncludesSubject }
              ]
            }
          ),
          showSubjectWarning && /* @__PURE__ */ jsx(
            Box,
            {
              pos: "absolute",
              top: "calc(100% + .5rem)",
              left: "50%",
              w: "max-content",
              style: {
                transform: "translateX(-50%)",
                textAlign: "center",
                cursor: "pointer"
              },
              onClick: (e2) => {
                e2.stopPropagation(), setScope("global");
              },
              children: /* @__PURE__ */ jsx(Text$6, { fw: 500, size: "xs", c: "orange", component: "div", children: "Current view doesn't include this element, switched to Global" })
            }
          ),
          viewIncludesSubject && scope === "view" && notIncludedRelations > 0 && /* @__PURE__ */ jsx(
            Box,
            {
              pos: "absolute",
              top: "calc(100% + .5rem)",
              left: "50%",
              w: "max-content",
              style: {
                transform: "translateX(-50%)",
                textAlign: "center",
                cursor: "pointer"
              },
              onClick: (e2) => {
                e2.stopPropagation(), setScope("global");
              },
              children: /* @__PURE__ */ jsxs(Text$6, { fw: 500, size: "xs", c: "orange", component: "div", children: [
                "View does not include ",
                notIncludedRelations,
                " ",
                "relationship",
                notIncludedRelations > 1 ? "s" : "",
                ". Switch to Global to compare"
              ] })
            }
          )
        ] }),
        /* @__PURE__ */ jsx(
          Button,
          {
            rightSection: /* @__PURE__ */ jsx(IconArrowRight, { stroke: 3, size: 14 }),
            color: "dimmed",
            variant: "subtle",
            style: {
              visibility: current + 1 < history.length ? "visible" : "hidden",
              padding: "0.25rem 0.75rem"
            },
            styles: {
              label: {
                fontWeight: 400
              },
              section: {
                marginInlineStart: 4
              }
            },
            size: "sm",
            onClick: (e2) => {
              e2.stopPropagation(), historyOps.forward();
            },
            children: "Forward"
          }
        )
      ] }) })
    }
  );
}), Overlays = memo$1(() => {
  const diagramStore = useDiagramStoreApi(), {
    activeOverlay,
    viewId
  } = useDiagramState((s2) => ({
    activeOverlay: s2.activeOverlay,
    viewId: s2.view.id
  })), onCloseCbRef = useRef(), ctxValue = useMemo(() => ({
    openOverlay: (overlay) => {
      diagramStore.getState().openOverlay(overlay);
    },
    close: (cb) => {
      onCloseCbRef.current = cb, diagramStore.getState().closeOverlay();
    }
  }), [diagramStore]), onExitComplete = () => {
    var _a4;
    (_a4 = onCloseCbRef.current) == null || _a4.call(onCloseCbRef), onCloseCbRef.current = void 0;
  };
  return useHotkeys(
    !!activeOverlay ? [
      ["Escape", (e2) => {
        e2.stopPropagation(), ctxValue.close();
      }, { preventDefault: !0 }]
    ] : []
  ), /* @__PURE__ */ jsxs(OverlayContext.Provider, { value: ctxValue, children: [
    /* @__PURE__ */ jsx(AnimatePresence, { initial: !1, onExitComplete, children: (activeOverlay == null ? void 0 : activeOverlay.elementDetails) && /* @__PURE__ */ jsx(ElementDetailsCard, { fqn: activeOverlay.elementDetails }, "details card") }, viewId),
    /* @__PURE__ */ jsx(AnimatePresence, { initial: !1, onExitComplete, children: activeOverlay && n$2(activeOverlay.elementDetails) && /* @__PURE__ */ jsx(RemoveScroll, { forwardProps: !0, children: /* @__PURE__ */ jsx(
      Box,
      {
        component: m$1.div,
        className: container$5,
        "data-likec4-color": "gray",
        initial: {
          "--backdrop-blur": "0px",
          "--backdrop-opacity": "0%",
          opacity: 0,
          translateY: -15
        },
        animate: {
          "--backdrop-blur": "10px",
          "--backdrop-opacity": "70%",
          opacity: 1,
          translateY: 0
        },
        exit: {
          "--backdrop-blur": "1px",
          "--backdrop-opacity": "0%",
          translateY: -5,
          opacity: 0,
          transition: {
            duration: 0.2
          }
        },
        children: /* @__PURE__ */ jsxs(FocusTrap, { children: [
          activeOverlay.relationshipsOf && /* @__PURE__ */ jsx(RelationshipsOverlay, { subjectId: activeOverlay.relationshipsOf }),
          activeOverlay.edgeDetails && /* @__PURE__ */ jsx(
            ReactFlowProvider,
            {
              defaultNodes: [],
              defaultEdges: [],
              children: /* @__PURE__ */ jsx(EdgeDetailsXYFlow, { edgeId: activeOverlay.edgeDetails })
            }
          ),
          /* @__PURE__ */ jsx(Box, { pos: "absolute", top: "1rem", right: "1rem", children: /* @__PURE__ */ jsx(
            ActionIcon$1,
            {
              variant: "default",
              size: "lg",
              onClick: (e2) => {
                e2.stopPropagation(), ctxValue.close();
              },
              children: /* @__PURE__ */ jsx(IconX, {})
            }
          ) })
        ] })
      }
    ) }) })
  ] });
});
function EnsureMantine({ children: children2 }) {
  if (!useContext(MantineContext))
    throw new Error("LikeC4Diagram must be a child of MantineProvider");
  return /* @__PURE__ */ jsx(Fragment, { children: children2 });
}
EnsureMantine.displayName = "EnsureMantine";
const FramerMotionConfig = ({ children: children2 }) => {
  var _a4;
  const layoutId = useId$1(), nonce = (_a4 = useMantineStyleNonce()) == null ? void 0 : _a4();
  return /* @__PURE__ */ jsx(LazyMotion, { features: domMax, strict: !0, children: /* @__PURE__ */ jsx(MotionConfig, { reducedMotion: "user", ...nonce && { nonce }, children: /* @__PURE__ */ jsx(LayoutGroup, { id: layoutId, children: children2 }) }) });
};
function selectXYFlowSize(state) {
  return `${Math.round(state.width)}:${Math.round(state.height)}`;
}
function selectDiagramsize({ view, fitViewPadding }) {
  return [
    view.bounds.x,
    view.bounds.y,
    view.bounds.width,
    view.bounds.height,
    fitViewPadding
  ].map(Math.round).join(":");
}
function FitViewOnViewportResize({ diagramApi }) {
  const xyflowsize = useXYStore(selectXYFlowSize), viewsize = useDiagramState(selectDiagramsize), dimensions = xyflowsize + viewsize, prevDimensionsRef = useRef(dimensions);
  return useDebouncedEffect(
    () => {
      const { focusedNodeId, fitDiagram } = diagramApi.getState();
      focusedNodeId || prevDimensionsRef.current === dimensions || (prevDimensionsRef.current = dimensions, fitDiagram(250));
    },
    [dimensions, diagramApi],
    250
  ), null;
}
function selector$4({ view, activeWalkthrough, viewportChanged, fitViewPadding }) {
  return {
    layoutId: view.id + "_" + view.autoLayout + "_" + fitViewPadding,
    isActiveWalkthrough: !!activeWalkthrough,
    viewportNotMoved: !viewportChanged
  };
}
function FitViewOnDiagramChange() {
  const {
    layoutId,
    isActiveWalkthrough,
    viewportNotMoved
  } = useDiagramState(selector$4, shallowEqual), diagramApi = useDiagramStoreApi(), [currentLayoutId, setCurrent] = useState(layoutId), requiresFit = layoutId !== currentLayoutId;
  return useDebouncedEffect(
    () => {
      layoutId !== currentLayoutId && (setCurrent(layoutId), diagramApi.getState().fitDiagram(450));
    },
    [requiresFit, diagramApi],
    50
  ), viewportNotMoved && !isActiveWalkthrough && !requiresFit ? /* @__PURE__ */ jsx(FitViewOnViewportResize, { diagramApi }) : null;
}
function SelectEdgesOnNodeFocus() {
  const diagramStore = useDiagramStoreApi(), focusedNodeId = useDiagramState((s2) => s2.focusedNodeId);
  return useUpdateEffect(() => {
    if (!focusedNodeId) {
      diagramStore.getState().xystore.getState().resetSelectedElements();
      return;
    }
    const container2 = diagramStore.getState().getContainer();
    if (!container2)
      return;
    const edgeChanges = [], nodeChanges = [], {
      edgeLookup,
      nodeLookup,
      panZoom,
      transform: transform2,
      triggerNodeChanges,
      triggerEdgeChanges
    } = diagramStore.getState().xystore.getState();
    let focusBounds = nodeToRect(nonNullable(nodeLookup.get(focusedNodeId)));
    for (const [, edge] of edgeLookup) {
      if (edge.source === focusedNodeId || edge.target === focusedNodeId) {
        const anotherNodeId = edge.source === focusedNodeId ? edge.target : edge.source, nd = nonNullable(nodeLookup.get(anotherNodeId));
        focusBounds = getBoundsOfRects(focusBounds, nodeToRect(nd));
      }
      edge.selected && edgeChanges.push({
        id: edge.id,
        type: "select",
        selected: !1
      });
    }
    for (const [, node2] of nodeLookup)
      node2.selected && node2.id !== focusedNodeId && nodeChanges.push({
        id: node2.id,
        type: "select",
        selected: !1
      });
    nodeChanges.push({
      id: focusedNodeId,
      type: "select",
      selected: !0
    }), edgeChanges.length > 0 && triggerEdgeChanges(edgeChanges), triggerNodeChanges(nodeChanges);
    const { width: width2, height } = container2.getBoundingClientRect(), maxZoom = Math.max(1, transform2[2]), viewport = getViewportForBounds(
      {
        x: focusBounds.x - 16,
        y: focusBounds.y - 16,
        width: focusBounds.width + 32,
        height: focusBounds.height + 32
      },
      width2,
      height,
      MinZoom,
      maxZoom,
      0
    );
    panZoom == null || panZoom.setViewport(viewport, {
      duration: 350
    });
  }, [focusedNodeId]), useHotkeys(
    focusedNodeId !== null ? [
      ["Escape", (e2) => {
        e2.stopPropagation();
        const { resetFocusAndLastClicked, fitDiagram } = diagramStore.getState();
        resetFocusAndLastClicked(), fitDiagram();
      }, { preventDefault: !0 }]
    ] : []
  ), null;
}
function assignInlineVars(varsOrContract, tokens) {
  var styles = {};
  {
    var _vars = varsOrContract;
    for (var varName in _vars) {
      var value = _vars[varName];
      value != null && (styles[getVarName(varName)] = value);
    }
  }
  return Object.defineProperty(styles, "toString", {
    value: function() {
      return Object.keys(this).map((key) => "".concat(key, ":").concat(this[key])).join(";");
    },
    writable: !1
  }), styles;
}
function constant(x2) {
  return function() {
    return x2;
  };
}
const epsilon$1 = 1e-12, pi = Math.PI, tau = 2 * pi, epsilon = 1e-6, tauEpsilon = tau - epsilon;
function append(strings) {
  this._ += strings[0];
  for (let i2 = 1, n2 = strings.length; i2 < n2; ++i2)
    this._ += arguments[i2] + strings[i2];
}
function appendRound(digits) {
  let d2 = Math.floor(digits);
  if (!(d2 >= 0)) throw new Error(`invalid digits: ${digits}`);
  if (d2 > 15) return append;
  const k2 = 10 ** d2;
  return function(strings) {
    this._ += strings[0];
    for (let i2 = 1, n2 = strings.length; i2 < n2; ++i2)
      this._ += Math.round(arguments[i2] * k2) / k2 + strings[i2];
  };
}
class Path {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x2, y2) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(x2, y2) {
    this._append`L${this._x1 = +x2},${this._y1 = +y2}`;
  }
  quadraticCurveTo(x1, y1, x2, y2) {
    this._append`Q${+x1},${+y1},${this._x1 = +x2},${this._y1 = +y2}`;
  }
  bezierCurveTo(x1, y1, x2, y2, x3, y3) {
    this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x3},${this._y1 = +y3}`;
  }
  arcTo(x1, y1, x2, y2, r2) {
    if (x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r2 = +r2, r2 < 0) throw new Error(`negative radius: ${r2}`);
    let x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null)
      this._append`M${this._x1 = x1},${this._y1 = y1}`;
    else if (l01_2 > epsilon) if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r2)
      this._append`L${this._x1 = x1},${this._y1 = y1}`;
    else {
      let x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l2 = r2 * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l2 / l01, t21 = l2 / l21;
      Math.abs(t01 - 1) > epsilon && this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`, this._append`A${r2},${r2},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
    }
  }
  arc(x2, y2, r2, a0, a1, ccw) {
    if (x2 = +x2, y2 = +y2, r2 = +r2, ccw = !!ccw, r2 < 0) throw new Error(`negative radius: ${r2}`);
    let dx = r2 * Math.cos(a0), dy = r2 * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    this._x1 === null ? this._append`M${x0},${y0}` : (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) && this._append`L${x0},${y0}`, r2 && (da < 0 && (da = da % tau + tau), da > tauEpsilon ? this._append`A${r2},${r2},0,1,${cw},${x2 - dx},${y2 - dy}A${r2},${r2},0,1,${cw},${this._x1 = x0},${this._y1 = y0}` : da > epsilon && this._append`A${r2},${r2},0,${+(da >= pi)},${cw},${this._x1 = x2 + r2 * Math.cos(a1)},${this._y1 = y2 + r2 * Math.sin(a1)}`);
  }
  rect(x2, y2, w2, h2) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}h${w2 = +w2}v${+h2}h${-w2}Z`;
  }
  toString() {
    return this._;
  }
}
function withPath(shape) {
  let digits = 3;
  return shape.digits = function(_) {
    if (!arguments.length) return digits;
    if (_ == null)
      digits = null;
    else {
      const d2 = Math.floor(_);
      if (!(d2 >= 0)) throw new RangeError(`invalid digits: ${_}`);
      digits = d2;
    }
    return shape;
  }, () => new Path(digits);
}
function array(x2) {
  return typeof x2 == "object" && "length" in x2 ? x2 : Array.from(x2);
}
function Linear(context) {
  this._context = context;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    switch (x2 = +x2, y2 = +y2, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(x2, y2);
        break;
    }
  }
};
function curveLinear(context) {
  return new Linear(context);
}
function x$1(p2) {
  return p2[0];
}
function y$1(p2) {
  return p2[1];
}
function d3line(x2, y2) {
  var defined = constant(!0), context = null, curve2 = curveLinear, output = null, path = withPath(line);
  x2 = typeof x2 == "function" ? x2 : x2 === void 0 ? x$1 : constant(x2), y2 = typeof y2 == "function" ? y2 : y2 === void 0 ? y$1 : constant(y2);
  function line(data) {
    var i2, n2 = (data = array(data)).length, d2, defined0 = !1, buffer;
    for (context == null && (output = curve2(buffer = path())), i2 = 0; i2 <= n2; ++i2)
      !(i2 < n2 && defined(d2 = data[i2], i2, data)) === defined0 && ((defined0 = !defined0) ? output.lineStart() : output.lineEnd()), defined0 && output.point(+x2(d2, i2, data), +y2(d2, i2, data));
    if (buffer) return output = null, buffer + "" || null;
  }
  return line.x = function(_) {
    return arguments.length ? (x2 = typeof _ == "function" ? _ : constant(+_), line) : x2;
  }, line.y = function(_) {
    return arguments.length ? (y2 = typeof _ == "function" ? _ : constant(+_), line) : y2;
  }, line.defined = function(_) {
    return arguments.length ? (defined = typeof _ == "function" ? _ : constant(!!_), line) : defined;
  }, line.curve = function(_) {
    return arguments.length ? (curve2 = _, context != null && (output = curve2(context)), line) : curve2;
  }, line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve2(context = _), line) : context;
  }, line;
}
function point$1(that, x2, y2) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x2),
    that._y2 + that._k * (that._y1 - y2),
    that._x2,
    that._y2
  );
}
function Cardinal(context, tension) {
  this._context = context, this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point$1(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    switch (x2 = +x2, y2 = +y2, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2, this._x1 = x2, this._y1 = y2;
        break;
      case 2:
        this._point = 3;
      default:
        point$1(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
(function custom(tension) {
  function cardinal(context) {
    return new Cardinal(context, tension);
  }
  return cardinal.tension = function(tension2) {
    return custom(+tension2);
  }, cardinal;
})(0);
function CardinalOpen(context, tension) {
  this._context = context, this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    switch (x2 = +x2, y2 = +y2, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point$1(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
(function custom2(tension) {
  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }
  return cardinal.tension = function(tension2) {
    return custom2(+tension2);
  }, cardinal;
})(0);
function point(that, x2, y2) {
  var x1 = that._x1, y1 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon$1) {
    var a2 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n2 = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a2 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n2, y1 = (y1 * a2 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n2;
  }
  if (that._l23_a > epsilon$1) {
    var b2 = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m2 = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b2 + that._x1 * that._l23_2a - x2 * that._l12_2a) / m2, y22 = (y22 * b2 + that._y1 * that._l23_2a - y2 * that._l12_2a) / m2;
  }
  that._context.bezierCurveTo(x1, y1, x22, y22, that._x2, that._y2);
}
function CatmullRom(context, alpha2) {
  this._context = context, this._alpha = alpha2;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    if (x2 = +x2, y2 = +y2, this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        point(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
(function custom3(alpha2) {
  function catmullRom(context) {
    return alpha2 ? new CatmullRom(context, alpha2) : new Cardinal(context, 0);
  }
  return catmullRom.alpha = function(alpha3) {
    return custom3(+alpha3);
  }, catmullRom;
})(0.5);
function CatmullRomOpen(context, alpha2) {
  this._context = context, this._alpha = alpha2;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    if (x2 = +x2, y2 = +y2, this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
const curveCatmullRomOpen = function custom4(alpha2) {
  function catmullRom(context) {
    return alpha2 ? new CatmullRomOpen(context, alpha2) : new CardinalOpen(context, 0);
  }
  return catmullRom.alpha = function(alpha3) {
    return custom4(+alpha3);
  }, catmullRom;
}(0.5), Open = (props) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "-4 -4 14 16",
    refX: 5,
    refY: 4,
    markerWidth: "7",
    markerHeight: "8",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...props,
    children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M0,0 L7,4 L0,8 L4,4 Z",
        stroke: "context-stroke",
        fill: "context-stroke",
        strokeDasharray: 0,
        strokeWidth: 1,
        strokeLinecap: "round"
      }
    )
  }
), Arrow = (props) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "-1 -1 12 10",
    refX: 4,
    refY: 3,
    markerWidth: "8",
    markerHeight: "6",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...props,
    children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M 0 0 L 8 3 L 0 6 L 1 3 z",
        fill: "context-stroke",
        strokeWidth: 0
      }
    )
  }
), Crow = (props) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "-1 -1 12 12",
    refX: 8,
    refY: 4,
    markerWidth: "8",
    markerHeight: "8",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...props,
    children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M 8 0 L 0 4 L 8 8 M 8 4 L 0 4",
        fill: "none",
        strokeWidth: 1
      }
    )
  }
), OArrow = (props) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "-1 -1 12 10",
    refX: 4,
    refY: 3,
    markerWidth: "8",
    markerHeight: "6",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...props,
    children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M 0 0 L 8 3 L 0 6 L 1 3 z",
        stroke: "context-stroke",
        fill: "var(--likec4-background-color)",
        strokeWidth: 1.25,
        strokeLinejoin: "miter",
        strokeLinecap: "square"
      }
    )
  }
), Diamond = (props) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "-4 -4 16 14",
    refX: 5,
    refY: 4,
    markerWidth: "10",
    markerHeight: "8",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...props,
    children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M5,0 L10,4 L5,8 L0,4 Z",
        fill: "context-stroke",
        strokeWidth: 0,
        strokeLinecap: "round"
      }
    )
  }
), ODiamond = (props) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "-4 -4 16 14",
    refX: 6,
    refY: 4,
    markerWidth: "10",
    markerHeight: "8",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...props,
    children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M5,0 L10,4 L5,8 L0,4 Z",
        stroke: "context-stroke",
        fill: "var(--likec4-background-color)",
        strokeWidth: 1.25,
        strokeLinecap: "round"
      }
    )
  }
), Dot = (props) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "0 0 10 10",
    refX: 4,
    refY: 4,
    markerWidth: "6",
    markerHeight: "6",
    ...props,
    children: /* @__PURE__ */ jsx(
      "circle",
      {
        strokeWidth: 0,
        fill: "context-stroke",
        cx: 4,
        cy: 4,
        r: 3
      }
    )
  }
), ODot = (props) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "0 0 10 10",
    refX: 4,
    refY: 4,
    markerWidth: "6",
    markerHeight: "6",
    ...props,
    children: /* @__PURE__ */ jsx(
      "circle",
      {
        strokeWidth: 1.25,
        stroke: "context-stroke",
        fill: "var(--likec4-background-color)",
        cx: 4,
        cy: 4,
        r: 3
      }
    )
  }
), EdgeMarkers = {
  Arrow,
  Crow,
  OArrow,
  Open,
  Diamond,
  ODiamond,
  Dot,
  ODot
};
var container$4 = "_1wtl1y51", dimmed$1 = "_1wtl1y52", edgePathBg = "_1wtl1y53", markerContext = "_1wtl1y54", controlPoint = "_1wtl1y55", controlDragging = "_1wtl1y56", cssEdgePath = "_1wtl1y58", stepEdgeNumber = "_1wtl1y59", varLabelX = "var(--_1wtl1y5a)", varLabelY = "var(--_1wtl1y5b)", edgeLabel = "_1wtl1y5d", edgeLabelText = "_1wtl1y5e", edgeNoteCloseButton = "_1wtl1y5f", edgeNoteText = "_1wtl1y5g", cssNavigateBtn = "_1wtl1y5h", cssNavigateBtnIcon = "_1wtl1y5i", menuDropdown = "_17kny4m0", menuItemRelationship = "_17kny4m1", endpoint = "_17kny4m2", title$2 = "_17kny4m3";
const stopPropagation = (e2) => e2.stopPropagation(), Tooltip$2 = Tooltip$5.withProps({
  color: "gray",
  fz: "xs",
  openDelay: 300,
  closeDelay: 150,
  label: "",
  children: null,
  offset: 8,
  withinPortal: !1
});
function RelationshipsDropdownMenu({
  edge,
  disabled = !1,
  likec4model,
  children: children2
}) {
  const {
    openOverlay,
    enableRelationshipBrowser
  } = useDiagramState(i$6(["openOverlay", "enableRelationshipBrowser"])), portalProps = useMantinePortalProps(), [sourceXYNode, targetXYNode] = useXYNodesData([edge.source, edge.target]);
  invariant$1(sourceXYNode, `Source XYNode ${edge.source} not found for edge ${edge.id}`), invariant$1(targetXYNode, `Target XYNode ${edge.target} not found for edge ${edge.id}`);
  const [direct, nested] = x$2(
    edge.relations,
    m$2((id2) => {
      try {
        return likec4model.relationship(id2);
      } catch (e2) {
        return console.error(
          `View is cached and likec4model missing relationship ${id2} from ${edge.source} -> ${edge.target}`,
          e2
        ), null;
      }
    }),
    T$1(n$4),
    d$3((r2) => r2.relationship.source === edge.source && r2.relationship.target === edge.target)
  ), onClickOpenOverlay = useCallback((e2) => {
    e2.stopPropagation(), enableRelationshipBrowser && openOverlay({
      edgeDetails: edge.id
    });
  }, [edge.id, openOverlay, enableRelationshipBrowser]), renderRelationship = (relationship, index2) => /* @__PURE__ */ jsxs(Fragment$1, { children: [
    index2 > 0 && /* @__PURE__ */ jsx(MenuDivider, { opacity: 0.65 }),
    /* @__PURE__ */ jsx(
      MenuItem,
      {
        onClick: onClickOpenOverlay,
        component: Relationship,
        relationship,
        sourceNode: sourceXYNode.data.element,
        targetNode: targetXYNode.data.element,
        edge
      }
    )
  ] }, relationship.id);
  return direct.length + nested.length === 0 ? /* @__PURE__ */ jsx(Fragment, { children: children2 }) : /* @__PURE__ */ jsxs(
    Menu,
    {
      trigger: "click-hover",
      openDelay: 300,
      closeDelay: 450,
      floatingStrategy: "fixed",
      closeOnClickOutside: !0,
      clickOutsideEvents: ["pointerdown", "mousedown", "click"],
      closeOnEscape: !0,
      closeOnItemClick: !1,
      disabled,
      ...portalProps,
      children: [
        /* @__PURE__ */ jsx(MenuTarget, { children: children2 }),
        /* @__PURE__ */ jsxs(
          MenuDropdown,
          {
            className: menuDropdown,
            onPointerDownCapture: stopPropagation,
            onPointerDown: stopPropagation,
            onClick: stopPropagation,
            children: [
              direct.length > 0 && /* @__PURE__ */ jsxs(Fragment, { children: [
                /* @__PURE__ */ jsx(MenuLabel, { children: "direct relationships" }),
                direct.map(renderRelationship)
              ] }),
              nested.length > 0 && /* @__PURE__ */ jsxs(Fragment, { children: [
                direct.length > 0 && /* @__PURE__ */ jsx(MenuDivider, {}),
                /* @__PURE__ */ jsx(MenuLabel, { children: "resolved from nested" }),
                nested.map(renderRelationship)
              ] }),
              enableRelationshipBrowser && /* @__PURE__ */ jsx(Box, { pos: "absolute", top: 5, right: 6, children: /* @__PURE__ */ jsx(
                ActionIcon$1,
                {
                  size: 24,
                  variant: "subtle",
                  onClick: onClickOpenOverlay,
                  children: /* @__PURE__ */ jsx(IconInfoCircle, { style: { width: "70%" } })
                }
              ) })
            ]
          }
        )
      ]
    }
  );
}
const Relationship = forwardRef(({
  className,
  relationship: r2,
  edge,
  sourceNode,
  targetNode,
  ...props
}, ref) => {
  const diagramApi = useDiagramStoreApi(), {
    viewId,
    hasOnOpenSourceRelation,
    hasOnNavigateTo
  } = useDiagramState((s2) => ({
    viewId: s2.view.id,
    hasOnOpenSourceRelation: !!s2.onOpenSourceRelation,
    hasOnNavigateTo: !!s2.onNavigateTo
  })), sourceId = nameFromFqn(edge.source) + r2.source.id.slice(edge.source.length), targetId = nameFromFqn(edge.target) + r2.target.id.slice(edge.target.length), navigateTo = hasOnNavigateTo && r2.relationship.navigateTo !== viewId ? r2.relationship.navigateTo : void 0;
  return /* @__PURE__ */ jsxs(Stack$1, { ref, className: clsx(menuItemRelationship, className), ...props, children: [
    /* @__PURE__ */ jsxs(Group, { gap: 4, children: [
      /* @__PURE__ */ jsx(Text$6, { component: "div", className: endpoint, "data-likec4-color": sourceNode.color, children: sourceId }),
      /* @__PURE__ */ jsx(IconArrowRight, { stroke: 2.5, size: 11 }),
      /* @__PURE__ */ jsx(Text$6, { component: "div", className: endpoint, "data-likec4-color": targetNode.color, children: targetId }),
      (navigateTo || hasOnOpenSourceRelation) && /* @__PURE__ */ jsxs(TooltipGroup, { openDelay: 100, children: [
        /* @__PURE__ */ jsx(Space, { w: "xs" }),
        navigateTo && /* @__PURE__ */ jsx(Tooltip$2, { label: "Open dynamic view", children: /* @__PURE__ */ jsx(
          ActionIcon$1,
          {
            className: clsx("nodrag nopan"),
            size: "sm",
            radius: "sm",
            variant: "default",
            onPointerDownCapture: stopPropagation,
            onClick: (event) => {
              var _a4, _b2;
              event.stopPropagation(), (_b2 = (_a4 = diagramApi.getState()).onNavigateTo) == null || _b2.call(_a4, navigateTo, event);
            },
            role: "button",
            children: /* @__PURE__ */ jsx(IconZoomScan, { size: "80%", stroke: 2 })
          }
        ) }),
        hasOnOpenSourceRelation && /* @__PURE__ */ jsx(Tooltip$2, { label: "Open source", children: /* @__PURE__ */ jsx(
          ActionIcon$1,
          {
            className: clsx("nodrag nopan"),
            size: "sm",
            radius: "sm",
            variant: "default",
            onPointerDownCapture: stopPropagation,
            onClick: (event) => {
              var _a4, _b2;
              event.stopPropagation(), (_b2 = (_a4 = diagramApi.getState()).onOpenSourceRelation) == null || _b2.call(_a4, r2.id);
            },
            role: "button",
            children: /* @__PURE__ */ jsx(IconFileSymlink, { size: "80%", stroke: 2 })
          }
        ) })
      ] })
    ] }),
    /* @__PURE__ */ jsx(Box, { className: title$2, children: r2.title || "untitled" })
  ] });
}), EdgeLabel = ({
  isDimmed,
  edgeData: {
    label: label2,
    edge
  },
  ...props
}) => {
  const likec4model = useLikeC4Model(), {
    enableRelationshipDetails,
    isActiveWalkthroughStep,
    hasOnNavigateTo
  } = useDiagramState((s2) => {
    var _a4;
    return {
      enableRelationshipDetails: s2.enableRelationshipDetails,
      isActiveWalkthroughStep: ((_a4 = s2.activeWalkthrough) == null ? void 0 : _a4.stepId) === edge.id,
      hasOnNavigateTo: !!s2.onNavigateTo
    };
  }), notes = isActiveWalkthroughStep ? edge.notes ?? null : null, stepNum = isStepEdgeId(edge.id) ? extractStep(edge.id) : null, navigateTo = hasOnNavigateTo ? edge.navigateTo ?? null : null;
  return /* @__PURE__ */ jsx(EdgeLabelRenderer, { children: ((node2) => n$4(notes) ? /* @__PURE__ */ jsx(NotePopover, { notes, children: node2 }) : enableRelationshipDetails && likec4model && edge.relations.length > 0 ? /* @__PURE__ */ jsx(
    RelationshipsDropdownMenu,
    {
      disabled: isDimmed,
      likec4model,
      edge,
      children: node2
    }
  ) : node2)(
    /* @__PURE__ */ jsxs(Box, { ...props, children: [
      stepNum !== null && /* @__PURE__ */ jsx(Box, { className: stepEdgeNumber, children: stepNum }),
      n$4(label2 == null ? void 0 : label2.text) && /* @__PURE__ */ jsx(Box, { className: edgeLabelText, children: label2.text }),
      navigateTo && /* @__PURE__ */ jsx(NavigateToBtn, { viewId: navigateTo })
    ] })
  ) });
}, NotePopover = ({ notes, children: children2 }) => {
  const {
    nextDynamicStep,
    hasNext,
    hasPrevious
  } = useDiagramState((s2) => {
    var _a4, _b2;
    return {
      nextDynamicStep: s2.nextDynamicStep,
      hasNext: ((_a4 = s2.activeWalkthrough) == null ? void 0 : _a4.hasNext) ?? !1,
      hasPrevious: ((_b2 = s2.activeWalkthrough) == null ? void 0 : _b2.hasPrevious) ?? !1
    };
  }), [isOpened, setIsOpened] = useState(!1), portalProps = useMantinePortalProps();
  return useDebouncedEffect(
    () => {
      setIsOpened(!0);
    },
    [],
    300
  ), /* @__PURE__ */ jsxs(
    Popover,
    {
      shadow: "xs",
      offset: 16,
      opened: isOpened,
      closeOnClickOutside: !1,
      ...portalProps,
      children: [
        /* @__PURE__ */ jsx(PopoverTarget, { children: children2 }),
        /* @__PURE__ */ jsxs(
          PopoverDropdown,
          {
            component: Stack$1,
            p: "xs",
            onPointerDownCapture: stopPropagation$1,
            onClick: stopPropagation$1,
            onDoubleClick: stopPropagation$1,
            children: [
              /* @__PURE__ */ jsx(ScrollAreaAutosize, { maw: 450, mah: 350, type: "scroll", mx: "auto", mt: 2, children: /* @__PURE__ */ jsx(Text$6, { component: "div", className: edgeNoteText, p: 4, children: notes }) }),
              /* @__PURE__ */ jsx(
                CloseButton,
                {
                  size: "xs",
                  className: edgeNoteCloseButton,
                  onClick: () => setIsOpened(!1)
                }
              ),
              (hasPrevious || hasNext) && /* @__PURE__ */ jsxs(Group, { gap: 0, justify: hasPrevious ? "flex-start" : "flex-end", children: [
                hasPrevious && /* @__PURE__ */ jsx(
                  Button,
                  {
                    variant: "subtle",
                    radius: "xs",
                    size: "compact-xs",
                    onClick: () => nextDynamicStep(-1),
                    children: "back"
                  }
                ),
                hasNext && /* @__PURE__ */ jsx(Button, { variant: "subtle", radius: "xs", size: "compact-xs", onClick: () => nextDynamicStep(), children: "next" })
              ] })
            ]
          }
        )
      ]
    }
  );
};
function NavigateToBtn({ viewId }) {
  const diagramApi = useDiagramStoreApi();
  return /* @__PURE__ */ jsx(
    ActionIcon$1,
    {
      className: clsx("nodrag nopan", cssNavigateBtn),
      size: "sm",
      radius: "sm",
      onPointerDownCapture: stopPropagation$1,
      onClick: (event) => {
        var _a4, _b2;
        event.stopPropagation(), (_b2 = (_a4 = diagramApi.getState()).onNavigateTo) == null || _b2.call(_a4, viewId, event);
      },
      role: "button",
      onDoubleClick: stopPropagation$1,
      children: /* @__PURE__ */ jsx(IconZoomScan, { className: cssNavigateBtnIcon })
    }
  );
}
function getNodeIntersectionFromCenterToPoint(intersectionNode, { x: x1, y: y1 }) {
  const {
    width: intersectionNodeWidth,
    height: intersectionNodeHeight
  } = getNodeDimensions(intersectionNode), intersectionNodePosition = intersectionNode.internals.positionAbsolute, w2 = intersectionNodeWidth / 2, h2 = intersectionNodeHeight / 2, x2 = intersectionNodePosition.x + w2, y2 = intersectionNodePosition.y + h2, xx1 = (x1 - x2) / (2 * w2) - (y1 - y2) / (2 * h2), yy1 = (x1 - x2) / (2 * w2) + (y1 - y2) / (2 * h2), a2 = 1 / (Math.abs(xx1) + Math.abs(yy1)), xx3 = a2 * xx1, yy3 = a2 * yy1, x3 = w2 * (xx3 + yy3) + x2, y3 = h2 * (-xx3 + yy3) + y2;
  return { x: x3, y: y3 };
}
const toMarker = (arrowType) => {
  if (!(!arrowType || arrowType === "none"))
    switch (arrowType) {
      case "normal":
        return "Arrow";
      case "crow":
        return "Crow";
      case "onormal":
        return "OArrow";
      case "diamond":
        return "Diamond";
      case "odiamond":
        return "ODiamond";
      case "open":
      case "vee":
        return "Open";
      case "dot":
        return "Dot";
      case "odot":
        return "ODot";
      default:
        nonexhaustive(arrowType);
    }
};
function bezierPath(bezierSpline) {
  let [start2, ...points] = bezierSpline;
  invariant$1(start2, "start should be defined");
  let path = `M ${start2[0]},${start2[1]}`;
  for (; i$8(points, 3); ) {
    const [cp1, cp2, end, ...rest] = points;
    path = path + ` C ${cp1[0]},${cp1[1]} ${cp2[0]},${cp2[1]} ${end[0]},${end[1]}`, points = rest;
  }
  return invariant$1(points.length === 0, "all points should be consumed"), path;
}
const isSame = (a2, b2) => Math.abs(a2 - b2) < 2.5, isSamePoint = (a2, b2) => isSame(o$3(a2) ? a2[0] : a2.x, o$3(b2) ? b2[0] : b2.x) && isSame(o$3(a2) ? a2[1] : a2.y, o$3(b2) ? b2[1] : b2.y), sameControlPoints = (a2, b2) => a2 === b2 ? !0 : !a2 || !b2 || a2.length !== b2.length ? !1 : a2.every((ap, i2) => isSamePoint(ap, b2[i2])), isEqualProps$2 = (prev, next) => prev.id === next.id && deepEqual$1(prev.source, next.source) && deepEqual$1(prev.target, next.target) && deepEqual$1(prev.selected ?? !1, next.selected ?? !1) && isSame(prev.sourceX, next.sourceX) && isSame(prev.sourceY, next.sourceY) && isSame(prev.targetX, next.targetX) && isSame(prev.targetY, next.targetY) && deepEqual$1(prev.data.label, next.data.label) && sameControlPoints(prev.data.controlPoints, next.data.controlPoints) && deepEqual$1(prev.data.edge, next.data.edge), curve = d3line().curve(curveCatmullRomOpen).x((d2) => d2.x).y((d2) => d2.y), RelationshipEdge = memo$1(function({
  id: id2,
  data,
  sourceX,
  sourceY,
  targetX,
  targetY,
  style: style2,
  source,
  target,
  interactionWidth
}) {
  const [isControlPointDragging, setIsControlPointDragging] = useState(!1), diagramStore = useDiagramStoreApi(), xyflowStore = useXYStoreApi(), {
    connectedToFocusedNode,
    isActiveWalkthroughStep,
    isEdgePathEditable,
    isHovered,
    isDimmed,
    isActiveAsParallel
  } = useDiagramState((s2) => {
    var _a4, _b2;
    return {
      isEdgePathEditable: s2.readonly !== !0 && s2.experimentalEdgeEditing === !0 && s2.focusedNodeId === null && s2.activeWalkthrough === null,
      connectedToFocusedNode: s2.focusedNodeId === source || s2.focusedNodeId === target,
      isActiveWalkthroughStep: ((_a4 = s2.activeWalkthrough) == null ? void 0 : _a4.stepId) === data.edge.id,
      // If activeWalkthrough and this edge is part of the parallel group
      isActiveAsParallel: !!((_b2 = s2.activeWalkthrough) != null && _b2.parallelPrefix) && id2.startsWith(s2.activeWalkthrough.parallelPrefix),
      isHovered: s2.hoveredEdgeId === id2,
      isDimmed: s2.dimmed.has(id2)
    };
  }), isActive = connectedToFocusedNode || isActiveWalkthroughStep, { nodeLookup, edgeLookup } = xyflowStore.getState(), sourceNode = nonNullable(nodeLookup.get(source), `source node ${source} not found`), targetNode = nonNullable(nodeLookup.get(target), `target node ${target} not found`), isModified = n$4(data.controlPoints) || !isSamePoint(sourceNode.internals.positionAbsolute, sourceNode.data.element.position) || !isSamePoint(targetNode.internals.positionAbsolute, targetNode.data.element.position), {
    label: label2,
    edge: {
      points: diagramEdgePoints,
      line = "dashed",
      color: color2 = "gray",
      labelBBox,
      ...diagramEdge
    }
  } = data;
  let controlPoints = data.controlPoints ?? bezierControlPoints(data.edge);
  const isStepEdge = isStepEdgeId(data.edge.id), isDotted = line === "dotted", isDashed = isDotted || line === "dashed";
  let strokeDasharray;
  isDotted ? strokeDasharray = "1,8" : isDashed && (strokeDasharray = "8,10");
  let labelX = (labelBBox == null ? void 0 : labelBBox.x) ?? 0, labelY = (labelBBox == null ? void 0 : labelBBox.y) ?? 0;
  const [labelPos, setLabelPos] = useState({
    x: (label2 == null ? void 0 : label2.bbox.x) ?? labelX,
    y: (label2 == null ? void 0 : label2.bbox.y) ?? labelY
  });
  let edgePath;
  if (isModified) {
    const sourceCenterPos = { x: sourceX, y: sourceY }, targetCenterPos = { x: targetX, y: targetY }, points = diagramEdge.dir === "back" ? [
      targetCenterPos,
      getNodeIntersectionFromCenterToPoint(targetNode, d$1(controlPoints) ?? sourceCenterPos),
      ...controlPoints,
      getNodeIntersectionFromCenterToPoint(sourceNode, a$2(controlPoints) ?? targetCenterPos),
      sourceCenterPos
    ] : [
      sourceCenterPos,
      getNodeIntersectionFromCenterToPoint(sourceNode, d$1(controlPoints) ?? targetCenterPos),
      ...controlPoints,
      getNodeIntersectionFromCenterToPoint(targetNode, a$2(controlPoints) ?? sourceCenterPos),
      targetCenterPos
    ];
    edgePath = nonNullable(curve(points));
  } else
    edgePath = bezierPath(diagramEdgePoints);
  const svgPathRef = useRef(null);
  useEffect(() => {
    const path = svgPathRef.current;
    if (!path) return;
    const dompoint = path.getPointAtLength(path.getTotalLength() * 0.5), point2 = {
      x: Math.round(dompoint.x),
      y: Math.round(dompoint.y)
    };
    setLabelPos((current) => isSamePoint(current, point2) ? current : point2);
  }, [edgePath]), useDebouncedEffect(
    () => {
      !label2 || label2.bbox.x === labelPos.x && label2.bbox.y === labelPos.y || diagramStore.getState().xyflow.updateEdgeData(id2, {
        label: {
          ...label2,
          bbox: {
            ...label2.bbox,
            ...labelPos
          }
        }
      });
    },
    [labelPos],
    50,
    300
  ), (isModified || isControlPointDragging) && (labelX = labelPos.x, labelY = labelPos.y);
  const onLmbControlPointerDown = (index2, e2, domNode) => {
    const { addSelectedEdges } = xyflowStore.getState(), { xyflow: xyflow2 } = diagramStore.getState();
    addSelectedEdges([id2]);
    const wasCanceled = diagramStore.getState().cancelSaveManualLayout();
    e2.stopPropagation();
    let hasMoved = !1, pointer2 = { x: e2.clientX, y: e2.clientY };
    const onPointerMove = (e22) => {
      const clientPoint = {
        x: e22.clientX,
        y: e22.clientY
      };
      if (!isSamePoint(pointer2, clientPoint)) {
        setIsControlPointDragging(!0), hasMoved = !0, pointer2 = clientPoint;
        const { x: x2, y: y2 } = xyflow2.screenToFlowPosition(pointer2, { snapToGrid: !1 });
        xyflow2.updateEdgeData(id2, (xyedge) => {
          const cp = (xyedge.data.controlPoints ?? controlPoints).slice();
          return cp[index2] = {
            x: Math.round(x2),
            y: Math.round(y2)
          }, {
            controlPoints: cp
          };
        });
      }
      e22.stopPropagation();
    }, onPointerUp = (e22) => {
      domNode.removeEventListener("pointermove", onPointerMove, {
        capture: !0
      }), hasMoved && e22.stopPropagation(), (hasMoved || wasCanceled) && diagramStore.getState().scheduleSaveManualLayout(), setIsControlPointDragging(!1);
    };
    domNode.addEventListener("pointermove", onPointerMove, {
      capture: !0
    }), domNode.addEventListener("pointerup", onPointerUp, {
      once: !0,
      capture: !0
    });
  }, onRmbControlPointerDown = (index2, e2, domNode) => {
    const { xyflow: xyflow2 } = diagramStore.getState();
    if (controlPoints.length <= 1)
      return;
    const onPointerUp = (e22) => {
      const newControlPoints = controlPoints.slice();
      newControlPoints.splice(index2, 1), e22.stopPropagation(), setTimeout(() => {
        xyflow2.updateEdgeData(id2, { controlPoints: newControlPoints }), diagramStore.getState().scheduleSaveManualLayout();
      }, 10), domNode.removeEventListener("pointerup", onPointerUp, {
        capture: !0
      }), e22.stopPropagation();
    };
    domNode.addEventListener("pointerup", onPointerUp, {
      once: !0,
      capture: !0
    }), e2.stopPropagation();
  }, onControlPointerDown = (index2, e2) => {
    const { domNode } = xyflowStore.getState();
    if (!(!domNode || e2.pointerType !== "mouse"))
      switch (e2.button) {
        case 0:
          onLmbControlPointerDown(index2, e2, domNode);
          break;
        case 2:
          onRmbControlPointerDown(index2, e2, domNode);
          break;
      }
  }, onEdgePointerDown = (e2) => {
    const { domNode } = xyflowStore.getState(), { xyflow: xyflow2, scheduleSaveManualLayout } = diagramStore.getState();
    !domNode || e2.pointerType !== "mouse" || e2.button === 2 && (xyflow2.updateEdgeData(id2, (edge) => {
      var _a4;
      const points = [
        new VectorImpl(sourceX, sourceY),
        ...controlPoints.map(vector) || [],
        new VectorImpl(targetX, targetY)
      ];
      let pointer2 = { x: e2.clientX, y: e2.clientY };
      const newPoint = vector(xyflow2.screenToFlowPosition(pointer2, { snapToGrid: !1 }));
      let insertionIndex = 0, minDistance = 1 / 0;
      for (let i2 = 0; i2 < points.length - 1; i2++) {
        const a2 = points[i2], b2 = points[i2 + 1], fromCurrentToNext = b2.sub(a2), fromCurrentToNew = newPoint.sub(a2), fromNextToNew = newPoint.sub(b2);
        if (fromCurrentToNext.dot(fromCurrentToNew) * fromCurrentToNext.dot(fromNextToNew) < 0) {
          const distanceToEdge = Math.abs(fromCurrentToNext.cross(fromCurrentToNew).abs() / fromCurrentToNext.abs());
          distanceToEdge < minDistance && (minDistance = distanceToEdge, insertionIndex = i2);
        }
      }
      const newControlPoints = ((_a4 = edge.data.controlPoints) == null ? void 0 : _a4.slice()) || [];
      return newControlPoints.splice(insertionIndex, 0, newPoint), { controlPoints: newControlPoints };
    }), scheduleSaveManualLayout(), e2.stopPropagation());
  };
  let markerStartName = toMarker(diagramEdge.tail), markerEndName = toMarker(diagramEdge.head ?? "normal");
  diagramEdge.dir === "back" && ([markerStartName, markerEndName] = [markerEndName, markerStartName]);
  const MarkerStart = markerStartName ? EdgeMarkers[markerStartName] : null, MarkerEnd = markerEndName ? EdgeMarkers[markerEndName] : null, edgeZIndex = edgeLookup.get(id2).zIndex ?? ZIndexes$2.Edge;
  let labelZIndex;
  return isEdgePathEditable ? labelZIndex = edgeZIndex - 1 : isHovered ? labelZIndex = ZIndexes$2.Element + 1 : labelZIndex = edgeZIndex + 1, /* @__PURE__ */ jsxs(
    "g",
    {
      className: clsx(
        container$4,
        isDimmed && dimmed$1,
        isControlPointDragging && controlDragging
      ),
      "data-likec4-color": color2,
      "data-edge-dir": diagramEdge.dir,
      "data-edge-active": isActive,
      "data-edge-animated": isActive || isActiveAsParallel,
      "data-edge-hovered": isHovered,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            className: clsx("react-flow__edge-interaction"),
            d: edgePath,
            fill: "none",
            stroke: "transparent",
            strokeWidth: interactionWidth ?? 10
          }
        ),
        /* @__PURE__ */ jsxs("g", { className: markerContext, onPointerDown: (e2) => onEdgePointerDown(e2), children: [
          /* @__PURE__ */ jsxs("defs", { children: [
            MarkerStart && /* @__PURE__ */ jsx(MarkerStart, { id: "start" + id2 }),
            MarkerEnd && /* @__PURE__ */ jsx(MarkerEnd, { id: "end" + id2 })
          ] }),
          /* @__PURE__ */ jsx(
            "path",
            {
              className: clsx("react-flow__edge-path", edgePathBg),
              d: edgePath,
              style: style2,
              strokeLinecap: "round"
            }
          ),
          /* @__PURE__ */ jsx(
            "path",
            {
              ref: svgPathRef,
              className: clsx("react-flow__edge-path", cssEdgePath),
              d: edgePath,
              style: style2,
              strokeLinecap: "round",
              strokeDasharray,
              markerStart: MarkerStart ? `url(#start${id2})` : void 0,
              markerEnd: MarkerEnd ? `url(#end${id2})` : void 0
            }
          )
        ] }),
        isEdgePathEditable && /* @__PURE__ */ jsx(
          "g",
          {
            onContextMenu: (e2) => {
              e2.preventDefault(), e2.stopPropagation();
            },
            children: controlPoints.map((p2, i2) => /* @__PURE__ */ jsx(
              "circle",
              {
                onPointerDown: (e2) => onControlPointerDown(i2, e2),
                className: controlPoint,
                cx: p2.x,
                cy: p2.y,
                r: 3
              },
              i2
            ))
          }
        ),
        (data.label || isStepEdge) && /* @__PURE__ */ jsx(
          EdgeLabel,
          {
            isDimmed,
            edgeData: data,
            className: clsx(
              "nodrag nopan",
              container$4,
              edgeLabel,
              isDimmed && dimmed$1
            ),
            style: {
              ...assignInlineVars({
                [varLabelX]: isModified ? `calc(${labelX}px - 10%)` : `${labelX}px`,
                [varLabelY]: isModified ? `${labelY - 5}px` : `${labelY}px`
              }),
              // ...(isEdgePathEditable && selected && {
              //   pointerEvents: 'none'
              // }),
              ...label2 && {
                maxWidth: label2.bbox.width + 18
              },
              zIndex: labelZIndex
            },
            mod: {
              "data-likec4-color": color2,
              "data-edge-hovered": isHovered && !isActiveWalkthroughStep,
              "data-edge-active": isActive
            }
          }
        )
      ]
    }
  );
}, isEqualProps$2), ElementIcon = ({
  element,
  viewId,
  className,
  renderIcon: RenderIcon
}) => {
  if (!element.icon)
    return null;
  let icon = null;
  return element.icon.startsWith("http://") || element.icon.startsWith("https://") ? icon = /* @__PURE__ */ jsx("img", { src: element.icon, alt: element.title }) : RenderIcon && (icon = /* @__PURE__ */ jsx(RenderIcon, { node: element })), icon ? /* @__PURE__ */ jsx(
    m$1.div,
    {
      layoutId: `${viewId}:element:icon:${element.id}`,
      className: clsx(
        className,
        "likec4-element-icon"
      ),
      "data-likec4-icon": element.icon,
      children: icon
    },
    `${viewId}:element:icon:${element.id}`
  ) : null;
}, {
  primary,
  secondary,
  muted,
  ...otherColors
} = defaultTheme.elements, themedColors = [
  { key: "primary", value: primary.fill },
  { key: "secondary", value: secondary.fill },
  { key: "muted", value: muted.fill }
], colors = keys(otherColors).map((key) => ({
  key,
  value: defaultTheme.elements[key].fill
})), Tooltip$1 = Tooltip$5.withProps({
  color: "dark",
  fz: "xs",
  openDelay: 400,
  closeDelay: 150,
  label: "",
  children: null,
  offset: 4
});
function CompoundToolbar({
  element,
  onColorPreview,
  ...props
}) {
  var _a4;
  const targets = [element.id], diagramApi = useDiagramStoreApi(), {
    hasGoToSource,
    enableRelationshipBrowser
  } = useDiagramState((s2) => ({
    hasGoToSource: !!s2.onOpenSourceElement,
    enableRelationshipBrowser: s2.enableRelationshipBrowser
  })), onChange = (style2) => {
    diagramApi.getState().triggerChangeElementStyle({
      op: "change-element-style",
      style: style2,
      targets
    });
  };
  return /* @__PURE__ */ jsxs(Toolbar, { element, ...props, children: [
    /* @__PURE__ */ jsx(
      ColorButton,
      {
        element,
        isOpacityEditable: !0,
        onColorPreview,
        onChange,
        position: "left-start"
      }
    ),
    /* @__PURE__ */ jsx(
      BorderStyleOption,
      {
        elementBorderStyle: (_a4 = element.style) == null ? void 0 : _a4.border,
        onChange
      }
    ),
    hasGoToSource && /* @__PURE__ */ jsx(GoToSourceButton, { elementId: element.id }),
    enableRelationshipBrowser && /* @__PURE__ */ jsx(BrowseRelationshipsButton, { elementId: element.id })
  ] });
}
function Toolbar({ element, children: children2, ...props }) {
  return /* @__PURE__ */ jsx(NodeToolbar, { ...props, children: /* @__PURE__ */ jsx(
    Paper,
    {
      className: clsx("nodrag", "nopan"),
      px: 5,
      pb: 8,
      pt: 4,
      radius: "sm",
      shadow: "xl",
      onDoubleClickCapture: stopPropagation$1,
      onPointerDown: stopPropagation$1,
      onClick: stopPropagation$1,
      onDoubleClick: stopPropagation$1,
      withBorder: !0,
      children: /* @__PURE__ */ jsxs(Stack$1, { gap: 4, children: [
        /* @__PURE__ */ jsx(Box, { pl: 2, children: /* @__PURE__ */ jsx(Text$6, { c: "dimmed", fz: 10, fw: 500, children: element.id }) }),
        /* @__PURE__ */ jsx(Group, { gap: 3, children: children2 })
      ] })
    }
  ) });
}
function ElementToolbar({
  element,
  onColorPreview,
  ...props
}) {
  const targets = [element.id], diagramApi = useDiagramStoreApi(), {
    hasGoToSource,
    enableRelationshipBrowser
  } = useDiagramState((s2) => ({
    hasGoToSource: !!s2.onOpenSourceElement,
    enableRelationshipBrowser: s2.enableRelationshipBrowser
  })), portalProps = useMantinePortalProps(), onChange = (style2) => {
    diagramApi.getState().triggerChangeElementStyle({
      op: "change-element-style",
      style: style2,
      targets
    });
  };
  return /* @__PURE__ */ jsxs(Toolbar, { element, ...props, children: [
    /* @__PURE__ */ jsxs(
      Menu,
      {
        openDelay: 300,
        closeDelay: 450,
        floatingStrategy: "fixed",
        closeOnClickOutside: !0,
        clickOutsideEvents: ["pointerdown", "mousedown", "click"],
        closeOnEscape: !0,
        closeOnItemClick: !1,
        position: "bottom-start",
        offset: 2,
        styles: {
          item: {
            padding: "calc(var(--mantine-spacing-xs) / 1.5) var(--mantine-spacing-xs)"
          }
        },
        ...portalProps,
        children: [
          /* @__PURE__ */ jsx(MenuTarget, { children: /* @__PURE__ */ jsx(
            Button,
            {
              variant: "light",
              color: "gray",
              size: "compact-xs",
              rightSection: /* @__PURE__ */ jsx(IconSelector, { size: 12 }),
              children: element.shape
            }
          ) }),
          /* @__PURE__ */ jsx(
            MenuDropdown,
            {
              onDoubleClick: stopPropagation$1,
              onClick: stopPropagation$1,
              children: ElementShapes.map((shape) => /* @__PURE__ */ jsx(
                MenuItem,
                {
                  fz: 12,
                  fw: 500,
                  value: shape,
                  rightSection: element.shape === shape ? /* @__PURE__ */ jsx(IconCheck, { size: 12 }) : void 0,
                  onClick: (e2) => {
                    e2.stopPropagation(), onChange({ shape });
                  },
                  children: shape
                },
                shape
              ))
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ jsx(
      ColorButton,
      {
        element,
        onColorPreview,
        onChange,
        position: "right-end"
      }
    ),
    hasGoToSource && /* @__PURE__ */ jsx(GoToSourceButton, { elementId: element.id }),
    enableRelationshipBrowser && /* @__PURE__ */ jsx(BrowseRelationshipsButton, { elementId: element.id })
  ] });
}
function GoToSourceButton({ elementId }) {
  const diagramApi = useDiagramStoreApi(), portalProps = useMantinePortalProps();
  return /* @__PURE__ */ jsx(Tooltip$1, { label: "Open source", ...portalProps, children: /* @__PURE__ */ jsx(
    ActionIcon$1,
    {
      size: "sm",
      variant: "subtle",
      color: "gray",
      onClick: (e2) => {
        var _a4, _b2;
        e2.stopPropagation(), (_b2 = (_a4 = diagramApi.getState()).onOpenSourceElement) == null || _b2.call(_a4, elementId);
      },
      children: /* @__PURE__ */ jsx(IconFileSymlink, { stroke: 1.8, style: { width: "70%" } })
    }
  ) });
}
function ColorButton({
  element,
  onColorPreview,
  isOpacityEditable = !1,
  onChange,
  ...props
}) {
  var _a4, _b2;
  const elementColor = element.color ?? "primary";
  return /* @__PURE__ */ jsxs(
    Popover,
    {
      clickOutsideEvents: ["pointerdown", "mousedown", "click"],
      position: "right-end",
      offset: 2,
      ...props,
      children: [
        /* @__PURE__ */ jsx(PopoverTarget, { children: /* @__PURE__ */ jsx(Button, { variant: "subtle", color: "gray", size: "compact-xs", px: 3, children: /* @__PURE__ */ jsx(
          ColorSwatch,
          {
            color: (_a4 = defaultTheme.elements[elementColor]) == null ? void 0 : _a4.fill,
            size: 14,
            withShadow: !0,
            style: { color: "#fff", cursor: "pointer" }
          }
        ) }) }),
        /* @__PURE__ */ jsxs(PopoverDropdown, { p: "xs", children: [
          /* @__PURE__ */ jsx(
            ColorSwatches,
            {
              elementColor,
              onColorPreview,
              onChange: (color2) => onChange({ color: color2 })
            }
          ),
          isOpacityEditable && /* @__PURE__ */ jsxs(Fragment, { children: [
            /* @__PURE__ */ jsx(Space, { h: "xs" }),
            /* @__PURE__ */ jsx(Divider$1, { label: "opacity", labelPosition: "left" }),
            /* @__PURE__ */ jsx(Space, { h: "xs" }),
            /* @__PURE__ */ jsx(
              OpacityOption,
              {
                elementOpacity: (_b2 = element.style) == null ? void 0 : _b2.opacity,
                onOpacityChange: (opacity) => {
                  onChange({ opacity });
                }
              }
            )
          ] })
        ] })
      ]
    }
  );
}
function ColorSwatches({
  elementColor,
  onColorPreview,
  onChange
}) {
  const changeColor = (color2) => (e2) => {
    e2.stopPropagation(), onColorPreview(null), elementColor !== color2 && onChange(color2);
  };
  return /* @__PURE__ */ jsx(Stack$1, { gap: 2, onMouseLeave: () => onColorPreview(null), children: /* @__PURE__ */ jsxs(TooltipGroup, { openDelay: 1e3, closeDelay: 300, children: [
    /* @__PURE__ */ jsx(Flex, { maw: 120, gap: "6", justify: "flex-start", align: "flex-start", direction: "row", wrap: "wrap", children: themedColors.map(({ key, value }) => /* @__PURE__ */ jsx(
      Tooltip$5,
      {
        label: key,
        fz: "xs",
        color: "dark",
        offset: 2,
        transitionProps: { duration: 140, transition: "slide-up" },
        children: /* @__PURE__ */ jsx(
          ColorSwatch,
          {
            color: value,
            size: 18,
            withShadow: !0,
            onMouseEnter: () => onColorPreview(key),
            onClick: changeColor(key),
            style: { color: "#fff", cursor: "pointer" },
            children: elementColor === key && /* @__PURE__ */ jsx(CheckIcon, { style: { width: rem(10), height: rem(10) } })
          }
        )
      },
      key
    )) }),
    /* @__PURE__ */ jsx(
      Flex,
      {
        mt: "sm",
        maw: 110,
        gap: "6",
        justify: "flex-start",
        align: "flex-start",
        direction: "row",
        wrap: "wrap",
        children: colors.map(({ key, value }) => /* @__PURE__ */ jsx(
          Tooltip$5,
          {
            label: key,
            fz: "xs",
            color: "dark",
            offset: 2,
            transitionProps: { duration: 140, transition: "slide-up" },
            children: /* @__PURE__ */ jsx(
              ColorSwatch,
              {
                color: value,
                size: 18,
                onMouseEnter: () => onColorPreview(key),
                onClick: changeColor(key),
                style: { color: "#fff", cursor: "pointer" },
                children: elementColor === key && /* @__PURE__ */ jsx(CheckIcon, { style: { width: rem(10), height: rem(10) } })
              }
            )
          },
          key
        ))
      }
    )
  ] }) });
}
function BorderStyleOption({
  elementBorderStyle = "dashed",
  onChange
}) {
  const [value, setValue] = useState(elementBorderStyle);
  return useEffect(() => {
    setValue(elementBorderStyle);
  }, [elementBorderStyle]), /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(
    SegmentedControl,
    {
      size: "xs",
      fullWidth: !0,
      withItemsBorders: !1,
      value,
      onChange: (v2) => {
        const border = v2;
        setValue(border), onChange({ border });
      },
      styles: {
        label: {
          paddingTop: 2,
          paddingBottom: 2
        }
      },
      data: [
        { label: "Solid", value: "solid" },
        { label: "Dashed", value: "dashed" },
        { label: "Dotted", value: "dotted" },
        { label: "None", value: "none" }
      ]
    }
  ) });
}
function OpacityOption({
  elementOpacity = 100,
  onOpacityChange
}) {
  const [value, setValue] = useState(elementOpacity);
  return useUpdateEffect(() => {
    setValue(elementOpacity);
  }, [elementOpacity]), /* @__PURE__ */ jsx(
    Slider,
    {
      size: "sm",
      color: "dark",
      value,
      onChange: setValue,
      onChangeEnd: onOpacityChange
    }
  );
}
function BrowseRelationshipsButton({ elementId }) {
  const diagramApi = useDiagramStoreApi(), portalProps = useMantinePortalProps();
  return /* @__PURE__ */ jsx(Tooltip$1, { label: "Browse relationships", ...portalProps, children: /* @__PURE__ */ jsx(
    ActionIcon$1,
    {
      size: "sm",
      variant: "subtle",
      color: "gray",
      onClick: (e2) => {
        e2.stopPropagation(), diagramApi.getState().openOverlay({
          relationshipsOf: elementId
        });
      },
      children: /* @__PURE__ */ jsx(
        IconTransform,
        {
          stroke: 2,
          style: {
            width: "72%",
            height: "72%"
          }
        }
      )
    }
  ) });
}
function useFramerAnimateVariants() {
  const [variants, setVariants] = useState(null), handlers = useMemo(() => {
    const getTarget2 = (e2) => {
      var _a4, _b2;
      try {
        return ((_b2 = (_a4 = e2 == null ? void 0 : e2.target) == null ? void 0 : _a4.closest("[data-animate-target]")) == null ? void 0 : _b2.getAttribute("data-animate-target")) ?? null;
      } catch (_e) {
        return console.warn("Failed to get animate target", _e), null;
      }
    }, onHoverStart = (e2) => {
      e2 == null || e2.stopPropagation();
      const hoverTarget = getTarget2(e2);
      if (!t$4(hoverTarget) || n(hoverTarget)) {
        setVariants(null);
        return;
      }
      setVariants(["hovered", `hovered:${hoverTarget}`]);
    }, resetVariants = (e2) => {
      e2 == null || e2.stopPropagation(), setVariants(null);
    };
    return {
      onTapStart: (e2) => {
        e2 == null || e2.stopPropagation();
        const tapTarget = getTarget2(e2);
        if (!t$4(tapTarget)) {
          setVariants(null);
          return;
        }
        n(tapTarget) ? setVariants([
          "hovered",
          "tap"
        ]) : setVariants([
          "hovered",
          `hovered:${tapTarget}`,
          `tap:${tapTarget}`
        ]);
      },
      onHoverStart,
      onHoverEnd: resetVariants,
      onTapCancel: resetVariants,
      onTap: onHoverStart
    };
  }, [setVariants]);
  return [variants, handlers];
}
var containerForFramer = "_10hx3ma0", container$3 = "_10hx3ma2", nodeHandlerInCenter = "_10hx3ma3", dimmed = "_10hx3ma4", varOpacity = "var(--_10hx3ma5)", varBorderTransparency = "var(--_10hx3ma6)", compoundBody = "_10hx3ma7", compoundTitle = "_10hx3ma8", withNavigation = "_10hx3ma9", transparent = "_10hx3mab", title$1 = "_10hx3mac", indicator = "_10hx3mag", navigateBtn = "_10hx3maj _10hx3mai", detailsBtn = "_10hx3mak _10hx3mai", elementIcon = "_10hx3mal";
const isEqualProps$1 = (prev, next) => prev.id === next.id && deepEqual$1(prev.selected ?? !1, next.selected ?? !1) && deepEqual$1(prev.dragging ?? !1, next.dragging ?? !1) && deepEqual$1(prev.data, next.data), VariantsRoot$1 = {
  idle: {
    transition: {
      delayChildren: 0.1
      // stagger
    }
  },
  selected: {},
  hovered: {},
  tap: {}
}, VariantsNavigate$1 = {
  idle: {
    "--ai-bg": "var(--ai-bg-idle)",
    scale: 1,
    opacity: 0.8,
    originX: 1,
    originY: 0.25,
    translateX: 0,
    translateY: 0
  },
  selected: {},
  hovered: {
    "--ai-bg": "var(--ai-bg-hover)",
    scale: 1.25,
    opacity: 1,
    translateX: -1
  },
  "hovered:navigate": {
    scale: 1.42
  },
  "hovered:relations": {},
  "tap:navigate": {
    scale: 1.15
  }
};
VariantsNavigate$1.selected = VariantsNavigate$1.hovered;
const VariantsDetailsBtn$1 = {
  idle: {
    "--ai-bg": "var(--ai-bg-idle)",
    scale: 1,
    opacity: 0.3
  },
  selected: {},
  hovered: {
    scale: 1.2,
    opacity: 0.6
  },
  "hovered:details": {
    scale: 1.42,
    opacity: 1
  },
  "tap:details": {
    scale: 1.15
  }
};
VariantsDetailsBtn$1.selected = VariantsDetailsBtn$1.hovered;
const CompoundNodeMemo = /* @__PURE__ */ memo$1(({
  id: id2,
  selected: selected2 = !1,
  dragging = !1,
  data: {
    isViewGroup,
    element
  }
}) => {
  const { depth, style: style2, color: color2 } = element, isNotViewGroup = !isViewGroup, opacity = u((style2.opacity ?? 100) / 100, {
    min: 0,
    max: 1
  }), borderTransparency = u(50 - opacity * 50, {
    min: 0,
    max: 50
  }), {
    viewId,
    triggerOnNavigateTo,
    openOverlay,
    isEditable,
    isHovered,
    isDimmed,
    isInteractive,
    isNavigable,
    renderIcon,
    enableElementDetails
  } = useDiagramState((s2) => ({
    viewId: s2.view.id,
    triggerOnNavigateTo: s2.triggerOnNavigateTo,
    openOverlay: s2.openOverlay,
    isEditable: s2.readonly !== !0,
    isHovered: s2.hoveredNodeId === id2,
    isDimmed: s2.dimmed.has(id2),
    isInteractive: s2.nodesDraggable || s2.nodesSelectable || s2.enableElementDetails || !!s2.onNavigateTo && !!element.navigateTo,
    // If this is a view group, we don't want to show the navigate button
    isNavigable: isNotViewGroup && !!s2.onNavigateTo && !!element.navigateTo,
    renderIcon: s2.renderIcon,
    enableElementDetails: isNotViewGroup && s2.enableElementDetails
  })), _isToolbarVisible = isNotViewGroup && isEditable && (isHovered || !1), [isToolbarVisible] = useDebouncedValue(_isToolbarVisible, _isToolbarVisible ? 500 : 300), [animateVariants, animateHandlers] = useFramerAnimateVariants();
  let animate;
  switch (!0) {
    case (dragging && selected2):
      animate = "selected";
      break;
    case dragging:
      animate = "idle";
      break;
    case (isInteractive && isHovered):
      animate = "hovered";
      break;
    case selected2:
      animate = "selected";
      break;
    default:
      animate = "idle";
  }
  const [previewColor, setPreviewColor] = useState(null), onNavigateTo = useCallback((e2) => {
    e2.stopPropagation(), triggerOnNavigateTo(id2, e2);
  }, [triggerOnNavigateTo, id2]), onOpenDetails = useCallback((e2) => {
    e2.stopPropagation(), openOverlay({ elementDetails: element.id });
  }, [openOverlay, element.id]), elementIcon$12 = ElementIcon({
    element,
    viewId,
    className: elementIcon,
    renderIcon
  });
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    isToolbarVisible && /* @__PURE__ */ jsx(
      CompoundToolbar,
      {
        isVisible: !0,
        element,
        align: "start",
        onColorPreview: setPreviewColor
      }
    ),
    /* @__PURE__ */ jsx(
      Box,
      {
        component: m$1.div,
        layoutId: `${viewId}:element:${id2}`,
        className: containerForFramer,
        children: /* @__PURE__ */ jsxs(
          Box,
          {
            component: m$1.div,
            variants: VariantsRoot$1,
            initial: !1,
            animate: isHovered && !dragging ? animateVariants ?? animate : animate,
            className: clsx(
              container$3,
              "likec4-compound-node",
              opacity < 1 && "likec4-compound-transparent",
              isDimmed && dimmed
            ),
            mod: {
              "animate-target": "",
              "compound-depth": depth,
              "likec4-color": previewColor ?? color2,
              hovered: isHovered
            },
            tabIndex: -1,
            ...isInteractive && {
              onTapStart: animateHandlers.onTapStart,
              onTap: animateHandlers.onTap,
              onTapCancel: animateHandlers.onTapCancel
            },
            children: [
              /* @__PURE__ */ jsx("svg", { className: indicator, children: /* @__PURE__ */ jsx(
                "rect",
                {
                  x: 0,
                  y: 0,
                  width: "100%",
                  height: "100%",
                  rx: 6
                }
              ) }),
              /* @__PURE__ */ jsx(
                Box,
                {
                  className: clsx(
                    compoundBody,
                    opacity < 1 && transparent,
                    "likec4-compound"
                  ),
                  style: {
                    ...opacity < 1 && {
                      ...assignInlineVars({
                        [varBorderTransparency]: `${borderTransparency}%`,
                        [varOpacity]: opacity.toFixed(2)
                      }),
                      borderStyle: style2.border ?? "dashed"
                    }
                  },
                  children: /* @__PURE__ */ jsxs(
                    Box,
                    {
                      className: clsx(
                        compoundTitle,
                        isNavigable && withNavigation,
                        "likec4-compound-title"
                      ),
                      children: [
                        elementIcon$12,
                        /* @__PURE__ */ jsx(
                          Text$6,
                          {
                            component: m$1.div,
                            layoutId: `${viewId}:element:title:${id2}`,
                            className: title$1,
                            children: element.title
                          },
                          `${viewId}:element:title:${id2}`
                        ),
                        enableElementDetails && /* @__PURE__ */ jsx(
                          Tooltip$5,
                          {
                            fz: "xs",
                            color: "dark",
                            label: "Open details",
                            withinPortal: !1,
                            offset: 2,
                            openDelay: 600,
                            children: /* @__PURE__ */ jsx(
                              ActionIcon$1,
                              {
                                component: m$1.div,
                                variants: VariantsDetailsBtn$1,
                                "data-animate-target": "details",
                                className: clsx("nodrag nopan", detailsBtn),
                                radius: "md",
                                style: { zIndex: 100 },
                                role: "button",
                                onClick: onOpenDetails,
                                onDoubleClick: stopPropagation$1,
                                ...isInteractive && animateHandlers,
                                children: /* @__PURE__ */ jsx(IconId, { stroke: 1.8, style: { width: "75%" } })
                              }
                            )
                          }
                        )
                      ]
                    }
                  )
                }
              ),
              isNavigable && /* @__PURE__ */ jsx(
                ActionIcon$1,
                {
                  component: m$1.div,
                  variants: VariantsNavigate$1,
                  "data-animate-target": "navigate",
                  className: clsx("nodrag nopan", navigateBtn),
                  radius: "md",
                  style: { zIndex: 100 },
                  onClick: onNavigateTo,
                  role: "button",
                  onDoubleClick: stopPropagation$1,
                  ...isInteractive && animateHandlers,
                  children: /* @__PURE__ */ jsx(IconZoomScan, { style: { width: "75%" } })
                },
                "navigate"
              )
            ]
          }
        )
      },
      `${viewId}:element:${id2}`
    ),
    /* @__PURE__ */ jsx(Handle, { type: "target", position: Position.Top, className: nodeHandlerInCenter }),
    /* @__PURE__ */ jsx(Handle, { type: "source", position: Position.Top, className: nodeHandlerInCenter })
  ] });
}, isEqualProps$1), Text = Text$6.withProps({
  component: "div"
}), selectedScale = 1.015, VariantsRoot = {
  idle: (_, { scale: scale2 }) => ({
    scale: 1,
    transition: e$2(scale2) && scale2 > selectedScale ? {
      delay: 0.1,
      delayChildren: 0.06
      // staggerChildren: 0.07,
      // staggerDirection: -1
    } : {}
  }),
  selected: {
    scale: selectedScale
  },
  hovered: (_, { scale: scale2 }) => ({
    scale: 1.06,
    transition: !e$2(scale2) || scale2 >= 1 && scale2 < 1.06 ? {
      // delay: 0.09,
      delayChildren: 0.08
    } : {}
  }),
  tap: {
    scale: 0.975
  }
}, VariantsNavigateBtn = {
  idle: {
    "--ai-bg": "var(--ai-bg-idle)",
    scale: 1,
    opacity: 0.5,
    originY: 0.5
  },
  selected: {},
  hovered: {
    "--ai-bg": "var(--ai-bg-hover)",
    scale: 1.35,
    opacity: 1
  }
};
VariantsNavigateBtn.selected = VariantsNavigateBtn.hovered;
const VariantsNavigate = {
  ...VariantsNavigateBtn,
  "hovered:navigate": {
    scale: 1.42
  },
  "tap:navigate": {
    scale: 1.15
  }
}, VariantRealationships = {
  ...VariantsNavigateBtn,
  "hovered:relationships": {
    scale: 1.42
  },
  "tap:relationships": {
    scale: 1.15
  }
}, VariantsDetailsBtn = {
  idle: {
    "--ai-bg": "var(--ai-bg-idle)",
    scale: 1,
    opacity: 0.5
  },
  selected: {},
  hovered: {
    scale: 1.2,
    opacity: 0.7
  },
  "hovered:details": {
    scale: 1.42,
    opacity: 1
  },
  "tap:details": {
    scale: 1.15
  }
};
VariantsDetailsBtn.selected = VariantsDetailsBtn.hovered;
const isEqualProps = (prev, next) => prev.id === next.id && deepEqual$1(prev.selected ?? !1, next.selected ?? !1) && deepEqual$1(prev.dragging ?? !1, next.dragging ?? !1) && deepEqual$1(prev.width ?? 0, next.width ?? 0) && deepEqual$1(prev.height ?? 0, next.height ?? 0) && deepEqual$1(prev.data, next.data), ElementNodeMemo = memo$1(function({
  id: id2,
  data: {
    element
  },
  dragging,
  selected: selected2 = !1,
  width: width2,
  height
}) {
  const {
    viewId,
    isEditable,
    isHovered,
    isDimmed,
    isNavigable,
    isInteractive,
    enableElementDetails,
    enableRelationshipBrowser,
    triggerOnNavigateTo,
    openOverlay,
    isInActiveOverlay,
    renderIcon
  } = useDiagramState((s2) => {
    var _a4, _b2;
    return {
      viewId: s2.view.id,
      isEditable: s2.readonly !== !0,
      isHovered: s2.hoveredNodeId === id2,
      isDimmed: s2.dimmed.has(id2),
      isInteractive: s2.nodesDraggable || s2.nodesSelectable || s2.enableElementDetails || s2.enableRelationshipBrowser || !!s2.onNavigateTo && !!element.navigateTo,
      isNavigable: !!s2.onNavigateTo && !!element.navigateTo,
      enableElementDetails: s2.enableElementDetails,
      enableRelationshipBrowser: s2.enableRelationshipBrowser,
      triggerOnNavigateTo: s2.triggerOnNavigateTo,
      openOverlay: s2.openOverlay,
      isInActiveOverlay: (((_a4 = s2.activeOverlay) == null ? void 0 : _a4.elementDetails) ?? ((_b2 = s2.activeOverlay) == null ? void 0 : _b2.relationshipsOf)) === id2,
      renderIcon: s2.renderIcon
    };
  }), _isToolbarVisible = isEditable && (isHovered || !1), [isToolbarVisible] = useDebouncedValue(_isToolbarVisible, _isToolbarVisible ? 500 : 300), w2 = toDomPrecision(width2 ?? element.width), h2 = toDomPrecision(height ?? element.height), [animateVariants, animateHandlers] = useFramerAnimateVariants();
  let animate;
  switch (!0) {
    case isInActiveOverlay:
      animate = "idle";
      break;
    case (dragging && selected2):
      animate = "selected";
      break;
    case dragging:
      animate = "idle";
      break;
    case (isInteractive && isHovered):
      animate = "hovered";
      break;
    case selected2:
      animate = "selected";
      break;
    default:
      animate = "idle";
  }
  const elementIcon2 = ElementIcon({
    element,
    viewId,
    className: elementIcon$2,
    renderIcon
  }), [previewColor, setPreviewColor] = useState(null), onNavigateTo = useCallback((e2) => {
    e2.stopPropagation(), triggerOnNavigateTo(id2, e2);
  }, [triggerOnNavigateTo, id2]), onOpenDetails = useCallback((e2) => {
    e2.stopPropagation(), openOverlay({ elementDetails: element.id });
  }, [openOverlay, element.id]), onOpenRelationships = useCallback((e2) => {
    e2.stopPropagation(), openOverlay({ relationshipsOf: element.id });
  }, [openOverlay, element.id]);
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    isToolbarVisible && /* @__PURE__ */ jsx(
      ElementToolbar,
      {
        element,
        isVisible: isToolbarVisible,
        onColorPreview: setPreviewColor
      }
    ),
    /* @__PURE__ */ jsxs(
      Box,
      {
        component: m$1.div,
        className: clsx([
          container$6,
          isDimmed && dimmed$2,
          animate !== "idle" && containerAnimated,
          "likec4-element-node"
        ]),
        layoutId: `${viewId}:element:${id2}`,
        "data-hovered": !dragging && isHovered,
        "data-likec4-color": previewColor ?? element.color,
        "data-likec4-shape": element.shape,
        "data-animate-target": "",
        initial: !1,
        variants: VariantsRoot,
        animate: isHovered && !dragging && !isInActiveOverlay ? animateVariants ?? animate : animate,
        tabIndex: -1,
        ...isInteractive && {
          onTapStart: animateHandlers.onTapStart,
          onTap: animateHandlers.onTap,
          onTapCancel: animateHandlers.onTapCancel
        },
        children: [
          /* @__PURE__ */ jsxs(
            "svg",
            {
              className: clsx(shapeSvg$1),
              viewBox: `0 0 ${w2} ${h2}`,
              children: [
                /* @__PURE__ */ jsx("g", { className: indicator$1, children: /* @__PURE__ */ jsx(SelectedIndicator, { shape: element.shape, w: w2, h: h2 }) }),
                /* @__PURE__ */ jsx(ElementShapeSvg, { shape: element.shape, w: w2, h: h2 })
              ]
            }
          ),
          /* @__PURE__ */ jsxs(
            Box,
            {
              className: clsx(
                elementDataContainer,
                n$4(elementIcon2) && hasIcon,
                "likec4-element"
              ),
              children: [
                elementIcon2,
                /* @__PURE__ */ jsxs(Box, { className: clsx(elementTextData, "likec4-element-main-props"), children: [
                  /* @__PURE__ */ jsx(
                    Text,
                    {
                      component: m$1.div,
                      layoutId: `${viewId}:element:title:${id2}`,
                      className: clsx(title$4, "likec4-element-title"),
                      children: element.title
                    },
                    `${viewId}:element:title:${id2}`
                  ),
                  element.technology && /* @__PURE__ */ jsx(Text, { className: clsx(technology, "likec4-element-technology"), children: element.technology }),
                  element.description && /* @__PURE__ */ jsx(Text, { className: clsx(description$1, "likec4-element-description"), lineClamp: 5, children: element.description })
                ] })
              ]
            }
          ),
          (enableRelationshipBrowser || isNavigable) && /* @__PURE__ */ jsxs(Group, { className: navigateBtnBox$1, align: "center", children: [
            enableRelationshipBrowser && /* @__PURE__ */ jsx(
              ActionIcon$1,
              {
                component: m$1.div,
                variants: VariantRealationships,
                "data-animate-target": "relationships",
                className: clsx("nodrag nopan", navigateBtn$2),
                radius: "md",
                role: "button",
                onClick: onOpenRelationships,
                onDoubleClick: stopPropagation$1,
                ...isInteractive && animateHandlers,
                children: /* @__PURE__ */ jsx(IconTransform, { style: { width: "75%" } })
              }
            ),
            isNavigable && /* @__PURE__ */ jsx(
              ActionIcon$1,
              {
                component: m$1.div,
                variants: VariantsNavigate,
                "data-animate-target": "navigate",
                className: clsx("nodrag nopan", navigateBtn$2),
                radius: "md",
                role: "button",
                onClick: onNavigateTo,
                onDoubleClick: stopPropagation$1,
                ...isInteractive && animateHandlers,
                children: /* @__PURE__ */ jsx(IconZoomScan, { style: { width: "75%" } })
              }
            )
          ] }),
          enableElementDetails && /* @__PURE__ */ jsx(
            Tooltip$5,
            {
              fz: "xs",
              color: "dark",
              label: "Open details",
              withinPortal: !1,
              offset: 2,
              openDelay: 600,
              children: /* @__PURE__ */ jsx(
                ActionIcon$1,
                {
                  component: m$1.div,
                  variants: VariantsDetailsBtn,
                  "data-animate-target": "details",
                  className: clsx("nodrag nopan", detailsBtn$1),
                  radius: "md",
                  style: { zIndex: 100 },
                  role: "button",
                  onClick: onOpenDetails,
                  onDoubleClick: stopPropagation$1,
                  ...isInteractive && animateHandlers,
                  children: /* @__PURE__ */ jsx(IconId, { stroke: 1.8, style: { width: "75%" } })
                }
              )
            }
          )
        ]
      },
      `${viewId}:element:${id2}`
    ),
    /* @__PURE__ */ jsx(Handle, { type: "target", position: Position.Top, className: handleCenter }),
    /* @__PURE__ */ jsx(Handle, { type: "source", position: Position.Top, className: handleCenter })
  ] });
}, isEqualProps);
function useXYFlowEvents() {
  const diagramApi = useDiagramStoreApi(), lastClickTimestamp = useRef(), dblclickTimeout = useRef(), hoveredNodeFromOnEdgeEnterRef = useRef("");
  return useMemo(() => {
    const dbclickLock = () => dblclickTimeout.current !== void 0 ? !0 : (dblclickTimeout.current = window.setTimeout(() => {
      dblclickTimeout.current = void 0;
    }, 300), !1), lastClickWasRecent = (ms = 2e3) => {
      const prevTimestamp = lastClickTimestamp.current ?? 0, now2 = lastClickTimestamp.current = Date.now();
      return prevTimestamp + ms > now2;
    };
    return {
      onDoubleClick: (event) => {
        const {
          onCanvasDblClick,
          zoomable,
          viewportChanged,
          fitDiagram,
          resetFocusAndLastClicked
        } = diagramApi.getState();
        resetFocusAndLastClicked(), zoomable && viewportChanged && fitDiagram(), onCanvasDblClick || event.stopPropagation(), onCanvasDblClick == null || onCanvasDblClick(event);
      },
      onPaneClick: (event) => {
        if (dbclickLock())
          return;
        const {
          focusedNodeId,
          activeWalkthrough,
          fitDiagram,
          onCanvasClick,
          resetFocusAndLastClicked
        } = diagramApi.getState();
        (focusedNodeId ?? activeWalkthrough) !== null && (fitDiagram(), onCanvasClick || event.stopPropagation()), resetFocusAndLastClicked(), onCanvasClick == null || onCanvasClick(event);
      },
      onNodeContextMenu: (event, xynode) => {
        var _a4, _b2;
        diagramApi.getState().setLastClickedNode(xynode.id), (_b2 = (_a4 = diagramApi.getState()).onNodeContextMenu) == null || _b2.call(
          _a4,
          xynode.data.element,
          event
        );
      },
      onPaneContextMenu: (event) => {
        var _a4, _b2;
        diagramApi.getState().resetFocusAndLastClicked(), (_b2 = (_a4 = diagramApi.getState()).onCanvasContextMenu) == null || _b2.call(_a4, event);
      },
      onEdgeContextMenu: (event, xyedge) => {
        var _a4, _b2;
        diagramApi.getState().setLastClickedEdge(xyedge.id), (_b2 = (_a4 = diagramApi.getState()).onEdgeContextMenu) == null || _b2.call(
          _a4,
          xyedge.data.edge,
          event
        );
      },
      onNodeClick: (event, xynode) => {
        const {
          focusedNodeId,
          fitDiagram,
          focusOnNode,
          onNodeClick,
          xystore,
          enableFocusMode,
          lastClickedNodeId,
          nodesSelectable,
          enableElementDetails,
          setLastClickedNode,
          onOpenSourceElement,
          openOverlay
        } = diagramApi.getState();
        setLastClickedNode(xynode.id);
        const shallChangeFocus = !!focusedNodeId && focusedNodeId !== xynode.id, clickedRecently = lastClickWasRecent() && lastClickedNodeId === xynode.id;
        let stopPropagation2 = !1;
        if (clickedRecently && onOpenSourceElement && (onOpenSourceElement(xynode.data.element.id), stopPropagation2 = !0), enableFocusMode)
          switch (!0) {
            case (shallChangeFocus || clickedRecently && !focusedNodeId): {
              focusOnNode(xynode.id), stopPropagation2 = !0;
              break;
            }
            case (clickedRecently && focusedNodeId === xynode.id): {
              focusOnNode(!1), fitDiagram(), stopPropagation2 = !0;
              break;
            }
            case (!clickedRecently && focusedNodeId === xynode.id && enableElementDetails): {
              openOverlay({
                elementDetails: xynode.data.element.id
              }), stopPropagation2 = !0;
              break;
            }
          }
        else enableElementDetails && (clickedRecently || focusedNodeId === xynode.id) && !onNodeClick ? (openOverlay({
          elementDetails: xynode.data.element.id
        }), stopPropagation2 = !0) : nodesSelectable && (xystore.getState().addSelectedNodes([xynode.id]), stopPropagation2 = !0);
        if (!onNodeClick && stopPropagation2) {
          event.stopPropagation();
          return;
        }
        onNodeClick == null || onNodeClick(
          xynode.data.element,
          event
        );
      },
      onNodeDoubleClick: (event, xynode) => {
        const {
          setLastClickedNode
        } = diagramApi.getState();
        setLastClickedNode(xynode.id), lastClickWasRecent(), event.stopPropagation();
      },
      onEdgeClick: (event, xyedge) => {
        const {
          lastClickedEdgeId,
          isDynamicView,
          enableDynamicViewWalkthrough,
          activateWalkthrough,
          activeWalkthrough,
          focusedNodeId,
          xystore,
          nodesSelectable,
          focusOnNode,
          onEdgeClick,
          setLastClickedEdge
        } = diagramApi.getState();
        lastClickedEdgeId !== xyedge.id && setLastClickedEdge(xyedge.id);
        const isNotAFirstClick = lastClickedEdgeId === xyedge.id, connectedToFocusedNode = n$4(focusedNodeId) && (focusedNodeId === xyedge.source || focusedNodeId === xyedge.target);
        if (isDynamicView && enableDynamicViewWalkthrough && (connectedToFocusedNode || isNotAFirstClick || l$2(activeWalkthrough))) {
          const nextStep = xyedge.data.edge.id;
          if ((activeWalkthrough == null ? void 0 : activeWalkthrough.stepId) !== nextStep) {
            activateWalkthrough(nextStep), event.stopPropagation();
            return;
          }
        }
        if (n$4(focusedNodeId)) {
          if (focusOnNode(connectedToFocusedNode && focusedNodeId === xyedge.source ? xyedge.target : xyedge.source), !onEdgeClick) {
            event.stopPropagation();
            return;
          }
        } else if (nodesSelectable && (xystore.getState().addSelectedEdges([xyedge.id]), !onEdgeClick)) {
          event.stopPropagation();
          return;
        }
        onEdgeClick == null || onEdgeClick(
          xyedge.data.edge,
          event
        );
      },
      onEdgeDoubleClick: (event, xyedge) => {
        diagramApi.getState().setLastClickedEdge(xyedge.id);
        const {
          enableFocusMode,
          isDynamicView,
          enableDynamicViewWalkthrough,
          focusOnNode,
          activeWalkthrough,
          activateWalkthrough,
          openOverlay,
          enableRelationshipDetails
        } = diagramApi.getState();
        if (isDynamicView && enableDynamicViewWalkthrough) {
          const nextStep = xyedge.data.edge.id;
          (activeWalkthrough == null ? void 0 : activeWalkthrough.stepId) !== nextStep && (activateWalkthrough(nextStep), event.stopPropagation());
          return;
        }
        if (enableRelationshipDetails) {
          openOverlay({
            edgeDetails: xyedge.data.edge.id
          }), event.stopPropagation();
          return;
        }
        if (enableFocusMode) {
          focusOnNode(xyedge.source), event.stopPropagation();
          return;
        }
      },
      onMoveEnd: (event, _viewport) => {
        const viewportChanged = !!event;
        viewportChanged !== diagramApi.getState().viewportChanged && diagramApi.setState({ viewportChanged }, !1, `viewport-changed: ${viewportChanged}`);
      },
      onNodeMouseEnter: (_event, xynode) => {
        hoveredNodeFromOnEdgeEnterRef.current = "", diagramApi.getState().setHoveredNode(xynode.id);
      },
      onNodeMouseLeave: (_event, xynode) => {
        const { hoveredNodeId, setHoveredNode } = diagramApi.getState();
        hoveredNodeId === xynode.id && setHoveredNode(null);
      },
      onEdgeMouseEnter: (_event, { id: id2, source, target }) => {
        const { hoveredNodeId, focusedNodeId, setHoveredEdge, setHoveredNode } = diagramApi.getState();
        if (setHoveredEdge(id2), (focusedNodeId === source || focusedNodeId === target) && focusedNodeId !== hoveredNodeId) {
          const next = hoveredNodeFromOnEdgeEnterRef.current = source === focusedNodeId ? target : source;
          setHoveredNode(next);
        }
      },
      onEdgeMouseLeave: (_event, xyedge) => {
        const { hoveredEdgeId, setHoveredEdge, hoveredNodeId, setHoveredNode } = diagramApi.getState();
        hoveredEdgeId === xyedge.id && setHoveredEdge(null), hoveredNodeId === hoveredNodeFromOnEdgeEnterRef.current && setHoveredNode(null), hoveredNodeFromOnEdgeEnterRef.current = "";
      }
    };
  }, [diagramApi]);
}
const nodeTypes = {
  element: ElementNodeMemo,
  compound: CompoundNodeMemo
}, edgeTypes = {
  relationship: RelationshipEdge
}, selector$3 = (s2) => ({
  nodes: s2.xynodes,
  edges: s2.xyedges,
  onInit: s2.onInit,
  onNodesChange: s2.onNodesChange,
  onEdgesChange: s2.onEdgesChange,
  nodesSelectable: s2.nodesSelectable || s2.focusedNodeId !== null,
  nodesDraggable: s2.nodesDraggable,
  fitView: s2.fitViewEnabled,
  fitViewPadding: s2.fitViewPadding,
  // hasOnNavigateTo: !!s.onNavigateTo,
  // hasOnNodeClick: !!s.onNodeClick,
  hasOnNodeContextMenu: !!s2.onNodeContextMenu,
  hasOnCanvasContextMenu: !!s2.onCanvasContextMenu,
  hasOnEdgeContextMenu: !!s2.onEdgeContextMenu,
  hasOnEdgeClick: !!s2.onEdgeClick,
  zoomable: s2.zoomable,
  pannable: s2.pannable,
  // If fitView is not enabled
  // And diagram starts with a negative x or y - we need to translate viewprot
  translateX: s2.fitViewEnabled ? 0 : -Math.min(s2.view.bounds.x, 0),
  translateY: s2.fitViewEnabled ? 0 : -Math.min(s2.view.bounds.y, 0)
});
function XYFlow({
  colorMode = "system",
  className,
  children: children2,
  style: style2
}) {
  const xyflowApi = useXYStoreApi(), {
    nodes,
    edges,
    onInit,
    onNodesChange,
    onEdgesChange,
    nodesSelectable,
    nodesDraggable,
    fitView: fitView2,
    fitViewPadding,
    pannable,
    zoomable,
    hasOnNodeContextMenu,
    hasOnCanvasContextMenu,
    hasOnEdgeContextMenu,
    translateX,
    translateY
  } = useDiagramState(selector$3, shallowEqual), layoutConstraints = useLayoutConstraints(), {
    onNodeContextMenu,
    onPaneContextMenu,
    onEdgeContextMenu,
    ...handlers
  } = useXYFlowEvents();
  return useOnViewportChange({
    onEnd: ({ x: x2, y: y2, zoom: zoom2 }) => {
      const roundedX = Math.round(x2), roundedY = Math.round(y2);
      (x2 !== roundedX || y2 !== roundedY) && xyflowApi.setState({ transform: [roundedX, roundedY, zoom2] });
    }
  }), /* @__PURE__ */ jsx(
    index$2,
    {
      className,
      style: style2,
      ...colorMode && { colorMode },
      nodes,
      edges,
      onNodesChange,
      onEdgesChange,
      onInit,
      nodeTypes,
      edgeTypes,
      zoomOnPinch: zoomable,
      zoomOnScroll: !pannable && zoomable,
      ...!zoomable && {
        zoomActivationKeyCode: null
      },
      zoomOnDoubleClick: !1,
      maxZoom: zoomable ? MaxZoom : 1,
      minZoom: zoomable ? MinZoom : 1,
      fitView: !1,
      fitViewOptions: {
        minZoom: MinZoom,
        maxZoom: 1,
        padding: fitViewPadding,
        includeHiddenNodes: !0
      },
      ...!fitView2 && {
        viewport: {
          x: translateX,
          y: translateY,
          zoom: 1
        }
      },
      preventScrolling: zoomable || pannable,
      defaultMarkerColor: "var(--xy-edge-stroke)",
      noDragClassName: "nodrag",
      noPanClassName: "nopan",
      panOnScroll: pannable,
      panOnDrag: pannable,
      ...!pannable && {
        selectionKeyCode: null
      },
      elementsSelectable: nodesSelectable,
      nodesFocusable: nodesDraggable || nodesSelectable,
      edgesFocusable: !1,
      nodesDraggable,
      ...nodesDraggable && layoutConstraints,
      nodeDragThreshold: 4,
      elevateNodesOnSelect: !1,
      selectNodesOnDrag: !1,
      ...hasOnNodeContextMenu && { onNodeContextMenu },
      ...hasOnCanvasContextMenu && { onPaneContextMenu },
      ...hasOnEdgeContextMenu && { onEdgeContextMenu },
      ...handlers,
      children: children2
    }
  );
}
var container$2 = "oy449t0", card$1 = "oy449t1", title = "oy449t2", description = "oy449t3";
const selector$2 = (s2) => ({
  id: s2.view.id,
  title: s2.view.title ?? "untitled",
  description: s2.view.description,
  links: s2.view.links
});
function DiagramTitlePanel() {
  const { id: id2, title: title$12, description: description$12, links } = useDiagramState(selector$2), [isCollapsed, setCollapsed] = useLocalStorage({
    key: "diagram-title-webview-collapsed",
    defaultValue: !1
  }), toggle = () => setCollapsed((v2) => !v2);
  return /* @__PURE__ */ jsx(AnimatePresence, { mode: "wait", children: /* @__PURE__ */ jsx(
    m$1.div,
    {
      initial: { opacity: 0.05, scale: 0.7 },
      animate: { opacity: 1, scale: 1 },
      exit: {
        opacity: 0.05,
        scale: 0.6
      },
      className: clsx("react-flow__panel", container$2),
      style: {
        transformOrigin: "left center"
      },
      children: /* @__PURE__ */ jsxs(
        Card,
        {
          radius: "sm",
          className: card$1,
          withBorder: !isCollapsed,
          p: isCollapsed ? "sm" : "md",
          onDoubleClick: (e2) => e2.stopPropagation(),
          children: [
            isCollapsed && /* @__PURE__ */ jsx(CardSection, { children: /* @__PURE__ */ jsx(
              Button,
              {
                fullWidth: !0,
                justify: "stretch",
                size: "md",
                radius: "0",
                variant: "subtle",
                color: "gray",
                onClick: toggle,
                fw: 500,
                fz: "sm",
                tabIndex: -1,
                children: title$12
              }
            ) }),
            !isCollapsed && /* @__PURE__ */ jsxs(Fragment, { children: [
              /* @__PURE__ */ jsx(CardSection, { mb: "xs", children: /* @__PURE__ */ jsx(
                Button,
                {
                  fullWidth: !0,
                  size: "xs",
                  h: "sm",
                  py: 2,
                  radius: "0",
                  variant: "subtle",
                  color: "gray",
                  onClick: toggle,
                  tabIndex: -1,
                  children: /* @__PURE__ */ jsx(IconMenu, { size: 11, opacity: 0.7 })
                }
              ) }),
              /* @__PURE__ */ jsxs(Group, { justify: "stretch", wrap: "nowrap", mb: "sm", children: [
                /* @__PURE__ */ jsx(
                  Text$6,
                  {
                    component: "div",
                    flex: "1",
                    size: "md",
                    fw: 500,
                    lh: 1.1,
                    className: title,
                    children: title$12
                  }
                ),
                /* @__PURE__ */ jsxs(
                  Text$6,
                  {
                    hidden: isCollapsed,
                    component: "div",
                    flex: "0 0 auto",
                    inline: !0,
                    size: "xs",
                    fz: 9,
                    fw: 500,
                    c: "dimmed",
                    style: {
                      userSelect: "all"
                    },
                    children: [
                      /* @__PURE__ */ jsxs("span", { style: { userSelect: "none" }, children: [
                        "id:",
                        " "
                      ] }),
                      id2
                    ]
                  }
                )
              ] }),
              description$12 && /* @__PURE__ */ jsx(
                Spoiler,
                {
                  maxHeight: 42,
                  showLabel: /* @__PURE__ */ jsx(Button, { color: "gray", variant: "light", fz: "10", size: "compact-xs", tabIndex: -1, children: "show more" }),
                  hideLabel: /* @__PURE__ */ jsx(Button, { color: "gray", variant: "light", fz: "10", size: "compact-xs", tabIndex: -1, children: "hide" }),
                  children: /* @__PURE__ */ jsx(
                    Text$6,
                    {
                      component: "div",
                      size: "sm",
                      className: description,
                      children: description$12 || "no description"
                    }
                  )
                }
              ),
              !description$12 && /* @__PURE__ */ jsx(
                Text$6,
                {
                  component: "div",
                  size: "xs",
                  c: "dimmed",
                  children: "no description"
                }
              ),
              links && /* @__PURE__ */ jsx(
                Stack$1,
                {
                  gap: 3,
                  justify: "stretch",
                  align: "stretch",
                  children: links.map((link) => /* @__PURE__ */ jsxs(Group, { wrap: "nowrap", align: "center", gap: "sm", children: [
                    /* @__PURE__ */ jsx(Box, { flex: "1", style: { overflow: "hidden" }, children: /* @__PURE__ */ jsx(
                      Anchor,
                      {
                        href: link.url,
                        target: "_blank",
                        fz: "xs",
                        truncate: "end",
                        display: "inline-block",
                        w: "100%",
                        children: link.title || link.url
                      }
                    ) }),
                    /* @__PURE__ */ jsx(CopyButton, { value: link.url, children: ({ copied, copy }) => /* @__PURE__ */ jsx(
                      Button,
                      {
                        size: "compact-xs",
                        fz: "10",
                        variant: "light",
                        onClick: copy,
                        color: copied ? "teal" : "gray",
                        children: copied ? "copied" : "copy"
                      }
                    ) })
                  ] }, link.url))
                }
              )
            ] })
          ]
        }
      )
    },
    id2
  ) });
}
var container$1 = "_1cuwo5n0", buttons = "_1cuwo5n1", btn = "_1cuwo5n3", parallelStateFrame = "_1cuwo5n4";
function DynamicViewWalkthrough() {
  const isMobile = useXYStore((s2) => s2.width <= 750), {
    nextDynamicStep,
    stopDynamicView,
    isActive,
    isParallel,
    hasNext,
    hasPrevious
  } = useDiagramState((s2) => {
    var _a4, _b2, _c;
    return {
      nextDynamicStep: s2.nextDynamicStep,
      stopDynamicView: s2.stopWalkthrough,
      isActive: n$3(s2.activeWalkthrough),
      isParallel: n$4((_a4 = s2.activeWalkthrough) == null ? void 0 : _a4.parallelPrefix),
      hasNext: ((_b2 = s2.activeWalkthrough) == null ? void 0 : _b2.hasNext) ?? !1,
      hasPrevious: ((_c = s2.activeWalkthrough) == null ? void 0 : _c.hasPrevious) ?? !1
    };
  }), diagramApi = useDiagramStoreApi();
  useHotkeys(
    isActive ? [
      ["ArrowLeft", () => nextDynamicStep(-1)],
      ["ArrowRight", () => nextDynamicStep()],
      ["Escape", (e2) => {
        e2.stopImmediatePropagation(), stopDynamicView();
      }, { preventDefault: !0 }]
    ] : [
      ["ArrowLeft", () => nextDynamicStep()],
      ["ArrowRight", () => nextDynamicStep()]
    ]
  );
  const buttonProps = {
    className: btn,
    size: isMobile ? "compact-md" : "lg",
    radius: isMobile ? "lg" : "xl"
  }, startWalkthrough = (e2) => {
    e2.stopPropagation();
    const {
      xyedges,
      activateWalkthrough
    } = diagramApi.getState(), firstEdge = nonNullable(d$1(xyedges), "expected at least one edge");
    activateWalkthrough(firstEdge.data.edge.id);
  }, nextStep = (increment = 1) => (e2) => {
    e2.stopPropagation(), nextDynamicStep(increment);
  };
  return /* @__PURE__ */ jsxs(AnimatePresence, { children: [
    isParallel && /* @__PURE__ */ jsx(
      Box,
      {
        layout: !0,
        component: m$1.div,
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        className: clsx("react-flow__panel", parallelStateFrame)
      },
      "parallel-frame"
    ),
    /* @__PURE__ */ jsxs(
      Box,
      {
        className: clsx("react-flow__panel", container$1),
        onClick: (e2) => e2.stopPropagation(),
        onDoubleClick: (e2) => e2.stopPropagation(),
        children: [
          !isActive && /* @__PURE__ */ jsx(
            Button,
            {
              ...buttonProps,
              className: clsx(buttons, btn),
              rightSection: /* @__PURE__ */ jsx(IconPlayerPlayFilled, {}),
              onClick: startWalkthrough,
              px: "xl",
              children: "Start"
            }
          ),
          isParallel && /* @__PURE__ */ jsx(
            Badge,
            {
              component: m$1.div,
              initial: { opacity: 0.05, transform: "translateY(20px)" },
              animate: { opacity: 1, transform: "translateY(0)" },
              exit: {
                opacity: 0,
                transform: "translateY(20px)"
              },
              variant: "gradient",
              size: isMobile ? "xs" : "md",
              gradient: { from: "red", to: "orange", deg: 90 },
              radius: "sm",
              children: "parallel"
            },
            "parallel-badge"
          ),
          isActive && /* @__PURE__ */ jsxs(ButtonGroup, { className: buttons, children: [
            /* @__PURE__ */ jsx(
              Button,
              {
                ...buttonProps,
                pl: "lg",
                disabled: !hasPrevious,
                onClick: nextStep(-1),
                children: /* @__PURE__ */ jsx(IconPlayerSkipBackFilled, {})
              }
            ),
            /* @__PURE__ */ jsxs(
              Button,
              {
                ...buttonProps,
                px: hasNext ? "md" : "xl",
                onClick: (e2) => {
                  e2.stopPropagation(), stopDynamicView();
                },
                children: [
                  hasNext && /* @__PURE__ */ jsx(IconPlayerStopFilled, {}),
                  !hasNext && "End"
                ]
              }
            ),
            hasNext && /* @__PURE__ */ jsx(
              Button,
              {
                ...buttonProps,
                pr: "lg",
                onClick: nextStep(),
                children: /* @__PURE__ */ jsx(IconPlayerSkipForwardFilled, {})
              }
            )
          ] })
        ]
      }
    )
  ] });
}
var container = "_1o1a9t90", card = "_1o1a9t91", tabPanel = "_1o1a9t92", elementNotation = "_1o1a9t93", shapeSvg = "_1o1a9t94", shapeBadge = "_1o1a9t95";
const ElementNotation = ({ value }) => {
  const {
    title: title2,
    color: color2 = "primary",
    shape = "rectangle"
  } = value, [onlyKind, setOnlyKind] = useState(null), diagramStore = useDiagramStoreApi(), w2 = 300, h2 = 200;
  return /* @__PURE__ */ jsx(
    Card,
    {
      shadow: "none",
      px: "xs",
      py: "sm",
      className: elementNotation,
      mod: {
        "data-likec4-color": color2
      },
      onMouseEnter: () => {
        setOnlyKind(null), diagramStore.getState().highlightByElementNotation(value);
      },
      onMouseLeave: () => {
        setOnlyKind(null), diagramStore.setState({ dimmed: /* @__PURE__ */ new Set() });
      },
      children: /* @__PURE__ */ jsxs(
        Group,
        {
          gap: "sm",
          align: "stretch",
          wrap: "nowrap",
          children: [
            /* @__PURE__ */ jsx(
              Box,
              {
                flex: "0 0 70px",
                style: {
                  width: 70,
                  height: u$1(70 * (h2 / w2), 0)
                },
                children: /* @__PURE__ */ jsx(
                  "svg",
                  {
                    className: clsx(
                      shapeSvg
                    ),
                    viewBox: `0 0 ${w2} ${h2}`,
                    children: /* @__PURE__ */ jsx(
                      ElementShapeSvg,
                      {
                        shape,
                        w: w2,
                        h: h2
                      }
                    )
                  }
                )
              }
            ),
            /* @__PURE__ */ jsxs(Stack$1, { gap: 4, flex: 1, children: [
              /* @__PURE__ */ jsx(Group, { gap: 4, flex: "0 0 auto", children: value.kinds.map((kind) => /* @__PURE__ */ jsx(
                Badge,
                {
                  className: shapeBadge,
                  onMouseEnter: () => {
                    setOnlyKind(kind), diagramStore.getState().highlightByElementNotation(value, kind);
                  },
                  onMouseLeave: () => {
                    setOnlyKind(null), diagramStore.getState().highlightByElementNotation(value);
                  },
                  opacity: l$2(onlyKind) && onlyKind !== kind ? 0.25 : 1,
                  color: l$2(onlyKind) && onlyKind !== kind ? "gray" : vars.element.fill,
                  children: kind
                },
                kind
              )) }),
              /* @__PURE__ */ jsx(
                Text$6,
                {
                  component: "div",
                  fz: "sm",
                  fw: 500,
                  lh: "1.25",
                  style: {
                    textWrap: "pretty"
                  },
                  children: title2
                }
              )
            ] })
          ]
        }
      )
    }
  );
}, selector$1 = (s2) => {
  var _a4;
  return {
    id: s2.view.id,
    notations: ((_a4 = s2.view.notation) == null ? void 0 : _a4.elements) ?? [],
    isVisible: n$2(s2.focusedNodeId ?? s2.activeWalkthrough)
  };
};
function NotationPanel() {
  const height = useXYStore((s2) => s2.height), {
    id: id2,
    notations,
    isVisible
  } = useDiagramState(selector$1), [isCollapsed, setCollapsed] = useLocalStorage({
    key: "notation-webview-collapsed",
    defaultValue: !0
  }), hasNotations = notations.length > 0, portalProps = useMantinePortalProps();
  return /* @__PURE__ */ jsxs(AnimatePresence, { children: [
    !hasNotations && isVisible && /* @__PURE__ */ jsx(
      m$1.div,
      {
        initial: { opacity: 0.75, translateX: "50%" },
        animate: { opacity: 1, translateX: 0 },
        exit: {
          translateX: "100%",
          opacity: 0.6
        },
        className: clsx("react-flow__panel", container),
        children: /* @__PURE__ */ jsx(Tooltip$5, { label: "View has no notations", color: "orange", ...portalProps, children: /* @__PURE__ */ jsx(
          ThemeIcon,
          {
            size: "lg",
            variant: "light",
            color: "orange",
            radius: "md",
            children: /* @__PURE__ */ jsx(IconAlertTriangle, {})
          }
        ) })
      },
      "empty"
    ),
    hasNotations && isVisible && isCollapsed && /* @__PURE__ */ jsx(
      m$1.div,
      {
        initial: { opacity: 0.75, translateX: "50%" },
        animate: { opacity: 1, translateX: 0 },
        exit: {
          translateX: "100%",
          opacity: 0.6
        },
        className: clsx("react-flow__panel", container),
        children: /* @__PURE__ */ jsx(Tooltip$5, { label: "Show notation", color: "dark", fz: "xs", ...portalProps, children: /* @__PURE__ */ jsx(
          ActionIcon$1,
          {
            size: "lg",
            variant: "default",
            color: "gray",
            radius: "md",
            onClick: () => setCollapsed(!1),
            children: /* @__PURE__ */ jsx(IconHelpCircle, { stroke: 1.5 })
          }
        ) })
      },
      "collapsed"
    ),
    hasNotations && isVisible && !isCollapsed && /* @__PURE__ */ jsx(
      m$1.div,
      {
        initial: {
          opacity: 0.75,
          // translateX: '50%',
          scale: 0.2
        },
        animate: { opacity: 1, scale: 1 },
        exit: {
          opacity: 0,
          scale: 0.25
        },
        className: clsx("react-flow__panel", container),
        style: {
          transformOrigin: "bottom right"
        },
        children: /* @__PURE__ */ jsx(
          Paper,
          {
            radius: "sm",
            withBorder: !0,
            shadow: "lg",
            className: card,
            children: /* @__PURE__ */ jsxs(Tabs, { defaultValue: "first", radius: "xs", children: [
              /* @__PURE__ */ jsxs(TabsList, { children: [
                /* @__PURE__ */ jsx(
                  ActionIcon$1,
                  {
                    size: "md",
                    variant: "subtle",
                    color: "gray",
                    ml: 2,
                    style: {
                      alignSelf: "center"
                    },
                    onClick: () => setCollapsed(!0),
                    children: /* @__PURE__ */ jsx(IconArrowDownRight, { stroke: 2 })
                  }
                ),
                /* @__PURE__ */ jsx(TabsTab, { value: "first", fz: "xs", children: "Elements" }),
                /* @__PURE__ */ jsx(TabsTab, { value: "second", fz: "xs", disabled: !0, children: "Relationships" })
              ] }),
              /* @__PURE__ */ jsx(TabsPanel, { value: "first", className: tabPanel, hidden: isCollapsed, children: /* @__PURE__ */ jsx(
                ScrollAreaAutosize,
                {
                  viewportProps: {
                    style: {
                      maxHeight: `min(40vh, ${Math.max(height - 60, 50)}px)`
                    }
                  },
                  children: /* @__PURE__ */ jsx(Stack$1, { gap: 0, children: notations.map((n2, i2) => /* @__PURE__ */ jsx(ElementNotation, { value: n2 }, i2)) })
                }
              ) })
            ] })
          }
        )
      },
      id2
    )
  ] });
}
const Tooltip = Tooltip$5.withProps({
  color: "dark",
  fz: "xs",
  position: "right",
  openDelay: 600,
  closeDelay: 120,
  label: "",
  children: null,
  offset: 8
}), ActionIcon = ActionIcon$1.withProps({
  classNames: {
    root: "action-icon"
  },
  variant: "default",
  color: "gray"
});
var backwardForwardButtons = "_1s3ok7s0", panel = "_1s3ok7s1", actionIconGroup = "_1s3ok7s2", autolayoutButton = "_1s3ok7s4", autolayoutIndicator = "_1s3ok7s5", spacingSliderBody = "_1s3ok7s6", spacingSliderThumb = "_1s3ok7s7";
const selector = (state) => ({
  viewId: state.view.id,
  autoLayout: state.view.autoLayout
}), ChangeAutoLayoutButton = (props) => {
  const store = useDiagramStoreApi(), [rootRef, setRootRef] = useState(null), [controlsRefs, setControlsRefs] = useState({}), {
    autoLayout,
    viewId
  } = useDiagramState(selector), { ref, hovered: isSpacingHovered } = useHover$1(), setControlRef = (name) => (node2) => {
    controlsRefs[name] = node2, setControlsRefs(controlsRefs);
  }, setAutoLayout = (direction) => (event) => {
    var _a4, _b2;
    event.stopPropagation(), (_b2 = (_a4 = store.getState()).onChange) == null || _b2.call(_a4, {
      change: {
        op: "change-autolayout",
        layout: {
          ...autoLayout,
          direction
        }
      }
    });
  }, setSpacing = (nodeSep, rankSep) => {
    var _a4, _b2;
    store.setState({
      viewportChanged: !1
    }), (_b2 = (_a4 = store.getState()).onChange) == null || _b2.call(_a4, {
      change: {
        op: "change-autolayout",
        layout: {
          ...autoLayout,
          nodeSep,
          rankSep
        }
      }
    });
  };
  return /* @__PURE__ */ jsxs(
    Popover,
    {
      position: "right-start",
      clickOutsideEvents: [
        "pointerdown"
      ],
      radius: "xs",
      shadow: "lg",
      offset: {
        mainAxis: 10
      },
      ...props,
      children: [
        /* @__PURE__ */ jsx(PopoverTarget, { children: /* @__PURE__ */ jsx(Tooltip, { label: "Change Auto Layout", children: /* @__PURE__ */ jsx(ActionIcon, { children: /* @__PURE__ */ jsx(IconLayoutDashboard, {}) }) }) }),
        /* @__PURE__ */ jsx(PopoverDropdown, { className: "likec4-top-left-panel", p: 8, pt: 6, opacity: isSpacingHovered ? 0.6 : 1, children: /* @__PURE__ */ jsxs(Box, { pos: "relative", ref: setRootRef, children: [
          /* @__PURE__ */ jsx(
            FloatingIndicator,
            {
              target: controlsRefs[autoLayout.direction],
              parent: rootRef,
              className: autolayoutIndicator
            }
          ),
          /* @__PURE__ */ jsx(Box, { mb: 10, children: /* @__PURE__ */ jsx(Text$6, { inline: !0, fz: "xs", c: "dimmed", fw: 500, children: "Auto layout:" }) }),
          /* @__PURE__ */ jsxs(Flex, { gap: 2, wrap: "wrap", justify: "stretch", maw: 160, children: [
            /* @__PURE__ */ jsx(UnstyledButton, { className: autolayoutButton, ref: setControlRef("TB"), onClick: setAutoLayout("TB"), children: "Top-Bottom" }),
            /* @__PURE__ */ jsx(UnstyledButton, { className: autolayoutButton, ref: setControlRef("BT"), onClick: setAutoLayout("BT"), children: "Bottom-Top" }),
            /* @__PURE__ */ jsx(UnstyledButton, { className: autolayoutButton, ref: setControlRef("LR"), onClick: setAutoLayout("LR"), children: "Left-Right" }),
            /* @__PURE__ */ jsx(UnstyledButton, { className: autolayoutButton, ref: setControlRef("RL"), onClick: setAutoLayout("RL"), children: "Right-Left" })
          ] }),
          /* @__PURE__ */ jsx(Box, { my: 10, children: /* @__PURE__ */ jsx(Text$6, { inline: !0, fz: "xs", c: "dimmed", fw: 500, children: "Spacing:" }) }),
          /* @__PURE__ */ jsx(
            SpacingSliders,
            {
              ref,
              isVertical: autoLayout.direction === "TB" || autoLayout.direction === "BT",
              nodeSep: autoLayout.nodeSep,
              rankSep: autoLayout.rankSep,
              onChange: setSpacing
            },
            viewId
          )
        ] }) })
      ]
    }
  );
}, MAX_SPACING = 400, SpacingSliders = forwardRef(({
  isVertical,
  nodeSep,
  rankSep,
  onChange
}, _ref) => {
  isVertical || ([nodeSep, rankSep] = [rankSep, nodeSep]);
  const propagateChange = useDebouncedCallback(
    ({ x: x2, y: y2 }) => {
      isVertical || ([x2, y2] = [y2, x2]), onChange(Math.round(x2 * MAX_SPACING), Math.round(y2 * MAX_SPACING));
    },
    [onChange, isVertical],
    150,
    2e3
  ), [value, setValue] = useUncontrolled({
    defaultValue: clampUseMovePosition({
      x: (nodeSep ?? 100) / MAX_SPACING,
      y: (rankSep ?? 120) / MAX_SPACING
    }),
    onChange: propagateChange
  }), { ref } = useMove(setValue);
  let nodeSepValue = Math.round(value.x * MAX_SPACING), rankSepValue = Math.round(value.y * MAX_SPACING);
  isVertical || ([nodeSepValue, rankSepValue] = [rankSepValue, nodeSepValue]);
  const mergedRef = useMergedRef(ref, _ref);
  return /* @__PURE__ */ jsxs(Box, { ref: mergedRef, className: spacingSliderBody, pt: "100%", children: [
    /* @__PURE__ */ jsx(
      Box,
      {
        className: spacingSliderThumb,
        style: {
          left: `${value.x * 100}%`,
          top: `${value.y * 100}%`
        }
      }
    ),
    /* @__PURE__ */ jsx(Box, { pos: "absolute", left: 2, bottom: 2, children: /* @__PURE__ */ jsxs(Text$6, { component: "div", fz: 8, c: "dimmed", fw: 500, children: [
      rankSepValue,
      ", ",
      nodeSepValue
    ] }) })
  ] });
}), Action = ({
  label: label2,
  icon,
  onClick
}) => /* @__PURE__ */ jsx(Tooltip, { label: label2, withinPortal: !1, position: "top", children: /* @__PURE__ */ jsx(ActionIcon, { onClick, children: icon }) }), ManualLayoutToolsButton = (props) => {
  const store = useDiagramStoreApi();
  return /* @__PURE__ */ jsxs(
    Popover,
    {
      position: "right-start",
      clickOutsideEvents: [
        "pointerdown"
      ],
      radius: "xs",
      shadow: "lg",
      offset: {
        mainAxis: 10
      },
      ...props,
      children: [
        /* @__PURE__ */ jsx(PopoverTarget, { children: /* @__PURE__ */ jsx(Tooltip, { label: "Manual layouting tools", withinPortal: !1, position: "top-end", children: /* @__PURE__ */ jsx(ActionIcon, { children: /* @__PURE__ */ jsx(IconLayoutCollage, {}) }) }) }),
        /* @__PURE__ */ jsx(PopoverDropdown, { p: 0, children: /* @__PURE__ */ jsxs(Group, { gap: "xs", children: [
          /* @__PURE__ */ jsxs(ActionIconGroup, { pos: "relative", children: [
            /* @__PURE__ */ jsx(
              Action,
              {
                label: "Align in columns",
                icon: /* @__PURE__ */ jsx(IconLayoutBoardSplit, {}),
                onClick: (e2) => {
                  e2.stopPropagation(), store.getState().align("Column");
                }
              }
            ),
            /* @__PURE__ */ jsx(
              Action,
              {
                label: "Align left",
                icon: /* @__PURE__ */ jsx(IconLayoutAlignLeft, {}),
                onClick: (e2) => {
                  e2.stopPropagation(), store.getState().align("Left");
                }
              }
            ),
            /* @__PURE__ */ jsx(
              Action,
              {
                label: "Align center",
                icon: /* @__PURE__ */ jsx(IconLayoutAlignCenter, {}),
                onClick: (e2) => {
                  e2.stopPropagation(), store.getState().align("Center");
                }
              }
            ),
            /* @__PURE__ */ jsx(
              Action,
              {
                label: "Align right",
                icon: /* @__PURE__ */ jsx(IconLayoutAlignRight, {}),
                onClick: (e2) => {
                  e2.stopPropagation(), store.getState().align("Right");
                }
              }
            ),
            /* @__PURE__ */ jsx(
              Action,
              {
                label: "Align in rows",
                icon: /* @__PURE__ */ jsx(IconLayoutBoardSplit, { style: { transform: "rotate(90deg)" } }),
                onClick: (e2) => {
                  e2.stopPropagation(), store.getState().align("Row");
                }
              }
            ),
            /* @__PURE__ */ jsx(
              Action,
              {
                label: "Align top",
                icon: /* @__PURE__ */ jsx(IconLayoutAlignTop, {}),
                onClick: (e2) => {
                  e2.stopPropagation(), store.getState().align("Top");
                }
              }
            ),
            /* @__PURE__ */ jsx(
              Action,
              {
                label: "Align middle",
                icon: /* @__PURE__ */ jsx(IconLayoutAlignMiddle, {}),
                onClick: (e2) => {
                  e2.stopPropagation(), store.getState().align("Middle");
                }
              }
            ),
            /* @__PURE__ */ jsx(
              Action,
              {
                label: "Align bottom",
                icon: /* @__PURE__ */ jsx(IconLayoutAlignBottom, {}),
                onClick: (e2) => {
                  e2.stopPropagation(), store.getState().align("Bottom");
                }
              }
            )
          ] }),
          /* @__PURE__ */ jsx(
            Action,
            {
              label: "Reset all control points",
              icon: /* @__PURE__ */ jsx(IconRouteOff, {}),
              onClick: (e2) => {
                e2.stopPropagation(), store.getState().resetEdgeControlPoints();
              }
            }
          )
        ] }) })
      ]
    }
  );
}, historySelector = (s2) => ({
  showBurgerMenu: !!s2.onBurgerMenuClick,
  hasStepBack: s2.showNavigationButtons && !!s2.onNavigateTo && s2.navigationHistoryIndex > 0,
  hasStepForward: s2.showNavigationButtons && !!s2.onNavigateTo && s2.navigationHistoryIndex < s2.navigationHistory.length - 1
}), BackwardForwardButtons = () => {
  const store = useDiagramStoreApi(), {
    showBurgerMenu,
    hasStepBack,
    hasStepForward
  } = useDiagramState(historySelector);
  return /* @__PURE__ */ jsx(LayoutGroup, { children: /* @__PURE__ */ jsxs(
    Group,
    {
      className: clsx(backwardForwardButtons, "likec4-navigation-webview"),
      align: "flex-start",
      gap: "xs",
      children: [
        showBurgerMenu && /* @__PURE__ */ jsx(
          ActionIcon,
          {
            onClick: (e2) => {
              var _a4, _b2;
              e2.stopPropagation(), (_b2 = (_a4 = store.getState()).onBurgerMenuClick) == null || _b2.call(_a4);
            },
            children: /* @__PURE__ */ jsx(IconMenu2, {})
          }
        ),
        /* @__PURE__ */ jsxs(AnimatePresence, { children: [
          hasStepBack && /* @__PURE__ */ jsx(
            m$1.div,
            {
              layout: !0,
              initial: { opacity: 0.05, transform: "translateX(-10px)" },
              animate: { opacity: 1, transform: "translateX(0)" },
              exit: {
                opacity: 0.05,
                transform: "translateX(-10px)"
              },
              children: /* @__PURE__ */ jsx(
                ActionIcon,
                {
                  onClick: (e2) => {
                    e2.stopPropagation(), store.getState().goBack();
                  },
                  children: /* @__PURE__ */ jsx(IconChevronLeft, {})
                }
              )
            },
            "back"
          ),
          hasStepForward && /* @__PURE__ */ jsx(
            m$1.div,
            {
              layout: !0,
              initial: { opacity: 0.05, transform: "translateX(10px)" },
              animate: { opacity: 1, transform: "translateX(0)" },
              exit: {
                opacity: 0,
                transform: "translateX(10px)"
              },
              children: /* @__PURE__ */ jsx(
                ActionIcon,
                {
                  onClick: (e2) => {
                    e2.stopPropagation(), store.getState().goForward();
                  },
                  children: /* @__PURE__ */ jsx(IconChevronRight, {})
                }
              )
            },
            "forward"
          )
        ] })
      ]
    }
  ) });
}, LayoutDriftNotification = (props) => /* @__PURE__ */ jsxs(
  HoverCard,
  {
    position: "right-start",
    openDelay: 200,
    closeDelay: 100,
    ...props,
    children: [
      /* @__PURE__ */ jsx(HoverCardTarget, { children: /* @__PURE__ */ jsxs(ActionIcon, { c: "orange", children: [
        /* @__PURE__ */ jsx(Overlay, { color: mantine.colors.orange.lightHover, backgroundOpacity: 1 }),
        /* @__PURE__ */ jsx(IconAlertTriangle, {})
      ] }) }),
      /* @__PURE__ */ jsx(HoverCardDropdown, { p: "0", children: /* @__PURE__ */ jsxs(
        Notification,
        {
          color: "orange",
          withBorder: !1,
          withCloseButton: !1,
          title: "Manual layout issues",
          children: [
            /* @__PURE__ */ jsxs(Text$6, { mt: 2, size: "sm", lh: "xs", children: [
              "View contains new elements or their sizes have changed,",
              /* @__PURE__ */ jsx("br", {}),
              "last manual layout can not be applied."
            ] }),
            /* @__PURE__ */ jsxs(Text$6, { mt: "xs", size: "sm", lh: "xs", children: [
              "Update view predicates or remove ",
              /* @__PURE__ */ jsx(Code, { children: "@likec4-generated" })
            ] })
          ]
        }
      ) })
    ]
  }
), TopLeftPanel = () => {
  const store = useDiagramStoreApi(), {
    enableSearch,
    showNavigationButtons,
    showFitDiagram,
    showLayoutDriftWarning,
    showChangeAutoLayout,
    showGoToSource,
    viewportChanged,
    showManualLayoutTools
  } = useDiagramState((s2) => {
    const isNotWalkthrough = n$2(s2.activeWalkthrough), isNotFocused = n$2(s2.focusedNodeId), isNotActive = isNotWalkthrough && isNotFocused;
    return {
      enableSearch: s2.enableSearch,
      showNavigationButtons: !!s2.onBurgerMenuClick || s2.showNavigationButtons && !!s2.onNavigateTo,
      showFitDiagram: s2.controls && s2.fitViewEnabled && s2.zoomable && isNotWalkthrough,
      showLayoutDriftWarning: s2.controls && !s2.readonly && s2.view.hasLayoutDrift === !0 && isNotActive,
      showChangeAutoLayout: s2.controls && s2.isEditable() && isNotActive,
      showGoToSource: s2.controls && !!s2.onOpenSourceView && isNotWalkthrough,
      viewportChanged: s2.viewportChanged,
      showManualLayoutTools: s2.controls && s2.readonly !== !0 && s2.experimentalEdgeEditing === !0
    };
  }), portalProps = useMantinePortalProps();
  return /* @__PURE__ */ jsx(TooltipGroup, { openDelay: 600, closeDelay: 150, children: /* @__PURE__ */ jsxs(
    Stack$1,
    {
      className: clsx(
        "react-flow__panel",
        panel,
        "likec4-top-left-panel"
      ),
      align: "flex-start",
      onClick: (e2) => e2.stopPropagation(),
      gap: "xs",
      children: [
        showNavigationButtons && /* @__PURE__ */ jsx(BackwardForwardButtons, {}),
        /* @__PURE__ */ jsxs(ActionIconGroup, { className: actionIconGroup, orientation: "vertical", children: [
          enableSearch && /* @__PURE__ */ jsx(Tooltip, { label: "Search", children: /* @__PURE__ */ jsx(
            ActionIcon,
            {
              onClick: () => openSpotlight(),
              children: /* @__PURE__ */ jsx(IconSearch, {})
            }
          ) }),
          showGoToSource && /* @__PURE__ */ jsx(Tooltip, { label: "Open source", ...portalProps, children: /* @__PURE__ */ jsx(
            ActionIcon,
            {
              onClick: (e2) => {
                var _a4, _b2;
                e2.stopPropagation(), (_b2 = (_a4 = store.getState()).onOpenSourceView) == null || _b2.call(_a4);
              },
              children: /* @__PURE__ */ jsx(IconFileSymlink, { stroke: 1.5 })
            }
          ) }),
          showChangeAutoLayout && /* @__PURE__ */ jsx(ChangeAutoLayoutButton, { ...portalProps }),
          showLayoutDriftWarning && /* @__PURE__ */ jsx(LayoutDriftNotification, { ...portalProps }),
          showManualLayoutTools && /* @__PURE__ */ jsx(ManualLayoutToolsButton, { ...portalProps }),
          showFitDiagram && /* @__PURE__ */ jsx(Tooltip, { label: viewportChanged ? "Center camera" : "Camera is centered", ...portalProps, children: /* @__PURE__ */ jsx(
            ActionIcon,
            {
              onClick: (e2) => {
                e2.stopPropagation(), store.getState().fitDiagram();
              },
              children: /* @__PURE__ */ jsx(IconFocusCentered, {})
            }
          ) })
        ] })
      ]
    }
  ) });
};
TopLeftPanel.displayName = "TopLeftPanel";
function literalToEnum(value) {
  switch (value) {
    case "dots":
      return BackgroundVariant.Dots;
    case "lines":
      return BackgroundVariant.Lines;
    case "cross":
      return BackgroundVariant.Cross;
    default:
      nonexhaustive(value);
  }
}
function XYFlowBackground({ background }) {
  if (typeof background == "string")
    return /* @__PURE__ */ jsx(Background, { variant: literalToEnum(background), size: 2, gap: 20 });
  const { variant, ...rest } = background;
  return /* @__PURE__ */ jsx(Background, { variant: literalToEnum(variant), ...rest });
}
const XYFlowInner = /* @__PURE__ */ memo$1(function({
  background,
  showDiagramTitle
}) {
  const {
    showNotations,
    isDynamicView,
    showTopLeft,
    isDynamicViewActive,
    enableDynamicViewWalkthrough
  } = useDiagramState((s2) => ({
    showNotations: s2.showNotations,
    isDynamicView: s2.isDynamicView,
    showTopLeft: s2.controls || s2.showNavigationButtons && !!s2.onNavigateTo || !!s2.onBurgerMenuClick,
    enableDynamicViewWalkthrough: s2.enableDynamicViewWalkthrough,
    isDynamicViewActive: l$2(s2.activeWalkthrough)
  }));
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    background !== "transparent" && background !== "solid" && /* @__PURE__ */ jsx(XYFlowBackground, { background }),
    showTopLeft && /* @__PURE__ */ jsx(TopLeftPanel, {}),
    showDiagramTitle && !isDynamicViewActive && /* @__PURE__ */ jsx(DiagramTitlePanel, {}),
    isDynamicView && enableDynamicViewWalkthrough && /* @__PURE__ */ jsx(DynamicViewWalkthrough, {}),
    showNotations && /* @__PURE__ */ jsx(NotationPanel, {})
  ] });
}, deepEqual$1);
XYFlowInner.displayName = "XYFlowInner";
function LikeC4Diagram({
  view,
  className,
  fitView: fitView2 = !0,
  fitViewPadding = 0,
  readonly = !0,
  pannable = !0,
  zoomable = !0,
  nodesSelectable = !readonly,
  nodesDraggable = !readonly,
  background = "dots",
  controls = !readonly,
  showDiagramTitle = !0,
  showNotations = !0,
  enableDynamicViewWalkthrough = !1,
  enableFocusMode = !1,
  enableElementDetails = !1,
  enableRelationshipDetails = enableElementDetails,
  enableRelationshipBrowser = enableRelationshipDetails,
  enableSearch = !0,
  initialWidth,
  initialHeight,
  keepAspectRatio = !1,
  experimentalEdgeEditing = !1,
  onCanvasClick,
  onCanvasContextMenu,
  onCanvasDblClick,
  onEdgeClick,
  onChange,
  onEdgeContextMenu,
  onNavigateTo,
  onNodeClick,
  onNodeContextMenu,
  onOpenSourceElement,
  onOpenSourceView,
  onOpenSourceRelation,
  onBurgerMenuClick,
  renderIcon,
  where,
  showNavigationButtons = !!onNavigateTo
}) {
  const hasLikec4model = !!useLikeC4Model(), initialRef = useRef({
    defaultNodes: [],
    defaultEdges: [],
    initialWidth: initialWidth ?? view.bounds.width,
    initialHeight: initialHeight ?? view.bounds.height
  });
  return useEffect(() => {
    readonly !== !0 && where != null && console.warn(`Ignore filter, supported in readonly mode only
`, { where }), !hasLikec4model && (enableRelationshipDetails && console.warn("Invalid showRelationshipDetails=true, requires LikeC4ModelProvider"), enableElementDetails && console.warn("Invalid enableElementDetails=true, requires LikeC4ModelProvider"), enableRelationshipBrowser && console.warn("Invalid enableRelationshipBrowser=true, requires LikeC4ModelProvider"));
  }), /* @__PURE__ */ jsx(EnsureMantine, { children: /* @__PURE__ */ jsx(FramerMotionConfig, { children: /* @__PURE__ */ jsxs(
    ReactFlowProvider,
    {
      fitView: fitView2,
      ...initialRef.current,
      children: [
        !n(view.customColorDefinitions) && /* @__PURE__ */ jsx(LikeC4CustomColors, { customColors: view.customColorDefinitions }),
        /* @__PURE__ */ jsx(
          DiagramContextProvider,
          {
            view,
            keepAspectRatio,
            className: clsx(rootClassName, className),
            readonly,
            experimentalEdgeEditing: !readonly && experimentalEdgeEditing,
            pannable,
            zoomable,
            nodesDraggable,
            nodesSelectable: nodesSelectable || enableFocusMode,
            hasLikeC4Model: hasLikec4model,
            fitViewEnabled: fitView2,
            fitViewPadding,
            controls,
            showNavigationButtons: showNavigationButtons && !!onNavigateTo,
            showNotations,
            enableFocusMode,
            enableRelationshipDetails: enableRelationshipDetails && hasLikec4model,
            enableSearch: hasLikec4model && enableSearch,
            enableElementDetails: enableElementDetails && hasLikec4model,
            enableDynamicViewWalkthrough,
            enableRelationshipBrowser: enableRelationshipBrowser && hasLikec4model,
            whereFilter: readonly ? where ?? null : null,
            renderIcon: renderIcon ?? null,
            onCanvasClick: onCanvasClick ?? null,
            onCanvasContextMenu: onCanvasContextMenu ?? null,
            onEdgeClick: onEdgeClick ?? null,
            onEdgeContextMenu: onEdgeContextMenu ?? null,
            onNodeClick: onNodeClick ?? null,
            onNodeContextMenu: onNodeContextMenu ?? null,
            onChange: onChange ?? null,
            onNavigateTo: onNavigateTo ?? null,
            onCanvasDblClick: onCanvasDblClick ?? null,
            onOpenSourceView: onOpenSourceView ?? null,
            onOpenSourceElement: onOpenSourceElement ?? null,
            onOpenSourceRelation: onOpenSourceRelation ?? null,
            onBurgerMenuClick: onBurgerMenuClick ?? null,
            children: /* @__PURE__ */ jsx(
              LikeC4DiagramInnerMemo,
              {
                background,
                showDiagramTitle,
                enableSearch: hasLikec4model && enableSearch
              }
            )
          }
        )
      ]
    }
  ) }) });
}
LikeC4Diagram.displayName = "LikeC4Diagram";
const LikeC4DiagramInnerMemo = /* @__PURE__ */ memo$1(function({
  background,
  showDiagramTitle,
  enableSearch
}) {
  const {
    isInitialized,
    pannable,
    fitView: fitView2,
    enableFocusMode,
    enableOverlays
  } = useDiagramState((s2) => ({
    isInitialized: s2.initialized,
    pannable: s2.pannable,
    fitView: s2.fitViewEnabled,
    enableFocusMode: s2.enableFocusMode,
    enableOverlays: s2.hasLikeC4Model && (s2.enableRelationshipBrowser || s2.enableElementDetails)
  }));
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      XYFlow,
      {
        className: clsx(
          "likec4-diagram",
          cssReactFlow,
          cssNoControls,
          pannable !== !0 && cssDisablePan,
          background === "transparent" && cssTransparentBg,
          isInitialized ? "initialized" : notInitialized
        ),
        children: /* @__PURE__ */ jsx(
          XYFlowInner,
          {
            showDiagramTitle,
            background
          }
        )
      }
    ),
    enableOverlays && /* @__PURE__ */ jsx(Overlays, {}),
    enableSearch && /* @__PURE__ */ jsx(LikeC4Search, {}),
    isInitialized && /* @__PURE__ */ jsxs(Fragment, { children: [
      fitView2 && /* @__PURE__ */ jsx(FitViewOnDiagramChange, {}),
      enableFocusMode && /* @__PURE__ */ jsx(SelectEdgesOnNodeFocus, {})
    ] })
  ] });
}, deepEqual$1);
LikeC4DiagramInnerMemo.displayName = "LikeC4DiagramInnerMemo";
function LikeC4ModelProvider({
  children: children2,
  likec4model
}) {
  return /* @__PURE__ */ jsx(LikeC4ModelContext.Provider, { value: likec4model, children: children2 });
}
var cssDiagram = "_1gnojqn2", closeButton = "_1gnojqn3";
const renderToString = (view) => {
  throw new Error("LikeC4View is not available SSR");
};
var propTypes = { exports: {} }, ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED", ReactPropTypesSecret_1 = ReactPropTypesSecret$1, ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction() {
}
function emptyFunctionWithReset() {
}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
  function shim2(props, propName, componentName, location, propFullName, secret) {
    if (secret !== ReactPropTypesSecret) {
      var err = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      throw err.name = "Invariant Violation", err;
    }
  }
  shim2.isRequired = shim2;
  function getShim() {
    return shim2;
  }
  var ReactPropTypes = {
    array: shim2,
    bigint: shim2,
    bool: shim2,
    func: shim2,
    number: shim2,
    object: shim2,
    string: shim2,
    symbol: shim2,
    any: shim2,
    arrayOf: getShim,
    element: shim2,
    elementType: shim2,
    instanceOf: getShim,
    node: shim2,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  return ReactPropTypes.PropTypes = ReactPropTypes, ReactPropTypes;
};
propTypes.exports;
propTypes.exports = factoryWithThrowingShims();
var propTypesExports = propTypes.exports;
const s = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
var f = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function p(e2, r2) {
  return e2(r2 = { exports: {} }, r2.exports), r2.exports;
}
var d = p(function(e2) {
  (function(r2) {
    var t2 = function(e3, r3, n3) {
      if (!u2(r3) || s2(r3) || f2(r3) || p2(r3) || i2(r3)) return r3;
      var o3, a3 = 0, c2 = 0;
      if (l2(r3)) for (o3 = [], c2 = r3.length; a3 < c2; a3++) o3.push(t2(e3, r3[a3], n3));
      else for (var d3 in o3 = {}, r3) Object.prototype.hasOwnProperty.call(r3, d3) && (o3[e3(d3, n3)] = t2(e3, r3[d3], n3));
      return o3;
    }, n2 = function(e3) {
      return d2(e3) ? e3 : (e3 = e3.replace(/[\-_\s]+(.)?/g, function(e4, r3) {
        return r3 ? r3.toUpperCase() : "";
      })).substr(0, 1).toLowerCase() + e3.substr(1);
    }, o2 = function(e3) {
      var r3 = n2(e3);
      return r3.substr(0, 1).toUpperCase() + r3.substr(1);
    }, a2 = function(e3, r3) {
      return function(e4, r4) {
        var t3 = (r4 = r4 || {}).separator || "_", n3 = r4.split || /(?=[A-Z])/;
        return e4.split(n3).join(t3);
      }(e3, r3).toLowerCase();
    }, c = Object.prototype.toString, i2 = function(e3) {
      return typeof e3 == "function";
    }, u2 = function(e3) {
      return e3 === Object(e3);
    }, l2 = function(e3) {
      return c.call(e3) == "[object Array]";
    }, s2 = function(e3) {
      return c.call(e3) == "[object Date]";
    }, f2 = function(e3) {
      return c.call(e3) == "[object RegExp]";
    }, p2 = function(e3) {
      return c.call(e3) == "[object Boolean]";
    }, d2 = function(e3) {
      return (e3 -= 0) == e3;
    }, y2 = function(e3, r3) {
      var t3 = r3 && "process" in r3 ? r3.process : r3;
      return typeof t3 != "function" ? e3 : function(r4, n3) {
        return t3(r4, e3, n3);
      };
    }, h2 = { camelize: n2, decamelize: a2, pascalize: o2, depascalize: a2, camelizeKeys: function(e3, r3) {
      return t2(y2(n2, r3), e3);
    }, decamelizeKeys: function(e3, r3) {
      return t2(y2(a2, r3), e3, r3);
    }, pascalizeKeys: function(e3, r3) {
      return t2(y2(o2, r3), e3);
    }, depascalizeKeys: function() {
      return this.decamelizeKeys.apply(this, arguments);
    } };
    e2.exports ? e2.exports = h2 : r2.humps = h2;
  })(f);
}).decamelize, y = function(e2) {
  if (Array.isArray(e2)) return e2;
}, h = function(e2, r2) {
  if (typeof Symbol < "u" && Symbol.iterator in Object(e2)) {
    var t2 = [], n2 = !0, o2 = !1, a2 = void 0;
    try {
      for (var c, i2 = e2[Symbol.iterator](); !(n2 = (c = i2.next()).done) && (t2.push(c.value), !r2 || t2.length !== r2); n2 = !0) ;
    } catch (e3) {
      o2 = !0, a2 = e3;
    } finally {
      try {
        n2 || i2.return == null || i2.return();
      } finally {
        if (o2) throw a2;
      }
    }
    return t2;
  }
}, v = function(e2, r2) {
  (r2 == null || r2 > e2.length) && (r2 = e2.length);
  for (var t2 = 0, n2 = new Array(r2); t2 < r2; t2++) n2[t2] = e2[t2];
  return n2;
}, m = function(e2, r2) {
  if (e2) {
    if (typeof e2 == "string") return v(e2, r2);
    var t2 = Object.prototype.toString.call(e2).slice(8, -1);
    return t2 === "Object" && e2.constructor && (t2 = e2.constructor.name), t2 === "Map" || t2 === "Set" ? Array.from(e2) : t2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? v(e2, r2) : void 0;
  }
}, b = function() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}, g = function(e2, r2) {
  return y(e2) || h(e2, r2) || m(e2, r2) || b();
}, S = p(function(e2) {
  function r2() {
    return e2.exports = r2 = Object.assign || function(e3) {
      for (var r3 = 1; r3 < arguments.length; r3++) {
        var t2 = arguments[r3];
        for (var n2 in t2) Object.prototype.hasOwnProperty.call(t2, n2) && (e3[n2] = t2[n2]);
      }
      return e3;
    }, r2.apply(this, arguments);
  }
  e2.exports = r2;
}), w = function(e2, r2) {
  if (e2 == null) return {};
  var t2, n2, o2 = {}, a2 = Object.keys(e2);
  for (n2 = 0; n2 < a2.length; n2++) t2 = a2[n2], r2.indexOf(t2) >= 0 || (o2[t2] = e2[t2]);
  return o2;
}, O = function(e2, r2) {
  if (e2 == null) return {};
  var t2, n2, o2 = w(e2, r2);
  if (Object.getOwnPropertySymbols) {
    var a2 = Object.getOwnPropertySymbols(e2);
    for (n2 = 0; n2 < a2.length; n2++) t2 = a2[n2], r2.indexOf(t2) >= 0 || Object.prototype.propertyIsEnumerable.call(e2, t2) && (o2[t2] = e2[t2]);
  }
  return o2;
}, j = createContext(null);
function x(r2) {
  var t2 = r2.children, n2 = t2 === void 0 ? "" : t2, o2 = O(r2, ["children"]);
  return typeof n2 != "string" && (n2 = renderToString()), React__default.createElement("template", S({}, o2, { dangerouslySetInnerHTML: { __html: n2 } }));
}
function z(e2) {
  var r2 = e2.root, t2 = e2.children;
  return createPortal(t2 === void 0 ? null : t2, r2);
}
function E(n2) {
  var i2 = forwardRef(function(o2, i3) {
    var u2, l2, s2 = o2.mode, f2 = s2 === void 0 ? "open" : s2, p2 = o2.delegatesFocus, d2 = p2 !== void 0 && p2, y2 = o2.styleSheets, h2 = y2 === void 0 ? [] : y2, v2 = o2.ssr, m2 = v2 !== void 0 && v2, b2 = o2.children, w2 = O(o2, ["mode", "delegatesFocus", "styleSheets", "ssr", "children"]), E2 = (l2 = useRef((u2 = i3) && u2.current), useEffect(function() {
      u2 && (u2.current = l2.current);
    }, [u2]), l2), T2 = useState(null), A2 = g(T2, 2), C2 = A2[0], P2 = A2[1], F = "node_".concat(f2).concat(d2);
    return useLayoutEffect(function() {
      if (E2.current) try {
        if (typeof i3 == "function" && i3(E2.current), m2) {
          var e2 = E2.current.shadowRoot;
          return void P2(e2);
        }
        var r2 = E2.current.attachShadow({ mode: f2, delegatesFocus: d2 });
        h2.length > 0 && (r2.adoptedStyleSheets = h2), P2(r2);
      } catch (e3) {
        (function(e4) {
          var r3 = e4.error, t2 = e4.styleSheets, n3 = e4.root;
          switch (r3.name) {
            case "NotSupportedError":
              t2.length > 0 && (n3.adoptedStyleSheets = t2);
              break;
            default:
              throw r3;
          }
        })({ error: e3, styleSheets: h2, root: C2 });
      }
    }, [i3, E2, h2]), React__default.createElement(React__default.Fragment, null, React__default.createElement(n2.tag, S({ key: F, ref: E2 }, w2), (C2 || m2) && React__default.createElement(j.Provider, { value: C2 }, m2 ? React__default.createElement(x, { shadowroot: f2, shadowrootmode: f2 }, n2.render({ root: C2, ssr: m2, children: b2 })) : React__default.createElement(z, { root: C2 }, n2.render({ root: C2, ssr: m2, children: b2 })))));
  });
  return i2.propTypes = { mode: s.oneOf(["open", "closed"]), delegatesFocus: s.bool, styleSheets: s.arrayOf(s.instanceOf(globalThis.CSSStyleSheet)), ssr: s.bool, children: s.node }, i2;
}
x.propTypes = { children: s.oneOfType([s.string, s.node]) }, z.propTypes = { root: s.object.isRequired, children: s.node };
var T = /* @__PURE__ */ new Map();
function C() {
  var e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "core", t2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function(e3) {
    return e3.children;
  };
  return new Proxy(e2, { get: function(e3, n2) {
    var o2 = d(n2, { separator: "-" }), a2 = "".concat(r2, "-").concat(o2);
    return T.has(a2) || T.set(a2, E({ tag: o2, render: t2 })), T.get(a2);
  } });
}
var P = C();
const root = P, fontCss = '@font-face{font-family:IBM Plex Sans;font-style:normal;font-display:swap;font-weight:400;src:url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/latin-400-normal.woff2) format("woff2"),url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/latin-400-normal.woff) format("woff");unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:IBM Plex Sans;font-style:normal;font-display:swap;font-weight:500;src:url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/latin-500-normal.woff2) format("woff2"),url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/latin-500-normal.woff) format("woff");unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:IBM Plex Sans;font-style:normal;font-display:swap;font-weight:600;src:url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/latin-600-normal.woff2) format("woff2"),url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/latin-600-normal.woff) format("woff");unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:IBM Plex Sans;font-style:normal;font-display:swap;font-weight:400;src:url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/cyrillic-ext-400-normal.woff2) format("woff2"),url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/cyrillic-ext-400-normal.woff) format("woff");unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:IBM Plex Sans;font-style:normal;font-display:swap;font-weight:500;src:url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/cyrillic-ext-500-normal.woff2) format("woff2"),url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/cyrillic-ext-500-normal.woff) format("woff");unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:IBM Plex Sans;font-style:normal;font-display:swap;font-weight:600;src:url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/cyrillic-ext-600-normal.woff2) format("woff2"),url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/cyrillic-ext-600-normal.woff) format("woff");unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:IBM Plex Sans;font-style:normal;font-display:swap;font-weight:400;src:url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/cyrillic-400-normal.woff2) format("woff2"),url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/cyrillic-400-normal.woff) format("woff");unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:IBM Plex Sans;font-style:normal;font-display:swap;font-weight:500;src:url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/cyrillic-500-normal.woff2) format("woff2"),url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/cyrillic-500-normal.woff) format("woff");unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:IBM Plex Sans;font-style:normal;font-display:swap;font-weight:600;src:url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/cyrillic-600-normal.woff2) format("woff2"),url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/cyrillic-600-normal.woff) format("woff");unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:IBM Plex Sans;font-style:normal;font-display:swap;font-weight:400;src:url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/latin-ext-400-normal.woff2) format("woff2"),url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/latin-ext-400-normal.woff) format("woff");unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20C0,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:IBM Plex Sans;font-style:normal;font-display:swap;font-weight:500;src:url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/latin-ext-500-normal.woff2) format("woff2"),url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/latin-ext-500-normal.woff) format("woff");unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20C0,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:IBM Plex Sans;font-style:normal;font-display:swap;font-weight:600;src:url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/latin-ext-600-normal.woff2) format("woff2"),url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/latin-ext-600-normal.woff) format("woff");unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20C0,U+2113,U+2C60-2C7F,U+A720-A7FF}';
var shadowRoot = "_1nao5c00", cssLikeC4View = "_1nao5c01", cssInteractive = "_1nao5c02", cssLikeC4Browser = "_1nao5c03";
const DefaultTheme = {
  autoContrast: !0,
  primaryColor: "indigo",
  cursorType: "pointer",
  defaultRadius: "sm",
  fontFamily: "var(--likec4-default-font-family)",
  headings: {
    fontWeight: "500",
    sizes: {
      h1: {
        // fontSize: '2rem',
        fontWeight: "600"
      },
      h2: {
        fontWeight: "500"
        // fontSize: '1.85rem',
      }
    }
  }
}, ShadowRootCssSelector = `.${shadowRoot}`, BundledStyles = () => {
  let styles;
  return styles = `*,*:before,*:after{box-sizing:border-box}input,button,textarea,select{font:inherit}button,select{text-transform:none}body{margin:0;font-family:var(--mantine-font-family);font-size:var(--mantine-font-size-md);line-height:var(--mantine-line-height);background-color:var(--mantine-color-body);color:var(--mantine-color-text);-webkit-font-smoothing:var(--mantine-webkit-font-smoothing);-moz-osx-font-smoothing:var(--mantine-moz-font-smoothing)}@media screen and (max-device-width: 31.25em){body{-webkit-text-size-adjust:100%}}@media (prefers-reduced-motion: reduce){[data-respect-reduced-motion] [data-reduce-motion]{transition:none;animation:none}}[data-mantine-color-scheme=light] .mantine-light-hidden,[data-mantine-color-scheme=dark] .mantine-dark-hidden{display:none}.mantine-focus-auto:focus-visible{outline:2px solid var(--mantine-primary-color-filled);outline-offset:calc(.125rem * var(--mantine-scale))}.mantine-focus-always:focus{outline:2px solid var(--mantine-primary-color-filled);outline-offset:calc(.125rem * var(--mantine-scale))}.mantine-focus-never:focus{outline:none}.mantine-active:active{transform:translateY(calc(.0625rem * var(--mantine-scale)))}fieldset:disabled .mantine-active:active{transform:none}:where([dir=rtl]) .mantine-rotate-rtl{transform:rotate(180deg)}:root{color-scheme:var(--mantine-color-scheme);--mantine-z-index-app: 100;--mantine-z-index-modal: 200;--mantine-z-index-popover: 300;--mantine-z-index-overlay: 400;--mantine-z-index-max: 9999;--mantine-scale: 1;--mantine-cursor-type: default;--mantine-webkit-font-smoothing: antialiased;--mantine-color-scheme: light dark;--mantine-moz-font-smoothing: grayscale;--mantine-color-white: #fff;--mantine-color-black: #000;--mantine-line-height: 1.55;--mantine-font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji;--mantine-font-family-monospace: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace;--mantine-font-family-headings: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji;--mantine-heading-font-weight: 700;--mantine-radius-default: calc(.25rem * var(--mantine-scale));--mantine-primary-color-0: var(--mantine-color-blue-0);--mantine-primary-color-1: var(--mantine-color-blue-1);--mantine-primary-color-2: var(--mantine-color-blue-2);--mantine-primary-color-3: var(--mantine-color-blue-3);--mantine-primary-color-4: var(--mantine-color-blue-4);--mantine-primary-color-5: var(--mantine-color-blue-5);--mantine-primary-color-6: var(--mantine-color-blue-6);--mantine-primary-color-7: var(--mantine-color-blue-7);--mantine-primary-color-8: var(--mantine-color-blue-8);--mantine-primary-color-9: var(--mantine-color-blue-9);--mantine-primary-color-filled: var(--mantine-color-blue-filled);--mantine-primary-color-filled-hover: var(--mantine-color-blue-filled-hover);--mantine-primary-color-light: var(--mantine-color-blue-light);--mantine-primary-color-light-hover: var(--mantine-color-blue-light-hover);--mantine-primary-color-light-color: var(--mantine-color-blue-light-color);--mantine-breakpoint-xs: 36em;--mantine-breakpoint-sm: 48em;--mantine-breakpoint-md: 62em;--mantine-breakpoint-lg: 75em;--mantine-breakpoint-xl: 88em;--mantine-spacing-xs: calc(.625rem * var(--mantine-scale));--mantine-spacing-sm: calc(.75rem * var(--mantine-scale));--mantine-spacing-md: calc(1rem * var(--mantine-scale));--mantine-spacing-lg: calc(1.25rem * var(--mantine-scale));--mantine-spacing-xl: calc(2rem * var(--mantine-scale));--mantine-font-size-xs: calc(.75rem * var(--mantine-scale));--mantine-font-size-sm: calc(.875rem * var(--mantine-scale));--mantine-font-size-md: calc(1rem * var(--mantine-scale));--mantine-font-size-lg: calc(1.125rem * var(--mantine-scale));--mantine-font-size-xl: calc(1.25rem * var(--mantine-scale));--mantine-line-height-xs: 1.4;--mantine-line-height-sm: 1.45;--mantine-line-height-md: 1.55;--mantine-line-height-lg: 1.6;--mantine-line-height-xl: 1.65;--mantine-shadow-xs: 0 calc(.0625rem * var(--mantine-scale)) calc(.1875rem * var(--mantine-scale)) rgba(0, 0, 0, .05), 0 calc(.0625rem * var(--mantine-scale)) calc(.125rem * var(--mantine-scale)) rgba(0, 0, 0, .1);--mantine-shadow-sm: 0 calc(.0625rem * var(--mantine-scale)) calc(.1875rem * var(--mantine-scale)) rgba(0, 0, 0, .05), rgba(0, 0, 0, .05) 0 calc(.625rem * var(--mantine-scale)) calc(.9375rem * var(--mantine-scale)) calc(-.3125rem * var(--mantine-scale)), rgba(0, 0, 0, .04) 0 calc(.4375rem * var(--mantine-scale)) calc(.4375rem * var(--mantine-scale)) calc(-.3125rem * var(--mantine-scale));--mantine-shadow-md: 0 calc(.0625rem * var(--mantine-scale)) calc(.1875rem * var(--mantine-scale)) rgba(0, 0, 0, .05), rgba(0, 0, 0, .05) 0 calc(1.25rem * var(--mantine-scale)) calc(1.5625rem * var(--mantine-scale)) calc(-.3125rem * var(--mantine-scale)), rgba(0, 0, 0, .04) 0 calc(.625rem * var(--mantine-scale)) calc(.625rem * var(--mantine-scale)) calc(-.3125rem * var(--mantine-scale));--mantine-shadow-lg: 0 calc(.0625rem * var(--mantine-scale)) calc(.1875rem * var(--mantine-scale)) rgba(0, 0, 0, .05), rgba(0, 0, 0, .05) 0 calc(1.75rem * var(--mantine-scale)) calc(1.4375rem * var(--mantine-scale)) calc(-.4375rem * var(--mantine-scale)), rgba(0, 0, 0, .04) 0 calc(.75rem * var(--mantine-scale)) calc(.75rem * var(--mantine-scale)) calc(-.4375rem * var(--mantine-scale));--mantine-shadow-xl: 0 calc(.0625rem * var(--mantine-scale)) calc(.1875rem * var(--mantine-scale)) rgba(0, 0, 0, .05), rgba(0, 0, 0, .05) 0 calc(2.25rem * var(--mantine-scale)) calc(1.75rem * var(--mantine-scale)) calc(-.4375rem * var(--mantine-scale)), rgba(0, 0, 0, .04) 0 calc(1.0625rem * var(--mantine-scale)) calc(1.0625rem * var(--mantine-scale)) calc(-.4375rem * var(--mantine-scale));--mantine-radius-xs: calc(.125rem * var(--mantine-scale));--mantine-radius-sm: calc(.25rem * var(--mantine-scale));--mantine-radius-md: calc(.5rem * var(--mantine-scale));--mantine-radius-lg: calc(1rem * var(--mantine-scale));--mantine-radius-xl: calc(2rem * var(--mantine-scale));--mantine-color-dark-0: #c9c9c9;--mantine-color-dark-1: #b8b8b8;--mantine-color-dark-2: #828282;--mantine-color-dark-3: #696969;--mantine-color-dark-4: #424242;--mantine-color-dark-5: #3b3b3b;--mantine-color-dark-6: #2e2e2e;--mantine-color-dark-7: #242424;--mantine-color-dark-8: #1f1f1f;--mantine-color-dark-9: #141414;--mantine-color-gray-0: #f8f9fa;--mantine-color-gray-1: #f1f3f5;--mantine-color-gray-2: #e9ecef;--mantine-color-gray-3: #dee2e6;--mantine-color-gray-4: #ced4da;--mantine-color-gray-5: #adb5bd;--mantine-color-gray-6: #868e96;--mantine-color-gray-7: #495057;--mantine-color-gray-8: #343a40;--mantine-color-gray-9: #212529;--mantine-color-red-0: #fff5f5;--mantine-color-red-1: #ffe3e3;--mantine-color-red-2: #ffc9c9;--mantine-color-red-3: #ffa8a8;--mantine-color-red-4: #ff8787;--mantine-color-red-5: #ff6b6b;--mantine-color-red-6: #fa5252;--mantine-color-red-7: #f03e3e;--mantine-color-red-8: #e03131;--mantine-color-red-9: #c92a2a;--mantine-color-pink-0: #fff0f6;--mantine-color-pink-1: #ffdeeb;--mantine-color-pink-2: #fcc2d7;--mantine-color-pink-3: #faa2c1;--mantine-color-pink-4: #f783ac;--mantine-color-pink-5: #f06595;--mantine-color-pink-6: #e64980;--mantine-color-pink-7: #d6336c;--mantine-color-pink-8: #c2255c;--mantine-color-pink-9: #a61e4d;--mantine-color-grape-0: #f8f0fc;--mantine-color-grape-1: #f3d9fa;--mantine-color-grape-2: #eebefa;--mantine-color-grape-3: #e599f7;--mantine-color-grape-4: #da77f2;--mantine-color-grape-5: #cc5de8;--mantine-color-grape-6: #be4bdb;--mantine-color-grape-7: #ae3ec9;--mantine-color-grape-8: #9c36b5;--mantine-color-grape-9: #862e9c;--mantine-color-violet-0: #f3f0ff;--mantine-color-violet-1: #e5dbff;--mantine-color-violet-2: #d0bfff;--mantine-color-violet-3: #b197fc;--mantine-color-violet-4: #9775fa;--mantine-color-violet-5: #845ef7;--mantine-color-violet-6: #7950f2;--mantine-color-violet-7: #7048e8;--mantine-color-violet-8: #6741d9;--mantine-color-violet-9: #5f3dc4;--mantine-color-indigo-0: #edf2ff;--mantine-color-indigo-1: #dbe4ff;--mantine-color-indigo-2: #bac8ff;--mantine-color-indigo-3: #91a7ff;--mantine-color-indigo-4: #748ffc;--mantine-color-indigo-5: #5c7cfa;--mantine-color-indigo-6: #4c6ef5;--mantine-color-indigo-7: #4263eb;--mantine-color-indigo-8: #3b5bdb;--mantine-color-indigo-9: #364fc7;--mantine-color-blue-0: #e7f5ff;--mantine-color-blue-1: #d0ebff;--mantine-color-blue-2: #a5d8ff;--mantine-color-blue-3: #74c0fc;--mantine-color-blue-4: #4dabf7;--mantine-color-blue-5: #339af0;--mantine-color-blue-6: #228be6;--mantine-color-blue-7: #1c7ed6;--mantine-color-blue-8: #1971c2;--mantine-color-blue-9: #1864ab;--mantine-color-cyan-0: #e3fafc;--mantine-color-cyan-1: #c5f6fa;--mantine-color-cyan-2: #99e9f2;--mantine-color-cyan-3: #66d9e8;--mantine-color-cyan-4: #3bc9db;--mantine-color-cyan-5: #22b8cf;--mantine-color-cyan-6: #15aabf;--mantine-color-cyan-7: #1098ad;--mantine-color-cyan-8: #0c8599;--mantine-color-cyan-9: #0b7285;--mantine-color-teal-0: #e6fcf5;--mantine-color-teal-1: #c3fae8;--mantine-color-teal-2: #96f2d7;--mantine-color-teal-3: #63e6be;--mantine-color-teal-4: #38d9a9;--mantine-color-teal-5: #20c997;--mantine-color-teal-6: #12b886;--mantine-color-teal-7: #0ca678;--mantine-color-teal-8: #099268;--mantine-color-teal-9: #087f5b;--mantine-color-green-0: #ebfbee;--mantine-color-green-1: #d3f9d8;--mantine-color-green-2: #b2f2bb;--mantine-color-green-3: #8ce99a;--mantine-color-green-4: #69db7c;--mantine-color-green-5: #51cf66;--mantine-color-green-6: #40c057;--mantine-color-green-7: #37b24d;--mantine-color-green-8: #2f9e44;--mantine-color-green-9: #2b8a3e;--mantine-color-lime-0: #f4fce3;--mantine-color-lime-1: #e9fac8;--mantine-color-lime-2: #d8f5a2;--mantine-color-lime-3: #c0eb75;--mantine-color-lime-4: #a9e34b;--mantine-color-lime-5: #94d82d;--mantine-color-lime-6: #82c91e;--mantine-color-lime-7: #74b816;--mantine-color-lime-8: #66a80f;--mantine-color-lime-9: #5c940d;--mantine-color-yellow-0: #fff9db;--mantine-color-yellow-1: #fff3bf;--mantine-color-yellow-2: #ffec99;--mantine-color-yellow-3: #ffe066;--mantine-color-yellow-4: #ffd43b;--mantine-color-yellow-5: #fcc419;--mantine-color-yellow-6: #fab005;--mantine-color-yellow-7: #f59f00;--mantine-color-yellow-8: #f08c00;--mantine-color-yellow-9: #e67700;--mantine-color-orange-0: #fff4e6;--mantine-color-orange-1: #ffe8cc;--mantine-color-orange-2: #ffd8a8;--mantine-color-orange-3: #ffc078;--mantine-color-orange-4: #ffa94d;--mantine-color-orange-5: #ff922b;--mantine-color-orange-6: #fd7e14;--mantine-color-orange-7: #f76707;--mantine-color-orange-8: #e8590c;--mantine-color-orange-9: #d9480f;--mantine-h1-font-size: calc(2.125rem * var(--mantine-scale));--mantine-h1-line-height: 1.3;--mantine-h1-font-weight: 700;--mantine-h2-font-size: calc(1.625rem * var(--mantine-scale));--mantine-h2-line-height: 1.35;--mantine-h2-font-weight: 700;--mantine-h3-font-size: calc(1.375rem * var(--mantine-scale));--mantine-h3-line-height: 1.4;--mantine-h3-font-weight: 700;--mantine-h4-font-size: calc(1.125rem * var(--mantine-scale));--mantine-h4-line-height: 1.45;--mantine-h4-font-weight: 700;--mantine-h5-font-size: calc(1rem * var(--mantine-scale));--mantine-h5-line-height: 1.5;--mantine-h5-font-weight: 700;--mantine-h6-font-size: calc(.875rem * var(--mantine-scale));--mantine-h6-line-height: 1.5;--mantine-h6-font-weight: 700}:root[data-mantine-color-scheme=dark]{--mantine-color-scheme: dark;--mantine-primary-color-contrast: var(--mantine-color-white);--mantine-color-bright: var(--mantine-color-white);--mantine-color-text: var(--mantine-color-dark-0);--mantine-color-body: var(--mantine-color-dark-7);--mantine-color-error: var(--mantine-color-red-8);--mantine-color-placeholder: var(--mantine-color-dark-3);--mantine-color-anchor: var(--mantine-color-blue-4);--mantine-color-default: var(--mantine-color-dark-6);--mantine-color-default-hover: var(--mantine-color-dark-5);--mantine-color-default-color: var(--mantine-color-white);--mantine-color-default-border: var(--mantine-color-dark-4);--mantine-color-dimmed: var(--mantine-color-dark-2);--mantine-color-dark-text: var(--mantine-color-dark-4);--mantine-color-dark-filled: var(--mantine-color-dark-8);--mantine-color-dark-filled-hover: var(--mantine-color-dark-7);--mantine-color-dark-light: rgba(36, 36, 36, .15);--mantine-color-dark-light-hover: rgba(36, 36, 36, .2);--mantine-color-dark-light-color: var(--mantine-color-dark-3);--mantine-color-dark-outline: var(--mantine-color-dark-4);--mantine-color-dark-outline-hover: rgba(36, 36, 36, .05);--mantine-color-gray-text: var(--mantine-color-gray-4);--mantine-color-gray-filled: var(--mantine-color-gray-8);--mantine-color-gray-filled-hover: var(--mantine-color-gray-9);--mantine-color-gray-light: rgba(134, 142, 150, .15);--mantine-color-gray-light-hover: rgba(134, 142, 150, .2);--mantine-color-gray-light-color: var(--mantine-color-gray-3);--mantine-color-gray-outline: var(--mantine-color-gray-4);--mantine-color-gray-outline-hover: rgba(206, 212, 218, .05);--mantine-color-red-text: var(--mantine-color-red-4);--mantine-color-red-filled: var(--mantine-color-red-8);--mantine-color-red-filled-hover: var(--mantine-color-red-9);--mantine-color-red-light: rgba(250, 82, 82, .15);--mantine-color-red-light-hover: rgba(250, 82, 82, .2);--mantine-color-red-light-color: var(--mantine-color-red-3);--mantine-color-red-outline: var(--mantine-color-red-4);--mantine-color-red-outline-hover: rgba(255, 135, 135, .05);--mantine-color-pink-text: var(--mantine-color-pink-4);--mantine-color-pink-filled: var(--mantine-color-pink-8);--mantine-color-pink-filled-hover: var(--mantine-color-pink-9);--mantine-color-pink-light: rgba(230, 73, 128, .15);--mantine-color-pink-light-hover: rgba(230, 73, 128, .2);--mantine-color-pink-light-color: var(--mantine-color-pink-3);--mantine-color-pink-outline: var(--mantine-color-pink-4);--mantine-color-pink-outline-hover: rgba(247, 131, 172, .05);--mantine-color-grape-text: var(--mantine-color-grape-4);--mantine-color-grape-filled: var(--mantine-color-grape-8);--mantine-color-grape-filled-hover: var(--mantine-color-grape-9);--mantine-color-grape-light: rgba(190, 75, 219, .15);--mantine-color-grape-light-hover: rgba(190, 75, 219, .2);--mantine-color-grape-light-color: var(--mantine-color-grape-3);--mantine-color-grape-outline: var(--mantine-color-grape-4);--mantine-color-grape-outline-hover: rgba(218, 119, 242, .05);--mantine-color-violet-text: var(--mantine-color-violet-4);--mantine-color-violet-filled: var(--mantine-color-violet-8);--mantine-color-violet-filled-hover: var(--mantine-color-violet-9);--mantine-color-violet-light: rgba(121, 80, 242, .15);--mantine-color-violet-light-hover: rgba(121, 80, 242, .2);--mantine-color-violet-light-color: var(--mantine-color-violet-3);--mantine-color-violet-outline: var(--mantine-color-violet-4);--mantine-color-violet-outline-hover: rgba(151, 117, 250, .05);--mantine-color-indigo-text: var(--mantine-color-indigo-4);--mantine-color-indigo-filled: var(--mantine-color-indigo-8);--mantine-color-indigo-filled-hover: var(--mantine-color-indigo-9);--mantine-color-indigo-light: rgba(76, 110, 245, .15);--mantine-color-indigo-light-hover: rgba(76, 110, 245, .2);--mantine-color-indigo-light-color: var(--mantine-color-indigo-3);--mantine-color-indigo-outline: var(--mantine-color-indigo-4);--mantine-color-indigo-outline-hover: rgba(116, 143, 252, .05);--mantine-color-blue-text: var(--mantine-color-blue-4);--mantine-color-blue-filled: var(--mantine-color-blue-8);--mantine-color-blue-filled-hover: var(--mantine-color-blue-9);--mantine-color-blue-light: rgba(34, 139, 230, .15);--mantine-color-blue-light-hover: rgba(34, 139, 230, .2);--mantine-color-blue-light-color: var(--mantine-color-blue-3);--mantine-color-blue-outline: var(--mantine-color-blue-4);--mantine-color-blue-outline-hover: rgba(77, 171, 247, .05);--mantine-color-cyan-text: var(--mantine-color-cyan-4);--mantine-color-cyan-filled: var(--mantine-color-cyan-8);--mantine-color-cyan-filled-hover: var(--mantine-color-cyan-9);--mantine-color-cyan-light: rgba(21, 170, 191, .15);--mantine-color-cyan-light-hover: rgba(21, 170, 191, .2);--mantine-color-cyan-light-color: var(--mantine-color-cyan-3);--mantine-color-cyan-outline: var(--mantine-color-cyan-4);--mantine-color-cyan-outline-hover: rgba(59, 201, 219, .05);--mantine-color-teal-text: var(--mantine-color-teal-4);--mantine-color-teal-filled: var(--mantine-color-teal-8);--mantine-color-teal-filled-hover: var(--mantine-color-teal-9);--mantine-color-teal-light: rgba(18, 184, 134, .15);--mantine-color-teal-light-hover: rgba(18, 184, 134, .2);--mantine-color-teal-light-color: var(--mantine-color-teal-3);--mantine-color-teal-outline: var(--mantine-color-teal-4);--mantine-color-teal-outline-hover: rgba(56, 217, 169, .05);--mantine-color-green-text: var(--mantine-color-green-4);--mantine-color-green-filled: var(--mantine-color-green-8);--mantine-color-green-filled-hover: var(--mantine-color-green-9);--mantine-color-green-light: rgba(64, 192, 87, .15);--mantine-color-green-light-hover: rgba(64, 192, 87, .2);--mantine-color-green-light-color: var(--mantine-color-green-3);--mantine-color-green-outline: var(--mantine-color-green-4);--mantine-color-green-outline-hover: rgba(105, 219, 124, .05);--mantine-color-lime-text: var(--mantine-color-lime-4);--mantine-color-lime-filled: var(--mantine-color-lime-8);--mantine-color-lime-filled-hover: var(--mantine-color-lime-9);--mantine-color-lime-light: rgba(130, 201, 30, .15);--mantine-color-lime-light-hover: rgba(130, 201, 30, .2);--mantine-color-lime-light-color: var(--mantine-color-lime-3);--mantine-color-lime-outline: var(--mantine-color-lime-4);--mantine-color-lime-outline-hover: rgba(169, 227, 75, .05);--mantine-color-yellow-text: var(--mantine-color-yellow-4);--mantine-color-yellow-filled: var(--mantine-color-yellow-8);--mantine-color-yellow-filled-hover: var(--mantine-color-yellow-9);--mantine-color-yellow-light: rgba(250, 176, 5, .15);--mantine-color-yellow-light-hover: rgba(250, 176, 5, .2);--mantine-color-yellow-light-color: var(--mantine-color-yellow-3);--mantine-color-yellow-outline: var(--mantine-color-yellow-4);--mantine-color-yellow-outline-hover: rgba(255, 212, 59, .05);--mantine-color-orange-text: var(--mantine-color-orange-4);--mantine-color-orange-filled: var(--mantine-color-orange-8);--mantine-color-orange-filled-hover: var(--mantine-color-orange-9);--mantine-color-orange-light: rgba(253, 126, 20, .15);--mantine-color-orange-light-hover: rgba(253, 126, 20, .2);--mantine-color-orange-light-color: var(--mantine-color-orange-3);--mantine-color-orange-outline: var(--mantine-color-orange-4);--mantine-color-orange-outline-hover: rgba(255, 169, 77, .05)}:root[data-mantine-color-scheme=light]{--mantine-color-scheme: light;--mantine-color-bright: var(--mantine-color-black);--mantine-color-text: var(--mantine-color-black);--mantine-color-body: var(--mantine-color-white);--mantine-primary-color-contrast: var(--mantine-color-white);--mantine-color-error: var(--mantine-color-red-6);--mantine-color-placeholder: var(--mantine-color-gray-5);--mantine-color-anchor: var(--mantine-primary-color-filled);--mantine-color-default: var(--mantine-color-white);--mantine-color-default-hover: var(--mantine-color-gray-0);--mantine-color-default-color: var(--mantine-color-gray-9);--mantine-color-default-border: var(--mantine-color-gray-4);--mantine-color-dimmed: var(--mantine-color-gray-6);--mantine-color-dark-text: var(--mantine-color-dark-filled);--mantine-color-dark-filled: var(--mantine-color-dark-6);--mantine-color-dark-filled-hover: var(--mantine-color-dark-7);--mantine-color-dark-light: rgba(56, 56, 56, .1);--mantine-color-dark-light-hover: rgba(56, 56, 56, .12);--mantine-color-dark-light-color: var(--mantine-color-dark-6);--mantine-color-dark-outline: var(--mantine-color-dark-6);--mantine-color-dark-outline-hover: rgba(56, 56, 56, .05);--mantine-color-gray-text: var(--mantine-color-gray-filled);--mantine-color-gray-filled: var(--mantine-color-gray-6);--mantine-color-gray-filled-hover: var(--mantine-color-gray-7);--mantine-color-gray-light: rgba(134, 142, 150, .1);--mantine-color-gray-light-hover: rgba(134, 142, 150, .12);--mantine-color-gray-light-color: var(--mantine-color-gray-6);--mantine-color-gray-outline: var(--mantine-color-gray-6);--mantine-color-gray-outline-hover: rgba(134, 142, 150, .05);--mantine-color-red-text: var(--mantine-color-red-filled);--mantine-color-red-filled: var(--mantine-color-red-6);--mantine-color-red-filled-hover: var(--mantine-color-red-7);--mantine-color-red-light: rgba(250, 82, 82, .1);--mantine-color-red-light-hover: rgba(250, 82, 82, .12);--mantine-color-red-light-color: var(--mantine-color-red-6);--mantine-color-red-outline: var(--mantine-color-red-6);--mantine-color-red-outline-hover: rgba(250, 82, 82, .05);--mantine-color-pink-text: var(--mantine-color-pink-filled);--mantine-color-pink-filled: var(--mantine-color-pink-6);--mantine-color-pink-filled-hover: var(--mantine-color-pink-7);--mantine-color-pink-light: rgba(230, 73, 128, .1);--mantine-color-pink-light-hover: rgba(230, 73, 128, .12);--mantine-color-pink-light-color: var(--mantine-color-pink-6);--mantine-color-pink-outline: var(--mantine-color-pink-6);--mantine-color-pink-outline-hover: rgba(230, 73, 128, .05);--mantine-color-grape-text: var(--mantine-color-grape-filled);--mantine-color-grape-filled: var(--mantine-color-grape-6);--mantine-color-grape-filled-hover: var(--mantine-color-grape-7);--mantine-color-grape-light: rgba(190, 75, 219, .1);--mantine-color-grape-light-hover: rgba(190, 75, 219, .12);--mantine-color-grape-light-color: var(--mantine-color-grape-6);--mantine-color-grape-outline: var(--mantine-color-grape-6);--mantine-color-grape-outline-hover: rgba(190, 75, 219, .05);--mantine-color-violet-text: var(--mantine-color-violet-filled);--mantine-color-violet-filled: var(--mantine-color-violet-6);--mantine-color-violet-filled-hover: var(--mantine-color-violet-7);--mantine-color-violet-light: rgba(121, 80, 242, .1);--mantine-color-violet-light-hover: rgba(121, 80, 242, .12);--mantine-color-violet-light-color: var(--mantine-color-violet-6);--mantine-color-violet-outline: var(--mantine-color-violet-6);--mantine-color-violet-outline-hover: rgba(121, 80, 242, .05);--mantine-color-indigo-text: var(--mantine-color-indigo-filled);--mantine-color-indigo-filled: var(--mantine-color-indigo-6);--mantine-color-indigo-filled-hover: var(--mantine-color-indigo-7);--mantine-color-indigo-light: rgba(76, 110, 245, .1);--mantine-color-indigo-light-hover: rgba(76, 110, 245, .12);--mantine-color-indigo-light-color: var(--mantine-color-indigo-6);--mantine-color-indigo-outline: var(--mantine-color-indigo-6);--mantine-color-indigo-outline-hover: rgba(76, 110, 245, .05);--mantine-color-blue-text: var(--mantine-color-blue-filled);--mantine-color-blue-filled: var(--mantine-color-blue-6);--mantine-color-blue-filled-hover: var(--mantine-color-blue-7);--mantine-color-blue-light: rgba(34, 139, 230, .1);--mantine-color-blue-light-hover: rgba(34, 139, 230, .12);--mantine-color-blue-light-color: var(--mantine-color-blue-6);--mantine-color-blue-outline: var(--mantine-color-blue-6);--mantine-color-blue-outline-hover: rgba(34, 139, 230, .05);--mantine-color-cyan-text: var(--mantine-color-cyan-filled);--mantine-color-cyan-filled: var(--mantine-color-cyan-6);--mantine-color-cyan-filled-hover: var(--mantine-color-cyan-7);--mantine-color-cyan-light: rgba(21, 170, 191, .1);--mantine-color-cyan-light-hover: rgba(21, 170, 191, .12);--mantine-color-cyan-light-color: var(--mantine-color-cyan-6);--mantine-color-cyan-outline: var(--mantine-color-cyan-6);--mantine-color-cyan-outline-hover: rgba(21, 170, 191, .05);--mantine-color-teal-text: var(--mantine-color-teal-filled);--mantine-color-teal-filled: var(--mantine-color-teal-6);--mantine-color-teal-filled-hover: var(--mantine-color-teal-7);--mantine-color-teal-light: rgba(18, 184, 134, .1);--mantine-color-teal-light-hover: rgba(18, 184, 134, .12);--mantine-color-teal-light-color: var(--mantine-color-teal-6);--mantine-color-teal-outline: var(--mantine-color-teal-6);--mantine-color-teal-outline-hover: rgba(18, 184, 134, .05);--mantine-color-green-text: var(--mantine-color-green-filled);--mantine-color-green-filled: var(--mantine-color-green-6);--mantine-color-green-filled-hover: var(--mantine-color-green-7);--mantine-color-green-light: rgba(64, 192, 87, .1);--mantine-color-green-light-hover: rgba(64, 192, 87, .12);--mantine-color-green-light-color: var(--mantine-color-green-6);--mantine-color-green-outline: var(--mantine-color-green-6);--mantine-color-green-outline-hover: rgba(64, 192, 87, .05);--mantine-color-lime-text: var(--mantine-color-lime-filled);--mantine-color-lime-filled: var(--mantine-color-lime-6);--mantine-color-lime-filled-hover: var(--mantine-color-lime-7);--mantine-color-lime-light: rgba(130, 201, 30, .1);--mantine-color-lime-light-hover: rgba(130, 201, 30, .12);--mantine-color-lime-light-color: var(--mantine-color-lime-6);--mantine-color-lime-outline: var(--mantine-color-lime-6);--mantine-color-lime-outline-hover: rgba(130, 201, 30, .05);--mantine-color-yellow-text: var(--mantine-color-yellow-filled);--mantine-color-yellow-filled: var(--mantine-color-yellow-6);--mantine-color-yellow-filled-hover: var(--mantine-color-yellow-7);--mantine-color-yellow-light: rgba(250, 176, 5, .1);--mantine-color-yellow-light-hover: rgba(250, 176, 5, .12);--mantine-color-yellow-light-color: var(--mantine-color-yellow-6);--mantine-color-yellow-outline: var(--mantine-color-yellow-6);--mantine-color-yellow-outline-hover: rgba(250, 176, 5, .05);--mantine-color-orange-text: var(--mantine-color-orange-filled);--mantine-color-orange-filled: var(--mantine-color-orange-6);--mantine-color-orange-filled-hover: var(--mantine-color-orange-7);--mantine-color-orange-light: rgba(253, 126, 20, .1);--mantine-color-orange-light-hover: rgba(253, 126, 20, .12);--mantine-color-orange-light-color: var(--mantine-color-orange-6);--mantine-color-orange-outline: var(--mantine-color-orange-6);--mantine-color-orange-outline-hover: rgba(253, 126, 20, .05)}.m_d57069b5{--scrollarea-scrollbar-size: calc(.75rem * var(--mantine-scale));position:relative;overflow:hidden}.m_c0783ff9{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;width:100%;height:100%}.m_c0783ff9::-webkit-scrollbar{display:none}.m_c0783ff9:where([data-scrollbars=xy],[data-scrollbars=y]):where([data-offset-scrollbars=xy],[data-offset-scrollbars=y]){padding-inline-end:var(--scrollarea-scrollbar-size);padding-inline-start:unset}.m_c0783ff9:where([data-scrollbars=xy],[data-scrollbars=x]):where([data-offset-scrollbars=xy],[data-offset-scrollbars=x]){padding-bottom:var(--scrollarea-scrollbar-size)}.m_f8f631dd{min-width:100%;display:table}.m_c44ba933{-webkit-user-select:none;-moz-user-select:none;user-select:none;touch-action:none;box-sizing:border-box;transition:background-color .15s ease,opacity .15s ease;padding:calc(var(--scrollarea-scrollbar-size) / 5);display:flex;background-color:transparent;flex-direction:row}@media (hover: hover){:where([data-mantine-color-scheme=light]) .m_c44ba933:hover{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=light]) .m_c44ba933:hover>.m_d8b5e363{background-color:#00000080}:where([data-mantine-color-scheme=dark]) .m_c44ba933:hover{background-color:var(--mantine-color-dark-8)}:where([data-mantine-color-scheme=dark]) .m_c44ba933:hover>.m_d8b5e363{background-color:#ffffff80}}@media (hover: none){:where([data-mantine-color-scheme=light]) .m_c44ba933:active{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=light]) .m_c44ba933:active>.m_d8b5e363{background-color:#00000080}:where([data-mantine-color-scheme=dark]) .m_c44ba933:active{background-color:var(--mantine-color-dark-8)}:where([data-mantine-color-scheme=dark]) .m_c44ba933:active>.m_d8b5e363{background-color:#ffffff80}}.m_c44ba933:where([data-hidden],[data-state=hidden]){display:none}.m_c44ba933:where([data-orientation=vertical]){width:var(--scrollarea-scrollbar-size);top:0;bottom:var(--sa-corner-width);inset-inline-end:0}.m_c44ba933:where([data-orientation=horizontal]){height:var(--scrollarea-scrollbar-size);flex-direction:column;bottom:0;inset-inline-start:0;inset-inline-end:var(--sa-corner-width)}.m_d8b5e363{flex:1;border-radius:var(--scrollarea-scrollbar-size);position:relative;transition:background-color .15s ease;overflow:hidden}.m_d8b5e363:before{content:"";position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:100%;height:100%;min-width:calc(2.75rem * var(--mantine-scale));min-height:calc(2.75rem * var(--mantine-scale))}:where([data-mantine-color-scheme=light]) .m_d8b5e363{background-color:#0006}:where([data-mantine-color-scheme=dark]) .m_d8b5e363{background-color:#fff6}.m_21657268{position:absolute;opacity:0;transition:opacity .15s ease;display:block;inset-inline-end:0;bottom:0}:where([data-mantine-color-scheme=light]) .m_21657268{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_21657268{background-color:var(--mantine-color-dark-8)}.m_21657268:where([data-hovered]){opacity:1}.m_21657268:where([data-hidden]){display:none}.m_87cf2631{background-color:transparent;cursor:pointer;border:0;padding:0;-webkit-appearance:none;-moz-appearance:none;appearance:none;font-size:var(--mantine-font-size-md);text-align:left;text-decoration:none;color:inherit;touch-action:manipulation;-webkit-tap-highlight-color:transparent}:where([dir=rtl]) .m_87cf2631{text-align:right}.m_515a97f8{border:0;clip:rect(0 0 0 0);height:calc(.0625rem * var(--mantine-scale));width:calc(.0625rem * var(--mantine-scale));margin:calc(-.0625rem * var(--mantine-scale));overflow:hidden;padding:0;position:absolute;white-space:nowrap}.m_1b7284a3{--paper-radius: var(--mantine-radius-default);outline:0;-webkit-tap-highlight-color:transparent;display:block;touch-action:manipulation;text-decoration:none;border-radius:var(--paper-radius);box-shadow:var(--paper-shadow);background-color:var(--mantine-color-body)}:where([data-mantine-color-scheme=light]) .m_1b7284a3:where([data-with-border]){border:calc(.0625rem * var(--mantine-scale)) solid var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_1b7284a3:where([data-with-border]){border:calc(.0625rem * var(--mantine-scale)) solid var(--mantine-color-dark-4)}.m_38a85659{position:absolute;border:1px solid var(--popover-border-color);padding:var(--mantine-spacing-sm) var(--mantine-spacing-md);box-shadow:var(--popover-shadow, none);border-radius:var(--popover-radius, var(--mantine-radius-default))}.m_38a85659:where([data-fixed]){position:fixed}.m_38a85659:focus{outline:none}:where([data-mantine-color-scheme=light]) .m_38a85659{--popover-border-color: var(--mantine-color-gray-2);background-color:var(--mantine-color-white)}:where([data-mantine-color-scheme=dark]) .m_38a85659{--popover-border-color: var(--mantine-color-dark-4);background-color:var(--mantine-color-dark-6)}.m_a31dc6c1{background-color:inherit;border:1px solid var(--popover-border-color);z-index:1}.m_5ae2e3c{--loader-size-xs: calc(1.125rem * var(--mantine-scale));--loader-size-sm: calc(1.375rem * var(--mantine-scale));--loader-size-md: calc(2.25rem * var(--mantine-scale));--loader-size-lg: calc(2.75rem * var(--mantine-scale));--loader-size-xl: calc(3.625rem * var(--mantine-scale));--loader-size: var(--loader-size-md);--loader-color: var(--mantine-primary-color-filled)}@keyframes m_5d2b3b9d{0%{transform:scale(.6);opacity:0}50%,to{transform:scale(1)}}.m_7a2bd4cd{position:relative;width:var(--loader-size);height:var(--loader-size);display:flex;gap:calc(var(--loader-size) / 5)}.m_870bb79{flex:1;background:var(--loader-color);animation:m_5d2b3b9d 1.2s cubic-bezier(0,.5,.5,1) infinite;border-radius:calc(.125rem * var(--mantine-scale))}.m_870bb79:nth-of-type(1){animation-delay:-.24s}.m_870bb79:nth-of-type(2){animation-delay:-.12s}.m_870bb79:nth-of-type(3){animation-delay:0}@keyframes m_aac34a1{0%,to{transform:scale(1);opacity:1}50%{transform:scale(.6);opacity:.5}}.m_4e3f22d7{display:flex;justify-content:center;align-items:center;gap:calc(var(--loader-size) / 10);position:relative;width:var(--loader-size);height:var(--loader-size)}.m_870c4af{width:calc(var(--loader-size) / 3 - var(--loader-size) / 15);height:calc(var(--loader-size) / 3 - var(--loader-size) / 15);border-radius:50%;background:var(--loader-color);animation:m_aac34a1 .8s infinite linear}.m_870c4af:nth-child(2){animation-delay:.4s}@keyframes m_f8e89c4b{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.m_b34414df{display:inline-block;width:var(--loader-size);height:var(--loader-size)}.m_b34414df:after{content:"";display:block;width:var(--loader-size);height:var(--loader-size);border-radius:calc(625rem * var(--mantine-scale));border-width:calc(var(--loader-size) / 8);border-style:solid;border-color:var(--loader-color) var(--loader-color) var(--loader-color) transparent;animation:m_f8e89c4b 1.2s linear infinite}.m_8d3f4000{--ai-size-xs: calc(1.125rem * var(--mantine-scale));--ai-size-sm: calc(1.375rem * var(--mantine-scale));--ai-size-md: calc(1.75rem * var(--mantine-scale));--ai-size-lg: calc(2.125rem * var(--mantine-scale));--ai-size-xl: calc(2.75rem * var(--mantine-scale));--ai-size-input-xs: calc(1.875rem * var(--mantine-scale));--ai-size-input-sm: calc(2.25rem * var(--mantine-scale));--ai-size-input-md: calc(2.625rem * var(--mantine-scale));--ai-size-input-lg: calc(3.125rem * var(--mantine-scale));--ai-size-input-xl: calc(3.75rem * var(--mantine-scale));--ai-size: var(--ai-size-md);--ai-color: var(--mantine-color-white);line-height:1;display:inline-flex;align-items:center;justify-content:center;position:relative;-webkit-user-select:none;-moz-user-select:none;user-select:none;overflow:hidden;width:var(--ai-size);height:var(--ai-size);min-width:var(--ai-size);min-height:var(--ai-size);border-radius:var(--ai-radius, var(--mantine-radius-default));background:var(--ai-bg, var(--mantine-primary-color-filled));color:var(--ai-color, var(--mantine-color-white));border:var(--ai-bd, calc(.0625rem * var(--mantine-scale)) solid transparent);cursor:pointer}@media (hover: hover){.m_8d3f4000:hover:where(:not([data-loading],:disabled,[data-disabled])){background-color:var(--ai-hover, var(--mantine-primary-color-filled-hover));color:var(--ai-hover-color, var(--ai-color))}}@media (hover: none){.m_8d3f4000:active:where(:not([data-loading],:disabled,[data-disabled])){background-color:var(--ai-hover, var(--mantine-primary-color-filled-hover));color:var(--ai-hover-color, var(--ai-color))}}.m_8d3f4000[data-loading]{cursor:not-allowed}.m_8d3f4000[data-loading] .m_8d3afb97{opacity:0;transform:translateY(100%)}.m_8d3f4000:where(:disabled:not([data-loading]),[data-disabled]:not([data-loading])){cursor:not-allowed;border:calc(.0625rem * var(--mantine-scale)) solid transparent}:where([data-mantine-color-scheme=light]) .m_8d3f4000:where(:disabled:not([data-loading]),[data-disabled]:not([data-loading])){background-color:var(--mantine-color-gray-1);color:var(--mantine-color-gray-5)}:where([data-mantine-color-scheme=dark]) .m_8d3f4000:where(:disabled:not([data-loading]),[data-disabled]:not([data-loading])){background-color:var(--mantine-color-dark-6);color:var(--mantine-color-dark-3)}.m_8d3f4000:where(:disabled:not([data-loading]),[data-disabled]:not([data-loading])):active{transform:none}.m_302b9fb1{inset:calc(-.0625rem * var(--mantine-scale));position:absolute;border-radius:var(--ai-radius, var(--mantine-radius-default));display:flex;align-items:center;justify-content:center}:where([data-mantine-color-scheme=light]) .m_302b9fb1{background-color:#ffffff26}:where([data-mantine-color-scheme=dark]) .m_302b9fb1{background-color:#00000026}.m_1a0f1b21{--ai-border-width: calc(.0625rem * var(--mantine-scale));display:flex}.m_1a0f1b21 :where(*):focus{position:relative;z-index:1}.m_1a0f1b21[data-orientation=horizontal]{flex-direction:row}.m_1a0f1b21[data-orientation=horizontal] .m_8d3f4000:not(:only-child):first-child{border-end-end-radius:0;border-start-end-radius:0;border-inline-end-width:calc(var(--ai-border-width) / 2)}.m_1a0f1b21[data-orientation=horizontal] .m_8d3f4000:not(:only-child):last-child{border-end-start-radius:0;border-start-start-radius:0;border-inline-start-width:calc(var(--ai-border-width) / 2)}.m_1a0f1b21[data-orientation=horizontal] .m_8d3f4000:not(:only-child):not(:first-child):not(:last-child){border-radius:0;border-inline-width:calc(var(--ai-border-width) / 2)}.m_1a0f1b21[data-orientation=vertical]{flex-direction:column}.m_1a0f1b21[data-orientation=vertical] .m_8d3f4000:not(:only-child):first-child{border-end-start-radius:0;border-end-end-radius:0;border-bottom-width:calc(var(--ai-border-width) / 2)}.m_1a0f1b21[data-orientation=vertical] .m_8d3f4000:not(:only-child):last-child{border-start-start-radius:0;border-start-end-radius:0;border-top-width:calc(var(--ai-border-width) / 2)}.m_1a0f1b21[data-orientation=vertical] .m_8d3f4000:not(:only-child):not(:first-child):not(:last-child){border-radius:0;border-bottom-width:calc(var(--ai-border-width) / 2);border-top-width:calc(var(--ai-border-width) / 2)}.m_8d3afb97{display:flex;align-items:center;justify-content:center;transition:transform .15s ease,opacity .1s ease;width:100%;height:100%}.m_86a44da5{--cb-size-xs: calc(1.125rem * var(--mantine-scale));--cb-size-sm: calc(1.375rem * var(--mantine-scale));--cb-size-md: calc(1.75rem * var(--mantine-scale));--cb-size-lg: calc(2.125rem * var(--mantine-scale));--cb-size-xl: calc(2.75rem * var(--mantine-scale));--cb-size: var(--cb-size-md);--cb-icon-size: 70%;--cb-radius: var(--mantine-radius-default);line-height:1;display:inline-flex;align-items:center;justify-content:center;position:relative;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:var(--cb-size);height:var(--cb-size);min-width:var(--cb-size);min-height:var(--cb-size);border-radius:var(--cb-radius)}:where([data-mantine-color-scheme=light]) .m_86a44da5{color:var(--mantine-color-gray-7)}:where([data-mantine-color-scheme=dark]) .m_86a44da5{color:var(--mantine-color-dark-1)}.m_86a44da5[data-disabled],.m_86a44da5:disabled{cursor:not-allowed;opacity:.6}@media (hover: hover){:where([data-mantine-color-scheme=light]) .m_220c80f2:where(:not([data-disabled],:disabled)):hover{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_220c80f2:where(:not([data-disabled],:disabled)):hover{background-color:var(--mantine-color-dark-6)}}@media (hover: none){:where([data-mantine-color-scheme=light]) .m_220c80f2:where(:not([data-disabled],:disabled)):active{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_220c80f2:where(:not([data-disabled],:disabled)):active{background-color:var(--mantine-color-dark-6)}}.m_4081bf90{display:flex;flex-direction:row;flex-wrap:var(--group-wrap, wrap);justify-content:var(--group-justify, flex-start);align-items:var(--group-align, center);gap:var(--group-gap, var(--mantine-spacing-md))}.m_4081bf90:where([data-grow])>*{flex-grow:1;max-width:var(--group-child-width)}.m_9814e45f{top:0;right:0;bottom:0;left:0;position:absolute;background:var(--overlay-bg, rgba(0, 0, 0, .6));backdrop-filter:var(--overlay-filter);-webkit-backdrop-filter:var(--overlay-filter);border-radius:var(--overlay-radius, 0);z-index:var(--overlay-z-index)}.m_9814e45f:where([data-fixed]){position:fixed}.m_9814e45f:where([data-center]){display:flex;align-items:center;justify-content:center}.m_615af6c9{line-height:1;padding:0;margin:0;font-weight:400;font-size:var(--mantine-font-size-md)}.m_b5489c3c{display:flex;justify-content:space-between;align-items:center;padding:var(--mb-padding, var(--mantine-spacing-md));padding-inline-end:calc(var(--mb-padding, var(--mantine-spacing-md)) - calc(.3125rem * var(--mantine-scale)));position:sticky;top:0;background-color:var(--mantine-color-body);z-index:1000;min-height:calc(3.75rem * var(--mantine-scale));transition:padding-inline-end .1s}.m_60c222c7{position:fixed;width:100%;top:0;bottom:0;z-index:var(--mb-z-index);pointer-events:none}.m_fd1ab0aa{pointer-events:all;box-shadow:var(--mb-shadow, var(--mantine-shadow-xl))}.m_fd1ab0aa [data-mantine-scrollbar]{z-index:1001}.m_fd1ab0aa:has([data-mantine-scrollbar][data-state=visible]) .m_b5489c3c{padding-inline-end:calc(var(--mb-padding, var(--mantine-spacing-md)) + calc(.3125rem * var(--mantine-scale)))}.m_606cb269{margin-inline-start:auto}.m_5df29311{padding:var(--mb-padding, var(--mantine-spacing-md));padding-top:var(--mb-padding, var(--mantine-spacing-md))}.m_5df29311:where(:not(:only-child)){padding-top:0}.m_6c018570{position:relative;margin-top:var(--input-margin-top, 0rem);margin-bottom:var(--input-margin-bottom, 0rem);--input-height-xs: calc(1.875rem * var(--mantine-scale));--input-height-sm: calc(2.25rem * var(--mantine-scale));--input-height-md: calc(2.625rem * var(--mantine-scale));--input-height-lg: calc(3.125rem * var(--mantine-scale));--input-height-xl: calc(3.75rem * var(--mantine-scale));--input-padding-y-xs: calc(.3125rem * var(--mantine-scale));--input-padding-y-sm: calc(.375rem * var(--mantine-scale));--input-padding-y-md: calc(.5rem * var(--mantine-scale));--input-padding-y-lg: calc(.625rem * var(--mantine-scale));--input-padding-y-xl: calc(.8125rem * var(--mantine-scale));--input-height: var(--input-height-sm);--input-radius: var(--mantine-radius-default);--input-cursor: text;--input-text-align: left;--input-line-height: calc(var(--input-height) - calc(.125rem * var(--mantine-scale)));--input-padding: calc(var(--input-height) / 3);--input-padding-inline-start: var(--input-padding);--input-padding-inline-end: var(--input-padding);--input-placeholder-color: var(--mantine-color-placeholder);--input-color: var(--mantine-color-text);--input-left-section-size: var(--input-left-section-width, calc(var(--input-height) - calc(.125rem * var(--mantine-scale))));--input-right-section-size: var( --input-right-section-width, calc(var(--input-height) - calc(.125rem * var(--mantine-scale))) );--input-size: var(--input-height);--section-y: calc(.0625rem * var(--mantine-scale));--left-section-start: calc(.0625rem * var(--mantine-scale));--left-section-border-radius: var(--input-radius) 0 0 var(--input-radius);--right-section-end: calc(.0625rem * var(--mantine-scale));--right-section-border-radius: 0 var(--input-radius) var(--input-radius) 0}.m_6c018570[data-variant=unstyled]{--input-padding: 0;--input-padding-y: 0;--input-padding-inline-start: 0;--input-padding-inline-end: 0}.m_6c018570[data-pointer]{--input-cursor: pointer}.m_6c018570[data-multiline]{--input-padding-y-xs: calc(.28125rem * var(--mantine-scale));--input-padding-y-sm: calc(.34375rem * var(--mantine-scale));--input-padding-y-md: calc(.4375rem * var(--mantine-scale));--input-padding-y-lg: calc(.59375rem * var(--mantine-scale));--input-padding-y-xl: calc(.8125rem * var(--mantine-scale));--input-size: auto;--input-line-height: var(--mantine-line-height);--input-padding-y: var(--input-padding-y-sm)}.m_6c018570[data-with-left-section]{--input-padding-inline-start: var(--input-left-section-size)}.m_6c018570[data-with-right-section]{--input-padding-inline-end: var(--input-right-section-size)}[data-mantine-color-scheme=light] .m_6c018570{--input-disabled-bg: var(--mantine-color-gray-1);--input-disabled-color: var(--mantine-color-gray-6)}[data-mantine-color-scheme=light] .m_6c018570[data-variant=default]{--input-bd: var(--mantine-color-gray-4);--input-bg: var(--mantine-color-white);--input-bd-focus: var(--mantine-primary-color-filled)}[data-mantine-color-scheme=light] .m_6c018570[data-variant=filled]{--input-bd: transparent;--input-bg: var(--mantine-color-gray-1);--input-bd-focus: var(--mantine-primary-color-filled)}[data-mantine-color-scheme=light] .m_6c018570[data-variant=unstyled]{--input-bd: transparent;--input-bg: transparent;--input-bd-focus: transparent}[data-mantine-color-scheme=dark] .m_6c018570{--input-disabled-bg: var(--mantine-color-dark-6);--input-disabled-color: var(--mantine-color-dark-2)}[data-mantine-color-scheme=dark] .m_6c018570[data-variant=default]{--input-bd: var(--mantine-color-dark-4);--input-bg: var(--mantine-color-dark-6);--input-bd-focus: var(--mantine-primary-color-filled)}[data-mantine-color-scheme=dark] .m_6c018570[data-variant=filled]{--input-bd: transparent;--input-bg: var(--mantine-color-dark-5);--input-bd-focus: var(--mantine-primary-color-filled)}[data-mantine-color-scheme=dark] .m_6c018570[data-variant=unstyled]{--input-bd: transparent;--input-bg: transparent;--input-bd-focus: transparent}[data-mantine-color-scheme] .m_6c018570[data-error]:not([data-variant=unstyled]){--input-bd: var(--mantine-color-error)}[data-mantine-color-scheme] .m_6c018570[data-error]{--input-color: var(--mantine-color-error);--input-placeholder-color: var(--mantine-color-error);--input-section-color: var(--mantine-color-error)}:where([dir=rtl]) .m_6c018570{--input-text-align: right;--left-section-border-radius: 0 var(--input-radius) var(--input-radius) 0;--right-section-border-radius: var(--input-radius) 0 0 var(--input-radius)}.m_8fb7ebe7{-webkit-tap-highlight-color:transparent;-webkit-appearance:none;-moz-appearance:none;appearance:none;resize:var(--input-resize, none);display:block;width:100%;transition:border-color .1s ease;text-align:var(--input-text-align);color:var(--input-color);border:calc(.0625rem * var(--mantine-scale)) solid var(--input-bd);background-color:var(--input-bg);font-family:var(--input-font-family, var(--mantine-font-family));height:var(--input-size);min-height:var(--input-height);line-height:var(--input-line-height);font-size:var(--input-fz, var(--input-fz, var(--mantine-font-size-sm)));border-radius:var(--input-radius);padding-inline-start:var(--input-padding-inline-start);padding-inline-end:var(--input-padding-inline-end);padding-top:var(--input-padding-y, 0rem);padding-bottom:var(--input-padding-y, 0rem);cursor:var(--input-cursor);overflow:var(--input-overflow)}.m_8fb7ebe7[data-no-overflow]{--input-overflow: hidden}.m_8fb7ebe7[data-monospace]{--input-font-family: var(--mantine-font-family-monospace);--input-fz: calc(var(--input-fz, var(--mantine-font-size-sm)) - calc(.125rem * var(--mantine-scale)))}.m_8fb7ebe7:focus,.m_8fb7ebe7:focus-within{outline:none;--input-bd: var(--input-bd-focus)}[data-error] .m_8fb7ebe7:focus,[data-error] .m_8fb7ebe7:focus-within{--input-bd: var(--mantine-color-error)}.m_8fb7ebe7::-moz-placeholder{color:var(--input-placeholder-color);opacity:1}.m_8fb7ebe7::placeholder{color:var(--input-placeholder-color);opacity:1}.m_8fb7ebe7::-webkit-inner-spin-button,.m_8fb7ebe7::-webkit-outer-spin-button,.m_8fb7ebe7::-webkit-search-decoration,.m_8fb7ebe7::-webkit-search-cancel-button,.m_8fb7ebe7::-webkit-search-results-button,.m_8fb7ebe7::-webkit-search-results-decoration{-webkit-appearance:none;-moz-appearance:none;appearance:none}.m_8fb7ebe7[type=number]{-moz-appearance:textfield}.m_8fb7ebe7:disabled,.m_8fb7ebe7[data-disabled]{cursor:not-allowed;opacity:.6;background-color:var(--input-disabled-bg);color:var(--input-disabled-color)}.m_8fb7ebe7:has(input:disabled){cursor:not-allowed;opacity:.6;background-color:var(--input-disabled-bg);color:var(--input-disabled-color)}.m_82577fc2{pointer-events:var(--section-pointer-events);position:absolute;z-index:1;inset-inline-start:var(--section-start);inset-inline-end:var(--section-end);bottom:var(--section-y);top:var(--section-y);display:flex;align-items:center;justify-content:center;width:var(--section-size);border-radius:var(--section-border-radius);color:var(--input-section-color, var(--mantine-color-dimmed))}.m_82577fc2[data-position=right]{--section-pointer-events: var(--input-right-section-pointer-events);--section-end: var(--right-section-end);--section-size: var(--input-right-section-size);--section-border-radius: var(--right-section-border-radius)}.m_82577fc2[data-position=left]{--section-pointer-events: var(--input-left-section-pointer-events);--section-start: var(--left-section-start);--section-size: var(--input-left-section-size);--section-border-radius: var(--left-section-border-radius)}.m_88bacfd0{color:var(--input-placeholder-color, var(--mantine-color-placeholder))}[data-error] .m_88bacfd0{--input-placeholder-color: var(--input-color, var(--mantine-color-placeholder))}.m_46b77525{line-height:var(--mantine-line-height)}.m_8fdc1311{display:inline-block;font-weight:500;word-break:break-word;cursor:default;-webkit-tap-highlight-color:transparent;font-size:var(--input-label-size, var(--mantine-font-size-sm))}.m_78a94662{color:var(--input-asterisk-color, var(--mantine-color-error))}.m_8f816625,.m_fe47ce59{word-wrap:break-word;line-height:1.2;display:block;margin:0;padding:0}.m_8f816625{color:var(--mantine-color-error);font-size:var(--input-error-size, calc(var(--mantine-font-size-sm) - calc(.125rem * var(--mantine-scale))))}.m_fe47ce59{color:var(--mantine-color-dimmed);font-size:var(--input-description-size, calc(var(--mantine-font-size-sm) - calc(.125rem * var(--mantine-scale))))}.m_8bffd616{display:flex}.m_96b553a6{--transition-duration: .15s;top:0;left:0;position:absolute;z-index:0;transition-property:transform,width,height;transition-timing-function:ease;transition-duration:0ms}.m_96b553a6:where([data-initialized]){transition-duration:var(--transition-duration)}.m_96b553a6:where([data-hidden]){background-color:red;display:none}.m_9bdbb667{--accordion-radius: var(--mantine-radius-default)}.m_df78851f{word-break:break-word}.m_4ba554d4{padding:var(--mantine-spacing-md);padding-top:calc(var(--mantine-spacing-xs) / 2)}.m_8fa820a0{margin:0;padding:0}.m_4ba585b8{width:100%;display:flex;align-items:center;flex-direction:row-reverse;padding-inline:var(--mantine-spacing-md);opacity:1;cursor:pointer;background-color:transparent}.m_4ba585b8:where([data-chevron-position=left]){flex-direction:row;padding-inline-start:0}:where([data-mantine-color-scheme=light]) .m_4ba585b8{color:var(--mantine-color-black)}:where([data-mantine-color-scheme=dark]) .m_4ba585b8{color:var(--mantine-color-dark-0)}.m_4ba585b8:where(:disabled,[data-disabled]){opacity:.4;cursor:not-allowed}@media (hover: hover){:where([data-mantine-color-scheme=light]) .m_6939a5e9:where(:not(:disabled,[data-disabled])):hover,:where([data-mantine-color-scheme=light]) .m_4271d21b:where(:not(:disabled,[data-disabled])):hover{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_6939a5e9:where(:not(:disabled,[data-disabled])):hover,:where([data-mantine-color-scheme=dark]) .m_4271d21b:where(:not(:disabled,[data-disabled])):hover{background-color:var(--mantine-color-dark-6)}}@media (hover: none){:where([data-mantine-color-scheme=light]) .m_6939a5e9:where(:not(:disabled,[data-disabled])):active,:where([data-mantine-color-scheme=light]) .m_4271d21b:where(:not(:disabled,[data-disabled])):active{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_6939a5e9:where(:not(:disabled,[data-disabled])):active,:where([data-mantine-color-scheme=dark]) .m_4271d21b:where(:not(:disabled,[data-disabled])):active{background-color:var(--mantine-color-dark-6)}}.m_df3ffa0f{color:inherit;font-weight:400;flex:1;overflow:hidden;text-overflow:ellipsis;padding-top:var(--mantine-spacing-sm);padding-bottom:var(--mantine-spacing-sm)}.m_3f35ae96{display:flex;align-items:center;justify-content:flex-start;transition:transform var(--accordion-transition-duration, .2s) ease;width:var(--accordion-chevron-size, calc(.9375rem * var(--mantine-scale)));min-width:var(--accordion-chevron-size, calc(.9375rem * var(--mantine-scale)));transform:rotate(0)}.m_3f35ae96:where([data-rotate]){transform:rotate(180deg)}.m_3f35ae96:where([data-position=left]){margin-inline-end:var(--mantine-spacing-md);margin-inline-start:var(--mantine-spacing-md)}.m_9bd771fe{display:flex;align-items:center;justify-content:center;margin-inline-end:var(--mantine-spacing-sm)}.m_9bd771fe:where([data-chevron-position=left]){margin-inline-end:0;margin-inline-start:var(--mantine-spacing-lg)}:where([data-mantine-color-scheme=light]) .m_9bd7b098{--item-border-color: var(--mantine-color-gray-3);--item-filled-color: var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_9bd7b098{--item-border-color: var(--mantine-color-dark-4);--item-filled-color: var(--mantine-color-dark-6)}.m_fe19b709{border-bottom:1px solid var(--item-border-color)}.m_1f921b3b{border:1px solid var(--item-border-color);transition:background-color .15s ease}.m_1f921b3b:where([data-active]){background-color:var(--item-filled-color)}.m_1f921b3b:first-of-type{border-start-start-radius:var(--accordion-radius);border-start-end-radius:var(--accordion-radius)}.m_1f921b3b:first-of-type>[data-accordion-control]{border-start-start-radius:var(--accordion-radius);border-start-end-radius:var(--accordion-radius)}.m_1f921b3b:last-of-type{border-end-start-radius:var(--accordion-radius);border-end-end-radius:var(--accordion-radius)}.m_1f921b3b:last-of-type>[data-accordion-control]{border-end-start-radius:var(--accordion-radius);border-end-end-radius:var(--accordion-radius)}.m_1f921b3b+.m_1f921b3b{border-top:0}.m_2cdf939a{border-radius:var(--accordion-radius)}.m_2cdf939a:where([data-active]){background-color:var(--item-filled-color)}.m_9f59b069{background-color:var(--item-filled-color);border-radius:var(--accordion-radius);border:calc(.0625rem * var(--mantine-scale)) solid transparent;transition:background-color .15s ease}.m_9f59b069[data-active]{border-color:var(--item-border-color)}:where([data-mantine-color-scheme=light]) .m_9f59b069[data-active]{background-color:var(--mantine-color-white)}:where([data-mantine-color-scheme=dark]) .m_9f59b069[data-active]{background-color:var(--mantine-color-dark-7)}.m_9f59b069+.m_9f59b069{margin-top:var(--mantine-spacing-md)}.m_7f854edf{position:fixed;z-index:var(--affix-z-index);inset-inline-start:var(--affix-left);inset-inline-end:var(--affix-right);top:var(--affix-top);bottom:var(--affix-bottom)}.m_66836ed3{--alert-radius: var(--mantine-radius-default);--alert-bg: var(--mantine-primary-color-light);--alert-bd: calc(.0625rem * var(--mantine-scale)) solid transparent;--alert-color: var(--mantine-primary-color-light-color);padding:var(--mantine-spacing-md) var(--mantine-spacing-md);border-radius:var(--alert-radius);position:relative;overflow:hidden;background-color:var(--alert-bg);border:var(--alert-bd);color:var(--alert-color)}.m_a5d60502{display:flex}.m_667c2793{flex:1;display:flex;flex-direction:column;gap:var(--mantine-spacing-xs)}.m_6a03f287{display:flex;align-items:center;justify-content:space-between;font-size:var(--mantine-font-size-sm);font-weight:700}.m_6a03f287:where([data-with-close-button]){padding-inline-end:var(--mantine-spacing-md)}.m_698f4f23{display:block;overflow:hidden;text-overflow:ellipsis}.m_667f2a6a{line-height:1;width:calc(1.25rem * var(--mantine-scale));height:calc(1.25rem * var(--mantine-scale));display:flex;align-items:center;justify-content:flex-start;margin-inline-end:var(--mantine-spacing-md);margin-top:calc(.0625rem * var(--mantine-scale))}.m_7fa78076{text-overflow:ellipsis;overflow:hidden;font-size:var(--mantine-font-size-sm)}:where([data-mantine-color-scheme=light]) .m_7fa78076{color:var(--mantine-color-black)}:where([data-mantine-color-scheme=dark]) .m_7fa78076{color:var(--mantine-color-white)}.m_7fa78076:where([data-variant=filled]){color:var(--alert-color)}.m_7fa78076:where([data-variant=white]){color:var(--mantine-color-black)}.m_87f54839{width:calc(1.25rem * var(--mantine-scale));height:calc(1.25rem * var(--mantine-scale));color:var(--alert-color)}.m_b6d8b162{-webkit-tap-highlight-color:transparent;text-decoration:none;font-size:var(--text-fz, var(--mantine-font-size-md));line-height:var(--text-lh, var(--mantine-line-height-md));font-weight:400;margin:0;padding:0;color:var(--text-color)}.m_b6d8b162:where([data-truncate]){overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.m_b6d8b162:where([data-truncate=start]){direction:rtl;text-align:right}:where([dir=rtl]) .m_b6d8b162:where([data-truncate=start]){direction:ltr;text-align:left}.m_b6d8b162:where([data-variant=gradient]){background-image:var(--text-gradient);background-clip:text;-webkit-background-clip:text;-webkit-text-fill-color:transparent}.m_b6d8b162:where([data-line-clamp]){overflow:hidden;text-overflow:ellipsis;display:-webkit-box;-webkit-line-clamp:var(--text-line-clamp);-webkit-box-orient:vertical}.m_b6d8b162:where([data-inherit]){line-height:inherit;font-weight:inherit;font-size:inherit}.m_b6d8b162:where([data-inline]){line-height:1}.m_849cf0da{color:var(--mantine-color-anchor);text-decoration:none;-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;display:inline;padding:0;margin:0;background-color:transparent;cursor:pointer}@media (hover: hover){.m_849cf0da:where([data-underline=hover]):hover{text-decoration:underline}}@media (hover: none){.m_849cf0da:where([data-underline=hover]):active{text-decoration:underline}}.m_849cf0da:where([data-underline=always]){text-decoration:underline}.m_849cf0da:where([data-variant=gradient]),.m_849cf0da:where([data-variant=gradient]):hover{text-decoration:none}.m_849cf0da:where([data-line-clamp]){display:-webkit-box}.m_48204f9b{width:var(--slider-size);height:var(--slider-size);position:relative;border-radius:100%;display:flex;align-items:center;justify-content:center;-webkit-user-select:none;-moz-user-select:none;user-select:none}.m_48204f9b:focus-within{outline:2px solid var(--mantine-primary-color-filled);outline-offset:calc(.125rem * var(--mantine-scale))}.m_48204f9b{--slider-size: calc(3.75rem * var(--mantine-scale));--thumb-size: calc(var(--slider-size) / 5)}:where([data-mantine-color-scheme=light]) .m_48204f9b{background-color:var(--mantine-color-gray-1)}:where([data-mantine-color-scheme=dark]) .m_48204f9b{background-color:var(--mantine-color-dark-5)}.m_bb9cdbad{position:absolute;inset:calc(.0625rem * var(--mantine-scale));border-radius:var(--slider-size);pointer-events:none}.m_481dd586{width:calc(.125rem * var(--mantine-scale));position:absolute;top:0;bottom:0;left:calc(50% - 1px);transform:rotate(var(--angle))}.m_481dd586:before{content:"";position:absolute;top:calc(var(--thumb-size) / 3);left:calc(.03125rem * var(--mantine-scale));width:calc(.0625rem * var(--mantine-scale));height:calc(var(--thumb-size) / 1.5);transform:translate(-50%,-50%)}:where([data-mantine-color-scheme=light]) .m_481dd586:before{background-color:var(--mantine-color-gray-4)}:where([data-mantine-color-scheme=dark]) .m_481dd586:before{background-color:var(--mantine-color-dark-3)}.m_481dd586[data-label]:after{min-width:calc(1.125rem * var(--mantine-scale));text-align:center;content:attr(data-label);position:absolute;top:calc(-1.5rem * var(--mantine-scale));left:calc(-.4375rem * var(--mantine-scale));transform:rotate(calc(360deg - var(--angle)));font-size:var(--mantine-font-size-xs)}.m_bc02ba3d{position:absolute;top:0;right:0;bottom:0;left:calc(50% - 1.5px);height:100%;width:calc(.1875rem * var(--mantine-scale));outline:none;pointer-events:none}.m_bc02ba3d:before{content:"";position:absolute;right:0;top:0;height:min(var(--thumb-size),calc(var(--slider-size) / 2));width:calc(.1875rem * var(--mantine-scale))}:where([data-mantine-color-scheme=light]) .m_bc02ba3d:before{background-color:var(--mantine-color-gray-7)}:where([data-mantine-color-scheme=dark]) .m_bc02ba3d:before{background-color:var(--mantine-color-dark-1)}.m_bb8e875b{font-size:var(--mantine-font-size-xs)}.m_89ab340[data-resizing]{--app-shell-transition-duration: 0ms !important}.m_89ab340[data-disabled]{--app-shell-header-offset: 0rem !important;--app-shell-navbar-offset: 0rem !important}[data-mantine-color-scheme=light] .m_89ab340{--app-shell-border-color: var(--mantine-color-gray-3)}[data-mantine-color-scheme=dark] .m_89ab340{--app-shell-border-color: var(--mantine-color-dark-4)}.m_45252eee,.m_9cdde9a,.m_3b16f56b,.m_8983817,.m_3840c879{transition-duration:var(--app-shell-transition-duration);transition-timing-function:var(--app-shell-transition-timing-function)}.m_45252eee,.m_9cdde9a{position:fixed;display:flex;flex-direction:column;top:var(--app-shell-header-offset, 0rem);height:calc(100dvh - var(--app-shell-header-offset, 0rem) - var(--app-shell-footer-offset, 0rem));background-color:var(--mantine-color-body);transition-property:transform,top,height}:where([data-layout=alt]) .m_45252eee,:where([data-layout=alt]) .m_9cdde9a{top:0rem;height:100dvh}.m_45252eee{inset-inline-start:0;width:var(--app-shell-navbar-width);transition-property:transform,top,height;transform:var(--app-shell-navbar-transform);z-index:var(--app-shell-navbar-z-index)}:where([dir=rtl]) .m_45252eee{transform:var(--app-shell-navbar-transform-rtl)}.m_45252eee:where([data-with-border]){border-inline-end:1px solid var(--app-shell-border-color)}.m_9cdde9a{inset-inline-end:0;width:var(--app-shell-aside-width);transform:var(--app-shell-aside-transform);z-index:var(--app-shell-aside-z-index)}:where([dir=rtl]) .m_9cdde9a{transform:var(--app-shell-aside-transform-rtl)}.m_9cdde9a:where([data-with-border]){border-inline-start:1px solid var(--app-shell-border-color)}.m_8983817{padding-inline-start:calc(var(--app-shell-navbar-offset, 0rem) + var(--app-shell-padding));padding-inline-end:calc(var(--app-shell-aside-offset, 0rem) + var(--app-shell-padding));padding-top:calc(var(--app-shell-header-offset, 0rem) + var(--app-shell-padding));padding-bottom:calc(var(--app-shell-footer-offset, 0rem) + var(--app-shell-padding));min-height:100dvh;transition-property:padding}.m_3b16f56b,.m_3840c879{position:fixed;inset-inline:0;transition-property:transform,left,right;background-color:var(--mantine-color-body)}:where([data-layout=alt]) .m_3b16f56b,:where([data-layout=alt]) .m_3840c879{inset-inline-start:var(--app-shell-navbar-offset, 0rem);inset-inline-end:var(--app-shell-aside-offset, 0rem)}.m_3b16f56b{top:0;height:var(--app-shell-header-height);background-color:var(--mantine-color-body);transform:var(--app-shell-header-transform);z-index:var(--app-shell-header-z-index)}.m_3b16f56b:where([data-with-border]){border-bottom:1px solid var(--app-shell-border-color)}.m_3840c879{bottom:0;height:calc(var(--app-shell-footer-height) + env(safe-area-inset-bottom));padding-bottom:env(safe-area-inset-bottom);transform:var(--app-shell-footer-transform);z-index:var(--app-shell-footer-z-index)}.m_3840c879:where([data-with-border]){border-top:1px solid var(--app-shell-border-color)}.m_6dcfc7c7{flex-grow:0}.m_6dcfc7c7:where([data-grow]){flex-grow:1}.m_71ac47fc{--ar-ratio: 1;max-width:100%}.m_71ac47fc>:where(*:not(style)){aspect-ratio:var(--ar-ratio);width:100%}.m_71ac47fc>:where(img,video){-o-object-fit:cover;object-fit:cover}.m_88b62a41{--combobox-padding: calc(.25rem * var(--mantine-scale));padding:var(--combobox-padding)}.m_88b62a41:has([data-mantine-scrollbar]){padding-inline-end:0}.m_88b62a41:has([data-mantine-scrollbar]) .m_985517d8{max-width:calc(100% + var(--combobox-padding))}.m_88b62a41[data-hidden]{display:none}.m_88b62a41,.m_b2821a6e{--combobox-option-padding-xs: calc(.25rem * var(--mantine-scale)) calc(.5rem * var(--mantine-scale));--combobox-option-padding-sm: calc(.375rem * var(--mantine-scale)) calc(.625rem * var(--mantine-scale));--combobox-option-padding-md: calc(.5rem * var(--mantine-scale)) calc(.75rem * var(--mantine-scale));--combobox-option-padding-lg: calc(.625rem * var(--mantine-scale)) calc(1rem * var(--mantine-scale));--combobox-option-padding-xl: calc(.875rem * var(--mantine-scale)) calc(1.25rem * var(--mantine-scale));--combobox-option-padding: var(--combobox-option-padding-sm)}.m_92253aa5{padding:var(--combobox-option-padding);font-size:var(--combobox-option-fz, var(--mantine-font-size-sm));border-radius:var(--mantine-radius-default);background-color:transparent;color:inherit;cursor:pointer;word-break:break-word}.m_92253aa5:where([data-combobox-selected]){background-color:var(--mantine-primary-color-filled);color:var(--mantine-color-white)}.m_92253aa5:where([data-combobox-disabled]){cursor:not-allowed;opacity:.35}@media (hover: hover){:where([data-mantine-color-scheme=light]) .m_92253aa5:hover:where(:not([data-combobox-selected],[data-combobox-disabled])){background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_92253aa5:hover:where(:not([data-combobox-selected],[data-combobox-disabled])){background-color:var(--mantine-color-dark-7)}}@media (hover: none){:where([data-mantine-color-scheme=light]) .m_92253aa5:active:where(:not([data-combobox-selected],[data-combobox-disabled])){background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_92253aa5:active:where(:not([data-combobox-selected],[data-combobox-disabled])){background-color:var(--mantine-color-dark-7)}}.m_985517d8{margin-inline:calc(var(--combobox-padding) * -1);margin-top:calc(var(--combobox-padding) * -1);width:calc(100% + var(--combobox-padding) * 2);border-top-width:0;border-inline-width:0;border-end-start-radius:0;border-end-end-radius:0;margin-bottom:var(--combobox-padding);position:relative}:where([data-mantine-color-scheme=light]) .m_985517d8,:where([data-mantine-color-scheme=light]) .m_985517d8:focus{border-color:var(--mantine-color-gray-2)}:where([data-mantine-color-scheme=dark]) .m_985517d8,:where([data-mantine-color-scheme=dark]) .m_985517d8:focus{border-color:var(--mantine-color-dark-4)}:where([data-mantine-color-scheme=light]) .m_985517d8{background-color:var(--mantine-color-white)}:where([data-mantine-color-scheme=dark]) .m_985517d8{background-color:var(--mantine-color-dark-7)}.m_2530cd1d{font-size:var(--combobox-option-fz, var(--mantine-font-size-sm));text-align:center;padding:var(--combobox-option-padding);color:var(--mantine-color-dimmed)}.m_858f94bd,.m_82b967cb{font-size:var(--combobox-option-fz, var(--mantine-font-size-sm));border:0 solid transparent;margin-inline:calc(var(--combobox-padding) * -1);padding:var(--combobox-option-padding)}:where([data-mantine-color-scheme=light]) .m_858f94bd,:where([data-mantine-color-scheme=light]) .m_82b967cb{border-color:var(--mantine-color-gray-2)}:where([data-mantine-color-scheme=dark]) .m_858f94bd,:where([data-mantine-color-scheme=dark]) .m_82b967cb{border-color:var(--mantine-color-dark-4)}.m_82b967cb{border-top-width:calc(.0625rem * var(--mantine-scale));margin-top:var(--combobox-padding);margin-bottom:calc(var(--combobox-padding) * -1)}.m_858f94bd{border-bottom-width:calc(.0625rem * var(--mantine-scale));margin-bottom:var(--combobox-padding);margin-top:calc(var(--combobox-padding) * -1)}.m_254f3e4f:has(.m_2bb2e9e5:only-child){display:none}.m_2bb2e9e5{color:var(--mantine-color-dimmed);font-size:calc(var(--combobox-option-fz, var(--mantine-font-size-sm)) * .85);padding:var(--combobox-option-padding);font-weight:500;position:relative;display:flex;align-items:center}.m_2bb2e9e5:after{content:"";flex:1;inset-inline:0;height:calc(.0625rem * var(--mantine-scale));margin-inline-start:var(--mantine-spacing-xs)}:where([data-mantine-color-scheme=light]) .m_2bb2e9e5:after{background-color:var(--mantine-color-gray-2)}:where([data-mantine-color-scheme=dark]) .m_2bb2e9e5:after{background-color:var(--mantine-color-dark-4)}.m_2bb2e9e5:only-child{display:none}.m_2943220b{--combobox-chevron-size-xs: calc(.875rem * var(--mantine-scale));--combobox-chevron-size-sm: calc(1.125rem * var(--mantine-scale));--combobox-chevron-size-md: calc(1.25rem * var(--mantine-scale));--combobox-chevron-size-lg: calc(1.5rem * var(--mantine-scale));--combobox-chevron-size-xl: calc(1.75rem * var(--mantine-scale));--combobox-chevron-size: var(--combobox-chevron-size-sm);width:var(--combobox-chevron-size);height:var(--combobox-chevron-size)}:where([data-mantine-color-scheme=light]) .m_2943220b{color:var(--mantine-color-gray-6)}:where([data-mantine-color-scheme=dark]) .m_2943220b{color:var(--mantine-color-dark-3)}.m_2943220b:where([data-error]){color:var(--mantine-color-error)}.m_390b5f4{display:flex;align-items:center;gap:calc(.5rem * var(--mantine-scale))}.m_390b5f4:where([data-reverse]){justify-content:space-between}.m_8ee53fc2{opacity:.4;width:.8em;min-width:.8em;height:.8em}:where([data-combobox-selected]) .m_8ee53fc2{opacity:1}.m_5f75b09e{--label-lh-xs: calc(1rem * var(--mantine-scale));--label-lh-sm: calc(1.25rem * var(--mantine-scale));--label-lh-md: calc(1.5rem * var(--mantine-scale));--label-lh-lg: calc(1.875rem * var(--mantine-scale));--label-lh-xl: calc(2.25rem * var(--mantine-scale));--label-lh: var(--label-lh-sm)}.m_5f75b09e[data-label-position=left]{--label-order: 1;--label-offset-end: var(--mantine-spacing-sm);--label-offset-start: 0}.m_5f75b09e[data-label-position=right]{--label-order: 2;--label-offset-end: 0;--label-offset-start: var(--mantine-spacing-sm)}.m_5f6e695e{display:flex}.m_d3ea56bb{--label-cursor: var(--mantine-cursor-type);-webkit-tap-highlight-color:transparent;display:inline-flex;flex-direction:column;font-size:var(--label-fz, var(--mantine-font-size-sm));line-height:var(--label-lh);cursor:var(--label-cursor);order:var(--label-order)}fieldset:disabled .m_d3ea56bb,.m_d3ea56bb[data-disabled]{--label-cursor: not-allowed}.m_8ee546b8{cursor:var(--label-cursor);color:inherit;padding-inline-start:var(--label-offset-start);padding-inline-end:var(--label-offset-end)}:where([data-mantine-color-scheme=light]) fieldset:disabled .m_8ee546b8,:where([data-mantine-color-scheme=light]) .m_8ee546b8:where([data-disabled]){color:var(--mantine-color-gray-5)}:where([data-mantine-color-scheme=dark]) fieldset:disabled .m_8ee546b8,:where([data-mantine-color-scheme=dark]) .m_8ee546b8:where([data-disabled]){color:var(--mantine-color-dark-3)}.m_328f68c0,.m_8e8a99cc{margin-top:calc(var(--mantine-spacing-xs) / 2);padding-inline-start:var(--label-offset-start);padding-inline-end:var(--label-offset-end)}.m_26775b0a{--card-radius: var(--mantine-radius-default);display:block;width:100%;border-radius:var(--card-radius);cursor:pointer}.m_26775b0a :where(*){cursor:inherit}.m_26775b0a:where([data-with-border]){border:calc(.0625rem * var(--mantine-scale)) solid transparent}:where([data-mantine-color-scheme=light]) .m_26775b0a:where([data-with-border]){border-color:var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_26775b0a:where([data-with-border]){border-color:var(--mantine-color-dark-4)}.m_5e5256ee{--checkbox-size-xs: calc(1rem * var(--mantine-scale));--checkbox-size-sm: calc(1.25rem * var(--mantine-scale));--checkbox-size-md: calc(1.5rem * var(--mantine-scale));--checkbox-size-lg: calc(1.875rem * var(--mantine-scale));--checkbox-size-xl: calc(2.25rem * var(--mantine-scale));--checkbox-size: var(--checkbox-size-sm);--checkbox-color: var(--mantine-primary-color-filled);--checkbox-icon-color: var(--mantine-color-white);position:relative;border:calc(.0625rem * var(--mantine-scale)) solid transparent;width:var(--checkbox-size);min-width:var(--checkbox-size);height:var(--checkbox-size);min-height:var(--checkbox-size);border-radius:var(--checkbox-radius, var(--mantine-radius-default));transition:border-color .1s ease,background-color .1s ease;cursor:var(--mantine-cursor-type);-webkit-tap-highlight-color:transparent;display:flex;align-items:center;justify-content:center}:where([data-mantine-color-scheme=light]) .m_5e5256ee{background-color:var(--mantine-color-white);border-color:var(--mantine-color-gray-4)}:where([data-mantine-color-scheme=dark]) .m_5e5256ee{background-color:var(--mantine-color-dark-6);border-color:var(--mantine-color-dark-4)}.m_5e5256ee[data-indeterminate],.m_5e5256ee[data-checked]{background-color:var(--checkbox-color);border-color:var(--checkbox-color)}.m_5e5256ee[data-indeterminate]>.m_1b1c543a,.m_5e5256ee[data-checked]>.m_1b1c543a{opacity:1;transform:none;color:var(--checkbox-icon-color)}.m_5e5256ee[data-disabled]{cursor:not-allowed}:where([data-mantine-color-scheme=light]) .m_5e5256ee[data-disabled]{background-color:var(--mantine-color-gray-2);border-color:var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_5e5256ee[data-disabled]{background-color:var(--mantine-color-dark-6);border-color:var(--mantine-color-dark-6)}[data-mantine-color-scheme=light] .m_5e5256ee[data-disabled][data-checked]>.m_1b1c543a{color:var(--mantine-color-gray-5)}[data-mantine-color-scheme=dark] .m_5e5256ee[data-disabled][data-checked]>.m_1b1c543a{color:var(--mantine-color-dark-3)}.m_76e20374[data-indeterminate]:not([data-disabled]),.m_76e20374[data-checked]:not([data-disabled]){background-color:transparent;border-color:var(--checkbox-color)}.m_76e20374[data-indeterminate]:not([data-disabled])>.m_1b1c543a,.m_76e20374[data-checked]:not([data-disabled])>.m_1b1c543a{color:var(--checkbox-color);opacity:1;transform:none}.m_1b1c543a{display:block;width:60%;color:transparent;pointer-events:none;transform:translateY(calc(.3125rem * var(--mantine-scale))) scale(.5);opacity:1;transition:transform .1s ease,opacity .1s ease}.m_bf2d988c{--checkbox-size-xs: calc(1rem * var(--mantine-scale));--checkbox-size-sm: calc(1.25rem * var(--mantine-scale));--checkbox-size-md: calc(1.5rem * var(--mantine-scale));--checkbox-size-lg: calc(1.875rem * var(--mantine-scale));--checkbox-size-xl: calc(2.25rem * var(--mantine-scale));--checkbox-size: var(--checkbox-size-sm);--checkbox-color: var(--mantine-primary-color-filled);--checkbox-icon-color: var(--mantine-color-white)}.m_26062bec{position:relative;width:var(--checkbox-size);height:var(--checkbox-size);order:1}.m_26062bec:where([data-label-position=left]){order:2}.m_26063560{-webkit-appearance:none;-moz-appearance:none;appearance:none;border:calc(.0625rem * var(--mantine-scale)) solid transparent;width:var(--checkbox-size);height:var(--checkbox-size);border-radius:var(--checkbox-radius, var(--mantine-radius-default));padding:0;display:block;margin:0;transition:border-color .1s ease,background-color .1s ease;cursor:var(--mantine-cursor-type);-webkit-tap-highlight-color:transparent}:where([data-mantine-color-scheme=light]) .m_26063560{background-color:var(--mantine-color-white);border-color:var(--mantine-color-gray-4)}:where([data-mantine-color-scheme=dark]) .m_26063560{background-color:var(--mantine-color-dark-6);border-color:var(--mantine-color-dark-4)}.m_26063560:where([data-error]){border-color:var(--mantine-color-error)}.m_26063560[data-indeterminate],.m_26063560:checked{background-color:var(--checkbox-color);border-color:var(--checkbox-color)}.m_26063560[data-indeterminate]+.m_bf295423,.m_26063560:checked+.m_bf295423{opacity:1;transform:none}.m_26063560:disabled{cursor:not-allowed}:where([data-mantine-color-scheme=light]) .m_26063560:disabled{background-color:var(--mantine-color-gray-2);border-color:var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_26063560:disabled{background-color:var(--mantine-color-dark-6);border-color:var(--mantine-color-dark-6)}[data-mantine-color-scheme=light] .m_26063560:disabled+.m_bf295423{color:var(--mantine-color-gray-5)}[data-mantine-color-scheme=dark] .m_26063560:disabled+.m_bf295423{color:var(--mantine-color-dark-3)}.m_215c4542+.m_bf295423{color:var(--checkbox-color)}.m_215c4542[data-indeterminate]:not(:disabled),.m_215c4542:checked:not(:disabled){background-color:transparent;border-color:var(--checkbox-color)}.m_215c4542[data-indeterminate]:not(:disabled)+.m_bf295423,.m_215c4542:checked:not(:disabled)+.m_bf295423{color:var(--checkbox-color);opacity:1;transform:none}.m_bf295423{position:absolute;top:0;right:0;bottom:0;left:0;width:60%;margin:auto;color:var(--checkbox-icon-color);pointer-events:none;transform:translateY(calc(.3125rem * var(--mantine-scale))) scale(.5);opacity:0;transition:transform .1s ease,opacity .1s ease}.m_11def92b{--ag-spacing: var(--mantine-spacing-sm);--ag-offset: calc(var(--ag-spacing) * -1);display:flex;padding-inline-start:var(--ag-spacing)}.m_f85678b6{--avatar-size-xs: calc(1rem * var(--mantine-scale));--avatar-size-sm: calc(1.625rem * var(--mantine-scale));--avatar-size-md: calc(2.375rem * var(--mantine-scale));--avatar-size-lg: calc(3.5rem * var(--mantine-scale));--avatar-size-xl: calc(5.25rem * var(--mantine-scale));--avatar-size: var(--avatar-size-md);--avatar-radius: calc(62.5rem * var(--mantine-scale));--avatar-bg: var(--mantine-color-gray-light);--avatar-bd: calc(.0625rem * var(--mantine-scale)) solid transparent;--avatar-color: var(--mantine-color-gray-light-color);--avatar-placeholder-fz: calc(var(--avatar-size) / 2.5);-webkit-tap-highlight-color:transparent;position:relative;display:block;-webkit-user-select:none;-moz-user-select:none;user-select:none;overflow:hidden;border-radius:var(--avatar-radius);text-decoration:none;padding:0;width:var(--avatar-size);height:var(--avatar-size);min-width:var(--avatar-size)}.m_f85678b6:where([data-within-group]){margin-inline-start:var(--ag-offset);border:2px solid var(--mantine-color-body);background:var(--mantine-color-body)}.m_11f8ac07{-o-object-fit:cover;object-fit:cover;width:100%;height:100%;display:block}.m_104cd71f{font-weight:700;display:flex;align-items:center;justify-content:center;width:100%;height:100%;-webkit-user-select:none;-moz-user-select:none;user-select:none;border-radius:var(--avatar-radius);font-size:var(--avatar-placeholder-fz);background:var(--avatar-bg);border:var(--avatar-bd);color:var(--avatar-color)}.m_104cd71f>[data-avatar-placeholder-icon]{width:70%;height:70%}.m_2ce0de02{background-size:cover;background-position:center;display:block;width:100%;border:0;text-decoration:none;border-radius:var(--bi-radius, 0)}.m_347db0ec{--badge-height-xs: calc(1rem * var(--mantine-scale));--badge-height-sm: calc(1.125rem * var(--mantine-scale));--badge-height-md: calc(1.25rem * var(--mantine-scale));--badge-height-lg: calc(1.625rem * var(--mantine-scale));--badge-height-xl: calc(2rem * var(--mantine-scale));--badge-fz-xs: calc(.5625rem * var(--mantine-scale));--badge-fz-sm: calc(.625rem * var(--mantine-scale));--badge-fz-md: calc(.6875rem * var(--mantine-scale));--badge-fz-lg: calc(.8125rem * var(--mantine-scale));--badge-fz-xl: calc(1rem * var(--mantine-scale));--badge-padding-x-xs: calc(.375rem * var(--mantine-scale));--badge-padding-x-sm: calc(.5rem * var(--mantine-scale));--badge-padding-x-md: calc(.625rem * var(--mantine-scale));--badge-padding-x-lg: calc(.75rem * var(--mantine-scale));--badge-padding-x-xl: calc(1rem * var(--mantine-scale));--badge-height: var(--badge-height-md);--badge-fz: var(--badge-fz-md);--badge-padding-x: var(--badge-padding-x-md);--badge-radius: calc(62.5rem * var(--mantine-scale));--badge-lh: calc(var(--badge-height) - calc(.125rem * var(--mantine-scale)));--badge-color: var(--mantine-color-white);--badge-bg: var(--mantine-primary-color-filled);--badge-border-width: calc(.0625rem * var(--mantine-scale));--badge-bd: var(--badge-border-width) solid transparent;-webkit-tap-highlight-color:transparent;font-size:var(--badge-fz);border-radius:var(--badge-radius);height:var(--badge-height);line-height:var(--badge-lh);text-decoration:none;padding:0 var(--badge-padding-x);display:inline-grid;align-items:center;justify-content:center;width:-moz-fit-content;width:fit-content;text-transform:uppercase;font-weight:700;letter-spacing:calc(.015625rem * var(--mantine-scale));cursor:default;text-overflow:ellipsis;overflow:hidden;color:var(--badge-color);background:var(--badge-bg);border:var(--badge-bd)}.m_347db0ec:where([data-with-left-section],[data-variant=dot]){grid-template-columns:auto 1fr}.m_347db0ec:where([data-with-right-section]){grid-template-columns:1fr auto}.m_347db0ec:where([data-with-left-section][data-with-right-section],[data-variant=dot][data-with-right-section]){grid-template-columns:auto 1fr auto}.m_347db0ec:where([data-block]){display:flex;width:100%}.m_347db0ec:where([data-circle]){padding-inline:calc(.125rem * var(--mantine-scale));display:flex;width:var(--badge-height)}.m_fbd81e3d{--badge-dot-size: calc(var(--badge-height) / 3.4)}:where([data-mantine-color-scheme=light]) .m_fbd81e3d{background-color:var(--mantine-color-white);border-color:var(--mantine-color-gray-4);color:var(--mantine-color-black)}:where([data-mantine-color-scheme=dark]) .m_fbd81e3d{background-color:var(--mantine-color-dark-5);border-color:var(--mantine-color-dark-5);color:var(--mantine-color-white)}.m_fbd81e3d:before{content:"";display:block;width:var(--badge-dot-size);height:var(--badge-dot-size);border-radius:var(--badge-dot-size);background-color:var(--badge-dot-color);margin-inline-end:var(--badge-dot-size)}.m_5add502a{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-align:center;cursor:inherit}.m_91fdda9b{--badge-section-margin: calc(var(--mantine-spacing-xs) / 2);display:inline-flex;justify-content:center;align-items:center;max-height:calc(var(--badge-height) - var(--badge-border-width) * 2)}.m_91fdda9b:where([data-position=left]){margin-inline-end:var(--badge-section-margin)}.m_91fdda9b:where([data-position=right]){margin-inline-start:var(--badge-section-margin)}.m_ddec01c0{--blockquote-border: 3px solid var(--bq-bd);position:relative;margin:0;border-inline-start:var(--blockquote-border);border-start-end-radius:var(--bq-radius);border-end-end-radius:var(--bq-radius);padding:var(--mantine-spacing-xl) calc(2.375rem * var(--mantine-scale))}:where([data-mantine-color-scheme=light]) .m_ddec01c0{background-color:var(--bq-bg-light)}:where([data-mantine-color-scheme=dark]) .m_ddec01c0{background-color:var(--bq-bg-dark)}.m_dde7bd57{--blockquote-icon-offset: calc(var(--bq-icon-size) / -2);position:absolute;color:var(--bq-bd);background-color:var(--mantine-color-body);display:flex;align-items:center;justify-content:center;top:var(--blockquote-icon-offset);inset-inline-start:var(--blockquote-icon-offset);width:var(--bq-icon-size);height:var(--bq-icon-size);border-radius:var(--bq-icon-size)}.m_dde51a35{display:block;margin-top:var(--mantine-spacing-md);opacity:.6;font-size:85%}.m_8b3717df{display:flex;align-items:center;flex-wrap:wrap}.m_f678d540{line-height:1;white-space:nowrap;-webkit-tap-highlight-color:transparent}.m_3b8f2208{margin-inline:var(--bc-separator-margin, var(--mantine-spacing-xs));line-height:1;display:flex;align-items:center;justify-content:center}:where([data-mantine-color-scheme=light]) .m_3b8f2208{color:var(--mantine-color-gray-7)}:where([data-mantine-color-scheme=dark]) .m_3b8f2208{color:var(--mantine-color-dark-2)}.m_fea6bf1a{--burger-size-xs: calc(.75rem * var(--mantine-scale));--burger-size-sm: calc(1.125rem * var(--mantine-scale));--burger-size-md: calc(1.5rem * var(--mantine-scale));--burger-size-lg: calc(2.125rem * var(--mantine-scale));--burger-size-xl: calc(2.625rem * var(--mantine-scale));--burger-size: var(--burger-size-md);--burger-line-size: calc(var(--burger-size) / 12);width:calc(var(--burger-size) + var(--mantine-spacing-xs));height:calc(var(--burger-size) + var(--mantine-spacing-xs));padding:calc(var(--mantine-spacing-xs) / 2);cursor:pointer}:where([data-mantine-color-scheme=light]) .m_fea6bf1a{--burger-color: var(--mantine-color-black)}:where([data-mantine-color-scheme=dark]) .m_fea6bf1a{--burger-color: var(--mantine-color-white)}.m_d4fb9cad{position:relative;-webkit-user-select:none;-moz-user-select:none;user-select:none}.m_d4fb9cad,.m_d4fb9cad:before,.m_d4fb9cad:after{display:block;width:var(--burger-size);height:var(--burger-line-size);background-color:var(--burger-color);outline:calc(.0625rem * var(--mantine-scale)) solid transparent;transition-property:background-color,transform;transition-duration:var(--burger-transition-duration, .3s);transition-timing-function:var(--burger-transition-timing-function, ease)}.m_d4fb9cad:before,.m_d4fb9cad:after{position:absolute;content:"";inset-inline-start:0}.m_d4fb9cad:before{top:calc(var(--burger-size) / -3)}.m_d4fb9cad:after{top:calc(var(--burger-size) / 3)}.m_d4fb9cad[data-opened]{background-color:transparent}.m_d4fb9cad[data-opened]:before{transform:translateY(calc(var(--burger-size) / 3)) rotate(45deg)}.m_d4fb9cad[data-opened]:after{transform:translateY(calc(var(--burger-size) / -3)) rotate(-45deg)}.m_77c9d27d{--button-height-xs: calc(1.875rem * var(--mantine-scale));--button-height-sm: calc(2.25rem * var(--mantine-scale));--button-height-md: calc(2.625rem * var(--mantine-scale));--button-height-lg: calc(3.125rem * var(--mantine-scale));--button-height-xl: calc(3.75rem * var(--mantine-scale));--button-height-compact-xs: calc(1.375rem * var(--mantine-scale));--button-height-compact-sm: calc(1.625rem * var(--mantine-scale));--button-height-compact-md: calc(1.875rem * var(--mantine-scale));--button-height-compact-lg: calc(2.125rem * var(--mantine-scale));--button-height-compact-xl: calc(2.5rem * var(--mantine-scale));--button-padding-x-xs: calc(.875rem * var(--mantine-scale));--button-padding-x-sm: calc(1.125rem * var(--mantine-scale));--button-padding-x-md: calc(1.375rem * var(--mantine-scale));--button-padding-x-lg: calc(1.625rem * var(--mantine-scale));--button-padding-x-xl: calc(2rem * var(--mantine-scale));--button-padding-x-compact-xs: calc(.4375rem * var(--mantine-scale));--button-padding-x-compact-sm: calc(.5rem * var(--mantine-scale));--button-padding-x-compact-md: calc(.625rem * var(--mantine-scale));--button-padding-x-compact-lg: calc(.75rem * var(--mantine-scale));--button-padding-x-compact-xl: calc(.875rem * var(--mantine-scale));--button-height: var(--button-height-sm);--button-padding-x: var(--button-padding-x-sm);--button-color: var(--mantine-color-white);-webkit-user-select:none;-moz-user-select:none;user-select:none;font-weight:600;position:relative;line-height:1;text-align:center;overflow:hidden;width:auto;cursor:pointer;display:inline-block;border-radius:var(--button-radius, var(--mantine-radius-default));font-size:var(--button-fz, var(--mantine-font-size-sm));background:var(--button-bg, var(--mantine-primary-color-filled));border:var(--button-bd, calc(.0625rem * var(--mantine-scale)) solid transparent);color:var(--button-color, var(--mantine-color-white));height:var(--button-height, var(--button-height-sm));padding-inline:var(--button-padding-x, var(--button-padding-x-sm));vertical-align:middle}.m_77c9d27d:where([data-block]){display:block;width:100%}.m_77c9d27d:where([data-with-left-section]){padding-inline-start:calc(var(--button-padding-x) / 1.5)}.m_77c9d27d:where([data-with-right-section]){padding-inline-end:calc(var(--button-padding-x) / 1.5)}.m_77c9d27d:where(:disabled:not([data-loading]),[data-disabled]:not([data-loading])){cursor:not-allowed;border:calc(.0625rem * var(--mantine-scale)) solid transparent;transform:none}:where([data-mantine-color-scheme=light]) .m_77c9d27d:where(:disabled:not([data-loading]),[data-disabled]:not([data-loading])){color:var(--mantine-color-gray-5);background:var(--mantine-color-gray-1)}:where([data-mantine-color-scheme=dark]) .m_77c9d27d:where(:disabled:not([data-loading]),[data-disabled]:not([data-loading])){color:var(--mantine-color-dark-3);background:var(--mantine-color-dark-6)}.m_77c9d27d:before{content:"";pointer-events:none;position:absolute;inset:calc(-.0625rem * var(--mantine-scale));border-radius:var(--button-radius, var(--mantine-radius-default));transform:translateY(-100%);opacity:0;filter:blur(12px);transition:transform .15s ease,opacity .1s ease}:where([data-mantine-color-scheme=light]) .m_77c9d27d:before{background-color:#ffffff26}:where([data-mantine-color-scheme=dark]) .m_77c9d27d:before{background-color:#00000026}.m_77c9d27d:where([data-loading]){cursor:not-allowed;transform:none}.m_77c9d27d:where([data-loading]):before{transform:translateY(0);opacity:1}.m_77c9d27d:where([data-loading]) .m_80f1301b{opacity:0;transform:translateY(100%)}@media (hover: hover){.m_77c9d27d:hover:where(:not([data-loading],:disabled,[data-disabled])){background-color:var(--button-hover, var(--mantine-primary-color-filled-hover));color:var(--button-hover-color, var(--button-color))}}@media (hover: none){.m_77c9d27d:active:where(:not([data-loading],:disabled,[data-disabled])){background-color:var(--button-hover, var(--mantine-primary-color-filled-hover));color:var(--button-hover-color, var(--button-color))}}.m_80f1301b{display:flex;align-items:center;justify-content:var(--button-justify, center);height:100%;overflow:visible;transition:transform .15s ease,opacity .1s ease}.m_811560b9{white-space:nowrap;height:100%;overflow:hidden;display:flex;align-items:center;opacity:1}.m_811560b9:where([data-loading]){opacity:.2}.m_a74036a{display:flex;align-items:center}.m_a74036a:where([data-position=left]){margin-inline-end:var(--mantine-spacing-xs)}.m_a74036a:where([data-position=right]){margin-inline-start:var(--mantine-spacing-xs)}.m_a25b86ee{position:absolute;left:50%;top:50%}.m_80d6d844{--button-border-width: calc(.0625rem * var(--mantine-scale));display:flex}.m_80d6d844 :where(.m_77c9d27d):focus{position:relative;z-index:1}.m_80d6d844[data-orientation=horizontal]{flex-direction:row}.m_80d6d844[data-orientation=horizontal] .m_77c9d27d:not(:only-child):first-child{border-end-end-radius:0;border-start-end-radius:0;border-inline-end-width:calc(var(--button-border-width) / 2)}.m_80d6d844[data-orientation=horizontal] .m_77c9d27d:not(:only-child):last-child{border-end-start-radius:0;border-start-start-radius:0;border-inline-start-width:calc(var(--button-border-width) / 2)}.m_80d6d844[data-orientation=horizontal] .m_77c9d27d:not(:only-child):not(:first-child):not(:last-child){border-radius:0;border-inline-width:calc(var(--button-border-width) / 2)}.m_80d6d844[data-orientation=vertical]{flex-direction:column}.m_80d6d844[data-orientation=vertical] .m_77c9d27d:not(:only-child):first-child{border-end-start-radius:0;border-end-end-radius:0;border-bottom-width:calc(var(--button-border-width) / 2)}.m_80d6d844[data-orientation=vertical] .m_77c9d27d:not(:only-child):last-child{border-start-start-radius:0;border-start-end-radius:0;border-top-width:calc(var(--button-border-width) / 2)}.m_80d6d844[data-orientation=vertical] .m_77c9d27d:not(:only-child):not(:first-child):not(:last-child){border-radius:0;border-bottom-width:calc(var(--button-border-width) / 2);border-top-width:calc(var(--button-border-width) / 2)}.m_e615b15f{--card-padding: var(--mantine-spacing-md);position:relative;overflow:hidden;display:flex;flex-direction:column;padding:var(--card-padding);color:var(--mantine-color-text)}:where([data-mantine-color-scheme=light]) .m_e615b15f{background-color:var(--mantine-color-white)}:where([data-mantine-color-scheme=dark]) .m_e615b15f{background-color:var(--mantine-color-dark-6)}.m_599a2148{display:block;margin-inline:calc(var(--card-padding) * -1)}.m_599a2148:where(:first-child){margin-top:calc(var(--card-padding) * -1);border-top:none!important}.m_599a2148:where(:last-child){margin-bottom:calc(var(--card-padding) * -1);border-bottom:none!important}.m_599a2148:where([data-inherit-padding]){padding-inline:var(--card-padding)}.m_599a2148:where([data-with-border]){border-top:calc(.0625rem * var(--mantine-scale)) solid;border-bottom:calc(.0625rem * var(--mantine-scale)) solid}:where([data-mantine-color-scheme=light]) .m_599a2148{border-color:var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_599a2148{border-color:var(--mantine-color-dark-4)}.m_599a2148+.m_599a2148{border-top:none!important}.m_4451eb3a{display:flex;align-items:center;justify-content:center}.m_4451eb3a:where([data-inline]){display:inline-flex}.m_f59ffda3{--chip-size-xs: calc(1.4375rem * var(--mantine-scale));--chip-size-sm: calc(1.75rem * var(--mantine-scale));--chip-size-md: calc(2rem * var(--mantine-scale));--chip-size-lg: calc(2.25rem * var(--mantine-scale));--chip-size-xl: calc(2.5rem * var(--mantine-scale));--chip-icon-size-xs: calc(.625rem * var(--mantine-scale));--chip-icon-size-sm: calc(.75rem * var(--mantine-scale));--chip-icon-size-md: calc(.875rem * var(--mantine-scale));--chip-icon-size-lg: calc(1rem * var(--mantine-scale));--chip-icon-size-xl: calc(1.125rem * var(--mantine-scale));--chip-padding-xs: calc(1rem * var(--mantine-scale));--chip-padding-sm: calc(1.25rem * var(--mantine-scale));--chip-padding-md: calc(1.5rem * var(--mantine-scale));--chip-padding-lg: calc(1.75rem * var(--mantine-scale));--chip-padding-xl: calc(2rem * var(--mantine-scale));--chip-checked-padding-xs: calc(.46875rem * var(--mantine-scale));--chip-checked-padding-sm: calc(.625rem * var(--mantine-scale));--chip-checked-padding-md: calc(.73125rem * var(--mantine-scale));--chip-checked-padding-lg: calc(.84375rem * var(--mantine-scale));--chip-checked-padding-xl: calc(.98125rem * var(--mantine-scale));--chip-spacing-xs: calc(.625rem * var(--mantine-scale));--chip-spacing-sm: calc(.75rem * var(--mantine-scale));--chip-spacing-md: calc(1rem * var(--mantine-scale));--chip-spacing-lg: calc(1.25rem * var(--mantine-scale));--chip-spacing-xl: calc(1.375rem * var(--mantine-scale));--chip-size: var(--chip-size-sm);--chip-icon-size: var(--chip-icon-size-sm);--chip-padding: var(--chip-padding-sm);--chip-spacing: var(--chip-spacing-sm);--chip-checked-padding: var(--chip-checked-padding-sm);--chip-bg: var(--mantine-primary-color-filled);--chip-hover: var(--mantine-primary-color-filled-hover);--chip-color: var(--mantine-color-white);--chip-bd: calc(.0625rem * var(--mantine-scale)) solid transparent}.m_be049a53{display:inline-flex;align-items:center;-webkit-user-select:none;-moz-user-select:none;user-select:none;border-radius:var(--chip-radius, 1000rem);height:var(--chip-size);font-size:var(--chip-fz, var(--mantine-font-size-sm));line-height:calc(var(--chip-size) - calc(.125rem * var(--mantine-scale)));padding-inline:var(--chip-padding);cursor:pointer;white-space:nowrap;-webkit-tap-highlight-color:transparent;border:calc(.0625rem * var(--mantine-scale)) solid transparent;color:var(--mantine-color-text)}.m_be049a53:where([data-checked]){padding:var(--chip-checked-padding)}.m_be049a53:where([data-disabled]){cursor:not-allowed}:where([data-mantine-color-scheme=light]) .m_be049a53:where([data-disabled]){background-color:var(--mantine-color-gray-2);color:var(--mantine-color-gray-5)}:where([data-mantine-color-scheme=dark]) .m_be049a53:where([data-disabled]){background-color:var(--mantine-color-dark-6);color:var(--mantine-color-dark-3)}:where([data-mantine-color-scheme=light]) .m_3904c1af:not([data-disabled]){background-color:var(--mantine-color-white);border:1px solid var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_3904c1af:not([data-disabled]){background-color:var(--mantine-color-dark-6);border:1px solid var(--mantine-color-dark-4)}@media (hover: hover){:where([data-mantine-color-scheme=light]) .m_3904c1af:not([data-disabled]):hover{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_3904c1af:not([data-disabled]):hover{background-color:var(--mantine-color-dark-5)}}@media (hover: none){:where([data-mantine-color-scheme=light]) .m_3904c1af:not([data-disabled]):active{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_3904c1af:not([data-disabled]):active{background-color:var(--mantine-color-dark-5)}}.m_3904c1af:not([data-disabled]):where([data-checked]){--chip-icon-color: var(--chip-color);border:var(--chip-bd)}@media (hover: hover){.m_3904c1af:not([data-disabled]):where([data-checked]):hover{background-color:var(--chip-hover)}}@media (hover: none){.m_3904c1af:not([data-disabled]):where([data-checked]):active{background-color:var(--chip-hover)}}.m_fa109255:not([data-disabled]),.m_f7e165c3:not([data-disabled]){border:calc(.0625rem * var(--mantine-scale)) solid transparent;color:var(--mantine-color-text)}:where([data-mantine-color-scheme=light]) .m_fa109255:not([data-disabled]),:where([data-mantine-color-scheme=light]) .m_f7e165c3:not([data-disabled]){background-color:var(--mantine-color-gray-1)}:where([data-mantine-color-scheme=dark]) .m_fa109255:not([data-disabled]),:where([data-mantine-color-scheme=dark]) .m_f7e165c3:not([data-disabled]){background-color:var(--mantine-color-dark-5)}@media (hover: hover){:where([data-mantine-color-scheme=light]) .m_fa109255:not([data-disabled]):hover,:where([data-mantine-color-scheme=light]) .m_f7e165c3:not([data-disabled]):hover{background-color:var(--mantine-color-gray-2)}:where([data-mantine-color-scheme=dark]) .m_fa109255:not([data-disabled]):hover,:where([data-mantine-color-scheme=dark]) .m_f7e165c3:not([data-disabled]):hover{background-color:var(--mantine-color-dark-4)}}@media (hover: none){:where([data-mantine-color-scheme=light]) .m_fa109255:not([data-disabled]):active,:where([data-mantine-color-scheme=light]) .m_f7e165c3:not([data-disabled]):active{background-color:var(--mantine-color-gray-2)}:where([data-mantine-color-scheme=dark]) .m_fa109255:not([data-disabled]):active,:where([data-mantine-color-scheme=dark]) .m_f7e165c3:not([data-disabled]):active{background-color:var(--mantine-color-dark-4)}}.m_fa109255:not([data-disabled]):where([data-checked]),.m_f7e165c3:not([data-disabled]):where([data-checked]){--chip-icon-color: var(--chip-color);color:var(--chip-color);background-color:var(--chip-bg)}@media (hover: hover){.m_fa109255:not([data-disabled]):where([data-checked]):hover,.m_f7e165c3:not([data-disabled]):where([data-checked]):hover{background-color:var(--chip-hover)}}@media (hover: none){.m_fa109255:not([data-disabled]):where([data-checked]):active,.m_f7e165c3:not([data-disabled]):where([data-checked]):active{background-color:var(--chip-hover)}}.m_9ac86df9{width:calc(var(--chip-icon-size) + (var(--chip-spacing) / 1.5));max-width:calc(var(--chip-icon-size) + (var(--chip-spacing) / 1.5));height:var(--chip-icon-size);display:flex;align-items:center;overflow:hidden}.m_d6d72580{width:var(--chip-icon-size);height:var(--chip-icon-size);display:block;color:var(--chip-icon-color, inherit)}.m_bde07329{width:0;height:0;padding:0;opacity:0;margin:0}.m_bde07329:focus-visible+.m_be049a53{outline:2px solid var(--mantine-primary-color-filled);outline-offset:calc(.125rem * var(--mantine-scale))}.m_b183c0a2{font-family:var(--mantine-font-family-monospace);line-height:var(--mantine-line-height);padding:2px calc(var(--mantine-spacing-xs) / 2);border-radius:var(--mantine-radius-sm);font-size:var(--mantine-font-size-xs);margin:0;overflow:auto}:where([data-mantine-color-scheme=light]) .m_b183c0a2{background-color:var(--code-bg, var(--mantine-color-gray-1));color:var(--mantine-color-black)}:where([data-mantine-color-scheme=dark]) .m_b183c0a2{background-color:var(--code-bg, var(--mantine-color-dark-5));color:var(--mantine-color-white)}.m_b183c0a2[data-block]{padding:var(--mantine-spacing-xs)}.m_de3d2490{--cs-size: calc(1.75rem * var(--mantine-scale));--cs-radius: calc(62.5rem * var(--mantine-scale));-webkit-tap-highlight-color:transparent;border:none;-webkit-appearance:none;-moz-appearance:none;appearance:none;display:block;line-height:1;position:relative;width:var(--cs-size);height:var(--cs-size);min-width:var(--cs-size);min-height:var(--cs-size);border-radius:var(--cs-radius);color:inherit;text-decoration:none}[data-mantine-color-scheme=light] .m_de3d2490{--alpha-overlay-color: var(--mantine-color-gray-3);--alpha-overlay-bg: var(--mantine-color-white)}[data-mantine-color-scheme=dark] .m_de3d2490{--alpha-overlay-color: var(--mantine-color-dark-4);--alpha-overlay-bg: var(--mantine-color-dark-7)}.m_862f3d1b{position:absolute;top:0;right:0;bottom:0;left:0;border-radius:var(--cs-radius)}.m_98ae7f22{position:absolute;top:0;right:0;bottom:0;left:0;border-radius:var(--cs-radius);z-index:1;box-shadow:#0000001a 0 0 0 calc(.0625rem * var(--mantine-scale)) inset,#00000026 0 0 calc(.25rem * var(--mantine-scale)) inset}.m_95709ac0{position:absolute;top:0;right:0;bottom:0;left:0;border-radius:var(--cs-radius);background-size:calc(.5rem * var(--mantine-scale)) calc(.5rem * var(--mantine-scale));background-position:0 0,0 calc(.25rem * var(--mantine-scale)),calc(.25rem * var(--mantine-scale)) calc(-.25rem * var(--mantine-scale)),calc(-.25rem * var(--mantine-scale)) 0;background-image:linear-gradient(45deg,var(--alpha-overlay-color) 25%,transparent 25%),linear-gradient(-45deg,var(--alpha-overlay-color) 25%,transparent 25%),linear-gradient(45deg,transparent 75%,var(--alpha-overlay-color) 75%),linear-gradient(-45deg,var(--alpha-overlay-bg) 75%,var(--alpha-overlay-color) 75%)}.m_93e74e3{position:absolute;top:0;right:0;bottom:0;left:0;border-radius:var(--cs-radius);z-index:2;display:flex;align-items:center;justify-content:center}.m_fee9c77{--cp-width-xs: calc(11.25rem * var(--mantine-scale));--cp-width-sm: calc(12.5rem * var(--mantine-scale));--cp-width-md: calc(15rem * var(--mantine-scale));--cp-width-lg: calc(17.5rem * var(--mantine-scale));--cp-width-xl: calc(20rem * var(--mantine-scale));--cp-preview-size-xs: calc(1.625rem * var(--mantine-scale));--cp-preview-size-sm: calc(2.125rem * var(--mantine-scale));--cp-preview-size-md: calc(2.625rem * var(--mantine-scale));--cp-preview-size-lg: calc(3.125rem * var(--mantine-scale));--cp-preview-size-xl: calc(3.375rem * var(--mantine-scale));--cp-thumb-size-xs: calc(.5rem * var(--mantine-scale));--cp-thumb-size-sm: calc(.75rem * var(--mantine-scale));--cp-thumb-size-md: calc(1rem * var(--mantine-scale));--cp-thumb-size-lg: calc(1.25rem * var(--mantine-scale));--cp-thumb-size-xl: calc(1.375rem * var(--mantine-scale));--cp-saturation-height-xs: calc(6.25rem * var(--mantine-scale));--cp-saturation-height-sm: calc(6.875rem * var(--mantine-scale));--cp-saturation-height-md: calc(7.5rem * var(--mantine-scale));--cp-saturation-height-lg: calc(8.75rem * var(--mantine-scale));--cp-saturation-height-xl: calc(10rem * var(--mantine-scale));--cp-preview-size: var(--cp-preview-size-sm);--cp-thumb-size: var(--cp-thumb-size-sm);--cp-saturation-height: var(--cp-saturation-height-sm);--cp-width: var(--cp-width-sm);--cp-body-spacing: var(--mantine-spacing-sm);width:var(--cp-width);padding:calc(.0625rem * var(--mantine-scale))}.m_fee9c77:where([data-full-width]){width:100%}.m_9dddfbac{width:var(--cp-preview-size);height:var(--cp-preview-size)}.m_bffecc3e{display:flex;padding-top:calc(var(--cp-body-spacing) / 2)}.m_3283bb96{flex:1}.m_3283bb96:not(:only-child){margin-inline-end:var(--mantine-spacing-xs)}.m_40d572ba{overflow:hidden;position:absolute;box-shadow:0 0 1px #0009;border:2px solid var(--mantine-color-white);width:var(--cp-thumb-size);height:var(--cp-thumb-size);border-radius:var(--cp-thumb-size);left:calc(var(--thumb-x-offset) - var(--cp-thumb-size) / 2);top:calc(var(--thumb-y-offset) - var(--cp-thumb-size) / 2)}.m_d8ee6fd8{height:unset!important;width:unset!important;min-width:0!important;min-height:0!important;margin:calc(.125rem * var(--mantine-scale));cursor:pointer;padding-bottom:calc(var(--cp-swatch-size) - calc(.25rem * var(--mantine-scale)));flex:0 0 calc(var(--cp-swatch-size) - calc(.25rem * var(--mantine-scale)))}.m_5711e686{margin-top:calc(.3125rem * var(--mantine-scale));margin-inline:calc(-.125rem * var(--mantine-scale));display:flex;flex-wrap:wrap}.m_202a296e{--cp-thumb-size-xs: calc(.5rem * var(--mantine-scale));--cp-thumb-size-sm: calc(.75rem * var(--mantine-scale));--cp-thumb-size-md: calc(1rem * var(--mantine-scale));--cp-thumb-size-lg: calc(1.25rem * var(--mantine-scale));--cp-thumb-size-xl: calc(1.375rem * var(--mantine-scale));-webkit-tap-highlight-color:transparent;position:relative;height:var(--cp-saturation-height);border-radius:var(--mantine-radius-sm);margin:calc(var(--cp-thumb-size) / 2)}.m_202a296e:where([data-focus-ring=auto]):focus:focus-visible .m_40d572ba{outline:2px solid var(--mantine-color-blue-filled)}.m_202a296e:where([data-focus-ring=always]):focus .m_40d572ba{outline:2px solid var(--mantine-color-blue-filled)}.m_11b3db02{position:absolute;border-radius:var(--mantine-radius-sm);inset:calc(var(--cp-thumb-size) * -1 / 2 - calc(.0625rem * var(--mantine-scale)))}.m_d856d47d{--cp-thumb-size-xs: calc(.5rem * var(--mantine-scale));--cp-thumb-size-sm: calc(.75rem * var(--mantine-scale));--cp-thumb-size-md: calc(1rem * var(--mantine-scale));--cp-thumb-size-lg: calc(1.25rem * var(--mantine-scale));--cp-thumb-size-xl: calc(1.375rem * var(--mantine-scale));--cp-thumb-size: var(--cp-thumb-size, calc(.75rem * var(--mantine-scale)));position:relative;height:calc(var(--cp-thumb-size) + calc(.125rem * var(--mantine-scale)));margin-inline:calc(var(--cp-thumb-size) / 2);outline:none}.m_d856d47d+.m_d856d47d{margin-top:calc(.375rem * var(--mantine-scale))}.m_d856d47d:where([data-focus-ring=auto]):focus:focus-visible .m_40d572ba{outline:2px solid var(--mantine-color-blue-filled)}.m_d856d47d:where([data-focus-ring=always]):focus .m_40d572ba{outline:2px solid var(--mantine-color-blue-filled)}:where([data-mantine-color-scheme=light]) .m_d856d47d{--slider-checkers: var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_d856d47d{--slider-checkers: var(--mantine-color-dark-4)}.m_8f327113{position:absolute;top:0;bottom:0;inset-inline:calc(var(--cp-thumb-size) * -1 / 2 - calc(.0625rem * var(--mantine-scale)));border-radius:10000rem}.m_b077c2bc{--ci-eye-dropper-icon-size-xs: calc(.875rem * var(--mantine-scale));--ci-eye-dropper-icon-size-sm: calc(1rem * var(--mantine-scale));--ci-eye-dropper-icon-size-md: calc(1.125rem * var(--mantine-scale));--ci-eye-dropper-icon-size-lg: calc(1.25rem * var(--mantine-scale));--ci-eye-dropper-icon-size-xl: calc(1.375rem * var(--mantine-scale));--ci-eye-dropper-icon-size: var(--ci-eye-dropper-icon-size-sm)}.m_c5ccdcab{--ci-preview-size-xs: calc(1rem * var(--mantine-scale));--ci-preview-size-sm: calc(1.125rem * var(--mantine-scale));--ci-preview-size-md: calc(1.375rem * var(--mantine-scale));--ci-preview-size-lg: calc(1.75rem * var(--mantine-scale));--ci-preview-size-xl: calc(2.25rem * var(--mantine-scale));--ci-preview-size: var(--ci-preview-size-sm)}.m_5ece2cd7{padding:calc(.5rem * var(--mantine-scale))}.m_7485cace{--container-size-xs: calc(33.75rem * var(--mantine-scale));--container-size-sm: calc(45rem * var(--mantine-scale));--container-size-md: calc(60rem * var(--mantine-scale));--container-size-lg: calc(71.25rem * var(--mantine-scale));--container-size-xl: calc(82.5rem * var(--mantine-scale));--container-size: var(--container-size-md);max-width:var(--container-size);padding-inline:var(--mantine-spacing-md);margin-inline:auto}.m_7485cace:where([data-fluid]){max-width:100%}.m_e2125a27{--dialog-size-xs: calc(10rem * var(--mantine-scale));--dialog-size-sm: calc(12.5rem * var(--mantine-scale));--dialog-size-md: calc(21.25rem * var(--mantine-scale));--dialog-size-lg: calc(25rem * var(--mantine-scale));--dialog-size-xl: calc(31.25rem * var(--mantine-scale));--dialog-size: var(--dialog-size-md);position:relative;width:var(--dialog-size);max-width:calc(100vw - var(--mantine-spacing-xl) * 2);min-height:calc(3.125rem * var(--mantine-scale))}.m_5abab665{position:absolute;top:calc(var(--mantine-spacing-md) / 2);inset-inline-end:calc(var(--mantine-spacing-md) / 2)}.m_3eebeb36{--divider-size-xs: calc(.0625rem * var(--mantine-scale));--divider-size-sm: calc(.125rem * var(--mantine-scale));--divider-size-md: calc(.1875rem * var(--mantine-scale));--divider-size-lg: calc(.25rem * var(--mantine-scale));--divider-size-xl: calc(.3125rem * var(--mantine-scale));--divider-size: var(--divider-size-xs)}:where([data-mantine-color-scheme=light]) .m_3eebeb36{--divider-color: var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_3eebeb36{--divider-color: var(--mantine-color-dark-4)}.m_3eebeb36:where([data-orientation=horizontal]){border-top:var(--divider-size) var(--divider-border-style, solid) var(--divider-color)}.m_3eebeb36:where([data-orientation=vertical]){border-inline-start:var(--divider-size) var(--divider-border-style, solid) var(--divider-color);height:auto;align-self:stretch}.m_3eebeb36:where([data-with-label]){border:0}.m_9e365f20{display:flex;align-items:center;font-size:var(--mantine-font-size-xs);color:var(--mantine-color-dimmed);white-space:nowrap}.m_9e365f20:where([data-position=left]):before{display:none}.m_9e365f20:where([data-position=right]):after{display:none}.m_9e365f20:before{content:"";flex:1;height:calc(.0625rem * var(--mantine-scale));border-top:var(--divider-size) var(--divider-border-style, solid) var(--divider-color);margin-inline-end:var(--mantine-spacing-xs)}.m_9e365f20:after{content:"";flex:1;height:calc(.0625rem * var(--mantine-scale));border-top:var(--divider-size) var(--divider-border-style, solid) var(--divider-color);margin-inline-start:var(--mantine-spacing-xs)}.m_f11b401e{--drawer-size-xs: calc(20rem * var(--mantine-scale));--drawer-size-sm: calc(23.75rem * var(--mantine-scale));--drawer-size-md: calc(27.5rem * var(--mantine-scale));--drawer-size-lg: calc(38.75rem * var(--mantine-scale));--drawer-size-xl: calc(48.75rem * var(--mantine-scale));--drawer-size: var(--drawer-size-md);--drawer-offset: 0rem}.m_5a7c2c9{z-index:1000}.m_b8a05bbd{flex:var(--drawer-flex, 0 0 var(--drawer-size));height:var(--drawer-height, calc(100% - var(--drawer-offset) * 2));margin:var(--drawer-offset);max-width:calc(100% - var(--drawer-offset) * 2);max-height:calc(100% - var(--drawer-offset) * 2);overflow-y:auto}.m_b8a05bbd[data-hidden]{opacity:0!important;pointer-events:none}.m_31cd769a{display:flex;justify-content:var(--drawer-justify, flex-start);align-items:var(--drawer-align, flex-start)}.m_e9408a47{padding:var(--mantine-spacing-lg);padding-top:var(--mantine-spacing-xs);border-radius:var(--fieldset-radius, var(--mantine-radius-default));min-inline-size:auto}.m_84c9523a{border:calc(.0625rem * var(--mantine-scale)) solid}:where([data-mantine-color-scheme=light]) .m_84c9523a{border-color:var(--mantine-color-gray-3);background-color:var(--mantine-color-white)}:where([data-mantine-color-scheme=dark]) .m_84c9523a{border-color:var(--mantine-color-dark-4);background-color:var(--mantine-color-dark-7)}.m_ef274e49{border:calc(.0625rem * var(--mantine-scale)) solid}:where([data-mantine-color-scheme=light]) .m_ef274e49{border-color:var(--mantine-color-gray-3);background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_ef274e49{border-color:var(--mantine-color-dark-4);background-color:var(--mantine-color-dark-6)}.m_eda993d3{padding:0;border:0;border-radius:0}.m_90794832{font-size:var(--mantine-font-size-sm)}.m_74ca27fe{padding:0;margin-bottom:var(--mantine-spacing-sm)}.m_8478a6da{container:mantine-grid / inline-size}.m_410352e9{--grid-overflow: visible;--grid-margin: calc(var(--grid-gutter) / -2);--grid-col-padding: calc(var(--grid-gutter) / 2);overflow:var(--grid-overflow)}.m_dee7bd2f{width:calc(100% + var(--grid-gutter));display:flex;flex-wrap:wrap;justify-content:var(--grid-justify);align-items:var(--grid-align);margin:var(--grid-margin)}.m_96bdd299{--col-flex-grow: 0;--col-offset: 0rem;flex-shrink:0;order:var(--col-order);flex-basis:var(--col-flex-basis);width:var(--col-width);max-width:var(--col-max-width);flex-grow:var(--col-flex-grow);margin-inline-start:var(--col-offset);padding:var(--grid-col-padding)}.m_bcb3f3c2{color:var(--mantine-color-black)}:where([data-mantine-color-scheme=light]) .m_bcb3f3c2{background-color:var(--mark-bg-light)}:where([data-mantine-color-scheme=dark]) .m_bcb3f3c2{background-color:var(--mark-bg-dark)}.m_9e117634{display:block;flex:0;-o-object-fit:var(--image-object-fit, cover);object-fit:var(--image-object-fit, cover);width:100%;border-radius:var(--image-radius, 0)}@keyframes m_885901b1{0%{opacity:.6;transform:scale(0)}to{opacity:0;transform:scale(2.8)}}.m_e5262200{--indicator-size: calc(.625rem * var(--mantine-scale));--indicator-color: var(--mantine-primary-color-filled);position:relative;display:block}.m_e5262200:where([data-inline]){display:inline-block}.m_760d1fb1{position:absolute;top:var(--indicator-top);left:var(--indicator-left);right:var(--indicator-right);bottom:var(--indicator-bottom);transform:translate(var(--indicator-translate-x),var(--indicator-translate-y));min-width:var(--indicator-size);height:var(--indicator-size);border-radius:var(--indicator-radius, 1000rem);z-index:var(--indicator-z-index, 200);display:flex;align-items:center;justify-content:center;font-size:var(--mantine-font-size-xs);background-color:var(--indicator-color);color:var(--indicator-text-color, var(--mantine-color-white));white-space:nowrap}.m_760d1fb1:before{content:"";position:absolute;top:0;right:0;bottom:0;left:0;background-color:var(--indicator-color);border-radius:var(--indicator-radius, 1000rem);z-index:-1}.m_760d1fb1:where([data-with-label]){padding-inline:calc(var(--mantine-spacing-xs) / 2)}.m_760d1fb1:where([data-with-border]){border:2px solid var(--mantine-color-body)}.m_760d1fb1[data-processing]:before{animation:m_885901b1 1s linear infinite}.m_dc6f14e2{--kbd-fz-xs: calc(.625rem * var(--mantine-scale));--kbd-fz-sm: calc(.75rem * var(--mantine-scale));--kbd-fz-md: calc(.875rem * var(--mantine-scale));--kbd-fz-lg: calc(1rem * var(--mantine-scale));--kbd-fz-xl: calc(1.25rem * var(--mantine-scale));--kbd-fz: var(--kbd-fz-sm);--kbd-padding-xs: calc(.125rem * var(--mantine-scale)) calc(.25rem * var(--mantine-scale));--kbd-padding-sm: calc(.1875rem * var(--mantine-scale)) calc(.3125rem * var(--mantine-scale));--kbd-padding-md: calc(.25rem * var(--mantine-scale)) calc(.4375rem * var(--mantine-scale));--kbd-padding-lg: calc(.3125rem * var(--mantine-scale)) calc(.5625rem * var(--mantine-scale));--kbd-padding-xl: calc(.5rem * var(--mantine-scale)) calc(.875rem * var(--mantine-scale));--kbd-padding: var(--kbd-padding-sm);font-family:var(--mantine-font-family-monospace);line-height:var(--mantine-line-height);font-weight:700;padding:var(--kbd-padding);font-size:var(--kbd-fz);border-radius:var(--mantine-radius-sm);border:calc(.0625rem * var(--mantine-scale)) solid;border-bottom-width:calc(.1875rem * var(--mantine-scale));unicode-bidi:embed}:where([data-mantine-color-scheme=light]) .m_dc6f14e2{border-color:var(--mantine-color-gray-3);color:var(--mantine-color-gray-7);background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_dc6f14e2{border-color:var(--mantine-color-dark-4);color:var(--mantine-color-dark-0);background-color:var(--mantine-color-dark-6)}.m_abbac491{--list-fz: var(--mantine-font-size-md);--list-lh: var(--mantine-line-height-md);list-style-position:inside;font-size:var(--list-fz);line-height:var(--list-lh);margin:0;padding:0}.m_abbac491:where([data-with-padding]){padding-inline-start:var(--mantine-spacing-md)}.m_abb6bec2{white-space:nowrap;line-height:var(--list-lh)}.m_abb6bec2:where([data-with-icon]){list-style:none}.m_abb6bec2:where([data-with-icon]) .m_75cd9f71{--li-direction: row;--li-align: center}.m_abb6bec2:where(:not(:first-of-type)){margin-top:var(--list-spacing, 0)}.m_abb6bec2:where([data-centered]){line-height:1}.m_75cd9f71{display:inline-flex;flex-direction:var(--li-direction, column);align-items:var(--li-align, flex-start);white-space:normal}.m_60f83e5b{display:inline-block;vertical-align:middle;margin-inline-end:var(--mantine-spacing-sm)}.m_6e45937b{position:absolute;top:0;right:0;bottom:0;left:0;display:flex;align-items:center;justify-content:center;overflow:hidden;z-index:var(--lo-z-index)}.m_e8eb006c{position:relative;z-index:calc(var(--lo-z-index) + 1)}.m_df587f17{z-index:var(--lo-z-index)}.m_dc9b7c9f{padding:calc(.25rem * var(--mantine-scale))}.m_9bfac126{color:var(--mantine-color-dimmed);font-weight:500;font-size:var(--mantine-font-size-xs);padding:calc(var(--mantine-spacing-xs) / 2) var(--mantine-spacing-sm);cursor:default}.m_efdf90cb{margin-top:calc(.25rem * var(--mantine-scale));margin-bottom:calc(.25rem * var(--mantine-scale));border-top:calc(.0625rem * var(--mantine-scale)) solid}:where([data-mantine-color-scheme=light]) .m_efdf90cb{border-color:var(--mantine-color-gray-2)}:where([data-mantine-color-scheme=dark]) .m_efdf90cb{border-color:var(--mantine-color-dark-4)}.m_99ac2aa1{font-size:var(--mantine-font-size-sm);width:100%;padding:calc(var(--mantine-spacing-xs) / 1.5) var(--mantine-spacing-sm);border-radius:var(--popover-radius, var(--mantine-radius-default));color:var(--menu-item-color, var(--mantine-color-text));display:flex;align-items:center;-webkit-user-select:none;-moz-user-select:none;user-select:none}.m_99ac2aa1:where([data-disabled],:disabled){color:var(--mantine-color-dimmed);opacity:.6;pointer-events:none}:where([data-mantine-color-scheme=light]) .m_99ac2aa1:where([data-hovered]){background-color:var(--menu-item-hover, var(--mantine-color-gray-1))}:where([data-mantine-color-scheme=dark]) .m_99ac2aa1:where([data-hovered]){background-color:var(--menu-item-hover, var(--mantine-color-dark-4))}.m_5476e0d3{flex:1}.m_8b75e504{display:flex;justify-content:center;align-items:center}.m_8b75e504:where([data-position=left]){margin-inline-end:var(--mantine-spacing-xs)}.m_8b75e504:where([data-position=right]){margin-inline-start:var(--mantine-spacing-xs)}.m_9df02822{--modal-size-xs: calc(20rem * var(--mantine-scale));--modal-size-sm: calc(23.75rem * var(--mantine-scale));--modal-size-md: calc(27.5rem * var(--mantine-scale));--modal-size-lg: calc(38.75rem * var(--mantine-scale));--modal-size-xl: calc(48.75rem * var(--mantine-scale));--modal-size: var(--modal-size-md);--modal-y-offset: 5dvh;--modal-x-offset: 5vw}.m_9df02822[data-full-screen]{--modal-border-radius: 0 !important}.m_9df02822[data-full-screen] .m_54c44539{--modal-content-flex: 0 0 100%;--modal-content-max-height: auto;--modal-content-height: 100dvh}.m_9df02822[data-full-screen] .m_1f958f16{--modal-inner-y-offset: 0;--modal-inner-x-offset: 0}.m_9df02822[data-centered] .m_1f958f16{--modal-inner-align: center}.m_d0e2b9cd{border-start-start-radius:var(--modal-radius, var(--mantine-radius-default));border-start-end-radius:var(--modal-radius, var(--mantine-radius-default))}.m_54c44539{flex:var(--modal-content-flex, 0 0 var(--modal-size));max-width:100%;max-height:var(--modal-content-max-height, calc(100dvh - var(--modal-y-offset) * 2));height:var(--modal-content-height, auto);overflow-y:auto}.m_54c44539[data-full-screen]{border-radius:0}.m_54c44539[data-hidden]{opacity:0!important;pointer-events:none}.m_1f958f16{display:flex;justify-content:center;align-items:var(--modal-inner-align, flex-start);padding-top:var(--modal-inner-y-offset, var(--modal-y-offset));padding-bottom:var(--modal-inner-y-offset, var(--modal-y-offset));padding-inline:var(--modal-inner-x-offset, var(--modal-x-offset))}.m_7cda1cd6{--pill-fz-xs: calc(.625rem * var(--mantine-scale));--pill-fz-sm: calc(.75rem * var(--mantine-scale));--pill-fz-md: calc(.875rem * var(--mantine-scale));--pill-fz-lg: calc(1rem * var(--mantine-scale));--pill-fz-xl: calc(1.125rem * var(--mantine-scale));--pill-height-xs: calc(1.125rem * var(--mantine-scale));--pill-height-sm: calc(1.375rem * var(--mantine-scale));--pill-height-md: calc(1.5625rem * var(--mantine-scale));--pill-height-lg: calc(1.75rem * var(--mantine-scale));--pill-height-xl: calc(2rem * var(--mantine-scale));--pill-fz: var(--pill-fz-sm);--pill-height: var(--pill-height-sm);font-size:var(--pill-fz);flex:0;height:var(--pill-height);padding-inline:.8em;display:inline-flex;align-items:center;border-radius:var(--pill-radius, 1000rem);line-height:1;white-space:nowrap;-moz-user-select:none;user-select:none;-webkit-user-select:none;max-width:100%}:where([data-mantine-color-scheme=dark]) .m_7cda1cd6{background-color:var(--mantine-color-dark-7);color:var(--mantine-color-dark-0)}:where([data-mantine-color-scheme=light]) .m_7cda1cd6{color:var(--mantine-color-black)}.m_7cda1cd6:where([data-with-remove]:not(:has(button:disabled))){padding-inline-end:0}.m_7cda1cd6:where([data-disabled],:has(button:disabled)){cursor:not-allowed}:where([data-mantine-color-scheme=light]) .m_44da308b{background-color:var(--mantine-color-gray-1)}:where([data-mantine-color-scheme=light]) .m_44da308b:where([data-disabled],:has(button:disabled)){background-color:var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=light]) .m_e3a01f8{background-color:var(--mantine-color-white)}:where([data-mantine-color-scheme=light]) .m_e3a01f8:where([data-disabled],:has(button:disabled)){background-color:var(--mantine-color-gray-3)}.m_1e0e6180{cursor:inherit;overflow:hidden;height:100%;line-height:var(--pill-height);text-overflow:ellipsis}.m_ae386778{color:inherit;font-size:inherit;height:100%;min-height:unset;min-width:2em;width:unset;border-radius:0;padding-inline-start:.1em;padding-inline-end:.3em;flex:0;border-end-end-radius:var(--pill-radius, 50%);border-start-end-radius:var(--pill-radius, 50%)}.m_7cda1cd6[data-disabled]>.m_ae386778,.m_ae386778:disabled{display:none;background-color:transparent;width:.8em;min-width:.8em;padding:0;cursor:not-allowed}.m_7cda1cd6[data-disabled]>.m_ae386778>svg,.m_ae386778:disabled>svg{display:none}.m_ae386778>svg{pointer-events:none}.m_1dcfd90b{--pg-gap-xs: calc(.375rem * var(--mantine-scale));--pg-gap-sm: calc(.5rem * var(--mantine-scale));--pg-gap-md: calc(.625rem * var(--mantine-scale));--pg-gap-lg: calc(.75rem * var(--mantine-scale));--pg-gap-xl: calc(.75rem * var(--mantine-scale));--pg-gap: var(--pg-gap-sm);display:flex;align-items:center;gap:var(--pg-gap);flex-wrap:wrap}.m_45c4369d{background-color:transparent;-webkit-appearance:none;-moz-appearance:none;appearance:none;min-width:calc(6.25rem * var(--mantine-scale));flex:1;border:0;font-size:inherit;height:1.6em;color:inherit;padding:0}.m_45c4369d::-moz-placeholder{color:var(--input-placeholder-color);opacity:1}.m_45c4369d::placeholder{color:var(--input-placeholder-color);opacity:1}.m_45c4369d:where([data-type=hidden],[data-type=auto]){height:calc(.0625rem * var(--mantine-scale));width:calc(.0625rem * var(--mantine-scale));top:0;left:0;pointer-events:none;position:absolute;opacity:0}.m_45c4369d:focus{outline:none}.m_45c4369d:where([data-type=auto]:focus){height:1.6em;visibility:visible;opacity:1;position:static}.m_45c4369d:where([data-pointer]:not([data-disabled],:disabled)){cursor:pointer}.m_45c4369d:where([data-disabled],:disabled){cursor:not-allowed}.m_f0824112{--nl-bg: var(--mantine-primary-color-light);--nl-hover: var(--mantine-primary-color-light-hover);--nl-color: var(--mantine-primary-color-light-color);display:flex;align-items:center;width:100%;padding:8px var(--mantine-spacing-sm);-webkit-user-select:none;-moz-user-select:none;user-select:none}@media (hover: hover){:where([data-mantine-color-scheme=light]) .m_f0824112:hover{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_f0824112:hover{background-color:var(--mantine-color-dark-6)}}@media (hover: none){:where([data-mantine-color-scheme=light]) .m_f0824112:active{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_f0824112:active{background-color:var(--mantine-color-dark-6)}}.m_f0824112:where([data-disabled]){opacity:.4;pointer-events:none}.m_f0824112:where([data-active],[aria-current=page]){background-color:var(--nl-bg);color:var(--nl-color)}@media (hover: hover){.m_f0824112:where([data-active],[aria-current=page]):hover{background-color:var(--nl-hover)}}@media (hover: none){.m_f0824112:where([data-active],[aria-current=page]):active{background-color:var(--nl-hover)}}.m_f0824112:where([data-active],[aria-current=page]) .m_57492dcc{--description-opacity: .9;--description-color: var(--nl-color)}.m_690090b5{display:flex;align-items:center;justify-content:center;transition:transform .15s ease}.m_690090b5>svg{display:block}.m_690090b5:where([data-position=left]){margin-inline-end:var(--mantine-spacing-sm)}.m_690090b5:where([data-position=right]){margin-inline-start:var(--mantine-spacing-sm)}.m_690090b5:where([data-rotate]){transform:rotate(90deg)}.m_1f6ac4c4{font-size:var(--mantine-font-size-sm)}.m_f07af9d2{flex:1;overflow:hidden;text-overflow:ellipsis}.m_f07af9d2:where([data-no-wrap]){white-space:nowrap}.m_57492dcc{display:block;font-size:var(--mantine-font-size-xs);opacity:var(--description-opacity, 1);color:var(--description-color, var(--mantine-color-dimmed));overflow:hidden;text-overflow:ellipsis}:where([data-no-wrap]) .m_57492dcc{white-space:nowrap}.m_e17b862f{padding-inline-start:var(--nl-offset, var(--mantine-spacing-lg))}.m_1fd8a00b{transform:rotate(-90deg)}.m_a513464{--notification-radius: var(--mantine-radius-default);--notification-color: var(--mantine-primary-color-filled);overflow:hidden;box-sizing:border-box;position:relative;display:flex;align-items:center;padding-inline-start:calc(1.375rem * var(--mantine-scale));padding-inline-end:var(--mantine-spacing-xs);padding-top:var(--mantine-spacing-xs);padding-bottom:var(--mantine-spacing-xs);border-radius:var(--notification-radius);box-shadow:var(--mantine-shadow-lg)}.m_a513464:before{content:"";display:block;position:absolute;width:calc(.375rem * var(--mantine-scale));top:var(--notification-radius);bottom:var(--notification-radius);inset-inline-start:calc(.25rem * var(--mantine-scale));border-radius:var(--notification-radius);background-color:var(--notification-color)}:where([data-mantine-color-scheme=light]) .m_a513464{background-color:var(--mantine-color-white)}:where([data-mantine-color-scheme=dark]) .m_a513464{background-color:var(--mantine-color-dark-6)}.m_a513464:where([data-with-icon]){padding-inline-start:var(--mantine-spacing-xs)}.m_a513464:where([data-with-icon]):before{display:none}:where([data-mantine-color-scheme=light]) .m_a513464:where([data-with-border]){border:1px solid var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_a513464:where([data-with-border]){border:1px solid var(--mantine-color-dark-4)}.m_a4ceffb{box-sizing:border-box;margin-inline-end:var(--mantine-spacing-md);width:calc(1.75rem * var(--mantine-scale));height:calc(1.75rem * var(--mantine-scale));border-radius:calc(1.75rem * var(--mantine-scale));display:flex;align-items:center;justify-content:center;background-color:var(--notification-color);color:var(--mantine-color-white)}.m_b0920b15{margin-inline-end:var(--mantine-spacing-md)}.m_a49ed24{flex:1;overflow:hidden;margin-inline-end:var(--mantine-spacing-xs)}.m_3feedf16{margin-bottom:calc(.125rem * var(--mantine-scale));overflow:hidden;text-overflow:ellipsis;font-size:var(--mantine-font-size-sm);line-height:var(--mantine-line-height-sm);font-weight:500}:where([data-mantine-color-scheme=light]) .m_3feedf16{color:var(--mantine-color-gray-9)}:where([data-mantine-color-scheme=dark]) .m_3feedf16{color:var(--mantine-color-white)}.m_3d733a3a{font-size:var(--mantine-font-size-sm);line-height:var(--mantine-line-height-sm);overflow:hidden;text-overflow:ellipsis}:where([data-mantine-color-scheme=light]) .m_3d733a3a{color:var(--mantine-color-black)}:where([data-mantine-color-scheme=dark]) .m_3d733a3a{color:var(--mantine-color-dark-0)}:where([data-mantine-color-scheme=light]) .m_3d733a3a:where([data-with-title]){color:var(--mantine-color-gray-6)}:where([data-mantine-color-scheme=dark]) .m_3d733a3a:where([data-with-title]){color:var(--mantine-color-dark-2)}@media (hover: hover){:where([data-mantine-color-scheme=light]) .m_919a4d88:hover{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_919a4d88:hover{background-color:var(--mantine-color-dark-8)}}@media (hover: none){:where([data-mantine-color-scheme=light]) .m_919a4d88:active{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_919a4d88:active{background-color:var(--mantine-color-dark-8)}}.m_e2f5cd4e{--ni-right-section-width-xs: calc(1.0625rem * var(--mantine-scale));--ni-right-section-width-sm: calc(1.5rem * var(--mantine-scale));--ni-right-section-width-md: calc(1.6875rem * var(--mantine-scale));--ni-right-section-width-lg: calc(1.9375rem * var(--mantine-scale));--ni-right-section-width-xl: calc(2.125rem * var(--mantine-scale))}.m_95e17d22{--ni-chevron-size-xs: calc(.625rem * var(--mantine-scale));--ni-chevron-size-sm: calc(.875rem * var(--mantine-scale));--ni-chevron-size-md: calc(1rem * var(--mantine-scale));--ni-chevron-size-lg: calc(1.125rem * var(--mantine-scale));--ni-chevron-size-xl: calc(1.25rem * var(--mantine-scale));--ni-chevron-size: var(--ni-chevron-size-sm);display:flex;flex-direction:column;width:100%;height:calc(var(--input-height) - calc(.125rem * var(--mantine-scale)));max-width:calc(var(--ni-chevron-size) * 1.7);margin-inline-start:auto}.m_80b4b171{--control-border: 1px solid var(--input-bd);--control-radius: calc(var(--input-radius) - calc(.0625rem * var(--mantine-scale)));flex:0 0 50%;width:100%;padding:0;height:calc(var(--input-height) / 2 - calc(.0625rem * var(--mantine-scale)));border-inline-start:var(--control-border);display:flex;align-items:center;justify-content:center;color:var(--mantine-color-text);background-color:transparent;cursor:pointer}.m_80b4b171:where(:disabled){background-color:transparent;cursor:not-allowed;opacity:.6}:where([data-mantine-color-scheme=light]) .m_80b4b171:where(:disabled){color:var(--mantine-color-gray-4)}:where([data-mantine-color-scheme=dark]) .m_80b4b171:where(:disabled){color:var(--mantine-color-dark-3)}.m_e2f5cd4e[data-error] :where(.m_80b4b171){color:var(--mantine-color-error)}@media (hover: hover){:where([data-mantine-color-scheme=light]) .m_80b4b171:hover{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_80b4b171:hover{background-color:var(--mantine-color-dark-4)}}@media (hover: none){:where([data-mantine-color-scheme=light]) .m_80b4b171:active{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_80b4b171:active{background-color:var(--mantine-color-dark-4)}}.m_80b4b171:where(:first-of-type){border-radius:0;border-start-end-radius:var(--control-radius)}.m_80b4b171:last-of-type{border-radius:0;border-end-end-radius:var(--control-radius)}.m_4addd315{--pagination-control-size-xs: calc(1.375rem * var(--mantine-scale));--pagination-control-size-sm: calc(1.625rem * var(--mantine-scale));--pagination-control-size-md: calc(2rem * var(--mantine-scale));--pagination-control-size-lg: calc(2.375rem * var(--mantine-scale));--pagination-control-size-xl: calc(2.75rem * var(--mantine-scale));--pagination-control-size: var(--pagination-control-size-md);--pagination-control-fz: var(--mantine-font-size-md);--pagination-active-bg: var(--mantine-primary-color-filled)}.m_326d024a{display:flex;align-items:center;justify-content:center;border:calc(.0625rem * var(--mantine-scale)) solid;cursor:pointer;color:var(--mantine-color-text);height:var(--pagination-control-size);min-width:var(--pagination-control-size);font-size:var(--pagination-control-fz);line-height:1;border-radius:var(--pagination-control-radius, var(--mantine-radius-default))}.m_326d024a:where([data-with-padding]){padding:calc(var(--pagination-control-size) / 4)}.m_326d024a:where(:disabled,[data-disabled]){cursor:not-allowed;opacity:.4}:where([data-mantine-color-scheme=light]) .m_326d024a{border-color:var(--mantine-color-gray-4);background-color:var(--mantine-color-white)}@media (hover: hover){:where([data-mantine-color-scheme=light]) .m_326d024a:hover:where(:not(:disabled,[data-disabled])){background-color:var(--mantine-color-gray-0)}}@media (hover: none){:where([data-mantine-color-scheme=light]) .m_326d024a:active:where(:not(:disabled,[data-disabled])){background-color:var(--mantine-color-gray-0)}}:where([data-mantine-color-scheme=dark]) .m_326d024a{border-color:var(--mantine-color-dark-4);background-color:var(--mantine-color-dark-6)}@media (hover: hover){:where([data-mantine-color-scheme=dark]) .m_326d024a:hover:where(:not(:disabled,[data-disabled])){background-color:var(--mantine-color-dark-5)}}@media (hover: none){:where([data-mantine-color-scheme=dark]) .m_326d024a:active:where(:not(:disabled,[data-disabled])){background-color:var(--mantine-color-dark-5)}}.m_326d024a:where([data-active]){background-color:var(--pagination-active-bg);border-color:var(--pagination-active-bg);color:var(--pagination-active-color, var(--mantine-color-white))}@media (hover: hover){.m_326d024a:where([data-active]):hover{background-color:var(--pagination-active-bg)}}@media (hover: none){.m_326d024a:where([data-active]):active{background-color:var(--pagination-active-bg)}}.m_4ad7767d{height:var(--pagination-control-size);min-width:var(--pagination-control-size);display:flex;align-items:center;justify-content:center;pointer-events:none}.m_f61ca620{--psi-button-size-xs: calc(1.375rem * var(--mantine-scale));--psi-button-size-sm: calc(1.625rem * var(--mantine-scale));--psi-button-size-md: calc(1.75rem * var(--mantine-scale));--psi-button-size-lg: calc(2rem * var(--mantine-scale));--psi-button-size-xl: calc(2.5rem * var(--mantine-scale));--psi-icon-size-xs: calc(.75rem * var(--mantine-scale));--psi-icon-size-sm: calc(.9375rem * var(--mantine-scale));--psi-icon-size-md: calc(1.0625rem * var(--mantine-scale));--psi-icon-size-lg: calc(1.1875rem * var(--mantine-scale));--psi-icon-size-xl: calc(1.3125rem * var(--mantine-scale));--psi-button-size: var(--psi-button-size-sm);--psi-icon-size: var(--psi-icon-size-sm)}.m_ccf8da4c{position:relative;overflow:hidden}.m_f2d85dd2{font-family:var(--mantine-font-family);background-color:transparent;border:0;padding-inline-end:var(--input-padding-inline-end);padding-inline-start:var(--input-padding-inline-start);position:absolute;top:0;right:0;bottom:0;left:0;outline:0;font-size:inherit;line-height:var(--mantine-line-height);height:100%;width:100%;color:inherit}.m_ccf8da4c[data-disabled] .m_f2d85dd2,.m_f2d85dd2:disabled{cursor:not-allowed}.m_f2d85dd2::-moz-placeholder{color:var(--input-placeholder-color);opacity:1}.m_f2d85dd2::placeholder{color:var(--input-placeholder-color);opacity:1}.m_f2d85dd2::-ms-reveal{display:none}.m_b1072d44{width:var(--psi-button-size);height:var(--psi-button-size);min-width:var(--psi-button-size);min-height:var(--psi-button-size)}.m_b1072d44:disabled{display:none}.m_f1cb205a{--pin-input-size-xs: calc(1.875rem * var(--mantine-scale));--pin-input-size-sm: calc(2.25rem * var(--mantine-scale));--pin-input-size-md: calc(2.625rem * var(--mantine-scale));--pin-input-size-lg: calc(3.125rem * var(--mantine-scale));--pin-input-size-xl: calc(3.75rem * var(--mantine-scale));--pin-input-size: var(--pin-input-size-sm)}.m_cb288ead{width:var(--pin-input-size);height:var(--pin-input-size)}@keyframes m_81a374bd{0%{background-position:0 0}to{background-position:calc(2.5rem * var(--mantine-scale)) 0}}.m_db6d6462{--progress-radius: var(--mantine-radius-default);--progress-size: var(--progress-size-md);--progress-size-xs: calc(.1875rem * var(--mantine-scale));--progress-size-sm: calc(.3125rem * var(--mantine-scale));--progress-size-md: calc(.5rem * var(--mantine-scale));--progress-size-lg: calc(.75rem * var(--mantine-scale));--progress-size-xl: calc(1rem * var(--mantine-scale));position:relative;height:var(--progress-size);border-radius:var(--progress-radius);overflow:hidden;display:flex}:where([data-mantine-color-scheme=light]) .m_db6d6462{background-color:var(--mantine-color-gray-2)}:where([data-mantine-color-scheme=dark]) .m_db6d6462{background-color:var(--mantine-color-dark-4)}.m_2242eb65{background-color:var(--progress-section-color);height:100%;width:var(--progress-section-width);display:flex;align-items:center;justify-content:center;overflow:hidden;background-size:calc(1.25rem * var(--mantine-scale)) calc(1.25rem * var(--mantine-scale));transition:width var(--progress-transition-duration, .1s) ease}.m_2242eb65:where([data-striped]){background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.m_2242eb65:where([data-animated]){animation:m_81a374bd 1s linear infinite}.m_2242eb65:where(:last-of-type){border-radius:0;border-start-end-radius:var(--progress-radius);border-end-end-radius:var(--progress-radius)}.m_2242eb65:where(:first-of-type){border-radius:0;border-start-start-radius:var(--progress-radius);border-end-start-radius:var(--progress-radius)}.m_91e40b74{color:var(--progress-label-color, var(--mantine-color-white));font-weight:700;-webkit-user-select:none;-moz-user-select:none;user-select:none;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;font-size:min(calc(var(--progress-size) * .65),calc(1.125rem * var(--mantine-scale)));line-height:1;padding-inline:calc(.25rem * var(--mantine-scale))}.m_9dc8ae12{--card-radius: var(--mantine-radius-default);display:block;width:100%;border-radius:var(--card-radius);cursor:pointer}.m_9dc8ae12 :where(*){cursor:inherit}.m_9dc8ae12:where([data-with-border]){border:calc(.0625rem * var(--mantine-scale)) solid transparent}:where([data-mantine-color-scheme=light]) .m_9dc8ae12:where([data-with-border]){border-color:var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_9dc8ae12:where([data-with-border]){border-color:var(--mantine-color-dark-4)}.m_717d7ff6{--radio-size-xs: calc(1rem * var(--mantine-scale));--radio-size-sm: calc(1.25rem * var(--mantine-scale));--radio-size-md: calc(1.5rem * var(--mantine-scale));--radio-size-lg: calc(1.875rem * var(--mantine-scale));--radio-size-xl: calc(2.25rem * var(--mantine-scale));--radio-icon-size-xs: calc(.375rem * var(--mantine-scale));--radio-icon-size-sm: calc(.5rem * var(--mantine-scale));--radio-icon-size-md: calc(.625rem * var(--mantine-scale));--radio-icon-size-lg: calc(.875rem * var(--mantine-scale));--radio-icon-size-xl: calc(1rem * var(--mantine-scale));--radio-icon-size: var(--radio-icon-size-sm);--radio-size: var(--radio-size-sm);--radio-color: var(--mantine-primary-color-filled);--radio-icon-color: var(--mantine-color-white);position:relative;border:calc(.0625rem * var(--mantine-scale)) solid transparent;width:var(--radio-size);min-width:var(--radio-size);height:var(--radio-size);min-height:var(--radio-size);border-radius:var(--radio-radius, 10000px);transition:border-color .1s ease,background-color .1s ease;cursor:var(--mantine-cursor-type);-webkit-tap-highlight-color:transparent;display:flex;align-items:center;justify-content:center}:where([data-mantine-color-scheme=light]) .m_717d7ff6{background-color:var(--mantine-color-white);border-color:var(--mantine-color-gray-4)}:where([data-mantine-color-scheme=dark]) .m_717d7ff6{background-color:var(--mantine-color-dark-6);border-color:var(--mantine-color-dark-4)}.m_717d7ff6[data-indeterminate],.m_717d7ff6[data-checked]{background-color:var(--radio-color);border-color:var(--radio-color)}.m_717d7ff6[data-indeterminate]>.m_3e4da632,.m_717d7ff6[data-checked]>.m_3e4da632{opacity:1;transform:none;color:var(--radio-icon-color)}.m_717d7ff6[data-disabled]{cursor:not-allowed}:where([data-mantine-color-scheme=light]) .m_717d7ff6[data-disabled]{background-color:var(--mantine-color-gray-2);border-color:var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_717d7ff6[data-disabled]{background-color:var(--mantine-color-dark-6);border-color:var(--mantine-color-dark-6)}[data-mantine-color-scheme=light] .m_717d7ff6[data-disabled][data-checked]>.m_3e4da632{color:var(--mantine-color-gray-5)}[data-mantine-color-scheme=dark] .m_717d7ff6[data-disabled][data-checked]>.m_3e4da632{color:var(--mantine-color-dark-3)}.m_2980836c[data-indeterminate]:not([data-disabled]),.m_2980836c[data-checked]:not([data-disabled]){background-color:transparent;border-color:var(--radio-color)}.m_2980836c[data-indeterminate]:not([data-disabled])>.m_3e4da632,.m_2980836c[data-checked]:not([data-disabled])>.m_3e4da632{color:var(--radio-color);opacity:1;transform:none}.m_3e4da632{display:block;width:var(--radio-icon-size);height:var(--radio-icon-size);color:transparent;pointer-events:none;transform:translateY(calc(.3125rem * var(--mantine-scale))) scale(.5);opacity:1;transition:transform .1s ease,opacity .1s ease}.m_f3f1af94{--radio-size-xs: calc(1rem * var(--mantine-scale));--radio-size-sm: calc(1.25rem * var(--mantine-scale));--radio-size-md: calc(1.5rem * var(--mantine-scale));--radio-size-lg: calc(1.875rem * var(--mantine-scale));--radio-size-xl: calc(2.25rem * var(--mantine-scale));--radio-size: var(--radio-size-sm);--radio-icon-size-xs: calc(.375rem * var(--mantine-scale));--radio-icon-size-sm: calc(.5rem * var(--mantine-scale));--radio-icon-size-md: calc(.625rem * var(--mantine-scale));--radio-icon-size-lg: calc(.875rem * var(--mantine-scale));--radio-icon-size-xl: calc(1rem * var(--mantine-scale));--radio-icon-size: var(--radio-icon-size-sm);--radio-icon-color: var(--mantine-color-white)}.m_89c4f5e4{position:relative;width:var(--radio-size);height:var(--radio-size);order:1}.m_89c4f5e4:where([data-label-position=left]){order:2}.m_f3ed6b2b{color:var(--radio-icon-color);opacity:var(--radio-icon-opacity, 0);transform:var(--radio-icon-transform, scale(.2) translateY(calc(.625rem * var(--mantine-scale))));transition:opacity .1s ease,transform .2s ease;pointer-events:none;width:var(--radio-icon-size);height:var(--radio-icon-size);position:absolute;top:calc(50% - var(--radio-icon-size) / 2);left:calc(50% - var(--radio-icon-size) / 2)}.m_8a3dbb89{border:calc(.0625rem * var(--mantine-scale)) solid;position:relative;-webkit-appearance:none;-moz-appearance:none;appearance:none;width:var(--radio-size);height:var(--radio-size);border-radius:var(--radio-radius, var(--radio-size));margin:0;display:flex;align-items:center;justify-content:center;transition-property:background-color,border-color;transition-timing-function:ease;transition-duration:.1s;cursor:var(--mantine-cursor-type);-webkit-tap-highlight-color:transparent}:where([data-mantine-color-scheme=light]) .m_8a3dbb89{background-color:var(--mantine-color-white);border-color:var(--mantine-color-gray-4)}:where([data-mantine-color-scheme=dark]) .m_8a3dbb89{background-color:var(--mantine-color-dark-6);border-color:var(--mantine-color-dark-4)}.m_8a3dbb89:checked{background-color:var(--radio-color, var(--mantine-primary-color-filled));border-color:var(--radio-color, var(--mantine-primary-color-filled))}.m_8a3dbb89:checked+.m_f3ed6b2b{--radio-icon-opacity: 1;--radio-icon-transform: scale(1)}.m_8a3dbb89:disabled{cursor:not-allowed}:where([data-mantine-color-scheme=light]) .m_8a3dbb89:disabled{background-color:var(--mantine-color-gray-1);border-color:var(--mantine-color-gray-2)}:where([data-mantine-color-scheme=light]) .m_8a3dbb89:disabled+.m_f3ed6b2b{--radio-icon-color: var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_8a3dbb89:disabled{background-color:var(--mantine-color-dark-5);border-color:var(--mantine-color-dark-4)}:where([data-mantine-color-scheme=dark]) .m_8a3dbb89:disabled+.m_f3ed6b2b{--radio-icon-color: var(--mantine-color-dark-7)}.m_8a3dbb89:where([data-error]){border-color:var(--mantine-color-error)}.m_1bfe9d39+.m_f3ed6b2b{--radio-icon-color: var(--radio-color)}.m_1bfe9d39:checked:not(:disabled){background-color:transparent;border-color:var(--radio-color)}.m_1bfe9d39:checked:not(:disabled)+.m_f3ed6b2b{--radio-icon-color: var(--radio-color);--radio-icon-opacity: 1;--radio-icon-transform: none}.m_f8d312f2{--rating-size-xs: calc(.875rem * var(--mantine-scale));--rating-size-sm: calc(1.125rem * var(--mantine-scale));--rating-size-md: calc(1.25rem * var(--mantine-scale));--rating-size-lg: calc(1.75rem * var(--mantine-scale));--rating-size-xl: calc(2rem * var(--mantine-scale));display:flex;width:-moz-max-content;width:max-content}.m_f8d312f2:where(:has(input:disabled)){pointer-events:none}.m_61734bb7{position:relative;transition:transform .1s ease}.m_61734bb7:where([data-active]){z-index:1;transform:scale(1.1)}.m_5662a89a{width:var(--rating-size);height:var(--rating-size);display:block}:where([data-mantine-color-scheme=light]) .m_5662a89a{fill:var(--mantine-color-gray-3);stroke:var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_5662a89a{fill:var(--mantine-color-dark-3);stroke:var(--mantine-color-dark-3)}.m_5662a89a:where([data-filled]){fill:var(--rating-color);stroke:var(--rating-color)}.m_211007ba{height:0;width:0;position:absolute;overflow:hidden;white-space:nowrap;opacity:0;-webkit-tap-highlight-color:transparent}.m_211007ba:focus-visible+label{outline:2px solid var(--mantine-primary-color-filled);outline-offset:calc(.125rem * var(--mantine-scale))}.m_21342ee4{display:block;cursor:pointer;position:absolute;top:0;left:0;z-index:var(--rating-item-z-index, 0);-webkit-tap-highlight-color:transparent}.m_21342ee4:where([data-read-only]){cursor:default}.m_21342ee4:where(:last-of-type){position:relative}.m_fae05d6a{clip-path:var(--rating-symbol-clip-path)}.m_1b3c8819{--tooltip-radius: var(--mantine-radius-default);position:absolute;padding:calc(var(--mantine-spacing-xs) / 2) var(--mantine-spacing-xs);pointer-events:none;font-size:var(--mantine-font-size-sm);white-space:nowrap;border-radius:var(--tooltip-radius)}:where([data-mantine-color-scheme=light]) .m_1b3c8819{background-color:var(--tooltip-bg, var(--mantine-color-gray-9));color:var(--tooltip-color, var(--mantine-color-white))}:where([data-mantine-color-scheme=dark]) .m_1b3c8819{background-color:var(--tooltip-bg, var(--mantine-color-gray-2));color:var(--tooltip-color, var(--mantine-color-black))}.m_1b3c8819:where([data-multiline]){white-space:normal}.m_1b3c8819:where([data-fixed]){position:fixed}.m_f898399f{background-color:inherit;border:0;z-index:1}.m_b32e4812{position:relative;width:var(--rp-size);height:var(--rp-size);min-width:var(--rp-size);min-height:var(--rp-size);--rp-transition-duration: 0ms}.m_d43b5134{width:var(--rp-size);height:var(--rp-size);min-width:var(--rp-size);min-height:var(--rp-size);transform:rotate(-90deg)}.m_b1ca1fbf{stroke:var(--curve-color, var(--rp-curve-root-color));transition:stroke-dashoffset var(--rp-transition-duration) ease,stroke-dasharray var(--rp-transition-duration) ease,stroke var(--rp-transition-duration)}[data-mantine-color-scheme=light] .m_b1ca1fbf{--rp-curve-root-color: var(--mantine-color-gray-2)}[data-mantine-color-scheme=dark] .m_b1ca1fbf{--rp-curve-root-color: var(--mantine-color-dark-4)}.m_b23f9dc4{position:absolute;top:50%;transform:translateY(-50%);inset-inline:var(--rp-label-offset)}.m_cf365364{--sc-padding-xs: calc(.1875rem * var(--mantine-scale)) calc(.375rem * var(--mantine-scale));--sc-padding-sm: calc(.3125rem * var(--mantine-scale)) calc(.625rem * var(--mantine-scale));--sc-padding-md: calc(.4375rem * var(--mantine-scale)) calc(.875rem * var(--mantine-scale));--sc-padding-lg: calc(.5625rem * var(--mantine-scale)) calc(1rem * var(--mantine-scale));--sc-padding-xl: calc(.75rem * var(--mantine-scale)) calc(1.25rem * var(--mantine-scale));--sc-transition-duration: .2s;--sc-padding: var(--sc-padding-sm);--sc-transition-timing-function: ease;--sc-font-size: var(--mantine-font-size-sm);position:relative;display:inline-flex;flex-direction:row;width:auto;border-radius:var(--sc-radius, var(--mantine-radius-default));overflow:hidden;padding:calc(.25rem * var(--mantine-scale))}.m_cf365364:where([data-full-width]){display:flex}.m_cf365364:where([data-orientation=vertical]){display:flex;flex-direction:column;width:-moz-max-content;width:max-content}.m_cf365364:where([data-orientation=vertical]):where([data-full-width]){width:auto}:where([data-mantine-color-scheme=light]) .m_cf365364{background-color:var(--mantine-color-gray-1)}:where([data-mantine-color-scheme=dark]) .m_cf365364{background-color:var(--mantine-color-dark-8)}.m_9e182ccd{position:absolute;display:block;z-index:1;border-radius:var(--sc-radius, var(--mantine-radius-default))}:where([data-mantine-color-scheme=light]) .m_9e182ccd{box-shadow:var(--sc-shadow, none);background-color:var(--sc-color, var(--mantine-color-white))}:where([data-mantine-color-scheme=dark]) .m_9e182ccd{box-shadow:none;background-color:var(--sc-color, var(--mantine-color-dark-5))}.m_1738fcb2{-webkit-tap-highlight-color:transparent;font-weight:500;display:block;text-align:center;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;-webkit-user-select:none;-moz-user-select:none;user-select:none;border-radius:var(--sc-radius, var(--mantine-radius-default));font-size:var(--sc-font-size);padding:var(--sc-padding);transition:color var(--sc-transition-duration) var(--sc-transition-timing-function);cursor:pointer;outline:var(--segmented-control-outline, none)}:where([data-mantine-color-scheme=light]) .m_1738fcb2{color:var(--mantine-color-gray-7)}:where([data-mantine-color-scheme=dark]) .m_1738fcb2{color:var(--mantine-color-dark-1)}.m_1738fcb2:where([data-read-only]){cursor:default}fieldset:disabled .m_1738fcb2,.m_1738fcb2:where([data-disabled]){cursor:not-allowed}:where([data-mantine-color-scheme=light]) fieldset:disabled .m_1738fcb2,:where([data-mantine-color-scheme=light]) .m_1738fcb2:where([data-disabled]){color:var(--mantine-color-gray-5)}:where([data-mantine-color-scheme=dark]) fieldset:disabled .m_1738fcb2,:where([data-mantine-color-scheme=dark]) .m_1738fcb2:where([data-disabled]){color:var(--mantine-color-dark-3)}:where([data-mantine-color-scheme=light]) .m_1738fcb2:where([data-active]){color:var(--sc-label-color, var(--mantine-color-black))}:where([data-mantine-color-scheme=dark]) .m_1738fcb2:where([data-active]){color:var(--sc-label-color, var(--mantine-color-white))}.m_cf365364:where([data-initialized]) .m_1738fcb2:where([data-active]):before{display:none}.m_1738fcb2:where([data-active]):before{content:"";top:0;right:0;bottom:0;left:0;z-index:0;position:absolute;border-radius:var(--sc-radius, var(--mantine-radius-default))}:where([data-mantine-color-scheme=light]) .m_1738fcb2:where([data-active]):before{box-shadow:var(--sc-shadow, none);background-color:var(--sc-color, var(--mantine-color-white))}:where([data-mantine-color-scheme=dark]) .m_1738fcb2:where([data-active]):before{box-shadow:none;background-color:var(--sc-color, var(--mantine-color-dark-5))}@media (hover: hover){:where([data-mantine-color-scheme=light]) .m_1738fcb2:where(:not([data-disabled],[data-active],[data-read-only])):hover{color:var(--mantine-color-black)}:where([data-mantine-color-scheme=dark]) .m_1738fcb2:where(:not([data-disabled],[data-active],[data-read-only])):hover{color:var(--mantine-color-white)}}@media (hover: none){:where([data-mantine-color-scheme=light]) .m_1738fcb2:where(:not([data-disabled],[data-active],[data-read-only])):active{color:var(--mantine-color-black)}:where([data-mantine-color-scheme=dark]) .m_1738fcb2:where(:not([data-disabled],[data-active],[data-read-only])):active{color:var(--mantine-color-white)}}@media (hover: hover){:where([data-mantine-color-scheme=light]) fieldset:disabled .m_1738fcb2:hover{color:var(--mantine-color-gray-5)!important}:where([data-mantine-color-scheme=dark]) fieldset:disabled .m_1738fcb2:hover{color:var(--mantine-color-dark-3)!important}}@media (hover: none){:where([data-mantine-color-scheme=light]) fieldset:disabled .m_1738fcb2:active{color:var(--mantine-color-gray-5)!important}:where([data-mantine-color-scheme=dark]) fieldset:disabled .m_1738fcb2:active{color:var(--mantine-color-dark-3)!important}}.m_1714d588{height:0;width:0;position:absolute;overflow:hidden;white-space:nowrap;opacity:0}.m_1714d588[data-focus-ring=auto]:focus:focus-visible+.m_1738fcb2{--segmented-control-outline: 2px solid var(--mantine-primary-color-filled)}.m_1714d588[data-focus-ring=always]:focus+.m_1738fcb2{--segmented-control-outline: 2px solid var(--mantine-primary-color-filled)}.m_69686b9b{position:relative;flex:1;z-index:2;transition:border-color var(--sc-transition-duration) var(--sc-transition-timing-function)}.m_cf365364[data-with-items-borders] :where(.m_69686b9b):before{content:"";position:absolute;top:0;bottom:0;inset-inline-start:0;background-color:var(--separator-color);width:calc(.0625rem * var(--mantine-scale));transition:background-color var(--sc-transition-duration) var(--sc-transition-timing-function)}.m_69686b9b[data-orientation=vertical]:before{top:0;inset-inline:0;bottom:auto;height:calc(.0625rem * var(--mantine-scale));width:auto}:where([data-mantine-color-scheme=light]) .m_69686b9b{--separator-color: var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_69686b9b{--separator-color: var(--mantine-color-dark-4)}.m_69686b9b:first-of-type:before{--separator-color: transparent}[data-mantine-color-scheme] .m_69686b9b[data-active]:before,[data-mantine-color-scheme] .m_69686b9b[data-active]+.m_69686b9b:before{--separator-color: transparent}.m_78882f40{position:relative;z-index:2}.m_fa528724{--scp-filled-segment-color: var(--mantine-primary-color-filled);--scp-transition-duration: 0ms;--scp-thickness: calc(.625rem * var(--mantine-scale))}:where([data-mantine-color-scheme=light]) .m_fa528724{--scp-empty-segment-color: var(--mantine-color-gray-2)}:where([data-mantine-color-scheme=dark]) .m_fa528724{--scp-empty-segment-color: var(--mantine-color-dark-4)}.m_fa528724{position:relative;width:-moz-fit-content;width:fit-content}.m_62e9e7e2{display:block;transform:var(--scp-rotation);overflow:hidden}.m_c573fb6f{transition:stroke-dashoffset var(--scp-transition-duration) ease,stroke-dasharray var(--scp-transition-duration) ease,stroke var(--scp-transition-duration)}.m_4fa340f2{position:absolute;margin:0;padding:0;inset-inline:0;text-align:center;z-index:1}.m_4fa340f2:where([data-position=bottom]){bottom:0;padding-inline:calc(var(--scp-thickness) * 2)}.m_4fa340f2:where([data-position=bottom]):where([data-orientation=down]){bottom:auto;top:0}.m_4fa340f2:where([data-position=center]){top:50%;padding-inline:calc(var(--scp-thickness) * 3)}.m_925c2d2c{container:simple-grid / inline-size}.m_2415a157{display:grid;grid-template-columns:repeat(var(--sg-cols),minmax(0,1fr));gap:var(--sg-spacing-y) var(--sg-spacing-x)}@keyframes m_299c329c{0%,to{opacity:.4}50%{opacity:1}}.m_18320242{height:var(--skeleton-height, auto);width:var(--skeleton-width, 100%);border-radius:var(--skeleton-radius, var(--mantine-radius-default));position:relative;transform:translateZ(0);-webkit-transform:translateZ(0)}.m_18320242:where([data-animate]):after{animation:m_299c329c 1.5s linear infinite}.m_18320242:where([data-visible]){overflow:hidden}.m_18320242:where([data-visible]):before{position:absolute;content:"";top:0;right:0;bottom:0;left:0;z-index:10;background-color:var(--mantine-color-body)}.m_18320242:where([data-visible]):after{position:absolute;content:"";top:0;right:0;bottom:0;left:0;z-index:11}:where([data-mantine-color-scheme=light]) .m_18320242:where([data-visible]):after{background-color:var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_18320242:where([data-visible]):after{background-color:var(--mantine-color-dark-4)}.m_dd36362e{--slider-size-xs: calc(.25rem * var(--mantine-scale));--slider-size-sm: calc(.375rem * var(--mantine-scale));--slider-size-md: calc(.5rem * var(--mantine-scale));--slider-size-lg: calc(.625rem * var(--mantine-scale));--slider-size-xl: calc(.75rem * var(--mantine-scale));--slider-size: var(--slider-size-md);--slider-radius: calc(62.5rem * var(--mantine-scale));--slider-color: var(--mantine-primary-color-filled);-webkit-tap-highlight-color:transparent;outline:none;height:calc(var(--slider-size) * 2);padding-inline:var(--slider-size);display:flex;flex-direction:column;align-items:center;touch-action:none;position:relative}[data-mantine-color-scheme=light] .m_dd36362e{--slider-track-bg: var(--mantine-color-gray-2);--slider-track-disabled-bg: var(--mantine-color-gray-4)}[data-mantine-color-scheme=dark] .m_dd36362e{--slider-track-bg: var(--mantine-color-dark-4);--slider-track-disabled-bg: var(--mantine-color-dark-3)}.m_c9357328{position:absolute;top:calc(-2.25rem * var(--mantine-scale));font-size:var(--mantine-font-size-xs);color:var(--mantine-color-white);padding:calc(var(--mantine-spacing-xs) / 2);border-radius:var(--mantine-radius-sm);white-space:nowrap;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;touch-action:none}:where([data-mantine-color-scheme=light]) .m_c9357328{background-color:var(--mantine-color-gray-9)}:where([data-mantine-color-scheme=dark]) .m_c9357328{background-color:var(--mantine-color-dark-4)}.m_c9a9a60a{position:absolute;display:flex;height:var(--slider-thumb-size);width:var(--slider-thumb-size);border:calc(.25rem * var(--mantine-scale)) solid;transform:translate(-50%,-50%);color:var(--slider-color);top:50%;cursor:pointer;border-radius:var(--slider-radius);align-items:center;justify-content:center;transition:box-shadow .1s ease,transform .1s ease;z-index:3;-webkit-user-select:none;-moz-user-select:none;user-select:none;touch-action:none;outline-offset:calc(.125rem * var(--mantine-scale));left:var(--slider-thumb-offset)}:where([dir=rtl]) .m_c9a9a60a{left:auto;right:calc(var(--slider-thumb-offset) - var(--slider-thumb-size))}fieldset:disabled .m_c9a9a60a,.m_c9a9a60a:where([data-disabled]){display:none}.m_c9a9a60a:where([data-dragging]){transform:translate(-50%,-50%) scale(1.05);box-shadow:var(--mantine-shadow-sm)}:where([data-mantine-color-scheme=light]) .m_c9a9a60a{border-color:var(--slider-color);background-color:var(--mantine-color-white)}:where([data-mantine-color-scheme=dark]) .m_c9a9a60a{border-color:var(--mantine-color-white);background-color:var(--slider-color)}.m_a8645c2{display:flex;align-items:center;width:100%;height:calc(var(--slider-size) * 2);cursor:pointer}fieldset:disabled .m_a8645c2,.m_a8645c2:where([data-disabled]){cursor:not-allowed}.m_c9ade57f{position:relative;width:100%;height:var(--slider-size)}.m_c9ade57f:where([data-inverted]:not([data-disabled])){--track-bg: var(--slider-color)}fieldset:disabled .m_c9ade57f:where([data-inverted]),.m_c9ade57f:where([data-inverted][data-disabled]){--track-bg: var(--slider-track-disabled-bg)}.m_c9ade57f:before{content:"";position:absolute;top:0;bottom:0;border-radius:var(--slider-radius);inset-inline:calc(var(--slider-size) * -1);background-color:var(--track-bg, var(--slider-track-bg));z-index:0}.m_38aeed47{position:absolute;z-index:1;top:0;bottom:0;background-color:var(--slider-color);border-radius:var(--slider-radius);width:var(--slider-bar-width);inset-inline-start:var(--slider-bar-offset)}.m_38aeed47:where([data-inverted]){background-color:var(--slider-track-bg)}:where([data-mantine-color-scheme=light]) fieldset:disabled .m_38aeed47:where(:not([data-inverted])),:where([data-mantine-color-scheme=light]) .m_38aeed47:where([data-disabled]:not([data-inverted])){background-color:var(--mantine-color-gray-4)}:where([data-mantine-color-scheme=dark]) fieldset:disabled .m_38aeed47:where(:not([data-inverted])),:where([data-mantine-color-scheme=dark]) .m_38aeed47:where([data-disabled]:not([data-inverted])){background-color:var(--mantine-color-dark-3)}.m_b7b0423a{position:absolute;inset-inline-start:calc(var(--mark-offset) - var(--slider-size) / 2);top:0;z-index:2;height:0;pointer-events:none}.m_dd33bc19{border:calc(.125rem * var(--mantine-scale)) solid;height:var(--slider-size);width:var(--slider-size);border-radius:calc(62.5rem * var(--mantine-scale));background-color:var(--mantine-color-white);pointer-events:none}:where([data-mantine-color-scheme=light]) .m_dd33bc19{border-color:var(--mantine-color-gray-2)}:where([data-mantine-color-scheme=dark]) .m_dd33bc19{border-color:var(--mantine-color-dark-4)}.m_dd33bc19:where([data-filled]){border-color:var(--slider-color)}:where([data-mantine-color-scheme=light]) .m_dd33bc19:where([data-filled]):where([data-disabled]){border-color:var(--mantine-color-gray-4)}:where([data-mantine-color-scheme=dark]) .m_dd33bc19:where([data-filled]):where([data-disabled]){border-color:var(--mantine-color-dark-3)}.m_68c77a5b{transform:translate(calc(-50% + var(--slider-size) / 2),calc(var(--mantine-spacing-xs) / 2));font-size:var(--mantine-font-size-sm);white-space:nowrap;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;user-select:none}:where([data-mantine-color-scheme=light]) .m_68c77a5b{color:var(--mantine-color-gray-6)}:where([data-mantine-color-scheme=dark]) .m_68c77a5b{color:var(--mantine-color-dark-2)}.m_559cce2d{position:relative}.m_559cce2d:where([data-has-spoiler]){margin-bottom:calc(1.5rem * var(--mantine-scale))}.m_b912df4e{display:flex;flex-direction:column;overflow:hidden;transition:max-height var(--spoiler-transition-duration, .2s) ease}.m_b9131032{position:absolute;inset-inline-start:0;top:100%;height:calc(1.5rem * var(--mantine-scale))}.m_6d731127{display:flex;flex-direction:column;align-items:var(--stack-align, stretch);justify-content:var(--stack-justify, flex-start);gap:var(--stack-gap, var(--mantine-spacing-md))}.m_cbb4ea7e{--stepper-icon-size-xs: calc(2.125rem * var(--mantine-scale));--stepper-icon-size-sm: calc(2.25rem * var(--mantine-scale));--stepper-icon-size-md: calc(2.625rem * var(--mantine-scale));--stepper-icon-size-lg: calc(3rem * var(--mantine-scale));--stepper-icon-size-xl: calc(3.25rem * var(--mantine-scale));--stepper-icon-size: var(--stepper-icon-size-md);--stepper-color: var(--mantine-primary-color-filled);--stepper-content-padding: var(--mantine-spacing-md);--stepper-spacing: var(--mantine-spacing-md);--stepper-radius: calc(62.5rem * var(--mantine-scale));--stepper-fz: var(--mantine-font-size-md)}.m_aaf89d0b{display:flex;flex-wrap:nowrap;align-items:center}.m_aaf89d0b:where([data-wrap]){flex-wrap:wrap;gap:var(--mantine-spacing-md) 0}.m_aaf89d0b:where([data-orientation=vertical]){flex-direction:column}.m_aaf89d0b:where([data-orientation=vertical]):where([data-icon-position=left]){align-items:flex-start}.m_aaf89d0b:where([data-orientation=vertical]):where([data-icon-position=right]){align-items:flex-end}.m_aaf89d0b:where([data-orientation=horizontal]){flex-direction:row}.m_2a371ac9{--separator-offset: calc(var(--stepper-icon-size) / 2 - calc(.0625rem * var(--mantine-scale)));transition:background-color .15s ease;flex:1}:where([data-mantine-color-scheme=light]) .m_2a371ac9{background-color:var(--mantine-color-gray-2)}:where([data-mantine-color-scheme=dark]) .m_2a371ac9{background-color:var(--mantine-color-dark-2)}.m_2a371ac9:where([data-active]){background-color:var(--stepper-color)}.m_2a371ac9:where([data-orientation=horizontal]){height:calc(.125rem * var(--mantine-scale));margin-inline:var(--mantine-spacing-md)}.m_2a371ac9:where([data-orientation=vertical]){width:calc(.125rem * var(--mantine-scale));margin-top:calc(var(--mantine-spacing-xs) / 2);margin-bottom:calc(var(--mantine-spacing-xs) - calc(.125rem * var(--mantine-scale)))}.m_2a371ac9:where([data-orientation=vertical]):where([data-icon-position=left]){margin-inline-start:var(--separator-offset)}.m_2a371ac9:where([data-orientation=vertical]):where([data-icon-position=right]){margin-inline-end:var(--separator-offset)}.m_78da155d{padding-top:var(--stepper-content-padding)}.m_cbb57068{--step-color: var(--stepper-color);display:flex;cursor:default}.m_cbb57068:where([data-allow-click]){cursor:pointer}.m_cbb57068:where([data-icon-position=left]){flex-direction:row}.m_cbb57068:where([data-icon-position=right]){flex-direction:row-reverse}.m_f56b1e2c{align-items:center}.m_833edb7e{--separator-spacing: calc(var(--mantine-spacing-xs) / 2);justify-content:flex-start;min-height:calc(var(--stepper-icon-size) + var(--mantine-spacing-xl) + var(--separator-spacing));margin-top:var(--separator-spacing);overflow:hidden}.m_833edb7e:where(:first-of-type){margin-top:0}.m_833edb7e:where(:last-of-type) .m_6496b3f3{display:none}.m_818e70b{position:relative}.m_6496b3f3{top:calc(var(--stepper-icon-size) + var(--separator-spacing));inset-inline-start:calc(var(--stepper-icon-size) / 2);height:100vh;position:absolute;border-inline-start:calc(.125rem * var(--mantine-scale)) solid}:where([data-mantine-color-scheme=light]) .m_6496b3f3{border-color:var(--mantine-color-gray-1)}:where([data-mantine-color-scheme=dark]) .m_6496b3f3{border-color:var(--mantine-color-dark-5)}.m_6496b3f3:where([data-active]){border-color:var(--stepper-color)}.m_1959ad01{height:var(--stepper-icon-size);width:var(--stepper-icon-size);min-height:var(--stepper-icon-size);min-width:var(--stepper-icon-size);border-radius:var(--stepper-radius);font-size:var(--stepper-fz);display:flex;align-items:center;justify-content:center;position:relative;font-weight:700;transition:background-color .15s ease,border-color .15s ease;border:calc(.125rem * var(--mantine-scale)) solid}:where([data-mantine-color-scheme=light]) .m_1959ad01{background-color:var(--mantine-color-gray-1);border-color:var(--mantine-color-gray-1);color:var(--mantine-color-gray-7)}:where([data-mantine-color-scheme=dark]) .m_1959ad01{background-color:var(--mantine-color-dark-5);border-color:var(--mantine-color-dark-5);color:var(--mantine-color-dark-1)}.m_1959ad01:where([data-progress]){border-color:var(--step-color)}.m_1959ad01:where([data-completed]){color:var(--stepper-icon-color, var(--mantine-color-white));background-color:var(--step-color);border-color:var(--step-color)}.m_a79331dc{position:absolute;top:0;right:0;bottom:0;left:0;display:flex;align-items:center;justify-content:center;color:var(--stepper-icon-color, var(--mantine-color-white))}.m_1956aa2a{display:flex;flex-direction:column}.m_1956aa2a:where([data-icon-position=left]){margin-inline-start:var(--mantine-spacing-sm)}.m_1956aa2a:where([data-icon-position=right]){text-align:right;margin-inline-end:var(--mantine-spacing-sm)}:where([dir=rtl]) .m_1956aa2a:where([data-icon-position=right]){text-align:left}.m_12051f6c{font-weight:500;font-size:var(--stepper-fz);line-height:1}.m_164eea74{margin-top:calc(var(--stepper-spacing) / 3);margin-bottom:calc(var(--stepper-spacing) / 3);font-size:calc(var(--stepper-fz) - calc(.125rem * var(--mantine-scale)));line-height:1;color:var(--mantine-color-dimmed)}.m_5f93f3bb{--switch-height-xs: calc(1rem * var(--mantine-scale));--switch-height-sm: calc(1.25rem * var(--mantine-scale));--switch-height-md: calc(1.5rem * var(--mantine-scale));--switch-height-lg: calc(1.875rem * var(--mantine-scale));--switch-height-xl: calc(2.25rem * var(--mantine-scale));--switch-width-xs: calc(2rem * var(--mantine-scale));--switch-width-sm: calc(2.375rem * var(--mantine-scale));--switch-width-md: calc(2.875rem * var(--mantine-scale));--switch-width-lg: calc(3.5rem * var(--mantine-scale));--switch-width-xl: calc(4.5rem * var(--mantine-scale));--switch-thumb-size-xs: calc(.75rem * var(--mantine-scale));--switch-thumb-size-sm: calc(.875rem * var(--mantine-scale));--switch-thumb-size-md: calc(1.125rem * var(--mantine-scale));--switch-thumb-size-lg: calc(1.375rem * var(--mantine-scale));--switch-thumb-size-xl: calc(1.75rem * var(--mantine-scale));--switch-label-font-size-xs: calc(.3125rem * var(--mantine-scale));--switch-label-font-size-sm: calc(.375rem * var(--mantine-scale));--switch-label-font-size-md: calc(.4375rem * var(--mantine-scale));--switch-label-font-size-lg: calc(.5625rem * var(--mantine-scale));--switch-label-font-size-xl: calc(.6875rem * var(--mantine-scale));--switch-track-label-padding-xs: calc(.0625rem * var(--mantine-scale));--switch-track-label-padding-sm: calc(.125rem * var(--mantine-scale));--switch-track-label-padding-md: calc(.125rem * var(--mantine-scale));--switch-track-label-padding-lg: calc(.1875rem * var(--mantine-scale));--switch-track-label-padding-xl: calc(.1875rem * var(--mantine-scale));--switch-height: var(--switch-height-sm);--switch-width: var(--switch-width-sm);--switch-thumb-size: var(--switch-thumb-size-sm);--switch-label-font-size: var(--switch-label-font-size-sm);--switch-track-label-padding: var(--switch-track-label-padding-sm);--switch-radius: calc(62.5rem * var(--mantine-scale));--switch-color: var(--mantine-primary-color-filled);position:relative}.m_926b4011{height:0;width:0;opacity:0;margin:0;padding:0;position:absolute;overflow:hidden;white-space:nowrap}.m_9307d992{-webkit-tap-highlight-color:transparent;cursor:var(--switch-cursor, var(--mantine-cursor-type));overflow:hidden;position:relative;border-radius:var(--switch-radius);background-color:var(--switch-bg);border:1px solid var(--switch-bd);height:var(--switch-height);min-width:var(--switch-width);margin:0;transition:background-color .15s ease,border-color .15s ease;-webkit-appearance:none;-moz-appearance:none;appearance:none;display:flex;align-items:center;font-size:var(--switch-label-font-size);font-weight:600;order:var(--switch-order, 1);-webkit-user-select:none;-moz-user-select:none;user-select:none;z-index:0;line-height:0;color:var(--switch-text-color)}.m_9307d992:where([data-without-labels]){width:var(--switch-width)}.m_926b4011:focus-visible+.m_9307d992{outline:2px solid var(--mantine-primary-color-filled);outline-offset:calc(.125rem * var(--mantine-scale))}.m_926b4011:checked+.m_9307d992{--switch-bg: var(--switch-color);--switch-bd: var(--switch-color);--switch-text-color: var(--mantine-color-white)}.m_926b4011:disabled+.m_9307d992,.m_926b4011[data-disabled]+.m_9307d992{--switch-bg: var(--switch-disabled-color);--switch-bd: var(--switch-disabled-color);--switch-cursor: not-allowed}[data-mantine-color-scheme=light] .m_9307d992{--switch-bg: var(--mantine-color-gray-2);--switch-bd: var(--mantine-color-gray-3);--switch-text-color: var(--mantine-color-gray-6);--switch-disabled-color: var(--mantine-color-gray-2)}[data-mantine-color-scheme=dark] .m_9307d992{--switch-bg: var(--mantine-color-dark-6);--switch-bd: var(--mantine-color-dark-4);--switch-text-color: var(--mantine-color-dark-1);--switch-disabled-color: var(--mantine-color-dark-4)}.m_9307d992[data-error]{--switch-bd: var(--mantine-color-error)}.m_9307d992[data-label-position=left]{--switch-order: 2}.m_93039a1d{position:absolute;z-index:1;border-radius:var(--switch-radius);display:flex;background-color:var(--switch-thumb-bg, var(--mantine-color-white));height:var(--switch-thumb-size);width:var(--switch-thumb-size);border:1px solid var(--switch-thumb-bd);inset-inline-start:var(--switch-thumb-start, var(--switch-track-label-padding));transition:inset-inline-start .15s ease}.m_93039a1d>*{margin:auto}.m_926b4011:checked+*>.m_93039a1d{--switch-thumb-start: calc(100% - var(--switch-thumb-size) - var(--switch-track-label-padding));--switch-thumb-bd: var(--mantine-color-white)}.m_926b4011:disabled+*>.m_93039a1d,.m_926b4011[data-disabled]+*>.m_93039a1d{--switch-thumb-bd: var(--switch-thumb-bg-disabled);--switch-thumb-bg: var(--switch-thumb-bg-disabled)}[data-mantine-color-scheme=light] .m_93039a1d{--switch-thumb-bd: var(--mantine-color-gray-3);--switch-thumb-bg-disabled: var(--mantine-color-gray-0)}[data-mantine-color-scheme=dark] .m_93039a1d{--switch-thumb-bd: var(--mantine-color-white);--switch-thumb-bg-disabled: var(--mantine-color-dark-3)}.m_8277e082{height:100%;display:grid;place-content:center;min-width:calc(var(--switch-width) - var(--switch-thumb-size));padding-inline:var(--switch-track-label-padding);margin-inline-start:calc(var(--switch-thumb-size) + var(--switch-track-label-padding));transition:margin .15s ease}.m_926b4011:checked+*>.m_8277e082{margin-inline-end:calc(var(--switch-thumb-size) + var(--switch-track-label-padding));margin-inline-start:0}.m_b23fa0ef{width:100%;border-collapse:collapse;line-height:var(--mantine-line-height);font-size:var(--mantine-font-size-sm);table-layout:var(--table-layout, auto);caption-side:var(--table-caption-side, bottom);border:none}:where([data-mantine-color-scheme=light]) .m_b23fa0ef{--table-hover-color: var(--mantine-color-gray-1);--table-striped-color: var(--mantine-color-gray-0);--table-border-color: var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_b23fa0ef{--table-hover-color: var(--mantine-color-dark-5);--table-striped-color: var(--mantine-color-dark-6);--table-border-color: var(--mantine-color-dark-4)}.m_b23fa0ef:where([data-with-table-border]){border:calc(.0625rem * var(--mantine-scale)) solid var(--table-border-color)}.m_4e7aa4f3{text-align:left}:where([dir=rtl]) .m_4e7aa4f3{text-align:right}.m_4e7aa4fd{border-bottom:none;background-color:transparent}@media (hover: hover){.m_4e7aa4fd:hover:where([data-hover]){background-color:var(--tr-hover-bg)}}@media (hover: none){.m_4e7aa4fd:active:where([data-hover]){background-color:var(--tr-hover-bg)}}.m_4e7aa4fd:where([data-with-row-border]){border-bottom:calc(.0625rem * var(--mantine-scale)) solid var(--table-border-color)}.m_4e7aa4ef,.m_4e7aa4f3{padding:var(--table-vertical-spacing) var(--table-horizontal-spacing, var(--mantine-spacing-xs))}.m_4e7aa4ef:where([data-with-column-border]:not(:last-child)),.m_4e7aa4f3:where([data-with-column-border]:not(:last-child)){border-inline-end:calc(.0625rem * var(--mantine-scale)) solid var(--table-border-color)}.m_b2404537 :where(tr):where([data-with-row-border]:last-of-type){border-bottom:none}.m_b2404537 :where(tr):where([data-striped=odd]:nth-of-type(odd)){background-color:var(--table-striped-color)}.m_b2404537 :where(tr):where([data-striped=even]:nth-of-type(2n)){background-color:var(--table-striped-color)}.m_b2404537 :where(tr)[data-hover]{--tr-hover-bg: var(--table-highlight-on-hover-color, var(--table-hover-color))}.m_b242d975{top:var(--table-sticky-header-offset, 0);z-index:3}.m_b242d975:where([data-sticky]){position:sticky;background-color:var(--mantine-color-body)}.m_9e5a3ac7{color:var(--mantine-color-dimmed)}.m_9e5a3ac7:where([data-side=top]){margin-bottom:var(--mantine-spacing-xs)}.m_9e5a3ac7:where([data-side=bottom]){margin-top:var(--mantine-spacing-xs)}.m_a100c15{overflow-x:var(--table-overflow)}.m_62259741{min-width:var(--table-min-width)}.m_89d60db1{display:var(--tabs-display);flex-direction:var(--tabs-flex-direction);--tab-justify: flex-start;--tabs-list-direction: row;--tabs-panel-grow: unset;--tabs-display: block;--tabs-flex-direction: row;--tabs-list-border-width: 0;--tabs-list-border-size: 0 0 var(--tabs-list-border-width) 0;--tabs-list-gap: unset;--tabs-list-line-bottom: 0;--tabs-list-line-top: unset;--tabs-list-line-start: 0;--tabs-list-line-end: 0;--tab-radius: var(--tabs-radius) var(--tabs-radius) 0 0;--tab-border-width: 0 0 var(--tabs-list-border-width) 0}.m_89d60db1[data-inverted]{--tabs-list-line-bottom: unset;--tabs-list-line-top: 0;--tab-radius: 0 0 var(--tabs-radius) var(--tabs-radius);--tab-border-width: var(--tabs-list-border-width) 0 0 0}.m_89d60db1[data-inverted] .m_576c9d4:before{top:0;bottom:unset}.m_89d60db1[data-orientation=vertical]{--tabs-list-line-start: unset;--tabs-list-line-end: 0;--tabs-list-line-top: 0;--tabs-list-line-bottom: 0;--tabs-list-border-size: 0 var(--tabs-list-border-width) 0 0;--tab-border-width: 0 var(--tabs-list-border-width) 0 0;--tab-radius: var(--tabs-radius) 0 0 var(--tabs-radius);--tabs-list-direction: column;--tabs-panel-grow: 1;--tabs-display: flex}[dir=rtl] .m_89d60db1[data-orientation=vertical]{--tabs-list-border-size: 0 0 0 var(--tabs-list-border-width);--tab-border-width: 0 0 0 var(--tabs-list-border-width);--tab-radius: 0 var(--tabs-radius) var(--tabs-radius) 0}.m_89d60db1[data-orientation=vertical][data-placement=right]{--tabs-flex-direction: row-reverse;--tabs-list-line-start: 0;--tabs-list-line-end: unset;--tabs-list-border-size: 0 0 0 var(--tabs-list-border-width);--tab-border-width: 0 0 0 var(--tabs-list-border-width);--tab-radius: 0 var(--tabs-radius) var(--tabs-radius) 0}[dir=rtl] .m_89d60db1[data-orientation=vertical][data-placement=right]{--tabs-list-border-size: 0 var(--tabs-list-border-width) 0 0;--tab-border-width: 0 var(--tabs-list-border-width) 0 0;--tab-radius: var(--tabs-radius) 0 0 var(--tabs-radius)}[data-mantine-color-scheme=light] .m_89d60db1{--tab-border-color: var(--mantine-color-gray-3)}[data-mantine-color-scheme=dark] .m_89d60db1{--tab-border-color: var(--mantine-color-dark-4)}.m_89d60db1[data-orientation=horizontal]{--tab-justify: center}.m_89d60db1[data-variant=default]{--tabs-list-border-width: calc(.125rem * var(--mantine-scale))}[data-mantine-color-scheme=light] .m_89d60db1[data-variant=default]{--tab-hover-color: var(--mantine-color-gray-0)}[data-mantine-color-scheme=dark] .m_89d60db1[data-variant=default]{--tab-hover-color: var(--mantine-color-dark-6)}.m_89d60db1[data-variant=outline]{--tabs-list-border-width: calc(.0625rem * var(--mantine-scale))}.m_89d60db1[data-variant=pills]{--tabs-list-gap: calc(var(--mantine-spacing-sm) / 2)}[data-mantine-color-scheme=light] .m_89d60db1[data-variant=pills]{--tab-hover-color: var(--mantine-color-gray-0)}[data-mantine-color-scheme=dark] .m_89d60db1[data-variant=pills]{--tab-hover-color: var(--mantine-color-dark-6)}.m_89d33d6d{display:flex;flex-wrap:wrap;justify-content:var(--tabs-justify, flex-start);flex-direction:var(--tabs-list-direction);gap:var(--tabs-list-gap);--tab-grow: unset}.m_89d33d6d[data-grow]{--tab-grow: 1}.m_b0c91715{flex-grow:var(--tabs-panel-grow)}.m_4ec4dce6{position:relative;padding:var(--mantine-spacing-xs) var(--mantine-spacing-md);font-size:var(--mantine-font-size-sm);white-space:nowrap;z-index:0;display:flex;align-items:center;line-height:1;-webkit-user-select:none;-moz-user-select:none;user-select:none;flex-grow:var(--tab-grow);justify-content:var(--tab-justify)}.m_4ec4dce6:disabled,.m_4ec4dce6[data-disabled]{opacity:.5;cursor:not-allowed}.m_4ec4dce6:focus{z-index:1}.m_fc420b1f{display:flex;align-items:center;justify-content:center;margin-left:var(--tab-section-margin-left, 0);margin-right:var(--tab-section-margin-right, 0)}.m_fc420b1f[data-position=left]:not(:only-child){--tab-section-margin-right: var(--mantine-spacing-xs)}[dir=rtl] .m_fc420b1f[data-position=left]:not(:only-child){--tab-section-margin-right: 0rem;--tab-section-margin-left: var(--mantine-spacing-xs)}.m_fc420b1f[data-position=right]:not(:only-child){--tab-section-margin-left: var(--mantine-spacing-xs)}[dir=rtl] .m_fc420b1f[data-position=right]:not(:only-child){--tab-section-margin-left: 0rem;--tab-section-margin-right: var(--mantine-spacing-xs)}.m_576c9d4{position:relative}.m_576c9d4:before{content:"";position:absolute;border-color:var(--tab-border-color);border-width:var(--tabs-list-border-size);border-style:solid;bottom:var(--tabs-list-line-bottom);inset-inline-start:var(--tabs-list-line-start);inset-inline-end:var(--tabs-list-line-end);top:var(--tabs-list-line-top)}.m_539e827b{border-radius:var(--tab-radius);border-width:var(--tab-border-width);border-style:solid;border-color:transparent;background-color:var(--tab-bg);--tab-bg: transparent}.m_539e827b:where([data-active]){border-color:var(--tabs-color)}@media (hover: hover){.m_539e827b:hover{--tab-bg: var(--tab-hover-color)}.m_539e827b:hover:where(:not([data-active])){border-color:var(--tab-border-color)}}@media (hover: none){.m_539e827b:active{--tab-bg: var(--tab-hover-color)}.m_539e827b:active:where(:not([data-active])){border-color:var(--tab-border-color)}}@media (hover: hover){.m_539e827b:disabled:hover,.m_539e827b[data-disabled]:hover{--tab-bg: transparent}}@media (hover: none){.m_539e827b:disabled:active,.m_539e827b[data-disabled]:active{--tab-bg: transparent}}.m_6772fbd5{position:relative}.m_6772fbd5:before{content:"";position:absolute;border-color:var(--tab-border-color);border-width:var(--tabs-list-border-size);border-style:solid;bottom:var(--tabs-list-line-bottom);inset-inline-start:var(--tabs-list-line-start);inset-inline-end:var(--tabs-list-line-end);top:var(--tabs-list-line-top)}.m_b59ab47c{border-top:calc(.0625rem * var(--mantine-scale)) solid transparent;border-bottom:calc(.0625rem * var(--mantine-scale)) solid transparent;border-right:calc(.0625rem * var(--mantine-scale)) solid transparent;border-left:calc(.0625rem * var(--mantine-scale)) solid transparent;border-top-color:var(--tab-border-top-color);border-bottom-color:var(--tab-border-bottom-color);border-radius:var(--tab-radius);position:relative;--tab-border-bottom-color: transparent;--tab-border-top-color: transparent;--tab-border-inline-end-color: transparent;--tab-border-inline-start-color: transparent}.m_b59ab47c:where([data-active]):before{content:"";position:absolute;background-color:var(--tab-border-color);bottom:var(--tab-before-bottom, calc(-.0625rem * var(--mantine-scale)));left:var(--tab-before-left, calc(-.0625rem * var(--mantine-scale)));right:var(--tab-before-right, auto);top:var(--tab-before-top, auto);width:calc(.0625rem * var(--mantine-scale));height:calc(.0625rem * var(--mantine-scale))}.m_b59ab47c:where([data-active]):after{content:"";position:absolute;background-color:var(--tab-border-color);bottom:var(--tab-after-bottom, calc(-.0625rem * var(--mantine-scale)));right:var(--tab-after-right, calc(-.0625rem * var(--mantine-scale)));left:var(--tab-after-left, auto);top:var(--tab-after-top, auto);width:calc(.0625rem * var(--mantine-scale));height:calc(.0625rem * var(--mantine-scale))}.m_b59ab47c:where([data-active]){border-top-color:var(--tab-border-top-color);border-bottom-color:var(--tab-border-bottom-color);border-inline-start-color:var(--tab-border-inline-start-color);border-inline-end-color:var(--tab-border-inline-end-color);--tab-border-top-color: var(--tab-border-color);--tab-border-inline-start-color: var(--tab-border-color);--tab-border-inline-end-color: var(--tab-border-color);--tab-border-bottom-color: var(--mantine-color-body)}.m_b59ab47c:where([data-active])[data-inverted]{--tab-border-bottom-color: var(--tab-border-color);--tab-border-top-color: var(--mantine-color-body);--tab-before-bottom: auto;--tab-before-top: calc(-.0625rem * var(--mantine-scale));--tab-after-bottom: auto;--tab-after-top: calc(-.0625rem * var(--mantine-scale))}.m_b59ab47c:where([data-active])[data-orientation=vertical][data-placement=left]{--tab-border-inline-end-color: var(--mantine-color-body);--tab-border-inline-start-color: var(--tab-border-color);--tab-border-bottom-color: var(--tab-border-color);--tab-before-right: calc(-.0625rem * var(--mantine-scale));--tab-before-left: auto;--tab-before-bottom: auto;--tab-before-top: calc(-.0625rem * var(--mantine-scale));--tab-after-left: auto;--tab-after-right: calc(-.0625rem * var(--mantine-scale))}[dir=rtl] .m_b59ab47c:where([data-active])[data-orientation=vertical][data-placement=left]{--tab-before-right: auto;--tab-before-left: calc(-.0625rem * var(--mantine-scale));--tab-after-left: calc(-.0625rem * var(--mantine-scale));--tab-after-right: auto}.m_b59ab47c:where([data-active])[data-orientation=vertical][data-placement=right]{--tab-border-inline-start-color: var(--mantine-color-body);--tab-border-inline-end-color: var(--tab-border-color);--tab-border-bottom-color: var(--tab-border-color);--tab-before-left: calc(-.0625rem * var(--mantine-scale));--tab-before-right: auto;--tab-before-bottom: auto;--tab-before-top: calc(-.0625rem * var(--mantine-scale));--tab-after-right: auto;--tab-after-left: calc(-.0625rem * var(--mantine-scale))}[dir=rtl] .m_b59ab47c:where([data-active])[data-orientation=vertical][data-placement=right]{--tab-before-left: auto;--tab-before-right: calc(-.0625rem * var(--mantine-scale));--tab-after-right: calc(-.0625rem * var(--mantine-scale));--tab-after-left: auto}.m_c3381914{border-radius:var(--tabs-radius);background-color:var(--tab-bg);color:var(--tab-color);--tab-bg: transparent;--tab-color: inherit}@media (hover: hover){.m_c3381914:not([data-disabled]):hover{--tab-bg: var(--tab-hover-color)}}@media (hover: none){.m_c3381914:not([data-disabled]):active{--tab-bg: var(--tab-hover-color)}}.m_c3381914[data-active][data-active]{--tab-bg: var(--tabs-color);--tab-color: var(--tabs-text-color, var(--mantine-color-white))}@media (hover: hover){.m_c3381914[data-active][data-active]:hover{--tab-bg: var(--tabs-color)}}@media (hover: none){.m_c3381914[data-active][data-active]:active{--tab-bg: var(--tabs-color)}}.m_7341320d{--ti-size-xs: calc(1.125rem * var(--mantine-scale));--ti-size-sm: calc(1.375rem * var(--mantine-scale));--ti-size-md: calc(1.75rem * var(--mantine-scale));--ti-size-lg: calc(2.125rem * var(--mantine-scale));--ti-size-xl: calc(2.75rem * var(--mantine-scale));--ti-size: var(--ti-size-md);line-height:1;display:inline-flex;align-items:center;justify-content:center;position:relative;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:var(--ti-size);height:var(--ti-size);min-width:var(--ti-size);min-height:var(--ti-size);border-radius:var(--ti-radius, var(--mantine-radius-default));background:var(--ti-bg, var(--mantine-primary-color-filled));color:var(--ti-color, var(--mantine-color-white));border:var(--ti-bd, 1px solid transparent)}.m_43657ece{--offset: calc(var(--tl-bullet-size) / 2 + var(--tl-line-width) / 2);--tl-bullet-size: calc(1.25rem * var(--mantine-scale));--tl-line-width: calc(.25rem * var(--mantine-scale));--tl-radius: calc(62.5rem * var(--mantine-scale));--tl-color: var(--mantine-primary-color-filled)}.m_43657ece:where([data-align=left]){padding-inline-start:var(--offset)}.m_43657ece:where([data-align=right]){padding-inline-end:var(--offset)}.m_2ebe8099{font-weight:500;line-height:1;margin-bottom:calc(var(--mantine-spacing-xs) / 2)}.m_436178ff{--item-border: var(--tl-line-width) var(--tli-border-style, solid) var(--item-border-color);position:relative;color:var(--mantine-color-text)}.m_436178ff:before{content:"";pointer-events:none;position:absolute;top:0;left:var(--timeline-line-left, 0);right:var(--timeline-line-right, 0);bottom:calc(var(--mantine-spacing-xl) * -1);border-inline-start:var(--item-border);display:var(--timeline-line-display, none)}.m_43657ece[data-align=left] .m_436178ff:before{--timeline-line-left: calc(var(--tl-line-width) * -1);--timeline-line-right: auto}[dir=rtl] .m_43657ece[data-align=left] .m_436178ff:before{--timeline-line-left: auto;--timeline-line-right: calc(var(--tl-line-width) * -1)}.m_43657ece[data-align=right] .m_436178ff:before{--timeline-line-left: auto;--timeline-line-right: calc(var(--tl-line-width) * -1)}[dir=rtl] .m_43657ece[data-align=right] .m_436178ff:before{--timeline-line-left: calc(var(--tl-line-width) * -1);--timeline-line-right: auto}.m_43657ece:where([data-align=left]) .m_436178ff{padding-inline-start:var(--offset);text-align:left}.m_43657ece:where([data-align=right]) .m_436178ff{padding-inline-end:var(--offset);text-align:right}:where([data-mantine-color-scheme=light]) .m_436178ff{--item-border-color: var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_436178ff{--item-border-color: var(--mantine-color-dark-4)}.m_436178ff:where([data-line-active]):before{border-color:var(--tli-color, var(--tl-color))}.m_436178ff:where(:not(:last-of-type)){--timeline-line-display: block}.m_436178ff:where(:not(:first-of-type)){margin-top:var(--mantine-spacing-xl)}.m_8affcee1{width:var(--tl-bullet-size);height:var(--tl-bullet-size);border-radius:var(--tli-radius, var(--tl-radius));border:var(--tl-line-width) solid;background-color:var(--mantine-color-body);position:absolute;top:0;display:flex;align-items:center;justify-content:center;color:var(--mantine-color-text)}:where([data-mantine-color-scheme=light]) .m_8affcee1{border-color:var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_8affcee1{border-color:var(--mantine-color-dark-4)}.m_43657ece:where([data-align=left]) .m_8affcee1{left:calc((var(--tl-bullet-size) / 2 + var(--tl-line-width) / 2) * -1);right:auto}:where([dir=rtl]) .m_43657ece:where([data-align=left]) .m_8affcee1{left:auto;right:calc((var(--tl-bullet-size) / 2 + var(--tl-line-width) / 2) * -1)}.m_43657ece:where([data-align=right]) .m_8affcee1{left:auto;right:calc((var(--tl-bullet-size) / 2 + var(--tl-line-width) / 2) * -1)}:where([dir=rtl]) .m_43657ece:where([data-align=right]) .m_8affcee1{left:calc((var(--tl-bullet-size) / 2 + var(--tl-line-width) / 2) * -1);right:auto}.m_8affcee1:where([data-with-child]){border-width:var(--tl-line-width)}:where([data-mantine-color-scheme=light]) .m_8affcee1:where([data-with-child]){background-color:var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_8affcee1:where([data-with-child]){background-color:var(--mantine-color-dark-4)}.m_8affcee1:where([data-active]){border-color:var(--tli-color, var(--tl-color));background-color:var(--mantine-color-white);color:var(--tl-icon-color, var(--mantine-color-white))}.m_8affcee1:where([data-active]):where([data-with-child]){background-color:var(--tli-color, var(--tl-color));color:var(--tl-icon-color, var(--mantine-color-white))}.m_43657ece:where([data-align=left]) .m_540e8f41{padding-inline-start:var(--offset);text-align:left}:where([dir=rtl]) .m_43657ece:where([data-align=left]) .m_540e8f41{text-align:right}.m_43657ece:where([data-align=right]) .m_540e8f41{padding-inline-end:var(--offset);text-align:right}:where([dir=rtl]) .m_43657ece:where([data-align=right]) .m_540e8f41{text-align:left}.m_8a5d1357{margin:0;font-weight:var(--title-fw);font-size:var(--title-fz);line-height:var(--title-lh);font-family:var(--mantine-font-family-headings);text-wrap:var(--title-text-wrap, var(--mantine-heading-text-wrap))}.m_8a5d1357:where([data-line-clamp]){overflow:hidden;text-overflow:ellipsis;display:-webkit-box;-webkit-line-clamp:var(--title-line-clamp);-webkit-box-orient:vertical}.m_f698e191{--level-offset: var(--mantine-spacing-lg);margin:0;padding:0;-webkit-user-select:none;-moz-user-select:none;user-select:none}.m_75f3ecf{margin:0;padding:0}.m_f6970eb1{cursor:pointer;list-style:none;margin:0;padding:0;outline:0}.m_f6970eb1:focus-visible>.m_dc283425{outline:2px solid var(--mantine-primary-color-filled);outline-offset:calc(.125rem * var(--mantine-scale))}.m_dc283425{padding-inline-start:var(--label-offset)}:where([data-mantine-color-scheme=light]) .m_dc283425:where([data-selected]){background-color:var(--mantine-color-gray-1)}:where([data-mantine-color-scheme=dark]) .m_dc283425:where([data-selected]){background-color:var(--mantine-color-dark-5)}.m_d6493fad :first-child{margin-top:0}.m_d6493fad :last-child{margin-bottom:0}.m_d6493fad :where(h1,h2,h3,h4,h5,h6){margin-bottom:var(--mantine-spacing-xs);text-wrap:var(--mantine-heading-text-wrap)}.m_d6493fad :where(h1){margin-top:calc(1.5 * var(--mantine-spacing-xl));font-size:var(--mantine-h1-font-size);line-height:var(--mantine-h1-line-height);font-weight:var(--mantine-h1-font-weight)}.m_d6493fad :where(h2){margin-top:var(--mantine-spacing-xl);font-size:var(--mantine-h2-font-size);line-height:var(--mantine-h2-line-height);font-weight:var(--mantine-h2-font-weight)}.m_d6493fad :where(h3){margin-top:calc(.8 * var(--mantine-spacing-xl));font-size:var(--mantine-h3-font-size);line-height:var(--mantine-h3-line-height);font-weight:var(--mantine-h3-font-weight)}.m_d6493fad :where(h4){margin-top:calc(.8 * var(--mantine-spacing-xl));font-size:var(--mantine-h4-font-size);line-height:var(--mantine-h4-line-height);font-weight:var(--mantine-h4-font-weight)}.m_d6493fad :where(h5){margin-top:calc(.5 * var(--mantine-spacing-xl));font-size:var(--mantine-h5-font-size);line-height:var(--mantine-h5-line-height);font-weight:var(--mantine-h5-font-weight)}.m_d6493fad :where(h6){margin-top:calc(.5 * var(--mantine-spacing-xl));font-size:var(--mantine-h6-font-size);line-height:var(--mantine-h6-line-height);font-weight:var(--mantine-h6-font-weight)}.m_d6493fad :where(img){max-width:100%;margin-bottom:var(--mantine-spacing-xs)}.m_d6493fad :where(p){margin-top:0;margin-bottom:var(--mantine-spacing-lg)}:where([data-mantine-color-scheme=light]) .m_d6493fad :where(mark){background-color:var(--mantine-color-yellow-2);color:inherit}:where([data-mantine-color-scheme=dark]) .m_d6493fad :where(mark){background-color:var(--mantine-color-yellow-5);color:var(--mantine-color-black)}.m_d6493fad :where(a){color:var(--mantine-color-anchor);text-decoration:none}@media (hover: hover){.m_d6493fad :where(a):hover{text-decoration:underline}}@media (hover: none){.m_d6493fad :where(a):active{text-decoration:underline}}.m_d6493fad :where(hr){margin-top:var(--mantine-spacing-md);margin-bottom:var(--mantine-spacing-md);border:0;border-top:calc(.0625rem * var(--mantine-scale)) solid}:where([data-mantine-color-scheme=light]) .m_d6493fad :where(hr){border-color:var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_d6493fad :where(hr){border-color:var(--mantine-color-dark-3)}.m_d6493fad :where(pre){padding:var(--mantine-spacing-xs);line-height:var(--mantine-line-height);margin:0;margin-top:var(--mantine-spacing-md);margin-bottom:var(--mantine-spacing-md);overflow-x:auto;font-family:var(--mantine-font-family-monospace);font-size:var(--mantine-font-size-xs);border-radius:var(--mantine-radius-sm)}:where([data-mantine-color-scheme=light]) .m_d6493fad :where(pre){background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_d6493fad :where(pre){background-color:var(--mantine-color-dark-8)}.m_d6493fad :where(pre) :where(code){background-color:transparent;padding:0;border-radius:0;color:inherit;border:0}.m_d6493fad :where(kbd){--kbd-fz: calc(.75rem * var(--mantine-scale));--kbd-padding: calc(.1875rem * var(--mantine-scale)) calc(.3125rem * var(--mantine-scale));font-family:var(--mantine-font-family-monospace);line-height:var(--mantine-line-height);font-weight:700;padding:var(--kbd-padding);font-size:var(--kbd-fz);border-radius:var(--mantine-radius-sm);border:calc(.0625rem * var(--mantine-scale)) solid;border-bottom-width:calc(.1875rem * var(--mantine-scale))}:where([data-mantine-color-scheme=light]) .m_d6493fad :where(kbd){border-color:var(--mantine-color-gray-3);color:var(--mantine-color-gray-7);background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_d6493fad :where(kbd){border-color:var(--mantine-color-dark-3);color:var(--mantine-color-dark-0);background-color:var(--mantine-color-dark-5)}.m_d6493fad :where(code){line-height:var(--mantine-line-height);padding:calc(.0625rem * var(--mantine-scale)) calc(.3125rem * var(--mantine-scale));border-radius:var(--mantine-radius-sm);font-family:var(--mantine-font-family-monospace);font-size:var(--mantine-font-size-xs)}:where([data-mantine-color-scheme=light]) .m_d6493fad :where(code){background-color:var(--mantine-color-gray-0);color:var(--mantine-color-black)}:where([data-mantine-color-scheme=dark]) .m_d6493fad :where(code){background-color:var(--mantine-color-dark-5);color:var(--mantine-color-white)}.m_d6493fad :where(ul,ol):not([data-type=taskList]){margin-bottom:var(--mantine-spacing-md);padding-inline-start:calc(2.375rem * var(--mantine-scale))}.m_d6493fad :where(ul,ol):not([data-type=taskList]) :where(li){margin-bottom:var(--mantine-spacing-xs)}.m_d6493fad :where(table){width:100%;border-collapse:collapse;caption-side:bottom;margin-bottom:var(--mantine-spacing-md)}:where([data-mantine-color-scheme=light]) .m_d6493fad :where(table){--table-border-color: var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_d6493fad :where(table){--table-border-color: var(--mantine-color-dark-4)}.m_d6493fad :where(table) :where(caption){margin-top:var(--mantine-spacing-xs);font-size:var(--mantine-font-size-sm);color:var(--mantine-color-dimmed)}.m_d6493fad :where(table) :where(th){text-align:left;font-weight:700;font-size:var(--mantine-font-size-sm);padding:var(--mantine-spacing-xs) var(--mantine-spacing-sm)}.m_d6493fad :where(table) :where(thead th){border-bottom:calc(.0625rem * var(--mantine-scale)) solid;border-color:var(--table-border-color)}.m_d6493fad :where(table) :where(tfoot th){border-top:calc(.0625rem * var(--mantine-scale)) solid;border-color:var(--table-border-color)}.m_d6493fad :where(table) :where(td){padding:var(--mantine-spacing-xs) var(--mantine-spacing-sm);border-bottom:calc(.0625rem * var(--mantine-scale)) solid;border-color:var(--table-border-color);font-size:var(--mantine-font-size-sm)}.m_d6493fad :where(table) :where(tr:last-of-type td){border-bottom:0}.m_d6493fad :where(blockquote){font-size:var(--mantine-font-size-lg);line-height:var(--mantine-line-height);margin:var(--mantine-spacing-md) 0;border-radius:var(--mantine-radius-sm);padding:var(--mantine-spacing-md) var(--mantine-spacing-lg)}:where([data-mantine-color-scheme=light]) .m_d6493fad :where(blockquote){background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_d6493fad :where(blockquote){background-color:var(--mantine-color-dark-8)}.m_d2b315db[data-scrollable]{--spotlight-content-height: 100%}.m_3cd250e0{overflow:hidden;height:var(--spotlight-content-height, auto);max-height:var(--spotlight-max-height)}.m_d2abce9b{display:flex;flex-direction:column;height:var(--spotlight-content-height, auto)}.m_f366a061{border:0;background-color:transparent}.m_6e463822{--spotlight-actions-list-padding: calc(.25rem * var(--mantine-scale));border-top:calc(.0625rem * var(--mantine-scale)) solid;flex:1;padding:var(--spotlight-actions-list-padding);max-height:calc(100% - 3.125rem);margin-inline-end:calc(var(--spotlight-actions-list-padding) * -1)}:where([data-mantine-color-scheme=light]) .m_6e463822{border-color:var(--mantine-color-gray-2)}:where([data-mantine-color-scheme=dark]) .m_6e463822{border-color:var(--mantine-color-dark-4)}.m_d49bb8ef{display:flex;align-items:center;width:100%;padding:7px var(--mantine-spacing-md);border-radius:var(--mantine-radius-default);background-color:transparent;color:inherit;text-align:left}:where([dir=rtl]) .m_d49bb8ef{text-align:right}@media (hover: hover){:where([data-mantine-color-scheme=light]) .m_d49bb8ef:where(:not([data-selected])):hover{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_d49bb8ef:where(:not([data-selected])):hover{background-color:var(--mantine-color-dark-6)}}@media (hover: none){:where([data-mantine-color-scheme=light]) .m_d49bb8ef:where(:not([data-selected])):active{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_d49bb8ef:where(:not([data-selected])):active{background-color:var(--mantine-color-dark-6)}}.m_d49bb8ef:where([data-selected]){background-color:var(--mantine-primary-color-filled);color:var(--mantine-primary-color-contrast, var(--mantine-color-white));--action-description-color: var(--mantine-primary-color-contrast, var(--mantine-color-white));--action-description-opacity: .7}.m_3d475731{flex:1}.m_832642f6{opacity:1;color:inherit}.m_832642f6:where([data-dimmed]){opacity:var(--action-description-opacity, 1);color:var(--action-description-color, var(--mantine-color-dimmed))}.m_832642f6:where([data-position=left]){margin-inline-end:var(--mantine-spacing-md)}.m_832642f6:where([data-position=right]){margin-inline-start:var(--mantine-spacing-md)}.m_832642f6>svg{display:block}.m_6c2a1345{display:block}.m_a6d9d78d{display:block;font-size:var(--mantine-font-size-xs);opacity:var(--action-description-opacity, 1);color:var(--action-description-color, var(--mantine-color-dimmed))}.m_82f78f74{color:var(--mantine-color-dimmed);padding:var(--mantine-spacing-md);text-align:center}.m_ddcaf054{padding:var(--mantine-spacing-xs) calc(var(--mantine-spacing-md) + calc(.25rem * var(--mantine-scale)));border-top:calc(.0625rem * var(--mantine-scale)) solid}:where([data-mantine-color-scheme=light]) .m_ddcaf054{border-color:var(--mantine-color-gray-2)}:where([data-mantine-color-scheme=dark]) .m_ddcaf054{border-color:var(--mantine-color-dark-4)}.m_5a3e5f7b{display:flex;flex-direction:column;margin-top:var(--mantine-spacing-md)}.m_5a3e5f7b:before{content:var(--spotlight-label);text-transform:uppercase;font-size:var(--mantine-font-size-xs);font-weight:700;color:var(--mantine-color-dimmed);padding-inline-start:var(--mantine-spacing-md)}.m_5a3e5f7b:empty{display:none}.react-flow{direction:ltr;--xy-edge-stroke-default: #b1b1b7;--xy-edge-stroke-width-default: 1;--xy-edge-stroke-selected-default: #555;--xy-connectionline-stroke-default: #b1b1b7;--xy-connectionline-stroke-width-default: 1;--xy-attribution-background-color-default: rgba(255, 255, 255, .5);--xy-minimap-background-color-default: #fff;--xy-minimap-mask-background-color-default: rgb(240, 240, 240, .6);--xy-minimap-mask-stroke-color-default: transparent;--xy-minimap-mask-stroke-width-default: 1;--xy-minimap-node-background-color-default: #e2e2e2;--xy-minimap-node-stroke-color-default: transparent;--xy-minimap-node-stroke-width-default: 2;--xy-background-color-default: transparent;--xy-background-pattern-dots-color-default: #91919a;--xy-background-pattern-lines-color-default: #eee;--xy-background-pattern-cross-color-default: #e2e2e2;background-color:var(--xy-background-color, var(--xy-background-color-default));--xy-node-color-default: inherit;--xy-node-border-default: 1px solid #1a192b;--xy-node-background-color-default: #fff;--xy-node-group-background-color-default: rgba(240, 240, 240, .25);--xy-node-boxshadow-hover-default: 0 1px 4px 1px rgba(0, 0, 0, .08);--xy-node-boxshadow-selected-default: 0 0 0 .5px #1a192b;--xy-node-border-radius-default: 3px;--xy-handle-background-color-default: #1a192b;--xy-handle-border-color-default: #fff;--xy-selection-background-color-default: rgba(0, 89, 220, .08);--xy-selection-border-default: 1px dotted rgba(0, 89, 220, .8);--xy-controls-button-background-color-default: #fefefe;--xy-controls-button-background-color-hover-default: #f4f4f4;--xy-controls-button-color-default: inherit;--xy-controls-button-color-hover-default: inherit;--xy-controls-button-border-color-default: #eee;--xy-controls-box-shadow-default: 0 0 2px 1px rgba(0, 0, 0, .08);--xy-edge-label-background-color-default: #ffffff;--xy-edge-label-color-default: inherit;--xy-resize-background-color-default: #3367d9}.react-flow.dark{--xy-edge-stroke-default: #3e3e3e;--xy-edge-stroke-width-default: 1;--xy-edge-stroke-selected-default: #727272;--xy-connectionline-stroke-default: #b1b1b7;--xy-connectionline-stroke-width-default: 1;--xy-attribution-background-color-default: rgba(150, 150, 150, .25);--xy-minimap-background-color-default: #141414;--xy-minimap-mask-background-color-default: rgb(60, 60, 60, .6);--xy-minimap-mask-stroke-color-default: transparent;--xy-minimap-mask-stroke-width-default: 1;--xy-minimap-node-background-color-default: #2b2b2b;--xy-minimap-node-stroke-color-default: transparent;--xy-minimap-node-stroke-width-default: 2;--xy-background-color-default: #141414;--xy-background-pattern-dots-color-default: #777;--xy-background-pattern-lines-color-default: #777;--xy-background-pattern-cross-color-default: #777;--xy-node-color-default: #f8f8f8;--xy-node-border-default: 1px solid #3c3c3c;--xy-node-background-color-default: #1e1e1e;--xy-node-group-background-color-default: rgba(240, 240, 240, .25);--xy-node-boxshadow-hover-default: 0 1px 4px 1px rgba(255, 255, 255, .08);--xy-node-boxshadow-selected-default: 0 0 0 .5px #999;--xy-handle-background-color-default: #bebebe;--xy-handle-border-color-default: #1e1e1e;--xy-selection-background-color-default: rgba(200, 200, 220, .08);--xy-selection-border-default: 1px dotted rgba(200, 200, 220, .8);--xy-controls-button-background-color-default: #2b2b2b;--xy-controls-button-background-color-hover-default: #3e3e3e;--xy-controls-button-color-default: #f8f8f8;--xy-controls-button-color-hover-default: #fff;--xy-controls-button-border-color-default: #5b5b5b;--xy-controls-box-shadow-default: 0 0 2px 1px rgba(0, 0, 0, .08);--xy-edge-label-background-color-default: #141414;--xy-edge-label-color-default: #f8f8f8}.react-flow__background{background-color:var(--xy-background-color, var(--xy-background-color-props, var(--xy-background-color-default)));pointer-events:none;z-index:-1}.react-flow__container{position:absolute;width:100%;height:100%;top:0;left:0}.react-flow__pane{z-index:1}.react-flow__pane.draggable{cursor:grab}.react-flow__pane.dragging{cursor:grabbing}.react-flow__pane.selection{cursor:pointer}.react-flow__viewport{transform-origin:0 0;z-index:2;pointer-events:none}.react-flow__renderer{z-index:4}.react-flow__selection{z-index:6}.react-flow__nodesselection-rect:focus,.react-flow__nodesselection-rect:focus-visible{outline:none}.react-flow__edge-path{stroke:var(--xy-edge-stroke, var(--xy-edge-stroke-default));stroke-width:var(--xy-edge-stroke-width, var(--xy-edge-stroke-width-default));fill:none}.react-flow__connection-path{stroke:var(--xy-connectionline-stroke, var(--xy-connectionline-stroke-default));stroke-width:var(--xy-connectionline-stroke-width, var(--xy-connectionline-stroke-width-default));fill:none}.react-flow .react-flow__edges{position:absolute}.react-flow .react-flow__edges svg{overflow:visible;position:absolute;pointer-events:none}.react-flow__edge{pointer-events:visibleStroke}.react-flow__edge.selectable{cursor:pointer}.react-flow__edge.animated path{stroke-dasharray:5;animation:dashdraw .5s linear infinite}.react-flow__edge.animated path.react-flow__edge-interaction{stroke-dasharray:none;animation:none}.react-flow__edge.inactive{pointer-events:none}.react-flow__edge.selected,.react-flow__edge:focus,.react-flow__edge:focus-visible{outline:none}.react-flow__edge.selected .react-flow__edge-path,.react-flow__edge.selectable:focus .react-flow__edge-path,.react-flow__edge.selectable:focus-visible .react-flow__edge-path{stroke:var(--xy-edge-stroke-selected, var(--xy-edge-stroke-selected-default))}.react-flow__edge-textwrapper{pointer-events:all}.react-flow__edge .react-flow__edge-text{pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.react-flow__connection{pointer-events:none}.react-flow__connection .animated{stroke-dasharray:5;animation:dashdraw .5s linear infinite}svg.react-flow__connectionline{z-index:1001;overflow:visible;position:absolute}.react-flow__nodes{pointer-events:none;transform-origin:0 0}.react-flow__node{position:absolute;-webkit-user-select:none;-moz-user-select:none;user-select:none;pointer-events:all;transform-origin:0 0;box-sizing:border-box;cursor:default}.react-flow__node.selectable{cursor:pointer}.react-flow__node.draggable{cursor:grab;pointer-events:all}.react-flow__node.draggable.dragging{cursor:grabbing}.react-flow__nodesselection{z-index:3;transform-origin:left top;pointer-events:none}.react-flow__nodesselection-rect{position:absolute;pointer-events:all;cursor:grab}.react-flow__handle{position:absolute;pointer-events:none;min-width:5px;min-height:5px;width:6px;height:6px;background-color:var(--xy-handle-background-color, var(--xy-handle-background-color-default));border:1px solid var(--xy-handle-border-color, var(--xy-handle-border-color-default));border-radius:100%}.react-flow__handle.connectingfrom{pointer-events:all}.react-flow__handle.connectionindicator{pointer-events:all;cursor:crosshair}.react-flow__handle-bottom{top:auto;left:50%;bottom:0;transform:translate(-50%,50%)}.react-flow__handle-top{top:0;left:50%;transform:translate(-50%,-50%)}.react-flow__handle-left{top:50%;left:0;transform:translate(-50%,-50%)}.react-flow__handle-right{top:50%;right:0;transform:translate(50%,-50%)}.react-flow__edgeupdater{cursor:move;pointer-events:all}.react-flow__panel{position:absolute;z-index:5;margin:15px}.react-flow__panel.top{top:0}.react-flow__panel.bottom{bottom:0}.react-flow__panel.left{left:0}.react-flow__panel.right{right:0}.react-flow__panel.center{left:50%;transform:translate(-50%)}.react-flow__attribution{font-size:10px;background:var(--xy-attribution-background-color, var(--xy-attribution-background-color-default));padding:2px 3px;margin:0}.react-flow__attribution a{text-decoration:none;color:#999}@keyframes dashdraw{0%{stroke-dashoffset:10}}.react-flow__edgelabel-renderer{position:absolute;width:100%;height:100%;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;left:0;top:0}.react-flow__viewport-portal{position:absolute;width:100%;height:100%;left:0;top:0;-webkit-user-select:none;-moz-user-select:none;user-select:none}.react-flow__minimap{background:var( --xy-minimap-background-color-props, var(--xy-minimap-background-color, var(--xy-minimap-background-color-default)) )}.react-flow__minimap-svg{display:block}.react-flow__minimap-mask{fill:var( --xy-minimap-mask-background-color-props, var(--xy-minimap-mask-background-color, var(--xy-minimap-mask-background-color-default)) );stroke:var( --xy-minimap-mask-stroke-color-props, var(--xy-minimap-mask-stroke-color, var(--xy-minimap-mask-stroke-color-default)) );stroke-width:var( --xy-minimap-mask-stroke-width-props, var(--xy-minimap-mask-stroke-width, var(--xy-minimap-mask-stroke-width-default)) )}.react-flow__minimap-node{fill:var( --xy-minimap-node-background-color-props, var(--xy-minimap-node-background-color, var(--xy-minimap-node-background-color-default)) );stroke:var( --xy-minimap-node-stroke-color-props, var(--xy-minimap-node-stroke-color, var(--xy-minimap-node-stroke-color-default)) );stroke-width:var( --xy-minimap-node-stroke-width-props, var(--xy-minimap-node-stroke-width, var(--xy-minimap-node-stroke-width-default)) )}.react-flow__background-pattern.dots{fill:var( --xy-background-pattern-color-props, var(--xy-background-pattern-color, var(--xy-background-pattern-dots-color-default)) )}.react-flow__background-pattern.lines{stroke:var( --xy-background-pattern-color-props, var(--xy-background-pattern-color, var(--xy-background-pattern-lines-color-default)) )}.react-flow__background-pattern.cross{stroke:var( --xy-background-pattern-color-props, var(--xy-background-pattern-color, var(--xy-background-pattern-cross-color-default)) )}.react-flow__controls{display:flex;flex-direction:column;box-shadow:var(--xy-controls-box-shadow, var(--xy-controls-box-shadow-default))}.react-flow__controls.horizontal{flex-direction:row}.react-flow__controls-button{display:flex;justify-content:center;align-items:center;height:26px;width:26px;padding:4px;border:none;background:var(--xy-controls-button-background-color, var(--xy-controls-button-background-color-default));border-bottom:1px solid var( --xy-controls-button-border-color-props, var(--xy-controls-button-border-color, var(--xy-controls-button-border-color-default)) );color:var( --xy-controls-button-color-props, var(--xy-controls-button-color, var(--xy-controls-button-color-default)) );cursor:pointer;-webkit-user-select:none;-moz-user-select:none;user-select:none}.react-flow__controls-button svg{width:100%;max-width:12px;max-height:12px;fill:currentColor}.react-flow__edge.updating .react-flow__edge-path{stroke:#777}.react-flow__edge-text{font-size:10px}.react-flow__node.selectable:focus,.react-flow__node.selectable:focus-visible{outline:none}.react-flow__node-input,.react-flow__node-default,.react-flow__node-output,.react-flow__node-group{padding:10px;border-radius:var(--xy-node-border-radius, var(--xy-node-border-radius-default));width:150px;font-size:12px;color:var(--xy-node-color, var(--xy-node-color-default));text-align:center;border:var(--xy-node-border, var(--xy-node-border-default));background-color:var(--xy-node-background-color, var(--xy-node-background-color-default))}.react-flow__node-input.selectable:hover,.react-flow__node-default.selectable:hover,.react-flow__node-output.selectable:hover,.react-flow__node-group.selectable:hover{box-shadow:var(--xy-node-boxshadow-hover, var(--xy-node-boxshadow-hover-default))}.react-flow__node-input.selectable.selected,.react-flow__node-input.selectable:focus,.react-flow__node-input.selectable:focus-visible,.react-flow__node-default.selectable.selected,.react-flow__node-default.selectable:focus,.react-flow__node-default.selectable:focus-visible,.react-flow__node-output.selectable.selected,.react-flow__node-output.selectable:focus,.react-flow__node-output.selectable:focus-visible,.react-flow__node-group.selectable.selected,.react-flow__node-group.selectable:focus,.react-flow__node-group.selectable:focus-visible{box-shadow:var(--xy-node-boxshadow-selected, var(--xy-node-boxshadow-selected-default))}.react-flow__node-group{background-color:var(--xy-node-group-background-color, var(--xy-node-group-background-color-default))}.react-flow__nodesselection-rect,.react-flow__selection{background:var(--xy-selection-background-color, var(--xy-selection-background-color-default));border:var(--xy-selection-border, var(--xy-selection-border-default))}.react-flow__nodesselection-rect:focus,.react-flow__nodesselection-rect:focus-visible,.react-flow__selection:focus,.react-flow__selection:focus-visible{outline:none}.react-flow__controls-button:hover{background:var( --xy-controls-button-background-color-hover-props, var(--xy-controls-button-background-color-hover, var(--xy-controls-button-background-color-hover-default)) );color:var( --xy-controls-button-color-hover-props, var(--xy-controls-button-color-hover, var(--xy-controls-button-color-hover-default)) )}.react-flow__controls-button:disabled{pointer-events:none}.react-flow__controls-button:disabled svg{fill-opacity:.4}.react-flow__controls-button:last-child{border-bottom:none}.react-flow__resize-control{position:absolute}.react-flow__resize-control.left,.react-flow__resize-control.right{cursor:ew-resize}.react-flow__resize-control.top,.react-flow__resize-control.bottom{cursor:ns-resize}.react-flow__resize-control.top.left,.react-flow__resize-control.bottom.right{cursor:nwse-resize}.react-flow__resize-control.bottom.left,.react-flow__resize-control.top.right{cursor:nesw-resize}.react-flow__resize-control.handle{width:4px;height:4px;border:1px solid #fff;border-radius:1px;background-color:var(--xy-resize-background-color, var(--xy-resize-background-color-default));transform:translate(-50%,-50%)}.react-flow__resize-control.handle.left{left:0;top:50%}.react-flow__resize-control.handle.right{left:100%;top:50%}.react-flow__resize-control.handle.top{left:50%;top:0}.react-flow__resize-control.handle.bottom{left:50%;top:100%}.react-flow__resize-control.handle.top.left,.react-flow__resize-control.handle.bottom.left{left:0}.react-flow__resize-control.handle.top.right,.react-flow__resize-control.handle.bottom.right{left:100%}.react-flow__resize-control.line{border-color:var(--xy-resize-background-color, var(--xy-resize-background-color-default));border-width:0;border-style:solid}.react-flow__resize-control.line.left,.react-flow__resize-control.line.right{width:1px;transform:translate(-50%);top:0;height:100%}.react-flow__resize-control.line.left{left:0;border-left-width:1px}.react-flow__resize-control.line.right{left:100%;border-right-width:1px}.react-flow__resize-control.line.top,.react-flow__resize-control.line.bottom{height:1px;transform:translateY(-50%);left:0;width:100%}.react-flow__resize-control.line.top{top:0;border-top-width:1px}.react-flow__resize-control.line.bottom{border-bottom-width:1px;top:100%}.react-flow__edge-textbg{fill:var(--xy-edge-label-background-color, var(--xy-edge-label-background-color-default))}.react-flow__edge-text{fill:var(--xy-edge-label-color, var(--xy-edge-label-color-default))}.likec4-diagram-root{overflow:hidden;position:relative;width:100%;height:100%;padding:0;margin:0;box-sizing:border-box;-webkit-font-smoothing:var(--mantine-webkit-font-smoothing);-moz-osx-font-smoothing:var(--mantine-moz-font-smoothing)}:where(.likec4-diagram-root) .mantine-ActionIcon-icon .tabler-icon{width:75%;height:75%}.likec4-diagram-root{--likec4-font-family: var(--likec4-default-font-family,'ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji"');--likec4-background-color: var(--mantine-color-body);--likec4-background-pattern-color: var(--mantine-color-gray-4);--likec4-compound-font-family: var(--likec4-font-family);--likec4-compound-title-color: var(--likec4-element-loContrast);--likec4-element-font-family: var(--likec4-font-family);--likec4-element-fill: #3b82f6;--likec4-element-stroke: #2563eb;--likec4-element-hiContrast: #eff6ff;--likec4-element-loContrast: #bfdbfe;--likec4-relation-lineColor: #64748b;--likec4-relation-labelBg: #0f172a;--likec4-relation-labelColor: #cbd5e1}:where([data-mantine-color-scheme=dark]) .likec4-diagram-root{--likec4-background-pattern-color: var(--mantine-color-dark-5)}:where([data-likec4-color=primary]){--likec4-element-fill: #3b82f6;--likec4-element-stroke: #2563eb;--likec4-element-hiContrast: #eff6ff;--likec4-element-loContrast: #bfdbfe;--likec4-compound-title-color: #bfdbfe;--likec4-relation-lineColor: #3b82f6;--likec4-relation-labelBg: #172554;--likec4-relation-labelColor: #60a5fa}:where([data-likec4-color=primary][data-compound-depth="1"]){--likec4-element-fill: #145ed7;--likec4-element-stroke: #194bb8}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=primary][data-compound-depth="1"]){--likec4-element-fill: #1a5bc5;--likec4-element-stroke: #1e49a9}:where([data-likec4-color=primary][data-compound-depth="2"]){--likec4-element-fill: #195cc8;--likec4-element-stroke: #1d4aac}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=primary][data-compound-depth="2"]){--likec4-element-fill: #1e56b1;--likec4-element-stroke: #204698}:where([data-likec4-color=primary][data-compound-depth="3"]){--likec4-element-fill: #1e59ba;--likec4-element-stroke: #2149a0}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=primary][data-compound-depth="3"]){--likec4-element-fill: #21519f;--likec4-element-stroke: #224289}:where([data-likec4-color=primary][data-compound-depth="4"]){--likec4-element-fill: #2357ad;--likec4-element-stroke: #244795}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=primary][data-compound-depth="4"]){--likec4-element-fill: #234c8e;--likec4-element-stroke: #243f7a}:where([data-likec4-color=primary][data-compound-depth="5"]){--likec4-element-fill: #2755a0;--likec4-element-stroke: #27468a}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=primary][data-compound-depth="5"]){--likec4-element-fill: #25467d;--likec4-element-stroke: #243b6c}:where([data-likec4-color=primary][data-compound-depth="6"]){--likec4-element-fill: #2a5293;--likec4-element-stroke: #2a447f}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=primary][data-compound-depth="6"]){--likec4-element-fill: #25416d;--likec4-element-stroke: #24365f}:where([data-likec4-color=blue]){--likec4-element-fill: #3b82f6;--likec4-element-stroke: #2563eb;--likec4-element-hiContrast: #eff6ff;--likec4-element-loContrast: #bfdbfe;--likec4-compound-title-color: #bfdbfe;--likec4-relation-lineColor: #3b82f6;--likec4-relation-labelBg: #172554;--likec4-relation-labelColor: #60a5fa}:where([data-likec4-color=blue][data-compound-depth="1"]){--likec4-element-fill: #145ed7;--likec4-element-stroke: #194bb8}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=blue][data-compound-depth="1"]){--likec4-element-fill: #1a5bc5;--likec4-element-stroke: #1e49a9}:where([data-likec4-color=blue][data-compound-depth="2"]){--likec4-element-fill: #195cc8;--likec4-element-stroke: #1d4aac}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=blue][data-compound-depth="2"]){--likec4-element-fill: #1e56b1;--likec4-element-stroke: #204698}:where([data-likec4-color=blue][data-compound-depth="3"]){--likec4-element-fill: #1e59ba;--likec4-element-stroke: #2149a0}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=blue][data-compound-depth="3"]){--likec4-element-fill: #21519f;--likec4-element-stroke: #224289}:where([data-likec4-color=blue][data-compound-depth="4"]){--likec4-element-fill: #2357ad;--likec4-element-stroke: #244795}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=blue][data-compound-depth="4"]){--likec4-element-fill: #234c8e;--likec4-element-stroke: #243f7a}:where([data-likec4-color=blue][data-compound-depth="5"]){--likec4-element-fill: #2755a0;--likec4-element-stroke: #27468a}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=blue][data-compound-depth="5"]){--likec4-element-fill: #25467d;--likec4-element-stroke: #243b6c}:where([data-likec4-color=blue][data-compound-depth="6"]){--likec4-element-fill: #2a5293;--likec4-element-stroke: #2a447f}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=blue][data-compound-depth="6"]){--likec4-element-fill: #25416d;--likec4-element-stroke: #24365f}:where([data-likec4-color=secondary]){--likec4-element-fill: #0284c7;--likec4-element-stroke: #0369a1;--likec4-element-hiContrast: #f0f9ff;--likec4-element-loContrast: #B6ECF7;--likec4-compound-title-color: #B6ECF7;--likec4-relation-lineColor: #0ea5e9;--likec4-relation-labelBg: #082f49;--likec4-relation-labelColor: #38bdf8}:where([data-likec4-color=secondary][data-compound-depth="1"]){--likec4-element-fill: #086392;--likec4-element-stroke: #084f76}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=secondary][data-compound-depth="1"]){--likec4-element-fill: #0d5d86;--likec4-element-stroke: #0b4a6c}:where([data-likec4-color=secondary][data-compound-depth="2"]){--likec4-element-fill: #0c5e88;--likec4-element-stroke: #0b4b6e}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=secondary][data-compound-depth="2"]){--likec4-element-fill: #105579;--likec4-element-stroke: #0e4462}:where([data-likec4-color=secondary][data-compound-depth="3"]){--likec4-element-fill: #10597f;--likec4-element-stroke: #0e4767}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=secondary][data-compound-depth="3"]){--likec4-element-fill: #134e6c;--likec4-element-stroke: #103e57}:where([data-likec4-color=secondary][data-compound-depth="4"]){--likec4-element-fill: #135475;--likec4-element-stroke: #11435f}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=secondary][data-compound-depth="4"]){--likec4-element-fill: #154660;--likec4-element-stroke: #11384e}:where([data-likec4-color=secondary][data-compound-depth="5"]){--likec4-element-fill: #164f6c;--likec4-element-stroke: #133f58}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=secondary][data-compound-depth="5"]){--likec4-element-fill: #163f55;--likec4-element-stroke: #123345}:where([data-likec4-color=secondary][data-compound-depth="6"]){--likec4-element-fill: #194a64;--likec4-element-stroke: #153c51}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=secondary][data-compound-depth="6"]){--likec4-element-fill: #17384a;--likec4-element-stroke: #132d3c}:where([data-likec4-color=sky]){--likec4-element-fill: #0284c7;--likec4-element-stroke: #0369a1;--likec4-element-hiContrast: #f0f9ff;--likec4-element-loContrast: #B6ECF7;--likec4-compound-title-color: #B6ECF7;--likec4-relation-lineColor: #0ea5e9;--likec4-relation-labelBg: #082f49;--likec4-relation-labelColor: #38bdf8}:where([data-likec4-color=sky][data-compound-depth="1"]){--likec4-element-fill: #086392;--likec4-element-stroke: #084f76}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=sky][data-compound-depth="1"]){--likec4-element-fill: #0d5d86;--likec4-element-stroke: #0b4a6c}:where([data-likec4-color=sky][data-compound-depth="2"]){--likec4-element-fill: #0c5e88;--likec4-element-stroke: #0b4b6e}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=sky][data-compound-depth="2"]){--likec4-element-fill: #105579;--likec4-element-stroke: #0e4462}:where([data-likec4-color=sky][data-compound-depth="3"]){--likec4-element-fill: #10597f;--likec4-element-stroke: #0e4767}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=sky][data-compound-depth="3"]){--likec4-element-fill: #134e6c;--likec4-element-stroke: #103e57}:where([data-likec4-color=sky][data-compound-depth="4"]){--likec4-element-fill: #135475;--likec4-element-stroke: #11435f}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=sky][data-compound-depth="4"]){--likec4-element-fill: #154660;--likec4-element-stroke: #11384e}:where([data-likec4-color=sky][data-compound-depth="5"]){--likec4-element-fill: #164f6c;--likec4-element-stroke: #133f58}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=sky][data-compound-depth="5"]){--likec4-element-fill: #163f55;--likec4-element-stroke: #123345}:where([data-likec4-color=sky][data-compound-depth="6"]){--likec4-element-fill: #194a64;--likec4-element-stroke: #153c51}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=sky][data-compound-depth="6"]){--likec4-element-fill: #17384a;--likec4-element-stroke: #132d3c}:where([data-likec4-color=muted]){--likec4-element-fill: #64748b;--likec4-element-stroke: #475569;--likec4-element-hiContrast: #f8fafc;--likec4-element-loContrast: #cbd5e1;--likec4-compound-title-color: #cbd5e1;--likec4-relation-lineColor: #64748b;--likec4-relation-labelBg: #0f172a;--likec4-relation-labelColor: #cbd5e1}:where([data-likec4-color=muted][data-compound-depth="1"]){--likec4-element-fill: #4e5a6a;--likec4-element-stroke: #384250}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=muted][data-compound-depth="1"]){--likec4-element-fill: #4b5563;--likec4-element-stroke: #363e4b}:where([data-likec4-color=muted][data-compound-depth="2"]){--likec4-element-fill: #4c5665;--likec4-element-stroke: #363f4c}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=muted][data-compound-depth="2"]){--likec4-element-fill: #474f5c;--likec4-element-stroke: #333a45}:where([data-likec4-color=muted][data-compound-depth="3"]){--likec4-element-fill: #4a5360;--likec4-element-stroke: #353d48}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=muted][data-compound-depth="3"]){--likec4-element-fill: #424a54;--likec4-element-stroke: #30363f}:where([data-likec4-color=muted][data-compound-depth="4"]){--likec4-element-fill: #48505b;--likec4-element-stroke: #333a44}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=muted][data-compound-depth="4"]){--likec4-element-fill: #3e444d;--likec4-element-stroke: #2d323a}:where([data-likec4-color=muted][data-compound-depth="5"]){--likec4-element-fill: #454c56;--likec4-element-stroke: #323841}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=muted][data-compound-depth="5"]){--likec4-element-fill: #393e46;--likec4-element-stroke: #292e34}:where([data-likec4-color=muted][data-compound-depth="6"]){--likec4-element-fill: #434951;--likec4-element-stroke: #30353d}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=muted][data-compound-depth="6"]){--likec4-element-fill: #34383e;--likec4-element-stroke: #26292f}:where([data-likec4-color=slate]){--likec4-element-fill: #64748b;--likec4-element-stroke: #475569;--likec4-element-hiContrast: #f8fafc;--likec4-element-loContrast: #cbd5e1;--likec4-compound-title-color: #cbd5e1;--likec4-relation-lineColor: #64748b;--likec4-relation-labelBg: #0f172a;--likec4-relation-labelColor: #cbd5e1}:where([data-likec4-color=slate][data-compound-depth="1"]){--likec4-element-fill: #4e5a6a;--likec4-element-stroke: #384250}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=slate][data-compound-depth="1"]){--likec4-element-fill: #4b5563;--likec4-element-stroke: #363e4b}:where([data-likec4-color=slate][data-compound-depth="2"]){--likec4-element-fill: #4c5665;--likec4-element-stroke: #363f4c}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=slate][data-compound-depth="2"]){--likec4-element-fill: #474f5c;--likec4-element-stroke: #333a45}:where([data-likec4-color=slate][data-compound-depth="3"]){--likec4-element-fill: #4a5360;--likec4-element-stroke: #353d48}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=slate][data-compound-depth="3"]){--likec4-element-fill: #424a54;--likec4-element-stroke: #30363f}:where([data-likec4-color=slate][data-compound-depth="4"]){--likec4-element-fill: #48505b;--likec4-element-stroke: #333a44}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=slate][data-compound-depth="4"]){--likec4-element-fill: #3e444d;--likec4-element-stroke: #2d323a}:where([data-likec4-color=slate][data-compound-depth="5"]){--likec4-element-fill: #454c56;--likec4-element-stroke: #323841}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=slate][data-compound-depth="5"]){--likec4-element-fill: #393e46;--likec4-element-stroke: #292e34}:where([data-likec4-color=slate][data-compound-depth="6"]){--likec4-element-fill: #434951;--likec4-element-stroke: #30353d}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=slate][data-compound-depth="6"]){--likec4-element-fill: #34383e;--likec4-element-stroke: #26292f}:where([data-likec4-color=gray]){--likec4-element-fill: #737373;--likec4-element-stroke: #525252;--likec4-element-hiContrast: #fafafa;--likec4-element-loContrast: #d4d4d4;--likec4-compound-title-color: #d4d4d4;--likec4-relation-lineColor: #6E6E6E;--likec4-relation-labelBg: #18191b;--likec4-relation-labelColor: #C6C6C6}:where([data-likec4-color=gray][data-compound-depth="1"]){--likec4-element-fill: #595959;--likec4-element-stroke: #3f3f3f}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=gray][data-compound-depth="1"]){--likec4-element-fill: #545454;--likec4-element-stroke: #3c3c3c}:where([data-likec4-color=gray][data-compound-depth="2"]){--likec4-element-fill: #555555;--likec4-element-stroke: #3d3d3d}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=gray][data-compound-depth="2"]){--likec4-element-fill: #4e4e4e;--likec4-element-stroke: #383838}:where([data-likec4-color=gray][data-compound-depth="3"]){--likec4-element-fill: #525252;--likec4-element-stroke: #3a3a3a}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=gray][data-compound-depth="3"]){--likec4-element-fill: #484848;--likec4-element-stroke: #343434}:where([data-likec4-color=gray][data-compound-depth="4"]){--likec4-element-fill: #4e4e4e;--likec4-element-stroke: #383838}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=gray][data-compound-depth="4"]){--likec4-element-fill: #434343;--likec4-element-stroke: #303030}:where([data-likec4-color=gray][data-compound-depth="5"]){--likec4-element-fill: #4b4b4b;--likec4-element-stroke: #353535}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=gray][data-compound-depth="5"]){--likec4-element-fill: #3d3d3d;--likec4-element-stroke: #2b2b2b}:where([data-likec4-color=gray][data-compound-depth="6"]){--likec4-element-fill: #474747;--likec4-element-stroke: #333333}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=gray][data-compound-depth="6"]){--likec4-element-fill: #373737;--likec4-element-stroke: #272727}:where([data-likec4-color=red]){--likec4-element-fill: #AC4D39;--likec4-element-stroke: #853A2D;--likec4-element-hiContrast: #FBD3CB;--likec4-element-loContrast: #f5b2a3;--likec4-compound-title-color: #f5b2a3;--likec4-relation-lineColor: #AC4D39;--likec4-relation-labelBg: #b91c1c;--likec4-relation-labelColor: #f5b2a3}:where([data-likec4-color=red][data-compound-depth="1"]){--likec4-element-fill: #803e30;--likec4-element-stroke: #632f26}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=red][data-compound-depth="1"]){--likec4-element-fill: #773d30;--likec4-element-stroke: #5c2e26}:where([data-likec4-color=red][data-compound-depth="2"]){--likec4-element-fill: #793d31;--likec4-element-stroke: #5e2e26}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=red][data-compound-depth="2"]){--likec4-element-fill: #6c3a2f;--likec4-element-stroke: #542c25}:where([data-likec4-color=red][data-compound-depth="3"]){--likec4-element-fill: #723c31;--likec4-element-stroke: #582e27}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=red][data-compound-depth="3"]){--likec4-element-fill: #62372e;--likec4-element-stroke: #4c2a24}:where([data-likec4-color=red][data-compound-depth="4"]){--likec4-element-fill: #6a3b31;--likec4-element-stroke: #522d27}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=red][data-compound-depth="4"]){--likec4-element-fill: #58342c;--likec4-element-stroke: #442823}:where([data-likec4-color=red][data-compound-depth="5"]){--likec4-element-fill: #633a31;--likec4-element-stroke: #4d2c27}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=red][data-compound-depth="5"]){--likec4-element-fill: #4f312a;--likec4-element-stroke: #3d2521}:where([data-likec4-color=red][data-compound-depth="6"]){--likec4-element-fill: #5d3931;--likec4-element-stroke: #482b27}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=red][data-compound-depth="6"]){--likec4-element-fill: #462d28;--likec4-element-stroke: #36231f}:where([data-likec4-color=green]){--likec4-element-fill: #428a4f;--likec4-element-stroke: #2d5d39;--likec4-element-hiContrast: #f8fafc;--likec4-element-loContrast: #c2f0c2;--likec4-compound-title-color: #c2f0c2;--likec4-relation-lineColor: #15803d;--likec4-relation-labelBg: #052e16;--likec4-relation-labelColor: #22c55e}:where([data-likec4-color=green][data-compound-depth="1"]){--likec4-element-fill: #35683e;--likec4-element-stroke: #24462d}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=green][data-compound-depth="1"]){--likec4-element-fill: #34613c;--likec4-element-stroke: #24412b}:where([data-likec4-color=green][data-compound-depth="2"]){--likec4-element-fill: #35623d;--likec4-element-stroke: #24422c}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=green][data-compound-depth="2"]){--likec4-element-fill: #325839;--likec4-element-stroke: #223c29}:where([data-likec4-color=green][data-compound-depth="3"]){--likec4-element-fill: #345d3c;--likec4-element-stroke: #243e2a}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=green][data-compound-depth="3"]){--likec4-element-fill: #305136;--likec4-element-stroke: #213626}:where([data-likec4-color=green][data-compound-depth="4"]){--likec4-element-fill: #33573a;--likec4-element-stroke: #233b29}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=green][data-compound-depth="4"]){--likec4-element-fill: #2d4932;--likec4-element-stroke: #1f3123}:where([data-likec4-color=green][data-compound-depth="5"]){--likec4-element-fill: #335238;--likec4-element-stroke: #223728}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=green][data-compound-depth="5"]){--likec4-element-fill: #2b422f;--likec4-element-stroke: #1d2c21}:where([data-likec4-color=green][data-compound-depth="6"]){--likec4-element-fill: #324d37;--likec4-element-stroke: #223426}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=green][data-compound-depth="6"]){--likec4-element-fill: #283a2b;--likec4-element-stroke: #1b271e}:where([data-likec4-color=amber]){--likec4-element-fill: #A35829;--likec4-element-stroke: #7E451D;--likec4-element-hiContrast: #FFE0C2;--likec4-element-loContrast: #f9b27c;--likec4-compound-title-color: #f9b27c;--likec4-relation-lineColor: #b45309;--likec4-relation-labelBg: #78350f;--likec4-relation-labelColor: #FFE0C2}:where([data-likec4-color=amber][data-compound-depth="1"]){--likec4-element-fill: #794524;--likec4-element-stroke: #5e361a}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=amber][data-compound-depth="1"]){--likec4-element-fill: #704225;--likec4-element-stroke: #56331b}:where([data-likec4-color=amber][data-compound-depth="2"]){--likec4-element-fill: #724325;--likec4-element-stroke: #58341b}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=amber][data-compound-depth="2"]){--likec4-element-fill: #663e25;--likec4-element-stroke: #4e301b}:where([data-likec4-color=amber][data-compound-depth="3"]){--likec4-element-fill: #6b4126;--likec4-element-stroke: #52321c}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=amber][data-compound-depth="3"]){--likec4-element-fill: #5c3a25;--likec4-element-stroke: #472d1b}:where([data-likec4-color=amber][data-compound-depth="4"]){--likec4-element-fill: #643e27;--likec4-element-stroke: #4d301d}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=amber][data-compound-depth="4"]){--likec4-element-fill: #533624;--likec4-element-stroke: #402a1a}:where([data-likec4-color=amber][data-compound-depth="5"]){--likec4-element-fill: #5d3c28;--likec4-element-stroke: #472f1d}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=amber][data-compound-depth="5"]){--likec4-element-fill: #493223;--likec4-element-stroke: #38261a}:where([data-likec4-color=amber][data-compound-depth="6"]){--likec4-element-fill: #563a28;--likec4-element-stroke: #422d1e}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=amber][data-compound-depth="6"]){--likec4-element-fill: #412d21;--likec4-element-stroke: #322319}:where([data-likec4-color=indigo]){--likec4-element-fill: #6366f1;--likec4-element-stroke: #4f46e5;--likec4-element-hiContrast: #eef2ff;--likec4-element-loContrast: #c7d2fe;--likec4-compound-title-color: #c7d2fe;--likec4-relation-lineColor: #6366f1;--likec4-relation-labelBg: #1e1b4b;--likec4-relation-labelColor: #818cf8}:where([data-likec4-color=indigo][data-compound-depth="1"]){--likec4-element-fill: #2529e1;--likec4-element-stroke: #2d24c2}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=indigo][data-compound-depth="1"]){--likec4-element-fill: #2529d3;--likec4-element-stroke: #3028b2}:where([data-likec4-color=indigo][data-compound-depth="2"]){--likec4-element-fill: #2428d7;--likec4-element-stroke: #3028b5}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=indigo][data-compound-depth="2"]){--likec4-element-fill: #282bbf;--likec4-element-stroke: #312aa1}:where([data-likec4-color=indigo][data-compound-depth="3"]){--likec4-element-fill: #292cc8;--likec4-element-stroke: #322ba9}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=indigo][data-compound-depth="3"]){--likec4-element-fill: #2b2dac;--likec4-element-stroke: #312b91}:where([data-likec4-color=indigo][data-compound-depth="4"]){--likec4-element-fill: #2d30ba;--likec4-element-stroke: #342e9e}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=indigo][data-compound-depth="4"]){--likec4-element-fill: #2c2f99;--likec4-element-stroke: #302c82}:where([data-likec4-color=indigo][data-compound-depth="5"]){--likec4-element-fill: #3133ac;--likec4-element-stroke: #363092}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=indigo][data-compound-depth="5"]){--likec4-element-fill: #2d2f87;--likec4-element-stroke: #2f2b73}:where([data-likec4-color=indigo][data-compound-depth="6"]){--likec4-element-fill: #34369f;--likec4-element-stroke: #373287}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=indigo][data-compound-depth="6"]){--likec4-element-fill: #2d2e76;--likec4-element-stroke: #2e2b65}._16viy561{opacity:0}.react-flow._16viy560{--xy-background-color: var(--likec4-background-color);--xy-background-pattern-color: var(--likec4-background-pattern-color)}.react-flow._16viy560._16viy563{--likec4-background-color: transparent !important;--xy-background-color: transparent !important;background-color:transparent!important}:where(._16viy564,._16viy563) .react-flow__attribution{display:none}@supports (hanging-punctuation: first) and (font: -apple-system-body) and (-webkit-appearance: none){._16viy560{--likec4-safari-animation-hook: }}._13zcbbh0{display:inline-flex;align-items:center;padding:6px 2px 0}._13zcbbh0 .mantine-Text-root{font-size:var(--mantine-font-size-xs);font-weight:500;line-height:1}._13zcbbh1{padding-left:4px;grid-column:1}._13zcbbh2{grid-column:2}._13zcbbh3{grid-column:3;padding-right:4px}._13zcbbh4{display:grid;grid-column-start:1;grid-column-end:4;border-bottom:1px solid var(--mantine-color-default-border);margin-bottom:0;padding:0 4px 5px}._13zcbbh4 .mantine-Text-root{font-size:var(--mantine-font-size-sm);font-weight:400;color:var(--mantine-color-dimmed)}._13zcbbh5{display:contents}._13zcbbh5:last-child ._13zcbbh4{border-bottom:none;margin-bottom:0}._13zcbbh5>*{transition:all .15s ease-in}._13zcbbh5:is(:hover,[data-selected=true])>*{transition:all .15s ease-out;cursor:pointer;background-color:var(--mantine-color-default-hover)}._13zcbbh6{display:grid;grid-template-columns:1fr 30px 1fr;grid-auto-rows:min-content max-content;gap:0;align-items:stretch}._13zcbbh7{display:grid;grid-template-columns:min-content 1fr;grid-auto-rows:min-content max-content;gap:10px 12px;align-items:baseline;justify-items:start}.q4g2qb1{--backdrop-blur: 0px;--backdrop-opacity: 0%;--q4g2qb0: black;position:absolute;top:0;left:0;padding:0;margin:0;box-sizing:border-box;border:0 solid transparent;width:100%;height:100%;z-index:1000;isolation:isolate;-webkit-backdrop-filter:blur(var(--backdrop-blur));backdrop-filter:blur(var(--backdrop-blur));background-color:rgb(200 200 200 / var(--backdrop-opacity))}:where([data-mantine-color-scheme=dark]) .q4g2qb1{--q4g2qb0: white;background-color:rgb(36 36 36 / var(--backdrop-opacity))}.react-flow.q4g2qb2{--xy-background-pattern-color: var(--likec4-background-pattern-color)}:where([data-mantine-color-scheme=dark]) .react-flow.q4g2qb2{--xy-edge-label-color: var(--likec4-relation-labelColor);--xy-edge-label-background-color: color-mix(in srgb, var(--likec4-relation-labelBg), transparent 50%)}:where(.q4g2qb2) .react-flow__attribution{display:none}:where(.q4g2qb2) .react-flow__edge-text{font-size:16px}.q4g2qb2 .react-flow__edges>svg{mix-blend-mode:plus-lighter}:where([data-mantine-color-scheme=light]) .q4g2qb2 .react-flow__edges>svg{mix-blend-mode:screen}._7mnxci0{width:100%;height:100%}._7mnxci1{width:100%;height:100%;display:flex;flex-direction:column;justify-content:center;align-items:center;overflow:hidden;gap:6px;padding:16px}._7mnxci2{flex:0 0 auto;width:-moz-fit-content;width:fit-content;text-align:center;font-family:var(--likec4-element-font-family);font-optical-sizing:auto;font-style:normal;font-weight:500;font-size:17px;line-height:1.25;text-wrap:balance;color:var(--likec4-element-hiContrast)}._7mnxci3{flex:0 0 auto;width:-moz-fit-content;width:fit-content;text-align:center;font-family:var(--likec4-element-font-family);font-optical-sizing:auto;font-style:normal;font-size:var(--mantine-font-size-xs);line-height:1.25;text-wrap:balance;color:var(--likec4-element-loContrast)}._7mnxci4{width:100%;height:100%;box-shadow:0 4px 10px .5px #0000001a,0 2px 2px -1px #0006;background:color-mix(in srgb,var(--likec4-element-fill),transparent 10%);border-radius:4px}._7mnxci5{font-family:var(--likec4-compound-font-family);font-optical-sizing:auto;font-style:normal;font-weight:600;font-size:14px;line-height:1;text-transform:uppercase;padding-top:12px;padding-left:10px;mix-blend-mode:screen;color:var(--likec4-compound-title-color)}._7mnxci6{top:0;left:0;position:absolute;pointer-events:none;fill:var(--likec4-element-fill);stroke:var(--likec4-element-stroke);overflow:visible;filter:drop-shadow(0 2px 1px rgba(0,0,0,.21)) drop-shadow(0 1px 1px color-mix(in srgb,var(--likec4-element-stroke) 40%,transparent)) drop-shadow(0 5px 3px rgba(0,0,0,.1));z-index:-1}._7mnxci7{--xy-edge-stroke: var(--likec4-relation-lineColor);--xy-edge-stroke-selected: color-mix(in srgb, var(--likec4-relation-lineColor), var(--q4g2qb0) 35%);--xy-edge-label-color: color-mix(in srgb, var(--likec4-relation-labelColor), rgba(255 255 255 / .85) 50%);--xy-edge-label-background-color: color-mix(in srgb, var(--likec4-relation-labelBg), transparent 20%);opacity:1;transition:all .13s cubic-bezier(.5,0,.2,1)}._7mnxci7[data-edge-dimmed=true]{opacity:.2;transition-delay:.4s}._7mnxci7[data-edge-dimmed=immediate]{opacity:.2}:where([data-mantine-color-scheme=dark]) ._7mnxci7{--xy-edge-label-background-color: color-mix(in srgb, var(--likec4-relation-labelBg), transparent 50%)}._7mnxci8{padding:2px 5px;font-family:var(--likec4-font-family);position:absolute;cursor:pointer;width:-moz-fit-content;width:fit-content;color:var(--xy-edge-label-color);background-color:var(--xy-edge-label-background-color);border-radius:4px;pointer-events:all;text-wrap:pretty;white-space:preserve-breaks}._7mnxci9{text-align:center;white-space-collapse:preserve-breaks;font-size:var(--mantine-font-size-md);line-height:var(--mantine-line-height-xs)}._7mnxcia{text-align:center;white-space-collapse:preserve-breaks;font-size:var(--mantine-font-size-sm);line-height:1}._7mnxcib{z-index:100;position:absolute;left:50%;bottom:2px;transform:translate(-50%);gap:0;transition:all .19s cubic-bezier(.5,0,.4,1)}:where([data-likec4-shape=browser],[data-likec4-shape=mobile]) ._7mnxcib{bottom:6px}:where(._7mnxci0:hover) ._7mnxcib{transition-delay:20ms;gap:8px;transform:translate(-50%,5px)}._7mnxcic{--ai-bg: color-mix(in srgb , var(--likec4-element-fill), transparent 99%);--ai-bg-hover: color-mix(in srgb , var(--likec4-element-fill) 65%, var(--likec4-element-stroke));--ai-hover: color-mix(in srgb , var(--likec4-element-fill) 50%, var(--likec4-element-stroke));opacity:.7;pointer-events:all;cursor:pointer;transform:scale(.9);transition:all .19s cubic-bezier(.5,0,.4,1)}._7mnxcic:hover{transition-delay:0ms;transform:scale(1.25);box-shadow:var(--mantine-shadow-lg)}._7mnxcic:active{transform:scale(.975)}:where(._7mnxci0:hover) ._7mnxcic{--ai-bg: var(--ai-bg-hover);transition-delay:40ms;transition-timing-function:cubic-bezier(0,0,.4,1);opacity:1;transform:scale(1.07);box-shadow:var(--mantine-shadow-md)}@keyframes lnegrx5{0%{stroke-opacity:.8}to{stroke-opacity:.5}}.lnegrx1{--lnegrx0: color-mix(in srgb, var(--likec4-element-stroke) 90%, var(--likec4-element-fill));position:absolute;top:0;left:0;width:100%;height:100%;padding:0;margin:0;display:flex;align-items:center;justify-content:center}.lnegrx1:after{content:" ";position:absolute;top:100%;left:0;right:0;height:16px;background:transparent;pointer-events:all}:where(.react-flow__node.selected) .lnegrx1{will-change:transform}.lnegrx1[data-hovered=true]{will-change:transform}.lnegrx2{top:50%;left:50%;visibility:hidden}.lnegrx3{will-change:transform}.react-flow__node-element:has(.lnegrx4){opacity:.25;transition:opacity .4s ease-in-out,filter .5s ease-in-out;transition-delay:50ms;filter:grayscale(.85) var(--likec4-safari-animation-hook, blur(2px));will-change:opacity,filter}.lnegrx7{--lnegrx6: var(--likec4-element-loContrast);stroke:var(--lnegrx6);fill:none;transform-origin:center center;stroke-width:6;animation-duration:1s;animation-iteration-count:infinite;animation-direction:alternate;stroke-opacity:.8;visibility:hidden}:where(.react-flow__node.selected) .lnegrx7{visibility:visible;animation-name:var(--likec4-safari-animation-hook, lnegrx5)}:where(.react-flow__node:focus-visible,.lnegrx1:focus-visible) .lnegrx7{stroke-width:10;stroke:var(--mantine-primary-color-outline, var(--mantine-primary-color-filled, var(--likec4-element-stroke)));visibility:visible}:where([data-likec4-shape=queue],[data-likec4-shape=cylinder],[data-likec4-shape=storage]) .lnegrx7{stroke-width:10}:where([data-mantine-color-scheme=light]) .lnegrx7{--lnegrx6: color-mix(in srgb, var(--likec4-element-fill) 50%, #3c3c3c)}.lnegrx4 .lnegrx7{visibility:hidden;display:none}.lnegrx8{fill:var(--likec4-element-fill)}.lnegrx9{fill:var(--likec4-element-stroke)}.lnegrxa{fill:var(--lnegrx0, color-mix(in srgb, var(--likec4-element-stroke) 90%, var(--likec4-element-fill)))}.lnegrxe{flex:0 0 auto;font-family:var(--likec4-element-font-family);font-optical-sizing:auto;font-style:normal;text-align:var(--lnegrxc);font-weight:500;font-size:19px;line-height:1.15;text-wrap:balance;color:var(--likec4-element-hiContrast)}.lnegrxf{flex:0 1 auto;font-family:var(--likec4-element-font-family);font-optical-sizing:auto;font-style:normal;font-weight:400;font-size:14px;line-height:1.2;text-align:var(--lnegrxc);text-wrap:pretty;color:var(--likec4-element-loContrast);white-space-collapse:preserve-breaks;text-overflow:ellipsis;overflow:hidden}:where(.lnegrxb) .lnegrxf{text-wrap:wrap}.lnegrxg{flex:0 0 auto;font-family:var(--likec4-element-font-family);font-optical-sizing:auto;font-style:normal;font-weight:400;font-size:12px;line-height:1.125;text-align:var(--lnegrxc);text-wrap:balance;opacity:.92;color:var(--likec4-element-loContrast)}.lnegrx1:hover .lnegrxg{opacity:1}.lnegrxh{--lnegrxd: 48px;flex:1;height:-moz-fit-content;height:fit-content;display:flex;align-items:center;justify-content:center;flex-direction:row;padding:calc(1.5rem * var(--mantine-scale));overflow:hidden;gap:calc(.625rem * var(--mantine-scale))}:where([data-likec4-shape=queue],[data-likec4-shape=mobile]) .lnegrxh{padding-left:40px;padding-right:20px}:where([data-likec4-shape=cylinder],[data-likec4-shape=storage]) .lnegrxh{padding-top:30px}:where([data-likec4-shape=browser]) .lnegrxh{padding-top:32px;padding-bottom:28px}.lnegrx1:not(:is([data-likec4-shape=queue],[data-likec4-shape=mobile])) .lnegrxh:is(.lnegrxb){padding-left:24px;padding-right:18px}.lnegrxh:has(.lnegrxf,.lnegrxg){--lnegrxd: 60px;gap:calc(1rem * var(--mantine-scale))}.lnegrxi{--lnegrxc: center;height:-moz-fit-content;height:fit-content;width:-moz-max-content;width:max-content;display:flex;flex-direction:column;align-items:stretch;justify-content:center;flex-wrap:nowrap;overflow:hidden;gap:calc(.5rem * var(--mantine-scale))}.lnegrxi:has(.lnegrxf):has(.lnegrxg){gap:calc(.375rem * var(--mantine-scale))}:where(.lnegrxb) .lnegrxi{--lnegrxc: left;min-width:calc(100% - 160px);align-items:flex-start}.lnegrxj{flex:0 0 var(--lnegrxd);height:var(--lnegrxd);width:var(--lnegrxd);display:flex;align-items:center;justify-content:center;mix-blend-mode:hard-light;align-self:flex-start}.lnegrxj svg,.lnegrxj img{width:100%;height:auto;max-height:100%;pointer-events:none;filter:drop-shadow(0 0 3px rgb(0 0 0 / 12%)) drop-shadow(0 1px 8px rgb(0 0 0 / 8%)) drop-shadow(1px 1px 16px rgb(0 0 0 / 3%))}.lnegrxj img{-o-object-fit:contain;object-fit:contain}.lnegrxl{top:0;left:0;position:absolute;pointer-events:none;transform-origin:50% 50%;fill:var(--likec4-element-fill);stroke:none;z-index:-1;transition:opacity .5s ease-out;transform:translate(8px,10px);opacity:.5}:where(.react-flow__node.selected,.react-flow__node:focus-visible,.lnegrx1:focus-visible) .lnegrxl{visibility:hidden}:where([data-likec4-shape=cylinder],[data-likec4-shape=storage]) .lnegrxl{transform:translate(8px,8px)}:where([data-likec4-shape=queue]) .lnegrxl{transform:translate(-10px,8px)}:where([data-hovered=true]) .lnegrxl{transition:opacity .3s ease-in;opacity:.2}.lnegrxm{--lnegrxk: drop-shadow(0 2px 1px rgba(0, 0, 0, .21)) drop-shadow(0 1px 1px color-mix(in srgb, var(--likec4-element-stroke) 40%, transparent)) drop-shadow(0 5px 3px rgba(0, 0, 0, .1)) ;top:0;left:0;position:absolute;width:100%;height:100%;pointer-events:none;fill:var(--likec4-element-fill);stroke:var(--likec4-element-stroke);overflow:visible;filter:var(--lnegrxk);transition:filter .3s ease-out;transition-delay:0ms;z-index:-1}:where(.react-flow__node.selected,.react-flow__node:focus-visible,.lnegrx1:focus-visible) .lnegrxm{--lnegrxk: none}.lnegrxn{--ai-bg-idle: color-mix(in srgb , var(--likec4-element-fill), transparent 99%);--ai-bg: var(--ai-bg-idle);--ai-bg-hover: color-mix(in srgb , var(--likec4-element-fill) 65%, var(--likec4-element-stroke));--ai-hover: color-mix(in srgb , var(--likec4-element-fill) 50%, var(--likec4-element-stroke));pointer-events:all;color:var(--likec4-element-loContrast);cursor:pointer;background-color:var(--ai-bg)}.lnegrxn:hover{box-shadow:var(--mantine-shadow-md)}.lnegrxo{z-index:100;position:absolute;left:50%;bottom:2px;transform:translate(-50%);gap:0}:where([data-likec4-shape=browser]) .lnegrxo{bottom:4px}:where(.react-flow__node:hover) .lnegrxo{transition-delay:20ms;gap:16px}.lnegrxq{position:absolute;top:2px;right:2px}:where([data-likec4-shape=browser]) .lnegrxq{right:5px}:where([data-likec4-shape=cylinder],[data-likec4-shape=storage]) .lnegrxq{top:14px}:where([data-likec4-shape=queue]) .lnegrxq{top:1px;right:12px}.oztqew2{--backdrop-opacity: 0%;--backdrop-blur: 0px;box-sizing:border-box;margin:0;padding:0;position:fixed;top:0;right:0;bottom:0;left:0;width:100%;height:100%;max-width:100%;max-height:100%;background:transparent;border:0 solid transparent}.oztqew2::backdrop{-webkit-backdrop-filter:blur(var(--backdrop-blur));backdrop-filter:blur(var(--backdrop-blur));background-color:rgb(36 36 36 / var(--backdrop-opacity))}.oztqew3{--oztqew0: var(--mantine-color-body);--oztqew1: linear-gradient(180deg, var(--likec4-element-fill), var(--likec4-element-fill) 4px, transparent 4px);position:absolute;pointer-events:all;gap:var(--mantine-spacing-lg);justify-content:stretch;background-color:var(--oztqew0);background-image:var(--oztqew1);border-top-color:var(--likec4-element-fill)}:where([data-mantine-color-scheme=dark]) .oztqew3{--oztqew0: var(--mantine-color-dark-6);--oztqew1: linear-gradient(180deg, color-mix(in srgb, var(--likec4-element-fill) 15%, transparent), transparent 80px), linear-gradient(180deg, var(--likec4-element-fill), var(--likec4-element-fill) 4px, transparent 4px) }.oztqew4{flex:0;cursor:move}:where(.oztqew3) .react-flow__attribution{display:none}.oztqew5{display:block;font-family:var(--likec4-element-font-family);font-optical-sizing:auto;font-style:normal;font-weight:600;font-size:24px;line-height:var(--mantine-line-height-xs)}.oztqew6{flex:0 0 40px;height:40px;width:40px;display:flex;align-items:center;justify-content:center;align-self:flex-start;cursor:move}:where([data-mantine-color-scheme=dark]) .oztqew6{mix-blend-mode:hard-light}.oztqew6 svg,.oztqew6 img{width:100%;height:auto;max-height:100%;pointer-events:none;filter:drop-shadow(0 0 3px rgb(0 0 0 / 10%)) drop-shadow(0 1px 8px rgb(0 0 0 / 5%)) drop-shadow(1px 1px 16px rgb(0 0 0 / 2%))}.oztqew6 img{-o-object-fit:contain;object-fit:contain}.oztqew9{--oztqew7: var(--mantine-color-dark-1);width:100%;background:var(--mantine-color-body);border-radius:var(--mantine-radius-sm);padding:10px 8px;transition:all .13s cubic-bezier(.5,0,.2,1);border:1px solid var(--mantine-color-default-border)}.oztqew9:hover{--oztqew8: var(--mantine-color-dark-1);--oztqew7: var(--mantine-color-default-color);background:var(--mantine-color-default-hover)}:where([data-mantine-color-scheme=dark]) .oztqew9{background:var(--mantine-color-dark-6)}:where([data-mantine-color-scheme=light]) .oztqew9{--oztqew8: var(--mantine-color-gray-6);--oztqew7: var(--mantine-color-gray-7)}:where([data-mantine-color-scheme=light]) .oztqew9:hover{--oztqew8: var(--mantine-color-gray-7)}.oztqew9 .mantine-ThemeIcon-root{--ti-size: 22px;transition:all .13s cubic-bezier(.5,0,.2,1);color:var(--oztqew8, var(--mantine-color-dark-2))}.oztqew9 .mantine-ThemeIcon-root:hover{color:var(--mantine-color-default-color)}.oztqew9>*{transition:all .13s cubic-bezier(.5,0,.2,1)}.oztqew9:hover>*{transition-timing-function:cubic-bezier(0,0,.4,1);transform:translate(1.6px)}.oztqewa{transition:all .13s cubic-bezier(.5,0,.2,1);color:var(--oztqew7, var(--mantine-color-gray-7));font-size:15px;font-weight:500;line-height:1.4}.oztqewb{flex:1;display:flex;flex-direction:column;justify-content:stretch;overflow:hidden;gap:var(--mantine-spacing-sm)}.oztqewc{background:var(--mantine-color-gray-1);border-radius:var(--mantine-radius-sm);flex-wrap:nowrap;gap:6px;padding:4px}:where([data-mantine-color-scheme=dark]) .oztqewc{background:var(--mantine-color-dark-7)}.oztqewd{font-size:var(--mantine-font-size-xs);font-weight:500;flex-grow:1;padding:6px 8px;transition:all .13s cubic-bezier(.5,0,.2,1);border-radius:var(--mantine-radius-sm);color:var(--mantine-color-gray-7)}.oztqewd:hover{transition-timing-function:cubic-bezier(0,0,.4,1);color:var(--mantine-color-default-color);background:var(--mantine-color-gray-3)}.oztqewd[data-active]{transition:none;background:var(--mantine-color-white);box-shadow:var(--mantine-shadow-xs);color:var(--mantine-color-default-color)}:where([data-mantine-color-scheme=dark]) .oztqewd{color:var(--mantine-color-dark-1)}:where([data-mantine-color-scheme=dark]) .oztqewd:hover{color:var(--mantine-color-white);background:var(--mantine-color-dark-6)}:where([data-mantine-color-scheme=dark]) .oztqewd:is([data-active]){color:var(--mantine-color-white);background:var(--mantine-color-dark-5)}.oztqewe{flex:1;overflow:hidden;position:relative}.oztqewe:not(:has(.mantine-ScrollArea-root)){padding-left:4px;padding-right:4px}.oztqewe .mantine-ScrollArea-root{width:100%;height:100%}.oztqewe .mantine-ScrollArea-viewport>div{padding-left:4px;padding-right:4px}.oztqewf{flex:1;display:grid;grid-template-columns:min-content 1fr;grid-auto-rows:min-content max-content;gap:calc(1.25rem * var(--mantine-scale)) calc(1rem * var(--mantine-scale));align-items:baseline;justify-items:stretch}.oztqewg{justify-self:end}.oztqewh{transition:all .13s cubic-bezier(.5,0,.2,1);border:1px dashed var(--mantine-color-default-border);border-radius:var(--mantine-radius-sm);min-height:30px;padding:3px 16px 3px 3px;cursor:pointer;color:var(--mantine-color-gray-7)}.oztqewh:hover{transition-timing-function:cubic-bezier(0,0,.4,1);border-style:solid;color:var(--mantine-color-default-color);background:var(--mantine-color-default-hover)}:where([data-mantine-color-scheme=dark]) .oztqewh{color:var(--mantine-color-dark-1)}.oztqewh>*{transition:all .13s cubic-bezier(.5,0,.2,1)}.oztqewh:hover>*{transition-timing-function:cubic-bezier(0,0,.4,1);transform:translate(1px)}.oztqewi{position:absolute;width:14px;height:14px;border:3.5px solid var(--mantine-color-dark-3);border-top:none;border-left:none;border-radius:2px;bottom:2px;right:2px;transition:all .13s cubic-bezier(.5,0,.2,1);cursor:se-resize}.oztqewi:hover{border-width:4px;border-color:var(--mantine-color-dark-1)}.esyd460{margin:0}.esyd461:hover{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .esyd461:hover{background-color:var(--mantine-color-default-hover);color:var(--mantine-color-white)}._17dfyw90{position:relative;width:100%;height:100%}._17dfyw91{width:100%;height:100%;display:flex;flex-direction:column;justify-content:center;align-items:center;overflow:hidden;gap:6px;padding:16px}._17dfyw92{flex:0 0 auto;width:-moz-fit-content;width:fit-content;text-align:center;font-family:var(--likec4-element-font-family);font-optical-sizing:auto;font-style:normal;font-weight:500;font-size:18px;line-height:1.25;text-wrap:balance;color:var(--likec4-element-hiContrast)}._17dfyw93{flex:0 0 auto;width:-moz-fit-content;width:fit-content;text-align:center;font-family:var(--likec4-element-font-family);font-optical-sizing:auto;font-style:normal;font-size:var(--mantine-font-size-sm);line-height:1.25;text-wrap:balance;color:var(--likec4-element-loContrast)}._17dfyw94{position:relative;width:100%;height:100%;box-shadow:0 4px 10px .5px #0000001a,1px 1px 4px -1px #0000004d;background:var(--likec4-element-fill);border-radius:6px}._17dfyw95{font-family:var(--likec4-compound-font-family);font-weight:600;font-size:15px;line-height:1;text-transform:uppercase;padding-top:14px;padding-left:12px;mix-blend-mode:screen;color:var(--likec4-compound-title-color)}._17dfyw96{top:0;left:0;position:absolute;pointer-events:none;fill:var(--likec4-element-fill);stroke:var(--likec4-element-stroke);overflow:visible;filter:drop-shadow(0 2px 1px rgba(0,0,0,.21)) drop-shadow(0 1px 1px color-mix(in srgb,var(--likec4-element-stroke) 40%,transparent)) drop-shadow(0 5px 3px rgba(0,0,0,.1));z-index:-1}._17dfyw97{--xy-edge-stroke: var(--likec4-relation-lineColor);--xy-edge-stroke-selected: color-mix(in srgb, var(--likec4-relation-lineColor), var(--q4g2qb0) 35%);--xy-edge-label-color: color-mix(in srgb, var(--likec4-relation-labelColor), rgba(255 255 255 / .85) 50%);--xy-edge-label-background-color: color-mix(in srgb, var(--likec4-relation-labelBg), transparent 20%);opacity:1;transition:all .13s cubic-bezier(.5,0,.2,1)}._17dfyw97[data-edge-dimmed=true]{opacity:.2;transition-delay:.4s}._17dfyw97[data-edge-dimmed=immediate]{opacity:.2}:where([data-mantine-color-scheme=dark]) ._17dfyw97{--xy-edge-label-background-color: color-mix(in srgb, var(--likec4-relation-labelBg), transparent 50%)}._17dfyw98{padding:2px 5px;font-family:var(--likec4-font-family);position:absolute;cursor:pointer;width:-moz-fit-content;width:fit-content;color:var(--xy-edge-label-color);background-color:var(--xy-edge-label-background-color);border-radius:4px;pointer-events:all;text-wrap:pretty;white-space:preserve-breaks}._17dfyw99{text-align:center;white-space-collapse:preserve-breaks;font-size:var(--mantine-font-size-md);line-height:var(--mantine-line-height-xs)}._17dfyw9a{text-align:center;white-space-collapse:preserve-breaks;font-size:var(--mantine-font-size-sm);line-height:1}._17dfyw9b{width:100%;height:100%;border:3px dashed var(--mantine-color-default-border);border-radius:var(--mantine-radius-md);display:flex;justify-content:center;align-items:center}._17dfyw9c{z-index:100;position:absolute;left:50%;bottom:2px;transform:translate(-50%);gap:0;transition:all .19s cubic-bezier(.5,0,.4,1)}:where([data-likec4-shape=browser]) ._17dfyw9c{bottom:4px}:where(._17dfyw90:hover) ._17dfyw9c{transition-delay:20ms;gap:8px;transform:translate(-50%,5px)}._17dfyw9d{--ai-bg: color-mix(in srgb , var(--likec4-element-fill), transparent 99%);--ai-bg-hover: color-mix(in srgb , var(--likec4-element-fill) 65%, var(--likec4-element-stroke));--ai-hover: color-mix(in srgb , var(--likec4-element-fill) 50%, var(--likec4-element-stroke));opacity:.7;pointer-events:all;cursor:pointer;transform:scale(.9);transition:all .19s cubic-bezier(.5,0,.4,1)}._17dfyw9d:hover{transition-delay:0ms;transform:scale(1.25);box-shadow:var(--mantine-shadow-lg)}._17dfyw9d:active{transform:scale(.975)}:where(._17dfyw90:hover) ._17dfyw9d{--ai-bg: var(--ai-bg-hover);transition-delay:40ms;transition-timing-function:cubic-bezier(0,0,.4,1);opacity:1;transform:scale(1.07);box-shadow:var(--mantine-shadow-md)}._6mj0ef0{display:inline-block;font-size:var(--mantine-font-size-sm);font-weight:500;white-space:nowrap;padding:3px 6px;border-radius:3px;background:color-mix(in srgb,var(--likec4-element-fill),transparent 25%);line-height:1.2;color:var(--likec4-element-hiContrast)}:where([data-mantine-color-scheme=light]) ._6mj0ef1{background:var(--mantine-color-gray-1)}._6mj0ef1[data-missing]{color:var(--mantine-color-orange-4);background:color-mix(in srgb,var(--mantine-color-orange-8) 15%,transparent);border-color:color-mix(in srgb,var(--mantine-color-orange-5) 20%,transparent)}:where([data-mantine-color-scheme=light]) ._6mj0ef1[data-missing]{color:var(--mantine-color-orange-8)}._6mj0ef2{flex:1 1 100%;position:relative;width:100%;height:100%;background:var(--mantine-color-body);border:1px solid var(--mantine-color-default-border);border-radius:var(--mantine-radius-sm)}:where([data-mantine-color-scheme=light]) ._6mj0ef2{border-color:var(--mantine-color-gray-3);background:var(--mantine-color-gray-1)}._6mj0ef3:before{content:"scope:";position:absolute;top:0;left:8px;font-size:9px;font-weight:500;line-height:1;color:var(--mantine-color-dimmed);opacity:.85;transform:translateY(-100%) translateY(-2px)}:where([data-mantine-color-scheme=light]) ._6mj0ef3 .mantine-SegmentedControl-root{background:var(--mantine-color-gray-3)}._6mj0ef4{display:inline-block;font-size:var(--mantine-font-size-xl);font-weight:600;padding:1px 5px;min-width:24px;text-align:center;border-radius:var(--mantine-radius-sm);background:var(--mantine-color-dark-7);color:var(--mantine-color-default-color)}:where([data-mantine-color-scheme=light]) ._6mj0ef4{background:var(--mantine-color-gray-4);color:var(--mantine-color-dark-6)}._6mj0ef4[data-zero]{color:var(--mantine-color-dimmed)}:where([data-mantine-color-scheme=light]) ._6mj0ef4[data-zero]{background:var(--mantine-color-gray-3)}._6mj0ef4[data-missing]{color:var(--mantine-color-orange-4);background:color-mix(in srgb,var(--mantine-color-orange-8) 20%,transparent)}:where([data-mantine-color-scheme=light]) ._6mj0ef4[data-missing]{color:var(--mantine-color-orange-8)}._14so4380{margin-top:var(--mantine-spacing-sm);margin-bottom:var(--mantine-spacing-sm)}._14so4381{display:inline-flex;transition:all .13s cubic-bezier(.5,0,.2,1);border:1px dashed var(--mantine-color-default-border);border-radius:var(--mantine-radius-sm);padding:var(--mantine-spacing-xs) var(--mantine-spacing-md);align-items:center;cursor:pointer;color:var(--mantine-color-gray-7)}._14so4381:hover{transition-timing-function:cubic-bezier(0,0,.4,1);border-style:solid;color:var(--mantine-color-default-color);background:var(--mantine-color-default-hover)}:where([data-mantine-color-scheme=dark]) ._14so4381{color:var(--mantine-color-dark-1)}._14so4381>*{transition:all .13s cubic-bezier(.5,0,.2,1)}._14so4381:hover>*{transition-timing-function:cubic-bezier(0,0,.4,1);transform:translate(1px)}@keyframes _1wtl1y57{0%{stroke-dashoffset:46}to{stroke-dashoffset:10}}._1wtl1y51{--_1wtl1y50: black;--xy-edge-stroke: var(--likec4-relation-lineColor);--xy-edge-stroke-selected: color-mix(in srgb, var(--likec4-relation-lineColor), var(--_1wtl1y50) 35%);--xy-edge-label-color: color-mix(in srgb, var(--likec4-relation-labelColor), rgba(255 255 255 / .85) 40%);--xy-edge-label-background-color: color-mix(in srgb, var(--likec4-relation-labelBg), transparent 40%);--xy-edge-stroke-width: 3}:where([data-mantine-color-scheme=dark]) ._1wtl1y51{--_1wtl1y50: white;--xy-edge-label-color: var(--likec4-relation-labelColor);--xy-edge-label-background-color: color-mix(in srgb, var(--likec4-relation-labelBg), transparent 50%)}:where(.react-flow__edge.selected) ._1wtl1y51{--xy-edge-stroke: var(--xy-edge-stroke-selected);--xy-edge-stroke-width: 3}._1wtl1y51:is([data-edge-hovered=true],[data-edge-active=true]){--xy-edge-stroke: var(--xy-edge-stroke-selected);--xy-edge-stroke-width: 3}:where(.react-flow__edge.selected) ._1wtl1y51[data-edge-hovered=true]{--xy-edge-stroke-width: 4}.likec4-diagram .react-flow__edges>svg{mix-blend-mode:plus-lighter}:where([data-mantine-color-scheme=light]) .likec4-diagram .react-flow__edges>svg{mix-blend-mode:screen}.likec4-diagram .react-flow__edges>svg:has(._1wtl1y52){opacity:.6;transition:opacity .6s ease-in-out,filter .6s ease-in-out;transition-delay:.2s;filter:grayscale(.85) var(--likec4-safari-animation-hook, blur(1px));will-change:opacity,filter}._1wtl1y53{stroke-opacity:.08;transition-property:stroke-width,stroke-opacity;transition-duration:155ms;transition-timing-function:ease-out}:where(.react-flow__edge.selected,[data-edge-active=true],[data-edge-hovered=true]) ._1wtl1y53{stroke-width:calc(var(--xy-edge-stroke-width) + 8);stroke-opacity:.15}._1wtl1y54{fill:var(--xy-edge-stroke);stroke:var(--xy-edge-stroke)}._1wtl1y55{fill:var(--xy-edge-stroke);stroke:var(--xy-edge-stroke);fill-opacity:.75;stroke-width:1;cursor:grab;pointer-events:auto;visibility:hidden}._1wtl1y55:hover{stroke:var(--mantine-primary-color-filled-hover);stroke-width:9;transition:stroke .1s ease-out,stroke-width .1s ease-out}:where(.react-flow__edge.selected,[data-edge-hovered=true]) ._1wtl1y55{visibility:visible;transition:fill-opacity .15s ease-out,stroke .15s ease-out,stroke-width .15s ease-out;transition-delay:50ms;fill-opacity:1;stroke-width:5}._1wtl1y56{cursor:grabbing}._1wtl1y56 *{cursor:grabbing!important}._1wtl1y58{animation-duration:.8s;animation-iteration-count:infinite;animation-timing-function:linear;animation-fill-mode:both;stroke-dashoffset:10}:where([data-edge-hovered=true]) ._1wtl1y58{animation-name:_1wtl1y57;animation-delay:.45s;transition:stroke .13s ease-out,stroke-width .13s ease-out}:where(.react-flow__edge.selected,[data-edge-active=true],[data-edge-animated=true]) ._1wtl1y58{animation-name:_1wtl1y57;animation-delay:0ms;transition:stroke .13s ease-out,stroke-width .13s ease-out}:where([data-edge-dir=back]) ._1wtl1y58{animation-direction:reverse}._1wtl1y52 ._1wtl1y58{animation-play-state:paused}._1wtl1y59{flex:0 0 auto;font-weight:600;font-size:calc(.875rem * var(--mantine-scale));line-height:1;padding:5px;text-align:center;min-width:22px;border-top-left-radius:2px;border-bottom-left-radius:2px;background-color:color-mix(in srgb,var(--likec4-relation-labelBg),var(--_1wtl1y50) 5%);font-variant-numeric:tabular-nums}:where([data-mantine-color-scheme=dark]) :where([data-likec4-color=gray]) ._1wtl1y59{background-color:color-mix(in srgb,var(--likec4-relation-labelBg),var(--_1wtl1y50) 15%)}:where([data-edge-active=true]) ._1wtl1y59{background-color:transparent}._1wtl1y5d{--_1wtl1y5c: translate(var(--_1wtl1y5a, -50%), var(--_1wtl1y5b, -50%));top:0;left:0;padding:2px 4px 4px;font-family:var(--likec4-font-family);display:flex;position:absolute;pointer-events:all;cursor:pointer;width:-moz-fit-content;width:fit-content;transform-origin:50% 50%;mix-blend-mode:plus-lighter;color:var(--xy-edge-label-color);background-color:var(--xy-edge-label-background-color);border-radius:2px;transform:var(--_1wtl1y5c)}._1wtl1y5d[data-edge-hovered=true]{transition:all .14s ease-in-out;transform:var(--_1wtl1y5c) scale(1.12)}._1wtl1y5d:has(._1wtl1y59){padding:0;gap:2px}._1wtl1y5d:is(._1wtl1y52){opacity:.3;transition:opacity .6s ease-in-out,filter .6s ease-in-out;transition-delay:.2s;filter:grayscale(.85) var(--likec4-safari-animation-hook, blur(1px));will-change:opacity,filter}._1wtl1y5e{text-align:center;white-space-collapse:preserve-breaks;font-size:calc(.875rem * var(--mantine-scale));line-height:1.185}._1wtl1y5d:has(._1wtl1y59) ._1wtl1y5e{padding:2px 5px 4px 2px}._1wtl1y5f{position:absolute;top:4px;right:4px;z-index:9}._1wtl1y5g{--text-fz: var(--mantine-font-size-sm);-webkit-user-select:all;-moz-user-select:all;user-select:all;text-align:left;white-space-collapse:preserve-breaks;text-wrap:pretty;line-height:1.25}._1wtl1y5h{--ai-bg: var(--likec4-relation-labelBg);--ai-hover: color-mix(in srgb , var(--likec4-relation-labelBg), var(--_1wtl1y50) 10%);z-index:calc(var(--layer-overlays, 1) + 1);position:absolute;pointer-events:all;left:50%;top:calc(100% + 1px);color:var(--xy-edge-label-color);cursor:pointer;transform-origin:top center;opacity:.8;transition:all .15s ease-in-out;transform:translate(-50%);transition-delay:0ms;background-color:var(--ai-bg)}._1wtl1y5h:hover{box-shadow:var(--mantine-shadow-lg);transform:translate(-50%) scale(1.3);opacity:1}._1wtl1y5h:active{transform:translate(-50%) scale(1.02)}:is(._1wtl1y52) ._1wtl1y5h{display:none}._1wtl1y5h .tabler-icon{width:75%;height:75%;stroke-width:2}@media (min-width: 62em){._1wtl1y5g{--text-fz: var(--mantine-font-size-md)}}._17kny4m0{min-width:250px;max-width:min(90vw,500px)}._17kny4m1{gap:4px}._17kny4m2{display:block;font-size:10px;font-weight:500;white-space:nowrap;padding:2px 5px;border-radius:2px;background:color-mix(in srgb,var(--likec4-element-fill),transparent 45%);line-height:1.1}:where([data-mantine-color-scheme=dark]) ._17kny4m2{color:var(--likec4-element-loContrast)}._17kny4m3{white-space-collapse:preserve-breaks;font-size:var(--mantine-font-size-sm)}@keyframes _10hx3mad{0%{opacity:.6}to{opacity:.3}}._10hx3ma0{position:relative;width:100%;height:100%}._10hx3ma2{--_10hx3ma1: 18px;width:100%;height:100%;position:relative;padding:0;margin:0}._10hx3ma2:before{content:" ";position:absolute;top:0;left:-16px;width:16px;height:min(100%,80px);pointer-events:all;background:transparent}._10hx3ma3{top:50%;left:50%;visibility:hidden}.react-flow__node-compound:has(._10hx3ma4){opacity:.25;transition:opacity .6s ease-in-out,filter .6s ease-in-out;transition-delay:.2s;filter:grayscale(.85) var(--likec4-safari-animation-hook, blur(1px));will-change:opacity,filter}._10hx3ma7{width:100%;height:100%;position:relative;border-radius:6px;box-shadow:0 4px 10px .5px #0000001a,0 2px 2px -1px #0006;padding:0;margin:0;transition:all .2s ease-out;background-clip:padding-box;cursor:default}._10hx3ma7:before{content:" ";position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;transition:background 175ms ease-out,opacity 175ms ease-out;background:var(--likec4-element-fill)}:where(.react-flow__node.selected) ._10hx3ma7{box-shadow:none}:where(.react-flow__node:focus-visible) ._10hx3ma7{transition-duration:0ms;outline:3px solid var(--mantine-primary-color-outline, var(--mantine-primary-color-filled, var(--likec4-element-stroke)));outline-offset:calc(.09375rem * var(--mantine-scale))}._10hx3ma8{display:flex;align-items:center;gap:6px;padding-left:14px;padding-top:9px;min-height:30px}:where(.react-flow__node.draggable) ._10hx3ma8{cursor:grab}:where(.likec4-compound-transparent) ._10hx3ma8{padding-top:4px}._10hx3ma9{padding-left:30px}._10hx3mab{--_10hx3maa: 0;border-style:dashed;border-width:3px;box-shadow:none;border-color:color-mix(in srgb,var(--likec4-element-stroke),transparent var(--_10hx3ma6, 10%))}._10hx3mab:before{border-radius:unset;transition-delay:.1s;opacity:calc(var(--_10hx3ma5, 1) + var(--_10hx3maa))}:where([data-hovered]) ._10hx3mab{--_10hx3maa: .08}._10hx3mac{flex:1;font-family:var(--likec4-compound-font-family);font-weight:600;font-size:calc(.9375rem * var(--mantine-scale));text-transform:uppercase;letter-spacing:.2px;color:var(--_compound-title-color,var(--likec4-compound-title-color));mix-blend-mode:screen}:where([data-mantine-color-scheme=light] .likec4-compound-transparent){--_compound-title-color: var(--likec4-element-stroke)}._10hx3mag{--_10hx3mae: var(--likec4-element-loContrast);--_10hx3maf: 6;position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;overflow:visible;visibility:hidden}:where(.react-flow__node.selected:not(:focus-visible)) ._10hx3mag{visibility:visible}:where(.react-flow__node:focus-within:not(.selected)) ._10hx3mag{--_10hx3mae: color-mix(in srgb, var(--likec4-element-stroke) 30%, var(--likec4-element-loContrast));--_10hx3maf: 8}:where([data-mantine-color-scheme=light]) ._10hx3mag{--_10hx3mae: color-mix(in srgb, var(--likec4-element-stroke) 80%, #000)}._10hx3mag rect{stroke:var(--_10hx3mae);transform-origin:center center;stroke-width:var(--_10hx3maf);animation-duration:.8s;animation-name:_10hx3mad;animation-iteration-count:infinite;animation-direction:alternate;fill:none}._10hx3ma2{--_10hx3mah: var(--likec4-element-loContrast)}:where([data-mantine-color-scheme=light] .likec4-compound-transparent){--_10hx3mah: var(--likec4-element-stroke)}._10hx3mai{--ai-opacity: 1;--ai-bg-idle: color-mix(in srgb , var(--likec4-element-fill), transparent 99%);--ai-bg: var(--ai-bg-idle);--ai-bg-hover: color-mix(in srgb , var(--likec4-element-fill) 65%, var(--likec4-element-stroke));--ai-hover: color-mix(in srgb , var(--likec4-element-fill) 50%, var(--likec4-element-stroke));pointer-events:all;cursor:pointer;color:var(--_compound-title-color,var(--_10hx3mah));opacity:var(--ai-opacity);background-color:var(--ai-bg)}._10hx3mai:hover{box-shadow:var(--mantine-shadow-md)}:where([data-mantine-color-scheme=light]) .likec4-compound-transparent ._10hx3mai{--ai-bg-hover: color-mix(in srgb , var(--likec4-element-fill), transparent 20%);--ai-hover: color-mix(in srgb , var(--likec4-element-fill), transparent 10%);--ai-bg: color-mix(in srgb , var(--likec4-element-fill), transparent 99%);opacity:.85}._10hx3maj{position:absolute;left:3px;top:6px}._10hx3mal{flex:0 0 var(--_10hx3ma1);height:var(--_10hx3ma1);width:var(--_10hx3ma1);display:flex;align-items:center;justify-content:center;mix-blend-mode:luminosity}._10hx3mal svg,._10hx3mal img{width:100%;height:auto;max-height:100%;pointer-events:none;filter:drop-shadow(0 0 3px rgb(0 0 0 / 10%)) drop-shadow(0 1px 8px rgb(0 0 0 / 8%)) drop-shadow(1px 1px 16px rgb(0 0 0 / 3%))}._10hx3mal img{-o-object-fit:contain;object-fit:contain}.oy449t0{bottom:0;left:0;padding:8px;margin:0}.oy449t1{cursor:default;min-width:200px;max-width:calc(100vw - 16px);background-color:color-mix(in srgb,var(--mantine-color-body),transparent 20%);-webkit-backdrop-filter:var(--likec4-safari-animation-hook, blur(8px));backdrop-filter:var(--likec4-safari-animation-hook, blur(8px))}:where([data-mantine-color-scheme=dark]) .oy449t1{background-color:color-mix(in srgb,var(--mantine-color-dark-6),transparent 20%)}.oy449t3{white-space-collapse:preserve-breaks;color:var(--mantine-color-gray-7)}:where([data-mantine-color-scheme=dark]) .oy449t3{color:var(--mantine-color-gray-5)}@media (min-width: 48em){.oy449t1{min-width:250px;max-width:90vw}}@media (min-width: 62em){.oy449t1{min-width:350px;max-width:70vw}}._1cuwo5n0{position:absolute;bottom:.5rem;left:50%;transform:translate(-50%);padding:0;margin:0;display:flex;flex-direction:column;gap:.4rem;align-items:center}._1cuwo5n1{-webkit-backdrop-filter:blur(8px);backdrop-filter:blur(8px);transition:all 175ms ease-in}._1cuwo5n1:hover{transition-timing-function:ease-out;transform:scale(1.1)}._1cuwo5n1:active{transition-duration:.1s;transform:scale(.98) translateY(3px)}._1cuwo5n3{--_1cuwo5n2: 35%;--button-bg: color-mix(in srgb, var(--mantine-primary-color-filled), transparent var(--_1cuwo5n2));--button-hover: color-mix(in srgb, var(--mantine-primary-color-filled-hover), transparent var(--_1cuwo5n2));transition:all 175ms ease-in;background-color:var(--button-bg)}[data-mantine-color-scheme=light] ._1cuwo5n3{--_1cuwo5n2: 15%}:where(._1cuwo5n1,._1cuwo5n3) .tabler-icon{width:.85em;height:.85em}._1cuwo5n4{position:absolute;margin:0;padding:0;top:0;left:0;width:100%;height:100%;border:2px solid var(--mantine-color-orange-6);pointer-events:none}@media (min-width: 62em){._1cuwo5n0{gap:.6rem}._1cuwo5n4{border-width:4px}}._1o1a9t90{bottom:0;right:0;padding:8px;margin:0}._1o1a9t91{cursor:default;-webkit-user-select:none;-moz-user-select:none;user-select:none;min-width:200px;max-width:calc(100vw - 20px);background-color:color-mix(in srgb,var(--mantine-color-body),transparent 20%);-webkit-backdrop-filter:var(--likec4-safari-animation-hook, blur(8px));backdrop-filter:var(--likec4-safari-animation-hook, blur(8px))}:where([data-mantine-color-scheme=dark]) ._1o1a9t91{background-color:color-mix(in srgb,var(--mantine-color-dark-6),transparent 20%)}._1o1a9t92{padding:calc(var(--mantine-spacing-xs) / 2)}._1o1a9t93{--lnegrx0: color-mix(in srgb, var(--likec4-element-stroke) 90%, var(--likec4-element-fill));background-color:transparent;transition:all .1s ease-in}._1o1a9t93:hover{transition:all .12s ease-out;background-color:color-mix(in srgb,var(--mantine-primary-color-2),transparent 50%)}:where([data-mantine-color-scheme=dark]) ._1o1a9t93:hover{background-color:color-mix(in srgb,var(--mantine-color-dark-3),transparent 60%)}._1o1a9t94{fill:var(--likec4-element-fill);stroke:var(--likec4-element-stroke);stroke-width:1;overflow:visible;width:100%;height:auto;filter:drop-shadow(0 2px 3px rgb(0 0 0 / 22%)) drop-shadow(0 1px 8px rgb(0 0 0 / 10%))}._1o1a9t95{--badge-radius: 2px;--badge-fz: 9.5px;--badge-padding-x: 3px;--badge-height: 13.5px;--badge-lh: 1;font-weight:500;letter-spacing:.2px;padding-top:0;padding-bottom:0;text-transform:lowercase;transition:all .15s ease-in-out;cursor:pointer}@media (min-width: 48em){._1o1a9t91{min-width:300px;max-width:65vw}}@media (min-width: 62em){._1o1a9t91{max-width:40vw}}._1s3ok7s0{gap:calc(var(--mantine-spacing-xs) / 1.5)}._1s3ok7s1{top:var(--likec4-navigation-webview-top, 1rem);left:var(--likec4-navigation-webview-left, 1rem);gap:calc(var(--mantine-spacing-xs) / 1.5);margin:0}.likec4-top-left-panel .action-icon{--ai-size: 2rem}.likec4-top-left-panel .action-icon .tabler-icon{width:65%;height:65%}._1s3ok7s2{box-shadow:var(--mantine-shadow-md)}._1s3ok7s3 .tabler-icon{width:65%;height:65%}._1s3ok7s4{flex:1 1 40%;text-align:center;font-weight:500;padding:4px 6px;font-size:calc(.6875rem * var(--mantine-scale));z-index:1}._1s3ok7s5{background:var(--mantine-color-gray-2);border-radius:var(--mantine-radius-sm);border:1px solid var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) ._1s3ok7s5{background:var(--mantine-color-dark-5);border-color:var(--mantine-color-dark-4)}._1s3ok7s6{position:relative;border-radius:var(--mantine-radius-sm);background:var(--mantine-color-gray-3);box-shadow:inset 1px 1px 3px #00000024}:where([data-mantine-color-scheme=dark]) ._1s3ok7s6{background:var(--mantine-color-dark-7)}._1s3ok7s7{position:absolute;width:8px;height:8px;border:2px solid var(--mantine-color-gray-5);border-radius:3px;transform:translate(-50%,-50%)}._1gnojqn0{background-color:transparent;width:100%;height:100%}._1gnojqn1{background-color:transparent;padding:0;width:100%;height:100%}._1gnojqn2{--likec4-background-color: transparent}._1gnojqn3{--ai-size: var(--ai-size-lg);position:absolute;z-index:1;top:1rem;right:1rem}._1nao5c00{--likec4-default-font-family: "IBM Plex Sans",ui-sans-serif system-ui, sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";margin:0;padding:0;display:block;width:100%;height:100%;overflow:hidden;background-color:transparent}._1nao5c02{--mantine-cursor-pointer: pointer;cursor:pointer}._1nao5c02 :where(.likec4-diagram,.likec4-compound-node,.likec4-element-node){cursor:pointer}
`, styles;
}, createStyleSheet = () => {
  const bundledCSS = new CSSStyleSheet();
  return bundledCSS.replaceSync(
    BundledStyles().replaceAll("body {", `${ShadowRootCssSelector}{`).replaceAll("body{", `${ShadowRootCssSelector}{`).replaceAll(":root", `${ShadowRootCssSelector}`)
  ), bundledCSS;
};
function useCreateStyleSheet(injectFontCss, styleNonce) {
  return useIsomorphicLayoutEffect(() => {
    if (injectFontCss && !document.querySelector("style[data-likec4-font]")) {
      const style2 = document.createElement("style");
      style2.setAttribute("type", "text/css"), style2.setAttribute("data-likec4-font", ""), t$4(styleNonce) && style2.setAttribute("nonce", styleNonce), t$3(styleNonce) && style2.setAttribute("nonce", styleNonce()), style2.appendChild(document.createTextNode(fontCss)), document.head.appendChild(style2);
    }
  }, [injectFontCss]), createStyleSheet;
}
function useBundledStyleSheet(injectFontCss, styleNonce) {
  const [styleSheets, setStyleSheets] = useState([]), createCssStyleSheet = useCreateStyleSheet(injectFontCss, styleNonce);
  return useIsomorphicLayoutEffect(() => {
    const css = createCssStyleSheet();
    return setStyleSheets([css]), () => {
      css.replaceSync("");
    };
  }, [createCssStyleSheet]), styleSheets;
}
const getComputedColorScheme = () => {
  try {
    const htmlScheme = window.getComputedStyle(document.documentElement).colorScheme ?? "", colorScheme = d$1(htmlScheme.split(" "));
    if (colorScheme === "light" || colorScheme === "dark")
      return colorScheme;
  } catch {
  }
  return null;
};
function useColorScheme(explicit) {
  const preferred = useColorScheme$1(), [computed2, setComputed] = useState(getComputedColorScheme);
  return useMutationObserver(
    useDebouncedCallback$1(() => setComputed(getComputedColorScheme), 50),
    {
      attributes: !0,
      childList: !1,
      subtree: !1
    },
    () => document.documentElement
  ), explicit ?? computed2 ?? preferred;
}
function useShadowRootStyle(keepAspectRatio, view) {
  const id2 = useId$2();
  if (keepAspectRatio === !1)
    return [
      { "data-likec4-instance": id2 },
      `
:where([data-likec4-instance="${id2}"]) {
  display: block;
  box-sizing: border-box;
  border: 0 solid transparent;
  background: transparent;
  padding: 0;
  width: 100%;
  height: 100%;
  min-width: 80px;
  min-height: 80px;
}
  `.trim()
    ];
  const isLandscape = view.bounds.width > view.bounds.height;
  return [
    { "data-likec4-instance": id2 },
    `
:where([data-likec4-instance="${id2}"]) {
  display: block;
  box-sizing: border-box;
  border: 0 solid transparent;
  background: transparent;
  padding: 0;
  ${isLandscape ? "" : `
  max-width: var(--likec4-view-max-width, ${Math.ceil(view.bounds.width)}px);
  margin-left: auto;
  margin-right: auto;`}
  width: ${isLandscape ? "100%" : "auto"};
  height: ${isLandscape ? "auto" : "100%"};
  ${isLandscape ? "min-width: 80px;" : "min-height: 80px;"}
  aspect-ratio: ${Math.ceil(view.bounds.width)} / ${Math.ceil(view.bounds.height)};
  max-height: var(--likec4-view-max-height, ${Math.ceil(view.bounds.height)}px);
}
`.trim()
  ];
}
const Root = root.div;
function ShadowRoot$1({
  children: children2,
  injectFontCss = !0,
  styleNonce,
  ...props
}) {
  const styleSheets = useBundledStyleSheet(injectFontCss, styleNonce);
  return /* @__PURE__ */ jsx(Root, { styleSheets, ...props, children: children2 });
}
function ShadowRootMantineProvider({
  theme = DefaultTheme,
  children: children2,
  className,
  colorScheme,
  styleNonce
}) {
  const mantineRootRef = useRef(null);
  let getStyleNonce;
  return n$1(styleNonce) && (getStyleNonce = typeof styleNonce == "function" ? styleNonce : () => styleNonce), /* @__PURE__ */ jsx(
    "div",
    {
      ref: mantineRootRef,
      className: clsx(shadowRoot, className),
      ...colorScheme && { "data-mantine-color-scheme": colorScheme },
      children: /* @__PURE__ */ jsx(
        MantineProvider,
        {
          ...colorScheme && { forceColorScheme: colorScheme },
          defaultColorScheme: "auto",
          getRootElement: () => mantineRootRef.current ?? void 0,
          ...getStyleNonce && { getStyleNonce },
          cssVariablesSelector: ShadowRootCssSelector,
          theme,
          children: children2
        }
      )
    }
  );
}
function LikeC4Browser({
  className,
  colorScheme,
  view,
  injectFontCss,
  onNavigateTo,
  onClose,
  renderIcon,
  where,
  style: style2,
  mantineTheme,
  background = "dots",
  styleNonce,
  enableElementDetails = !0,
  enableRelationshipBrowser = enableElementDetails,
  enableRelationshipDetails = enableRelationshipBrowser
}) {
  var _a4;
  const onCloseRef = useSyncedRef(onClose), [opened, setOpened] = useState(!1), dialogRef = useRef(null), id2 = useId$2();
  useDebouncedEffect(
    () => {
      var _a5;
      return (_a5 = dialogRef.current) == null ? void 0 : _a5.showModal();
    },
    [],
    30
  ), useDebouncedEffect(
    () => setOpened(!0),
    [],
    80
  );
  const { start: triggerOnClose } = useTimeout(() => {
    var _a5;
    (_a5 = onCloseRef.current) == null || _a5.call(onCloseRef);
  }, 300), backdropRgb = colorScheme === "dark" ? "36 36 36" : "255 255 255", hasNotations = (((_a4 = view.notation) == null ? void 0 : _a4.elements) ?? []).length > 0;
  let nonce;
  return typeof styleNonce == "string" ? nonce = styleNonce : typeof styleNonce == "function" && (nonce = styleNonce()), /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      "style",
      {
        type: "text/css",
        nonce,
        dangerouslySetInnerHTML: {
          __html: `
        @keyframes likec4-dialog-fade-in {
          0% {
            opacity: 0;
            transform: scale(0.7);
            display: none;
          }
          100% {
            opacity: 1;
            transform: scale(1);
            display: block;
          }
        }
        @keyframes likec4-dialog-fade-out {
          0% {
            opacity: 1;
            transform: scale(1);
            display: block;
          }

          100% {
            opacity: 0;
            transform: scale(0.9);
            display: none;
          }
        }
        @keyframes likec4-dialog-backdrop-fade-in {
          0% {
            -webkit-backdrop-filter: blur(1px);
            backdrop-filter: blur(1px);
            background-color: rgb(${backdropRgb} / 30%);
          }
          100% {
            -webkit-backdrop-filter: blur(8px);
            backdrop-filter: blur(8px);
            background-color: rgb(${backdropRgb} / ${colorScheme === "dark" ? "85" : "75"}%);
          }
        }
        [data-likec4-instance="${id2}"] {
          top: 0;
          left: 0;
          border: 0 solid transparent;
          box-sizing: border-box;
          width: 100%;
          min-width: 100dvw;
          height: 100%;
          min-height: 100dvh;
          background: transparent;
          animation: likec4-dialog-fade-out 0.15s ease-out;
          transform-origin: 50% 20%;
        }
        [data-likec4-instance="${id2}"][open] {
          animation: likec4-dialog-fade-in 0.3s ease-out;
        }
        [data-likec4-instance="${id2}"] > div {
          width: 100%;
          height: 100%;
          padding: 0;
          margin: 0;
          border: 0 solid transparent;
          box-sizing: border-box;
        }
        [data-likec4-instance="${id2}"]::backdrop {
          -webkit-backdrop-filter: blur(1px);
          backdrop-filter: blur(1px);
          background-color: rgb(${backdropRgb} / 30%);
        }
        [data-likec4-instance="${id2}"][open]::backdrop {
          animation: likec4-dialog-backdrop-fade-in 450ms ease-out forwards;
        }
      `
        }
      }
    ),
    /* @__PURE__ */ jsx(
      "dialog",
      {
        "aria-modal": "true",
        "data-likec4-instance": id2,
        ref: dialogRef,
        style: {
          margin: 0,
          padding: 0,
          border: "0 solid transparent",
          ...style2
        },
        className,
        onClick: (e2) => {
          var _a5, _b2, _c;
          ((_b2 = (_a5 = e2.target) == null ? void 0 : _a5.nodeName) == null ? void 0 : _b2.toUpperCase()) === "DIALOG" && (e2.stopPropagation(), (_c = dialogRef.current) == null || _c.close());
        },
        onClose: (e2) => {
          e2.stopPropagation(), triggerOnClose();
        },
        children: /* @__PURE__ */ jsx(
          ShadowRoot$1,
          {
            injectFontCss,
            styleNonce,
            children: /* @__PURE__ */ jsxs(
              ShadowRootMantineProvider,
              {
                theme: mantineTheme,
                colorScheme,
                className: cssLikeC4Browser,
                styleNonce,
                children: [
                  opened && /* @__PURE__ */ jsx(
                    LikeC4Diagram,
                    {
                      className: cssDiagram,
                      view,
                      readonly: !0,
                      pannable: !0,
                      zoomable: !0,
                      fitView: !0,
                      fitViewPadding: 0.05,
                      showDiagramTitle: !0,
                      enableDynamicViewWalkthrough: !0,
                      enableFocusMode: !0,
                      enableSearch: !0,
                      enableElementDetails,
                      enableRelationshipBrowser,
                      enableRelationshipDetails,
                      showNavigationButtons: !0,
                      showNotations: hasNotations,
                      background,
                      controls: !0,
                      nodesSelectable: !1,
                      nodesDraggable: !1,
                      keepAspectRatio: !1,
                      renderIcon,
                      where,
                      onNavigateTo
                    }
                  ),
                  /* @__PURE__ */ jsx(
                    ActionIcon$1,
                    {
                      className: closeButton,
                      variant: "default",
                      color: "gray",
                      autoFocus: !0,
                      "data-autofocus": !0,
                      onClick: (e2) => {
                        var _a5;
                        e2.stopPropagation(), (_a5 = dialogRef.current) == null || _a5.close();
                      },
                      children: /* @__PURE__ */ jsx(IconX, {})
                    }
                  )
                ]
              }
            )
          }
        )
      }
    )
  ] });
}
function LikeC4ViewEmbedded({
  onNavigateTo: _onNavigateTo,
  className,
  view,
  injectFontCss,
  colorScheme,
  background = "transparent",
  renderIcon,
  showDiagramTitle = !1,
  showNavigationButtons = !1,
  enableFocusMode = !1,
  showNotations = !1,
  enableElementDetails = !1,
  enableRelationshipDetails = enableElementDetails,
  enableRelationshipBrowser = enableRelationshipDetails,
  mantineTheme,
  where,
  style: style2,
  styleNonce
}) {
  var _a4;
  const [shadowRootProps, cssstyle] = useShadowRootStyle(!0, view), onNavigateTo = useCallbackRef((to) => {
    _onNavigateTo == null || _onNavigateTo(to);
  }), onNavigateToMe = useCallbackRef(() => {
    _onNavigateTo == null || _onNavigateTo(view.id);
  }), hasNotations = (((_a4 = view.notation) == null ? void 0 : _a4.elements) ?? []).length > 0;
  let nonce;
  return typeof styleNonce == "string" ? nonce = styleNonce : typeof styleNonce == "function" && (nonce = styleNonce()), /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      "style",
      {
        type: "text/css",
        nonce,
        dangerouslySetInnerHTML: {
          __html: cssstyle
        }
      }
    ),
    /* @__PURE__ */ jsx(
      ShadowRoot$1,
      {
        ...shadowRootProps,
        injectFontCss,
        className: clsx("likec4-view", className),
        style: style2,
        children: /* @__PURE__ */ jsx(
          ShadowRootMantineProvider,
          {
            theme: mantineTheme,
            colorScheme,
            styleNonce,
            className: clsx(cssLikeC4View, !!_onNavigateTo && cssInteractive),
            children: /* @__PURE__ */ jsx(
              LikeC4Diagram,
              {
                view,
                readonly: !0,
                pannable: !1,
                zoomable: !1,
                background,
                fitView: !0,
                fitViewPadding: 0,
                showDiagramTitle,
                showNotations: showNotations && hasNotations,
                enableDynamicViewWalkthrough: enableFocusMode,
                showNavigationButtons,
                experimentalEdgeEditing: !1,
                enableFocusMode,
                enableRelationshipDetails,
                enableElementDetails,
                enableRelationshipBrowser,
                controls: !1,
                nodesSelectable: !1,
                nodesDraggable: !1,
                keepAspectRatio: !1,
                enableSearch: !1,
                renderIcon,
                where,
                ..._onNavigateTo && {
                  onNavigateTo,
                  onCanvasClick: onNavigateToMe,
                  onNodeClick: onNavigateToMe
                }
              }
            )
          }
        )
      }
    )
  ] });
}
function ReactLikeC4({
  className,
  view,
  colorScheme: explicitColorScheme,
  injectFontCss = !0,
  keepAspectRatio = !0,
  showNotations = !0,
  onNavigateTo,
  background = "transparent",
  style: style2,
  mantineTheme,
  styleNonce,
  ...props
}) {
  var _a4;
  const colorScheme = useColorScheme(explicitColorScheme), [shadowRootProps, cssstyle] = useShadowRootStyle(keepAspectRatio, view), hasNotations = (((_a4 = view.notation) == null ? void 0 : _a4.elements) ?? []).length > 0;
  let nonce;
  return t$4(styleNonce) ? nonce = styleNonce : t$3(styleNonce) && (nonce = styleNonce()), /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      "style",
      {
        type: "text/css",
        nonce,
        dangerouslySetInnerHTML: { __html: cssstyle }
      }
    ),
    /* @__PURE__ */ jsx(
      ShadowRoot$1,
      {
        ...shadowRootProps,
        injectFontCss,
        className: clsx("likec4-view", className),
        style: style2,
        styleNonce,
        children: /* @__PURE__ */ jsx(
          ShadowRootMantineProvider,
          {
            theme: mantineTheme,
            colorScheme,
            className: clsx(cssLikeC4View),
            styleNonce,
            children: /* @__PURE__ */ jsx(
              LikeC4Diagram,
              {
                view,
                showNotations: showNotations && hasNotations,
                keepAspectRatio: !1,
                onNavigateTo,
                background,
                ...props
              }
            )
          }
        )
      }
    )
  ] });
}
ReactLikeC4.displayName = "GenericReactLikeC4";
let listenerQueue = [], lqIndex = 0;
const QUEUE_ITEMS_PER_LISTENER = 4;
let epoch = 0, atom = (initialValue) => {
  let listeners = [], $atom = {
    get() {
      return $atom.lc || $atom.listen(() => {
      })(), $atom.value;
    },
    lc: 0,
    listen(listener) {
      return $atom.lc = listeners.push(listener), () => {
        for (let i2 = lqIndex + QUEUE_ITEMS_PER_LISTENER; i2 < listenerQueue.length; )
          listenerQueue[i2] === listener ? listenerQueue.splice(i2, QUEUE_ITEMS_PER_LISTENER) : i2 += QUEUE_ITEMS_PER_LISTENER;
        let index2 = listeners.indexOf(listener);
        ~index2 && (listeners.splice(index2, 1), --$atom.lc || $atom.off());
      };
    },
    notify(oldValue, changedKey) {
      epoch++;
      let runListenerQueue = !listenerQueue.length;
      for (let listener of listeners)
        listenerQueue.push(
          listener,
          $atom.value,
          oldValue,
          changedKey
        );
      if (runListenerQueue) {
        for (lqIndex = 0; lqIndex < listenerQueue.length; lqIndex += QUEUE_ITEMS_PER_LISTENER)
          listenerQueue[lqIndex](
            listenerQueue[lqIndex + 1],
            listenerQueue[lqIndex + 2],
            listenerQueue[lqIndex + 3]
          );
        listenerQueue.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(newValue) {
      let oldValue = $atom.value;
      oldValue !== newValue && ($atom.value = newValue, $atom.notify(oldValue));
    },
    subscribe(listener) {
      let unbind = $atom.listen(listener);
      return listener($atom.value), unbind;
    },
    value: initialValue
  };
  return $atom;
};
const MOUNT = 5, UNMOUNT = 6, REVERT_MUTATION = 10;
let on = (object2, listener, eventKey, mutateStore) => (object2.events = object2.events || {}, object2.events[eventKey + REVERT_MUTATION] || (object2.events[eventKey + REVERT_MUTATION] = mutateStore((eventProps) => {
  object2.events[eventKey].reduceRight((event, l2) => (l2(event), event), {
    shared: {},
    ...eventProps
  });
})), object2.events[eventKey] = object2.events[eventKey] || [], object2.events[eventKey].push(listener), () => {
  let currentListeners = object2.events[eventKey], index2 = currentListeners.indexOf(listener);
  currentListeners.splice(index2, 1), currentListeners.length || (delete object2.events[eventKey], object2.events[eventKey + REVERT_MUTATION](), delete object2.events[eventKey + REVERT_MUTATION]);
}), STORE_UNMOUNT_DELAY = 1e3, onMount = ($store, initialize) => on($store, (payload) => {
  let destroy = initialize(payload);
  destroy && $store.events[UNMOUNT].push(destroy);
}, MOUNT, (runListeners) => {
  let originListen = $store.listen;
  $store.listen = (...args) => (!$store.lc && !$store.active && ($store.active = !0, runListeners()), originListen(...args));
  let originOff = $store.off;
  return $store.events[UNMOUNT] = [], $store.off = () => {
    originOff(), setTimeout(() => {
      if ($store.active && !$store.lc) {
        $store.active = !1;
        for (let destroy of $store.events[UNMOUNT]) destroy();
        $store.events[UNMOUNT] = [];
      }
    }, STORE_UNMOUNT_DELAY);
  }, () => {
    $store.listen = originListen, $store.off = originOff;
  };
}), computedStore = (stores, cb, batched) => {
  Array.isArray(stores) || (stores = [stores]);
  let previousArgs, currentEpoch, set2 = () => {
    if (currentEpoch === epoch) return;
    currentEpoch = epoch;
    let args = stores.map(($store) => $store.get());
    if (!previousArgs || args.some((arg, i2) => arg !== previousArgs[i2])) {
      previousArgs = args;
      let value = cb(...args);
      value && value.then && value.t ? value.then((asyncValue) => {
        previousArgs === args && $computed.set(asyncValue);
      }) : ($computed.set(value), currentEpoch = epoch);
    }
  }, $computed = atom(void 0), get2 = $computed.get;
  $computed.get = () => (set2(), get2());
  let run2 = set2;
  return onMount($computed, () => {
    let unbinds = stores.map(($store) => $store.listen(run2));
    return set2(), () => {
      for (let unbind of unbinds) unbind();
    };
  }), $computed;
}, computed = (stores, fn) => computedStore(stores, fn);
function listenKeys($store, keys2, listener) {
  let keysSet = /* @__PURE__ */ new Set([...keys2, void 0]);
  return $store.listen((value, oldValue, changed) => {
    keysSet.has(changed) && listener(value, oldValue, changed);
  });
}
let map = (initial = {}) => {
  let $map = atom(initial);
  return $map.setKey = function(key, value) {
    let oldMap = $map.value;
    typeof value > "u" && key in $map.value ? ($map.value = { ...$map.value }, delete $map.value[key], $map.notify(oldMap, key)) : $map.value[key] !== value && ($map.value = {
      ...$map.value,
      [key]: value
    }, $map.notify(oldMap, key));
  }, $map;
}, emit = (snapshotRef, onChange) => (value) => {
  snapshotRef.current = value, onChange();
};
function useStore(store, { keys: keys2, deps = [store, keys2] } = {}) {
  let snapshotRef = useRef();
  snapshotRef.current = store.get();
  let subscribe = useCallback(
    (onChange) => (keys2 == null ? void 0 : keys2.length) > 0 ? listenKeys(store, keys2, emit(snapshotRef, onChange)) : store.listen(emit(snapshotRef, onChange)),
    deps
  ), get2 = () => snapshotRef.current;
  return useSyncExternalStore(subscribe, get2, get2);
}
const nanostores = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, atom, computed, map, useStore }, Symbol.toStringTag, { value: "Module" }));
function createLikeC4Model(model) {
  return LikeC4Model.layouted(model);
}
export {
  BundledStyles,
  DefaultTheme,
  LikeC4Browser,
  LikeC4Model,
  LikeC4ModelProvider,
  LikeC4ViewEmbedded,
  ReactLikeC4,
  createLikeC4Model,
  nanostores as nano,
  useBundledStyleSheet,
  useColorScheme,
  useLikeC4DiagramView,
  useLikeC4Model,
  useLikeC4View,
  useLikeC4ViewModel,
  useLikeC4Views
};
