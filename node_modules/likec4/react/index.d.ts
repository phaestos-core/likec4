// Generated by dts-bundle-generator v9.5.1

import { CSSProperties, DependencyList, HTMLAttributes, MouseEvent as ReactMouseEvent, PropsWithChildren, ReactNode } from 'react';
import { Class, LiteralUnion, NonEmptyTuple, OverrideProperties, PartialDeep, Tagged, TupleToUnion } from 'type-fest';

type NonEmptyArray<T> = [
	T,
	...T[]
];
type IconUrl = Tagged<string, "IconUrl"> | "none";
type Point = readonly [
	x: number,
	y: number
];
interface XYPoint {
	x: number;
	y: number;
}
declare const ThemeColors: readonly [
	"amber",
	"blue",
	"gray",
	"slate",
	"green",
	"indigo",
	"muted",
	"primary",
	"red",
	"secondary",
	"sky"
];
type ThemeColor = typeof ThemeColors[number];
type HexColorLiteral = `#${string}`;
type ColorLiteral = HexColorLiteral;
type Color = LiteralUnion<ThemeColor, string>;
interface ElementThemeColorValues {
	fill: ColorLiteral;
	stroke: ColorLiteral;
	hiContrast: ColorLiteral;
	loContrast: ColorLiteral;
}
interface RelationshipThemeColorValues {
	lineColor: ColorLiteral;
	labelBgColor: ColorLiteral;
	labelColor: ColorLiteral;
}
interface ThemeColorValues {
	elements: ElementThemeColorValues;
	relationships: RelationshipThemeColorValues;
}
type Fqn<Id extends string = string> = Tagged<Id, "Fqn">;
declare const BorderStyles: readonly [
	"solid",
	"dashed",
	"dotted",
	"none"
];
type BorderStyle = TupleToUnion<typeof BorderStyles>;
type ElementKind<Kinds extends string = string> = Tagged<Kinds, "ElementKind">;
declare namespace ElementKind {
	const Group: ElementKind;
}
declare const ElementShapes: readonly [
	"rectangle",
	"person",
	"browser",
	"mobile",
	"cylinder",
	"storage",
	"queue"
];
type ElementShape = TupleToUnion<typeof ElementShapes>;
interface ElementStyle {
	border?: BorderStyle;
	opacity?: number;
}
type Tag<Tags extends string = string> = Tagged<Tags, "Tag">;
interface Link {
	readonly title?: string;
	readonly url: string;
	readonly relative?: string;
}
interface TypedElement<Ids extends string, Kinds extends string, Tags extends string, MetadataKeys extends string = never> {
	readonly id: Fqn<Ids>;
	readonly kind: ElementKind<Kinds>;
	readonly title: string;
	readonly description: string | null;
	readonly technology: string | null;
	readonly tags: NonEmptyArray<Tag<Tags>> | null;
	readonly links: NonEmptyArray<Link> | null;
	readonly icon?: IconUrl;
	readonly shape?: ElementShape;
	readonly color?: Color;
	readonly style?: ElementStyle;
	readonly notation?: string;
	readonly metadata?: Record<MetadataKeys, string>;
}
interface Element$1 extends TypedElement<string, string, string, string> {
}
interface ElementKindSpecificationStyle {
	shape?: ElementShape;
	icon?: IconUrl;
	color?: Color;
	border?: BorderStyle;
	opacity?: number;
}
interface ElementKindSpecification {
	readonly technology?: string;
	readonly notation?: string;
	readonly style: ElementKindSpecificationStyle;
}
type EqualOperator<V> = {
	eq: V;
	neq?: never;
} | {
	eq?: never;
	neq: V;
};
type AllNever = {
	not?: never;
	and?: never;
	or?: never;
	tag?: never;
	kind?: never;
};
type TagEqual<Tag> = Omit<AllNever, "tag"> & {
	tag: EqualOperator<Tag>;
};
type KindEqual<Kind> = Omit<AllNever, "kind"> & {
	kind: EqualOperator<Kind>;
};
type NotOperator<Tag, Kind> = Omit<AllNever, "not"> & {
	not: WhereOperator<Tag, Kind>;
};
type AndOperator<Tag, Kind> = Omit<AllNever, "and"> & {
	and: NonEmptyArray<WhereOperator<Tag, Kind>>;
};
type OrOperator<Tag, Kind> = Omit<AllNever, "or"> & {
	or: NonEmptyArray<WhereOperator<Tag, Kind>>;
};
type WhereOperator<Tag, Kind> = TagEqual<Tag> | KindEqual<Kind> | NotOperator<Tag, Kind> | AndOperator<Tag, Kind> | OrOperator<Tag, Kind>;
type GlobalPredicateId = Tagged<string, "GlobalPredicateId">;
type GlobalPredicates = NonEmptyArray<ViewRulePredicate>;
type GlobalDynamicPredicates = NonEmptyArray<DynamicViewIncludeRule>;
type GlobalStyleID = Tagged<string, "GlobalStyleID">;
type GlobalStyles = NonEmptyTuple<ViewRuleStyle>;
interface ModelGlobals {
	predicates: Record<GlobalPredicateId, GlobalPredicates>;
	dynamicPredicates: Record<GlobalPredicateId, GlobalDynamicPredicates>;
	styles: Record<GlobalStyleID, GlobalStyles>;
}
type ElementNotation = {
	kinds: ElementKind[];
	shape: ElementShape;
	color: Color;
	title: string;
};
type ViewID<Id extends string = string> = Tagged<Id, "ViewID">;
type ViewRulePredicate = {
	include: Expression[];
	exclude?: never;
} | {
	include?: never;
	exclude: Expression[];
};
interface ViewRuleGlobalPredicateRef {
	predicateId: GlobalPredicateId;
}
interface ViewRuleStyle {
	targets: ElementExpression[];
	notation?: string;
	style: ElementStyle & {
		color?: Color;
		shape?: ElementShape;
		icon?: IconUrl;
	};
}
interface ViewRuleGlobalStyle {
	styleId: GlobalStyleID;
}
type AutoLayoutDirection = "TB" | "BT" | "LR" | "RL";
interface ViewRuleAutoLayout {
	direction: AutoLayoutDirection;
	nodeSep?: number;
	rankSep?: number;
}
interface ViewRuleGroup {
	groupRules: Array<ViewRulePredicate | ViewRuleGroup>;
	title: string | null;
	color?: Color;
	border?: BorderStyle;
	opacity?: number;
}
type ViewRule = ViewRulePredicate | ViewRuleGlobalPredicateRef | ViewRuleGroup | ViewRuleStyle | ViewRuleGlobalStyle | ViewRuleAutoLayout;
interface BasicView<ViewType extends "element" | "dynamic", ViewIDs extends string, Tags extends string> {
	readonly __?: ViewType;
	readonly id: ViewID<ViewIDs>;
	readonly title: string | null;
	readonly description: string | null;
	readonly tags: NonEmptyArray<Tag<Tags>> | null;
	readonly links: NonEmptyArray<Link> | null;
	/**
	 * URI to the source file of this view.
	 * Undefined if the view is auto-generated.
	 */
	readonly docUri?: string;
	/**
	 * For all views we find common ancestor path.
	 * This is used to generate relative paths, i.e.:
	 * - "/home/project/index.c4" becomes "index.c4"
	 * - "/home/project/subdir/views.c4" becomes "subdir/views.c4"
	 *
	 * Undefined if the view is auto-generated.
	 */
	readonly relativePath?: string;
	/**
	 * If the view is changed manually this field contains the layout data.
	 */
	readonly manualLayout?: ViewManualLayout | undefined;
	readonly customColorDefinitions: CustomColorDefinitions;
}
interface BasicElementView<ViewIDs extends string, Tags extends string> extends BasicView<"element", ViewIDs, Tags> {
	readonly viewOf?: Fqn;
	readonly rules: ViewRule[];
}
interface ScopedElementView<ViewIDs extends string, Tags extends string> extends BasicElementView<ViewIDs, Tags> {
	readonly viewOf: Fqn;
}
interface ExtendsElementView<ViewIDs extends string, Tags extends string> extends BasicElementView<ViewIDs, Tags> {
	readonly extends: ViewID<ViewIDs>;
}
type ElementView<ViewIDs extends string = string, Tags extends string = string> = ScopedElementView<ViewIDs, Tags> | ExtendsElementView<ViewIDs, Tags> | BasicElementView<ViewIDs, Tags>;
interface DynamicViewStep {
	readonly source: Fqn;
	readonly target: Fqn;
	readonly title: string | null;
	readonly description?: string;
	readonly technology?: string;
	readonly notation?: string;
	readonly notes?: string;
	readonly color?: Color;
	readonly line?: RelationshipLineType;
	readonly head?: RelationshipArrowType;
	readonly tail?: RelationshipArrowType;
	readonly isBackward?: boolean;
	readonly navigateTo?: ViewID;
	__parallel?: never;
}
interface DynamicViewParallelSteps {
	readonly __parallel: DynamicViewStep[];
}
type DynamicViewStepOrParallel = DynamicViewStep | DynamicViewParallelSteps;
type DynamicViewIncludeRule = {
	include: ElementPredicateExpression[];
};
type DynamicViewRule = DynamicViewIncludeRule | ViewRuleGlobalPredicateRef | ViewRuleStyle | ViewRuleGlobalStyle | ViewRuleAutoLayout;
interface DynamicView<ViewIDs extends string = string, Tags extends string = string> extends BasicView<"dynamic", ViewIDs, Tags> {
	readonly __: "dynamic";
	readonly steps: DynamicViewStepOrParallel[];
	readonly rules: DynamicViewRule[];
}
type CustomColorDefinitions = {
	[key: string]: ThemeColorValues;
};
type LikeC4View<ViewIDs extends string = string, Tags extends string = string> = ElementView<ViewIDs, Tags> | DynamicView<ViewIDs, Tags>;
type NodeId<IDs extends string = string> = Tagged<IDs, "Fqn">;
type EdgeId = Tagged<string, "EdgeId">;
interface ComputedNode {
	id: NodeId;
	kind: ElementKind;
	parent: NodeId | null;
	title: string;
	description: string | null;
	technology: string | null;
	notation?: string;
	tags: NonEmptyArray<Tag> | null;
	links: NonEmptyArray<Link> | null;
	children: NodeId[];
	inEdges: EdgeId[];
	outEdges: EdgeId[];
	shape: ElementShape;
	/**
	 * @deprecated Use `style` instead
	 */
	color: Color;
	/**
	 * @deprecated Use `style` instead
	 */
	icon?: IconUrl;
	style: ElementStyle;
	navigateTo?: ViewID;
	level: number;
	depth?: number;
	/**
	 * If this node was customized in the view
	 */
	isCustomized?: boolean;
}
declare namespace ComputedNode {
	/**
	 * Nodes group is a special kind of node, exisiting only in view
	 */
	function isNodesGroup(node: ComputedNode): boolean;
}
interface ComputedEdge {
	id: EdgeId;
	parent: NodeId | null;
	source: NodeId;
	target: NodeId;
	label: string | null;
	description?: string;
	technology?: string;
	relations: RelationID[];
	kind?: RelationshipKind;
	notation?: string;
	notes?: string;
	color?: Color;
	line?: RelationshipLineType;
	head?: RelationshipArrowType;
	tail?: RelationshipArrowType;
	tags?: NonEmptyArray<Tag>;
	navigateTo?: ViewID;
	/**
	 * If this edge is derived from custom relationship predicate
	 */
	isCustomized?: boolean;
	/**
	 * For layouting purposes
	 * @default 'forward'
	 */
	dir?: "forward" | "back";
}
interface ViewWithHash {
	/**
	 * Hash of the view object.
	 * This is used to detect changes in layout
	 */
	hash: string;
}
interface ViewWithNotation {
	notation?: {
		elements: ElementNotation[];
	};
}
interface ViewAutoLayout {
	direction: ViewRuleAutoLayout["direction"];
	rankSep?: number;
	nodeSep?: number;
}
interface ComputedElementView<ViewIDs extends string = string, Tags extends string = string> extends Omit<ElementView<ViewIDs, Tags>, "rules" | "docUri">, ViewWithHash, ViewWithNotation {
	readonly extends?: ViewID<ViewIDs>;
	readonly autoLayout: ViewAutoLayout;
	readonly nodes: ComputedNode[];
	readonly edges: ComputedEdge[];
	rules?: never;
	docUri?: never;
}
interface ComputedDynamicView<ViewIDs extends string = string, Tags extends string = string> extends Omit<DynamicView<ViewIDs, Tags>, "rules" | "steps" | "docUri">, ViewWithHash, ViewWithNotation {
	readonly autoLayout: ViewAutoLayout;
	readonly nodes: ComputedNode[];
	readonly edges: ComputedEdge[];
	steps?: never;
	rules?: never;
	docUri?: never;
}
type ComputedView<ViewIDs extends string = string, Tags extends string = string> = ComputedElementView<ViewIDs, Tags> | ComputedDynamicView<ViewIDs, Tags>;
type BBox = {
	x: number;
	y: number;
	width: number;
	height: number;
};
interface DiagramNode extends ComputedNode {
	width: number;
	height: number;
	position: Point;
	labelBBox: BBox;
}
declare namespace DiagramNode {
	/**
	 * Nodes group is a special kind of node, exisiting only in view
	 */
	function isNodesGroup(node: DiagramNode): boolean;
}
interface DiagramEdge extends ComputedEdge {
	points: NonEmptyArray<Point>;
	controlPoints?: NonEmptyArray<XYPoint>;
	labelBBox?: BBox | null;
	dotpos?: string;
}
interface DiagramView<ViewIDs extends string = string, Tags extends string = string> extends Omit<ComputedView<ViewIDs, Tags>, "nodes" | "edges" | "manualLayout"> {
	readonly nodes: DiagramNode[];
	readonly edges: DiagramEdge[];
	readonly bounds: BBox;
	/**
	 * If diagram has manual layout
	 * But was changed and layout should be recalculated
	 */
	hasLayoutDrift?: boolean;
	manualLayout?: never;
}
type ViewManualLayout = {
	readonly hash: string;
	readonly x: number;
	readonly y: number;
	readonly width: number;
	readonly height: number;
	readonly autoLayout: ViewAutoLayout;
	readonly nodes: Record<string, {
		isCompound: boolean;
		x: number;
		y: number;
		width: number;
		height: number;
	}>;
	readonly edges: Record<string, {
		dotpos?: string;
		points: NonEmptyArray<Point>;
		controlPoints?: NonEmptyArray<XYPoint>;
		labelBBox?: BBox;
	}>;
};
type RelationID = Tagged<string, "RelationID">;
type RelationshipKind<Kinds extends string = string> = Tagged<Kinds, "RelationshipKind">;
type RelationshipLineType = "dashed" | "solid" | "dotted";
type RelationshipArrowType = "none" | "normal" | "onormal" | "dot" | "odot" | "diamond" | "odiamond" | "crow" | "open" | "vee";
interface Relation {
	readonly id: RelationID;
	readonly source: Fqn;
	readonly target: Fqn;
	readonly title: string;
	readonly description?: string;
	readonly technology?: string;
	readonly tags?: NonEmptyArray<Tag>;
	readonly kind?: RelationshipKind;
	readonly color?: Color;
	readonly line?: RelationshipLineType;
	readonly head?: RelationshipArrowType;
	readonly tail?: RelationshipArrowType;
	readonly links?: NonEmptyArray<Link>;
	readonly navigateTo?: ViewID;
	readonly metadata?: {
		[key: string]: string;
	};
}
interface RelationshipKindSpecification {
	readonly technology?: string;
	readonly notation?: string;
	readonly color?: Color;
	readonly line?: RelationshipLineType;
	readonly head?: RelationshipArrowType;
	readonly tail?: RelationshipArrowType;
}
interface BaseExpr {
	where?: never;
	element?: never;
	custom?: never;
	expanded?: never;
	elementKind?: never;
	elementTag?: never;
	isEqual?: never;
	isDescedants?: never;
	wildcard?: never;
	source?: never;
	target?: never;
	inout?: never;
	incoming?: never;
	outgoing?: never;
	customRelation?: never;
}
interface ElementRefExpr extends Omit<BaseExpr, "element" | "isDescedants"> {
	element: Fqn;
	isDescedants?: boolean;
}
interface ExpandedElementExpr extends Omit<BaseExpr, "expanded"> {
	expanded: Fqn;
}
interface CustomElementExpr extends Omit<BaseExpr, "custom"> {
	custom: {
		expr: ElementExpression | ElementWhereExpr;
		title?: string;
		description?: string;
		technology?: string;
		notation?: string;
		shape?: ElementShape;
		color?: Color;
		icon?: IconUrl;
		border?: BorderStyle;
		opacity?: number;
		navigateTo?: ViewID;
	};
}
interface WildcardExpr extends Omit<BaseExpr, "wildcard"> {
	wildcard: true;
}
interface ElementKindExpr extends Omit<BaseExpr, "elementKind" | "isEqual"> {
	elementKind: ElementKind;
	isEqual: boolean;
}
interface ElementTagExpr extends Omit<BaseExpr, "elementTag" | "isEqual"> {
	elementTag: Tag;
	isEqual: boolean;
}
type ElementExpression = ElementRefExpr | WildcardExpr | ElementKindExpr | ElementTagExpr | ExpandedElementExpr;
interface ElementWhereExpr extends Omit<BaseExpr, "where"> {
	where: {
		expr: ElementExpression;
		condition: WhereOperator<string, string>;
	};
}
type ElementPredicateExpression = ElementExpression | ElementWhereExpr | CustomElementExpr;
interface RelationExpr extends Omit<BaseExpr, "source" | "target"> {
	source: ElementExpression;
	target: ElementExpression;
	isBidirectional?: boolean;
}
interface InOutExpr extends Omit<BaseExpr, "inout"> {
	inout: ElementExpression;
}
interface IncomingExpr extends Omit<BaseExpr, "incoming"> {
	incoming: ElementExpression;
}
interface OutgoingExpr extends Omit<BaseExpr, "outgoing"> {
	outgoing: ElementExpression;
}
type RelationExpression = RelationExpr | InOutExpr | IncomingExpr | OutgoingExpr;
interface RelationWhereExpr extends Omit<BaseExpr, "where"> {
	where: {
		expr: RelationExpression;
		condition: WhereOperator<string, string>;
	};
}
interface CustomRelationExpr extends Omit<BaseExpr, "customRelation"> {
	customRelation: {
		relation: RelationExpression | RelationWhereExpr;
		title?: string;
		description?: string;
		technology?: string;
		notation?: string;
		navigateTo?: ViewID;
		notes?: string;
		color?: Color;
		line?: RelationshipLineType;
		head?: RelationshipArrowType;
		tail?: RelationshipArrowType;
	};
}
type RelationPredicateExpression = RelationExpression | RelationWhereExpr | CustomRelationExpr;
type Expression = ElementPredicateExpression | RelationPredicateExpression;
interface ParsedLikeC4Model<ElementKinds extends string = string, RelationKinds extends string = string, Tags extends string = string, Fqns extends string = string, Views extends string = string> {
	specification: {
		tags: Tag<Tags>[];
		elements: Record<ElementKinds, ElementKindSpecification>;
		relationships: Record<RelationKinds, RelationshipKindSpecification>;
	};
	elements: Record<Fqns, TypedElement<Fqns, ElementKinds, Tags>>;
	relations: Record<RelationID, Relation>;
	globals: ModelGlobals;
	views: Record<Views, LikeC4View<Views, Tags>>;
}
interface ComputedLikeC4Model extends Omit<ParsedLikeC4Model, "views"> {
	__?: never;
	views: Record<ViewID, ComputedView>;
}
interface LayoutedLikeC4Model extends Omit<ParsedLikeC4Model, "views"> {
	__: "layouted";
	views: Record<ViewID, DiagramView>;
}
declare namespace ViewChange {
	interface ChangeElementStyle {
		op: "change-element-style";
		style: {
			border?: BorderStyle;
			opacity?: number;
			shape?: ElementShape;
			color?: ThemeColor;
		};
		targets: NonEmptyArray<Fqn>;
	}
	interface SaveManualLayout {
		op: "save-manual-layout";
		layout: ViewManualLayout;
	}
	interface ChangeAutoLayout {
		op: "change-autolayout";
		layout: {
			direction: AutoLayoutDirection;
			nodeSep?: number | null;
			rankSep?: number | null;
		};
	}
}
type ViewChange = ViewChange.ChangeElementStyle | ViewChange.SaveManualLayout | ViewChange.ChangeAutoLayout;
type Fqn$1 = LiteralUnion<Fqn, string>;
type RelationID$1 = LiteralUnion<RelationID, string>;
type ViewID$1 = LiteralUnion<ViewID, string>;
type EdgeId$1 = LiteralUnion<EdgeId, string>;
type IncomingFilter = "all" | "direct" | "to-descendants";
type OutgoingFilter = "all" | "direct" | "from-descendants";
type ElementOrFqn = Fqn$1 | {
	id: Fqn$1;
};
declare class LikeC4ViewModel {
	readonly view: ComputedView;
	readonly model: LikeC4Model<LikeC4ViewModel>;
	private readonly _rootElements;
	private readonly _elements;
	private readonly _connections;
	constructor(view: ComputedView, model: LikeC4Model<LikeC4ViewModel>);
	get id(): ViewID<string>;
	get title(): string;
	get viewOf(): LikeC4Model.ElementModel<LikeC4ViewModel>;
	get tags(): Tag[];
	roots(): ReadonlyArray<LikeC4ViewModel.Element>;
	elements(): ReadonlyArray<LikeC4ViewModel.Element>;
	element(id: Fqn$1): LikeC4ViewModel.Element;
	hasElement(id: Fqn$1): boolean;
	connections(): ReadonlyArray<LikeC4ViewModel.Connection>;
	connection(id: EdgeId$1): LikeC4ViewModel.Connection;
	findConnections(source: ElementOrFqn, target: ElementOrFqn, direction?: "both" | "direct"): ReadonlyArray<LikeC4ViewModel.Connection>;
	parent(element: ElementOrFqn): LikeC4ViewModel.Element | null;
	children(element: ElementOrFqn): ReadonlyArray<LikeC4ViewModel.Element>;
	siblings(element: ElementOrFqn): ReadonlyArray<LikeC4ViewModel.Element>;
	/**
	 * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
	 * (from closest to root)
	 */
	ancestors(element: ElementOrFqn): ReadonlyArray<LikeC4ViewModel.Element>;
	descendants(element: ElementOrFqn): ReadonlyArray<LikeC4ViewModel.Element>;
	incoming(element: ElementOrFqn, filter?: IncomingFilter): ReadonlyArray<LikeC4ViewModel.Connection>;
	incomers(element: ElementOrFqn, filter?: IncomingFilter): ReadonlyArray<LikeC4ViewModel.Element>;
	/**
	 * Outgoing relationships from the element and its descendants
	 */
	outgoing(element: ElementOrFqn, filter?: OutgoingFilter): ReadonlyArray<LikeC4ViewModel.Connection>;
	outgoers(element: ElementOrFqn, filter?: OutgoingFilter): ReadonlyArray<LikeC4ViewModel.Element>;
}
declare namespace LikeC4ViewModel {
	/**
	 * Represents an element in the view. (Diagram node)
	 * All methods are view-scoped, i.e. `children` returns only children of the element in the view.
	 */
	class Element {
		readonly node: ComputedNode;
		private readonly viewmodel;
		constructor(node: ComputedNode, viewmodel: LikeC4ViewModel);
		get id(): NodeId<string>;
		get title(): string;
		get kind(): ElementKind;
		get isRoot(): boolean;
		get hasNested(): boolean;
		get shape(): ElementShape;
		get color(): Color;
		get tags(): Tag[];
		model(): LikeC4Model.ElementModel<LikeC4ViewModel>;
		parent(): LikeC4ViewModel.Element | null;
		metadata(key: string): string | undefined;
		metadata(key: string, defaultValue: string): string;
		hasMetadata(key: string): boolean;
		ancestors(): ReadonlyArray<LikeC4ViewModel.Element>;
		siblings(): ReadonlyArray<LikeC4ViewModel.Element>;
		descendants(): ReadonlyArray<LikeC4ViewModel.Element>;
		children(): ReadonlyArray<LikeC4ViewModel.Element>;
		incoming(filter?: "all" | "direct" | "to-descendants"): ReadonlyArray<LikeC4ViewModel.Connection>;
		incomers(filter?: "all" | "direct" | "to-descendants"): ReadonlyArray<LikeC4ViewModel.Element>;
		outgoing(filter?: OutgoingFilter): ReadonlyArray<LikeC4ViewModel.Connection>;
		outgoers(filter?: OutgoingFilter): ReadonlyArray<LikeC4ViewModel.Element>;
		connectionsTo(target: Fqn$1 | LikeC4ViewModel.Element): ReadonlyArray<LikeC4ViewModel.Connection>;
	}
	/**
	 * Represents a connection between two elements.
	 * May be source from multiple model relationships.
	 */
	class Connection {
		readonly edge: ComputedEdge;
		private readonly viewmodel;
		constructor(edge: ComputedEdge, viewmodel: LikeC4ViewModel);
		get id(): EdgeId;
		get source(): LikeC4ViewModel.Element;
		get target(): LikeC4ViewModel.Element;
		get tags(): Tag[];
		/**
		 * Model relationships
		 */
		relationships(): ReadonlyArray<LikeC4Model.Relationship<LikeC4ViewModel>>;
	}
}
type PickBySource<Source> = Source extends LikeC4Model.Layouted.SourceModel ? LikeC4Model.Layouted : Source extends LikeC4Model.Computed.SourceModel ? LikeC4Model.Computed : never;
export declare class LikeC4Model<M extends LikeC4Model.ViewModel = LikeC4Model.ViewModel> {
	readonly type: LikeC4Model.ModelType<M>;
	readonly sourcemodel: LikeC4Model.SourceModel<M>;
	private _elements;
	private _parents;
	private _children;
	private _rootElements;
	private _relations;
	private _incoming;
	private _outgoing;
	private _internal;
	private _cacheAscendingSiblings;
	private _views;
	constructor(type: LikeC4Model.ModelType<M>, sourcemodel: LikeC4Model.SourceModel<M>, elements: Element$1[], relations: Relation[], views: LikeC4Model.SourceModel<M>["views"], ViewModelClass: Class<M>);
	/**
	 * Returns the root elements of the model.
	 */
	roots(): ReadonlyArray<LikeC4Model.ElementModel<M>>;
	/**
	 * Returns all elements in the model.
	 */
	elements(): ReadonlyArray<LikeC4Model.ElementModel<M>>;
	/**
	 * Returns a specific element by its FQN.
	 */
	element(id: Fqn$1): LikeC4Model.ElementModel<M>;
	/**
	 * Returns all relationships in the model.
	 */
	relationships(): ReadonlyArray<LikeC4Model.Relationship<M>>;
	/**
	 * Returns a specific relationship by its ID.
	 */
	relationship(id: RelationID$1): LikeC4Model.Relationship<M>;
	/**
	 * Returns all views in the model.
	 */
	views(): ReadonlyArray<M>;
	/**
	 * Returns a specific view by its ID.
	 */
	view(viewId: ViewID$1): M;
	/**
	 * Returns the parent element of given element.
	 * @see ancestors
	 */
	parent(element: ElementOrFqn): LikeC4Model.ElementModel<M> | null;
	/**
	 * Get all children of the element (only direct children),
	 * @see descendants
	 */
	children(element: ElementOrFqn): ReadonlyArray<LikeC4Model.ElementModel<M>>;
	/**
	 * Get all sibling (i.e. same parent)
	 */
	siblings(element: ElementOrFqn): ReadonlyArray<LikeC4Model.ElementModel<M>>;
	/**
	 * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
	 * (from closest to root)
	 */
	ancestors(element: ElementOrFqn): ReadonlyArray<LikeC4Model.ElementModel<M>>;
	/**
	 * Get all descendant elements (i.e. children, children’s children, etc.)
	 */
	descendants(element: ElementOrFqn): ReadonlyArray<LikeC4Model.ElementModel<M>>;
	/**
	 * Incoming relationships to the element and its descendants
	 * @see incomers
	 */
	incoming(element: ElementOrFqn, filter?: IncomingFilter): ReadonlyArray<LikeC4Model.Relationship<M>>;
	/**
	 * Source elements of incoming relationships
	 */
	incomers(element: ElementOrFqn, filter?: IncomingFilter): ReadonlyArray<LikeC4Model.ElementModel<M>>;
	/**
	 * Outgoing relationships from the element and its descendants
	 * @see outgoers
	 */
	outgoing(element: ElementOrFqn, filter?: OutgoingFilter): ReadonlyArray<LikeC4Model.Relationship<M>>;
	/**
	 * Target elements of outgoing relationships
	 */
	outgoers(element: ElementOrFqn, filter?: OutgoingFilter): ReadonlyArray<LikeC4Model.ElementModel<M>>;
	/**
	 * Relationships inside the element, among descendants
	 */
	internal(element: ElementOrFqn): ReadonlyArray<LikeC4Model.Relationship<M>>;
	/**
	 * Resolve siblings of the element and siblings of ancestors
	 *  (from closest to root)
	 */
	ascendingSiblings(element: ElementOrFqn): ReadonlyArray<LikeC4Model.ElementModel<M>>;
	/**
	 * Resolve all views that contain the element
	 */
	viewsWithElement(element: ElementOrFqn): ReadonlyArray<M>;
	private addElement;
	private addRelation;
	private _childrenOf;
	private _incomingTo;
	private _outgoingFrom;
	private _internalOf;
}
export declare namespace LikeC4Model {
	function create(source: LikeC4Model.SourceModel): PickBySource<typeof source>;
	function computed(source: ComputedLikeC4Model): LikeC4Model<LikeC4ViewModel>;
	function layouted(source: LayoutedLikeC4Model): LikeC4Model<LikeC4DiagramModel>;
	function isModel(model: any): model is LikeC4Model;
	type SourceModel<M extends ViewModel = ViewModel> = M extends LikeC4DiagramModel ? LayoutedLikeC4Model : ComputedLikeC4Model;
	type ViewModel = LikeC4ViewModel | LikeC4DiagramModel;
	namespace ViewModel {
		type ElementModel = LikeC4ViewModel.Element | LikeC4DiagramModel.Element;
		type Relationship = LikeC4Model.Relationship<ViewModel>;
		function isLayouted(model: ViewModel): model is LikeC4DiagramModel;
	}
	type Computed = LikeC4Model<LikeC4ViewModel>;
	namespace Computed {
		type ViewModel = LikeC4ViewModel;
		type SourceModel = LikeC4Model.SourceModel<ViewModel>;
	}
	type Layouted = LikeC4Model<LikeC4DiagramModel>;
	namespace Layouted {
		type ViewModel = LikeC4DiagramModel;
		type SourceModel = LikeC4Model.SourceModel<ViewModel>;
	}
	type ModelType<M extends ViewModel = ViewModel> = M extends LikeC4DiagramModel ? "layouted" : M extends LikeC4ViewModel ? "computed" : never;
	function isLayouted(model: LikeC4Model): model is Layouted;
	class Relationship<M extends ViewModel = ViewModel> {
		readonly relationship: Relation;
		private readonly model;
		constructor(relationship: Relation, model: LikeC4Model<M>);
		get id(): RelationID;
		get title(): string;
		get kind(): RelationshipKind<string>;
		get tags(): Tag[];
		get source(): ElementModel<M>;
		get target(): ElementModel<M>;
		metadata(key: string): string | undefined;
		metadata(key: string, defaultValue: string): string;
		hasMetadata(key: string): boolean;
	}
	class ElementModel<M extends ViewModel = ViewModel> {
		readonly element: Element$1;
		private readonly model;
		constructor(element: Element$1, model: LikeC4Model<M>);
		get id(): Fqn<string>;
		get title(): string;
		get kind(): ElementKind;
		get isRoot(): boolean;
		get hasNested(): boolean;
		get shape(): ElementShape;
		get color(): Color;
		get tags(): Tag[];
		parent(): ElementModel<M> | null;
		metadata(key: string): string | undefined;
		metadata(key: string, defaultValue: string): string;
		hasMetadata(key: string): boolean;
		ancestors(): readonly ElementModel<M>[];
		siblings(): readonly ElementModel<M>[];
		descendants(): readonly ElementModel<M>[];
		children(): readonly ElementModel<M>[];
		/**
		 * First 'view of' current element
		 */
		viewOf(): M;
		/**
		 * All views 'view of' current element
		 */
		viewsOf(): M[];
		/**
		 * Views that contain this element
		 */
		views(): readonly M[];
		incoming(filter?: IncomingFilter): readonly Relationship<M>[];
		incomers(filter?: IncomingFilter): readonly ElementModel<M>[];
		outgoing(filter?: OutgoingFilter): readonly Relationship<M>[];
		outgoers(filter?: OutgoingFilter): readonly ElementModel<M>[];
		internal(): readonly Relationship<M>[];
		/**
		 * Resolve siblings of the element and siblings of ancestors
		 *  (from closest to root)
		 */
		ascendingSiblings(): readonly ElementModel<M>[];
	}
}
declare class LikeC4DiagramModel {
	readonly view: DiagramView;
	readonly model: LikeC4Model.Layouted;
	private readonly _rootElements;
	private readonly _elements;
	private readonly _connections;
	constructor(view: DiagramView, model: LikeC4Model.Layouted);
	get isDynamic(): boolean;
	get id(): ViewID<string>;
	get title(): string;
	get viewOf(): LikeC4Model.ElementModel<LikeC4DiagramModel>;
	get tags(): Tag[];
	roots(): ReadonlyArray<LikeC4DiagramModel.Element>;
	elements(): ReadonlyArray<LikeC4DiagramModel.Element>;
	element(id: Fqn$1): LikeC4DiagramModel.Element;
	hasElement(id: Fqn$1): boolean;
	connections(): ReadonlyArray<LikeC4DiagramModel.Connection>;
	connection(id: EdgeId$1): LikeC4DiagramModel.Connection;
	findConnections(source: ElementOrFqn, target: ElementOrFqn, direction?: "both" | "direct"): ReadonlyArray<LikeC4DiagramModel.Connection>;
	parent(element: ElementOrFqn): LikeC4DiagramModel.Element | null;
	children(element: ElementOrFqn): ReadonlyArray<LikeC4DiagramModel.Element>;
	siblings(element: ElementOrFqn): ReadonlyArray<LikeC4DiagramModel.Element>;
	/**
	 * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
	 * (from closest to root)
	 */
	ancestors(element: ElementOrFqn): ReadonlyArray<LikeC4DiagramModel.Element>;
	descendants(element: ElementOrFqn): ReadonlyArray<LikeC4DiagramModel.Element>;
	incoming(element: ElementOrFqn, filter?: IncomingFilter): ReadonlyArray<LikeC4DiagramModel.Connection>;
	incomers(element: ElementOrFqn, filter?: IncomingFilter): ReadonlyArray<LikeC4DiagramModel.Element>;
	/**
	 * Outgoing relationships from the element and its descendants
	 */
	outgoing(element: ElementOrFqn, filter?: OutgoingFilter): ReadonlyArray<LikeC4DiagramModel.Connection>;
	outgoers(element: ElementOrFqn, filter?: OutgoingFilter): ReadonlyArray<LikeC4DiagramModel.Element>;
}
declare namespace LikeC4DiagramModel {
	/**
	 * Represents an element in the view. (Diagram node)
	 * All methods are view-scoped, i.e. `children` returns only children of the element in the view.
	 */
	class Element {
		readonly node: DiagramNode;
		private readonly view;
		constructor(node: DiagramNode, view: LikeC4DiagramModel);
		get id(): NodeId<string>;
		get title(): string;
		get kind(): ElementKind;
		get isRoot(): boolean;
		get hasNested(): boolean;
		get shape(): ElementShape;
		get color(): Color;
		get tags(): Tag[];
		get level(): number;
		get depth(): number;
		model(): LikeC4Model.ElementModel<LikeC4DiagramModel>;
		parent(): LikeC4DiagramModel.Element | null;
		metadata(key: string): string | undefined;
		metadata(key: string, defaultValue: string): string;
		hasMetadata(key: string): boolean;
		ancestors(): ReadonlyArray<LikeC4DiagramModel.Element>;
		siblings(): ReadonlyArray<LikeC4DiagramModel.Element>;
		descendants(): ReadonlyArray<LikeC4DiagramModel.Element>;
		children(): ReadonlyArray<LikeC4DiagramModel.Element>;
		incoming(filter?: IncomingFilter): ReadonlyArray<LikeC4DiagramModel.Connection>;
		incomers(filter?: IncomingFilter): ReadonlyArray<LikeC4DiagramModel.Element>;
		outgoing(filter?: OutgoingFilter): ReadonlyArray<LikeC4DiagramModel.Connection>;
		outgoers(filter?: OutgoingFilter): ReadonlyArray<LikeC4DiagramModel.Element>;
		connectionsTo(target: Fqn$1 | LikeC4DiagramModel.Element): ReadonlyArray<LikeC4DiagramModel.Connection>;
	}
	/**
	 * Represents a connection between two elements.
	 * May be source from multiple model relationships.
	 */
	class Connection {
		readonly edge: DiagramEdge;
		private readonly view;
		constructor(edge: DiagramEdge, view: LikeC4DiagramModel);
		get id(): EdgeId;
		get source(): LikeC4DiagramModel.Element;
		get target(): LikeC4DiagramModel.Element;
		get tags(): Tag[];
		get color(): Color;
		/**
		 * Model relationships
		 */
		relationships(): ReadonlyArray<LikeC4Model.Relationship<LikeC4DiagramModel>>;
	}
}
interface VariantColorsResolverInput {
	color: MantineColor | undefined;
	theme: MantineTheme;
	variant: string;
	gradient?: MantineGradient;
	autoContrast?: boolean;
}
interface VariantColorResolverResult {
	background: string;
	hover: string;
	color: string;
	border: string;
	hoverColor?: string;
}
type VariantColorsResolver = (input: VariantColorsResolverInput) => VariantColorResolverResult;
interface MantineTheme {
	/** Controls focus ring styles. Supports the following options:
	 *  - `auto` – focus ring is displayed only when the user navigates with keyboard (default value)
	 *  - `always` – focus ring is displayed when the user navigates with keyboard and mouse
	 *  - `never` – focus ring is always hidden (not recommended)
	 */
	focusRing: "auto" | "always" | "never";
	/** Rem units scale, change if you customize font-size of `<html />` element
	 *  default value is `1` (for `100%`/`16px` font-size on `<html />`)
	 */
	scale: number;
	/** Determines whether `font-smoothing` property should be set on the body, `true` by default */
	fontSmoothing: boolean;
	/** White color */
	white: string;
	/** Black color */
	black: string;
	/** Object of colors, key is color name, value is an array of at least 10 strings (colors) */
	colors: MantineThemeColors;
	/** Index of theme.colors[color].
	 *  Primary shade is used in all components to determine which color from theme.colors[color] should be used.
	 *  Can be either a number (0–9) or an object to specify different color shades for light and dark color schemes.
	 *  Default value `{ light: 6, dark: 8 }`
	 *
	 *  For example,
	 *  { primaryShade: 6 } // shade 6 is used both for dark and light color schemes
	 *  { primaryShade: { light: 6, dark: 7 } } // different shades for dark and light color schemes
	 * */
	primaryShade: MantineColorShade | MantinePrimaryShade;
	/** Key of `theme.colors`, hex/rgb/hsl values are not supported.
	 *  Determines which color will be used in all components by default.
	 *  Default value – `blue`.
	 * */
	primaryColor: string;
	/** Function to resolve colors based on variant.
	 *  Can be used to deeply customize how colors are applied to `Button`, `ActionIcon`, `ThemeIcon`
	 *  and other components that use colors from theme.
	 * */
	variantColorResolver: VariantColorsResolver;
	/** Determines whether text color must be changed based on the given `color` prop in filled variant
	 *  For example, if you pass `color="blue.1"` to Button component, text color will be changed to `var(--mantine-color-black)`
	 *  Default value – `false`
	 * */
	autoContrast: boolean;
	/** Determines which luminance value is used to determine if text color should be light or dark.
	 *  Used only if `theme.autoContrast` is set to `true`.
	 *  Default value is `0.3`
	 * */
	luminanceThreshold: number;
	/** Font-family used in all components, system fonts by default */
	fontFamily: string;
	/** Monospace font-family, used in code and other similar components, system fonts by default  */
	fontFamilyMonospace: string;
	/** Controls various styles of h1-h6 elements, used in TypographyStylesProvider and Title components */
	headings: {
		fontFamily: string;
		fontWeight: string;
		textWrap: "wrap" | "nowrap" | "balance" | "pretty" | "stable";
		sizes: {
			h1: HeadingStyle;
			h2: HeadingStyle;
			h3: HeadingStyle;
			h4: HeadingStyle;
			h5: HeadingStyle;
			h6: HeadingStyle;
		};
	};
	/** Object of values that are used to set `border-radius` in all components that support it */
	radius: MantineRadiusValues;
	/** Key of `theme.radius` or any valid CSS value. Default `border-radius` used by most components */
	defaultRadius: MantineRadius;
	/** Object of values that are used to set various CSS properties that control spacing between elements */
	spacing: MantineSpacingValues;
	/** Object of values that are used to control `font-size` property in all components */
	fontSizes: MantineFontSizesValues;
	/** Object of values that are used to control `line-height` property in `Text` component */
	lineHeights: MantineLineHeightValues;
	/** Object of values that are used to control breakpoints in all components,
	 *  values are expected to be defined in em
	 * */
	breakpoints: MantineBreakpointsValues;
	/** Object of values that are used to add `box-shadow` styles to components that support `shadow` prop */
	shadows: MantineShadowsValues;
	/** Determines whether user OS settings to reduce motion should be respected, `false` by default */
	respectReducedMotion: boolean;
	/** Determines which cursor type will be used for interactive elements
	 * - `default` – cursor that is used by native HTML elements, for example, `input[type="checkbox"]` has `cursor: default` styles
	 * - `pointer` – sets `cursor: pointer` on interactive elements that do not have these styles by default
	 */
	cursorType: "default" | "pointer";
	/** Default gradient configuration for components that support `variant="gradient"` */
	defaultGradient: MantineGradient;
	/** Class added to the elements that have active styles, for example, `Button` and `ActionIcon` */
	activeClassName: string;
	/** Class added to the elements that have focus styles, for example, `Button` or `ActionIcon`.
	 *  Overrides `theme.focusRing` property.
	 */
	focusClassName: string;
	/** Allows adding `classNames`, `styles` and `defaultProps` to any component */
	components: MantineThemeComponents;
	/** Any other properties that you want to access with the theme objects */
	other: MantineThemeOther;
}
type MantineThemeOverride = PartialDeep<MantineTheme>;
interface MantineThemeComponent {
	classNames?: any;
	styles?: any;
	vars?: any;
	defaultProps?: any;
}
type MantineThemeComponents = Record<string, MantineThemeComponent>;
interface HeadingStyle {
	fontSize: string;
	fontWeight?: string;
	lineHeight: string;
}
type MantineSize = "xs" | "sm" | "md" | "lg" | "xl";
type MantineBreakpointsValues = Record<MantineSize | (string & {}), string>;
type MantineFontSizesValues = Record<MantineSize | (string & {}), string>;
type MantineRadiusValues = Record<MantineSize | (string & {}), string>;
type MantineSpacingValues = Record<MantineSize | (string & {}), string>;
type MantineShadowsValues = Record<MantineSize | (string & {}), string>;
type MantineLineHeightValues = Record<MantineSize | (string & {}), string>;
type MantineRadius = keyof MantineRadiusValues | (string & {}) | number;
interface MantineThemeOther {
	[key: string]: any;
}
interface MantineGradient {
	from: string;
	to: string;
	deg?: number;
}
type MantineColorsTuple = readonly [
	string,
	string,
	string,
	string,
	string,
	string,
	string,
	string,
	string,
	string,
	...string[]
];
type MantineColorShade = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
interface MantinePrimaryShade {
	light: MantineColorShade;
	dark: MantineColorShade;
}
type DefaultMantineColor = "dark" | "gray" | "red" | "pink" | "grape" | "violet" | "indigo" | "blue" | "cyan" | "green" | "lime" | "yellow" | "orange" | "teal" | (string & {});
interface MantineThemeColorsOverride {
}
type MantineThemeColors = MantineThemeColorsOverride extends {
	colors: Record<infer CustomColors, MantineColorsTuple>;
} ? Record<CustomColors, MantineColorsTuple> : Record<DefaultMantineColor, MantineColorsTuple>;
type MantineColor = keyof MantineThemeColors;
export type ViewData<ViewId extends string> = Omit<DiagramView, "id"> & {
	id: ViewId;
};
type ElementIconRendererProps = {
	node: {
		id: string;
		title: string;
		icon?: string | undefined;
	};
};
export type ElementIconRenderer = (props: ElementIconRendererProps) => ReactNode;
export type LikeC4ViewProps<ViewId extends string, Tag extends string, Kind extends string> = {
	/**
	 * View to display.
	 */
	viewId: ViewId;
	/**
	 * Background pattern
	 * @default 'transparent'
	 */
	background?: "dots" | "lines" | "cross" | "transparent" | "solid" | undefined;
	/**
	 * Background pattern for the browser view.
	 * @default 'dots'
	 */
	browserBackground?: "dots" | "lines" | "cross" | "transparent" | "solid" | undefined;
	/**
	 * Click on the view opens a modal with browser.
	 *
	 * @default true
	 */
	interactive?: boolean;
	/**
	 * By default determined by the user's system preferences.
	 */
	colorScheme?: "light" | "dark" | undefined;
	/**
	 * LikeC4 views are using 'IBM Plex Sans' font.
	 * By default, component injects the CSS to document head.
	 * Set to false if you want to handle the font yourself.
	 *
	 * @default true
	 */
	injectFontCss?: boolean | undefined;
	/**
	 * Display webview with diagram title / description
	 * @default false
	 */
	showDiagramTitle?: boolean | undefined;
	/**
	 * Show back/forward navigation buttons
	 * @default false
	 */
	showNavigationButtons?: undefined | boolean;
	/**
	 * Display notations of the view
	 * @default false
	 */
	showNotations?: boolean | undefined;
	/**
	 * If double click on a node should enable focus mode, i.e. highlight incoming/outgoing edges
	 * Conflicts with `interactive`
	 *
	 * @default false
	 */
	enableFocusMode?: boolean | undefined;
	/**
	 * Enable popup with element details
	 * @default false
	 */
	enableElementDetails?: boolean | undefined;
	/**
	 * Experimental feature to browse relationships
	 *
	 * @default enableElementDetails
	 */
	enableRelationshipBrowser?: boolean | undefined;
	/**
	 * Display dropdown with details on relationship's label click
	 * @default enableRelationshipBrowser
	 */
	enableRelationshipDetails?: boolean | undefined;
	where?: WhereOperator<Tag, Kind> | undefined;
	className?: string | undefined;
	style?: CSSProperties | undefined;
	browserClassName?: string | undefined;
	browserStyle?: CSSProperties | undefined;
	mantineTheme?: MantineThemeOverride | undefined;
	/** Function to generate nonce attribute added to all generated `<style />` tags */
	styleNonce?: string | (() => string) | undefined;
};
export type LikeC4BrowserProps<ViewId extends string, Tag extends string, Kind extends string> = Pick<HTMLAttributes<HTMLDialogElement>, "style" | "className"> & {
	view: ViewData<ViewId>;
	/**
	 * By default determined by the user's system preferences.
	 */
	colorScheme?: "light" | "dark";
	/**
	 * LikeC4 views are using 'IBM Plex Sans' font.
	 * By default, component injects the CSS to document head.
	 * Set to false if you want to handle the font yourself.
	 *
	 * @default true
	 */
	injectFontCss?: boolean | undefined;
	/**
	 * Background pattern
	 * @default 'dots'
	 */
	background?: "dots" | "lines" | "cross" | "transparent" | "solid" | undefined;
	onNavigateTo: (to: ViewId) => void;
	onClose: () => void;
	/**
	 * Render custom icon for a node
	 * By default, if icon is http:// or https://, it will be rendered as an image
	 */
	renderIcon?: ElementIconRenderer | undefined;
	where?: WhereOperator<Tag, Kind> | undefined;
	mantineTheme?: MantineThemeOverride | undefined;
	/** Function to generate nonce attribute added to all generated `<style />` tags */
	styleNonce?: string | (() => string) | undefined;
	/**
	 * Enable popup with element details
	 * @default true
	 */
	enableElementDetails?: boolean | undefined;
	/**
	 * Experimental feature to browse relationships
	 *
	 * @default enableElementDetails
	 */
	enableRelationshipBrowser?: boolean | undefined;
	/**
	 * Display dropdown with details on relationship's label click
	 * @default enableRelationshipBrowser
	 */
	enableRelationshipDetails?: boolean | undefined;
};
export declare function LikeC4Browser<ViewId extends string = string, Tag extends string = string, Kind extends string = string>({ className, colorScheme, view, injectFontCss, onNavigateTo, onClose, renderIcon, where, style, mantineTheme, background, styleNonce, enableElementDetails, enableRelationshipBrowser, enableRelationshipDetails }: LikeC4BrowserProps<ViewId, Tag, Kind>): import("react/jsx-runtime").JSX.Element;
export type LikeC4ViewEmbeddedProps<ViewId extends string, Tag extends string, Kind extends string> = Pick<HTMLAttributes<HTMLDivElement>, "style" | "className"> & {
	view: ViewData<ViewId>;
	/**
	 * By default determined by the user's system preferences.
	 */
	colorScheme?: "light" | "dark";
	/**
	 * LikeC4 views are using 'IBM Plex Sans' font.
	 * By default, component injects the CSS to document head.
	 * Set to false if you want to handle the font yourself.
	 *
	 * @default true
	 */
	injectFontCss?: boolean | undefined;
	/**
	 * Background pattern
	 * @default 'transparent'
	 */
	background?: "dots" | "lines" | "cross" | "transparent" | "solid" | undefined;
	onNavigateTo?: ((to: ViewId) => void) | undefined;
	/**
	 * Render custom icon for a node
	 * By default, if icon is http:// or https://, it will be rendered as an image
	 */
	renderIcon?: ElementIconRenderer | undefined;
	/**
	 * Display webview with diagram title / description
	 * @default false
	 */
	showDiagramTitle?: boolean | undefined;
	/**
	 * Show back/forward navigation buttons
	 * @default false
	 */
	showNavigationButtons?: undefined | boolean;
	/**
	 * Display notations of the view
	 * @default false
	 */
	showNotations?: boolean | undefined;
	/**
	 * If double click on a node should enable focus mode, i.e. highlight incoming/outgoing edges
	 * @default false
	 */
	enableFocusMode?: boolean | undefined;
	where?: WhereOperator<Tag, Kind> | undefined;
	mantineTheme?: MantineThemeOverride | undefined;
	/** Function to generate nonce attribute added to all generated `<style />` tags */
	styleNonce?: string | (() => string) | undefined;
	/**
	 * Enable popup with element details
	 * @default false
	 */
	enableElementDetails?: boolean | undefined;
	/**
	 * Experimental feature to browse relationships
	 *
	 * @default enableElementDetails
	 */
	enableRelationshipBrowser?: boolean | undefined;
	/**
	 * Display dropdown with details on relationship's label click
	 * @default enableRelationshipBrowser
	 */
	enableRelationshipDetails?: boolean | undefined;
};
export declare function LikeC4ViewEmbedded<ViewId extends string = string, Tag extends string = string, Kind extends string = string>({ onNavigateTo: _onNavigateTo, className, view, injectFontCss, colorScheme, background, renderIcon, showDiagramTitle, showNavigationButtons, enableFocusMode, showNotations, enableElementDetails, enableRelationshipDetails, enableRelationshipBrowser, mantineTheme, where, style, styleNonce }: LikeC4ViewEmbeddedProps<ViewId, Tag, Kind>): import("react/jsx-runtime").JSX.Element;
declare enum BackgroundVariant {
	Lines = "lines",
	Dots = "dots",
	Cross = "cross"
}
type BackgroundProps = {
	id?: string;
	/** Color of the pattern */
	color?: string;
	/** Color of the background */
	bgColor?: string;
	/** Class applied to the container */
	className?: string;
	/** Class applied to the pattern */
	patternClassName?: string;
	/** Gap between repetitions of the pattern */
	gap?: number | [
		number,
		number
	];
	/** Size of a single pattern element */
	size?: number;
	/** Offset of the pattern */
	offset?: number | [
		number,
		number
	];
	/** Line width of the Line pattern */
	lineWidth?: number;
	/** Variant of the pattern
	 * @example BackgroundVariant.Lines, BackgroundVariant.Dots, BackgroundVariant.Cross
	 * 'lines', 'dots', 'cross'
	 */
	variant?: BackgroundVariant;
	/** Style applied to the container */
	style?: CSSProperties;
};
type XYBackgroundVariant = "dots" | "lines" | "cross";
type XYBackground = XYBackgroundVariant | OverrideProperties<BackgroundProps, {
	variant: XYBackgroundVariant;
}>;
type DiagramNodeWithNavigate<ID extends string = ViewID> = Omit<DiagramNode, "navigateTo"> & {
	navigateTo: ID;
};
type ElementIconNodeProps = {
	id: string;
	title: string;
	icon?: string | undefined;
};
type ElementIconRenderer$1 = (props: {
	node: ElementIconNodeProps;
}) => ReactNode;
type OnNavigateTo<ID extends string = ViewID> = (to: ID, event?: ReactMouseEvent, element?: DiagramNodeWithNavigate<ID>) => void;
type OnNodeClick = (node: DiagramNode, event: ReactMouseEvent) => void;
type OnEdgeClick = (edge: DiagramEdge, event: ReactMouseEvent) => void;
type OnCanvasClick = (event: ReactMouseEvent) => void;
type ChangeEvent = {
	change: ViewChange;
};
type OnChange = (event: ChangeEvent) => void;
interface LikeC4DiagramProperties {
	view: DiagramView;
	className?: string | undefined;
	/**
	 * Enable/disable panning
	 * @default true
	 */
	pannable?: boolean | undefined;
	/**
	 * Enable/disable zooming
	 * @default true
	 */
	zoomable?: boolean | undefined;
	/**
	 * Disable any editing (dragging still can be enabled with `nodesDraggable`)
	 * @default true
	 */
	readonly?: boolean | undefined;
	/**
	 * Show/hide panel with top left controls,
	 *
	 * @default true if not readonly
	 */
	controls?: boolean | undefined;
	/**
	 * If set, initial viewport will show all nodes & edges
	 * @default true
	 */
	fitView?: boolean | undefined;
	/**
	 * Seems like this is percentage of the view size
	 * @default 0
	 */
	fitViewPadding?: number | undefined;
	/**
	 * @default false if readonly
	 */
	nodesSelectable?: boolean | undefined;
	/**
	 * @default false if readonly
	 */
	nodesDraggable?: boolean | undefined;
	initialWidth?: number | undefined;
	initialHeight?: number | undefined;
	/**
	 * Keep aspect ratio of the diagram
	 * @default false
	 */
	keepAspectRatio?: boolean | undefined;
	/**
	 * Background pattern
	 * @default 'dots'
	 */
	background?: "transparent" | "solid" | XYBackground | undefined;
	/**
	 * Display webview with diagram title / description
	 * @default true
	 */
	showDiagramTitle?: boolean | undefined;
	/**
	 * Show back/forward history navigation buttons
	 * @default true if `onNavigateTo` is set
	 */
	showNavigationButtons?: undefined | boolean;
	/**
	 * Display notations of the view
	 * @default true
	 */
	showNotations?: boolean | undefined;
	/**
	 * Display dropdown with details on relationship's label click
	 * @default false
	 */
	enableRelationshipDetails?: boolean | undefined;
	/**
	 * If double click on a node should enable focus mode, i.e. highlight incoming/outgoing edges
	 * @default false
	 */
	enableFocusMode?: boolean | undefined;
	/**
	 * Enable search popup for elements and views
	 * @default true
	 */
	enableSearch?: boolean | undefined;
	/**
	 * Enable modal with element details
	 * @default false
	 */
	enableElementDetails?: boolean | undefined;
	/**
	 * Experimental feature to browse relationships
	 *
	 * @default false
	 */
	enableRelationshipBrowser?: boolean | undefined;
	/**
	 * If Walkthrough for dynamic views should be enabled
	 * @default false
	 */
	enableDynamicViewWalkthrough?: boolean | undefined;
	/**
	 * Experimental feature to enable edge editing
	 * @default false
	 */
	experimentalEdgeEditing?: boolean | undefined;
	/**
	 * Render icon for an element, bundled or remote
	 * By default, if icon is http:// or https://, it will be rendered as an image
	 */
	renderIcon?: ElementIconRenderer$1 | undefined;
	/**
	 * Dynamic filter, applies both to nodes and edges
	 */
	where?: WhereOperator<string, string> | undefined;
}
interface LikeC4DiagramEventHandlers {
	onChange?: OnChange | null | undefined;
	onNavigateTo?: OnNavigateTo | null | undefined;
	onNodeClick?: OnNodeClick | null | undefined;
	onNodeContextMenu?: OnNodeClick | null | undefined;
	onCanvasContextMenu?: OnCanvasClick | null | undefined;
	onEdgeClick?: OnEdgeClick | null | undefined;
	onEdgeContextMenu?: OnEdgeClick | null | undefined;
	onCanvasClick?: OnCanvasClick | null | undefined;
	onCanvasDblClick?: OnCanvasClick | null | undefined;
	onBurgerMenuClick?: null | undefined | (() => void);
	onOpenSourceView?: null | undefined | (() => void);
	onOpenSourceElement?: null | undefined | ((fqn: Fqn) => void);
	onOpenSourceRelation?: null | undefined | ((id: RelationID) => void);
}
type LikeC4DiagramProps = LikeC4DiagramProperties & LikeC4DiagramEventHandlers;
export declare function useLikeC4Model(): LikeC4Model | null;
export declare function useLikeC4Model(strict: true): LikeC4Model;
export declare function useLikeC4Model(strict: boolean): LikeC4Model | null;
export declare function useLikeC4Model(strict: true, type: "layouted"): LikeC4Model.Layouted;
export declare function useLikeC4Model(strict: true, type: "computed"): LikeC4Model.Computed;
export declare function useLikeC4Model(strict: true, type: LikeC4Model["type"] | undefined): LikeC4Model;
export declare function useLikeC4Model(strict: boolean, type: "layouted"): LikeC4Model.Layouted | null;
export declare function useLikeC4Model(strict: boolean, type: "computed"): LikeC4Model.Computed | null;
export declare function useLikeC4Model(strict: boolean, type: LikeC4Model["type"] | undefined): LikeC4Model | null;
export declare function useLikeC4Views(): LikeC4Model.SourceModel["views"];
export declare function useLikeC4ViewModel(viewId: LiteralUnion<ViewID, string>): LikeC4Model.ViewModel;
/**
 * Parsed view, computed or layouted
 */
export declare function useLikeC4View(viewId: LiteralUnion<ViewID, string>): ComputedView | DiagramView | null;
export declare function useLikeC4DiagramView(viewId: LiteralUnion<ViewID, string>): DiagramView | null;
type LikeC4ModelProviderProps = PropsWithChildren<{
	likec4model: LikeC4Model;
}>;
/**
 * Ensures LikeC4Model context
 */
export declare function LikeC4ModelProvider({ children, likec4model }: LikeC4ModelProviderProps): import("react/jsx-runtime").JSX.Element;
export type ReactLikeC4Props<ViewId extends string, Tag extends string, Kind extends string> = Omit<LikeC4DiagramProps, "view" | "where" | "onNavigateTo"> & {
	view: ViewData<ViewId>;
	/**
	 * Keep aspect ratio of the diagram
	 * Disable if you need to manage the viewport (use className)
	 *
	 * @default true
	 */
	keepAspectRatio?: boolean | undefined;
	/**
	 * By default determined by the user's system preferences.
	 */
	colorScheme?: "light" | "dark" | undefined;
	/**
	 * LikeC4 views are using 'IBM Plex Sans' font.
	 * By default, component injects the CSS to document head.
	 * Set to false if you want to handle the font yourself.
	 *
	 * @default true
	 */
	injectFontCss?: boolean | undefined;
	style?: CSSProperties | undefined;
	where?: WhereOperator<Tag, Kind> | undefined;
	onNavigateTo?: OnNavigateTo<ViewId> | undefined;
	mantineTheme?: MantineThemeOverride | undefined;
	/** Function to generate nonce attribute added to all generated `<style />` tags */
	styleNonce?: string | (() => string) | undefined;
};
export declare function ReactLikeC4<ViewId extends string = string, Tag extends string = string, Kind extends string = string>({ className, view, colorScheme: explicitColorScheme, injectFontCss, keepAspectRatio, showNotations, onNavigateTo, background, style, mantineTheme, styleNonce, ...props }: ReactLikeC4Props<ViewId, Tag, Kind>): import("react/jsx-runtime").JSX.Element;
export declare namespace ReactLikeC4 {
	var displayName: string;
}
type AllKeys<T> = T extends any ? keyof T : never;
type Primitive = boolean | number | string;
type ReadonlyIfObject<Value> = Value extends undefined ? Value : Value extends (...args: any) => any ? Value : Value extends Primitive ? Value : Value extends object ? Readonly<Value> : Value;
interface ReadableAtom<Value = any> {
	/**
	 * Get store value.
	 *
	 * In contrast with {@link ReadableAtom#value} this value will be always
	 * initialized even if store had no listeners.
	 *
	 * ```js
	 * $store.get()
	 * ```
	 *
	 * @returns Store value.
	 */
	get(): Value;
	/**
	 * Listeners count.
	 */
	readonly lc: number;
	/**
	 * Subscribe to store changes.
	 *
	 * In contrast with {@link Store#subscribe} it do not call listener
	 * immediately.
	 *
	 * @param listener Callback with store value and old value.
	 * @returns Function to remove listener.
	 */
	listen(listener: (value: ReadonlyIfObject<Value>, oldValue: ReadonlyIfObject<Value>) => void): () => void;
	/**
	 * Low-level method to notify listeners about changes in the store.
	 *
	 * Can cause unexpected behaviour when combined with frontend frameworks
	 * that perform equality checks for values, such as React.
	 */
	notify(oldValue?: ReadonlyIfObject<Value>): void;
	/**
	 * Unbind all listeners.
	 */
	off(): void;
	/**
	 * Subscribe to store changes and call listener immediately.
	 *
	 * ```
	 * import { $router } from '../store'
	 *
	 * $router.subscribe(page => {
	 *   console.log(page)
	 * })
	 * ```
	 *
	 * @param listener Callback with store value and old value.
	 * @returns Function to remove listener.
	 */
	subscribe(listener: (value: ReadonlyIfObject<Value>, oldValue?: ReadonlyIfObject<Value>) => void): () => void;
	/**
	 * Low-level method to read store’s value without calling `onStart`.
	 *
	 * Try to use only {@link ReadableAtom#get}.
	 * Without subscribers, value can be undefined.
	 */
	readonly value: undefined | Value;
}
interface WritableAtom<Value = any> extends ReadableAtom<Value> {
	/**
	 * Change store value.
	 *
	 * ```js
	 * $router.set({ path: location.pathname, page: parse(location.pathname) })
	 * ```
	 *
	 * @param newValue New store value.
	 */
	set(newValue: Value): void;
}
interface PreinitializedWritableAtom<Value extends any> extends WritableAtom<Value> {
	readonly value: Value;
}
declare function atom<Value, StoreExt = {}>(...args: undefined extends Value ? [
] | [
	Value
] : [
	Value
]): PreinitializedWritableAtom<Value> & StoreExt;
type KeyofBase = keyof any;
type Get<T, K extends KeyofBase> = Extract<T, {
	[K1 in K]: any;
}>[K];
type WritableStore<Value = any> = (Value extends object ? MapStore<Value> : never) | WritableAtom<Value>;
type Store<Value = any> = ReadableAtom<Value> | WritableStore<Value>;
type AnyStore<Value = any> = {
	get(): Value;
	readonly value: undefined | Value;
};
type StoreValue<SomeStore> = SomeStore extends {
	get(): infer Value;
} ? Value : any;
interface MapStore<Value extends object = any> extends WritableAtom<Value> {
	/**
	 * Subscribe to store changes.
	 *
	 * In contrast with {@link Store#subscribe} it do not call listener
	 * immediately.
	 *
	 * @param listener Callback with store value and old value.
	 * @param changedKey Key that was changed. Will present only if `setKey`
	 *                   has been used to change a store.
	 * @returns Function to remove listener.
	 */
	listen(listener: (value: ReadonlyIfObject<Value>, oldValue: ReadonlyIfObject<Value>, changedKey: AllKeys<Value>) => void): () => void;
	/**
	 * Low-level method to notify listeners about changes in the store.
	 *
	 * Can cause unexpected behaviour when combined with frontend frameworks
	 * that perform equality checks for values, such as React.
	 */
	notify(oldValue?: ReadonlyIfObject<Value>, changedKey?: AllKeys<Value>): void;
	/**
	 * Change store value.
	 *
	 * ```js
	 * $settings.set({ theme: 'dark' })
	 * ```
	 *
	 * Operation is atomic, subscribers will be notified once with the new value.
	 * `changedKey` will be undefined
	 *
	 * @param newValue New store value.
	 */
	set(newValue: Value): void;
	/**
	 * Change key in store value.
	 *
	 * ```js
	 * $settings.setKey('theme', 'dark')
	 * ```
	 *
	 * To delete key set `undefined`.
	 *
	 * ```js
	 * $settings.setKey('theme', undefined)
	 * ```
	 *
	 * @param key The key name.
	 * @param value New value.
	 */
	setKey<Key extends AllKeys<Value>>(key: Key, value: Get<Value, Key> | Value[Key]): void;
	/**
	 * Subscribe to store changes and call listener immediately.
	 *
	 * ```
	 * import { $router } from '../store'
	 *
	 * $router.subscribe(page => {
	 *   console.log(page)
	 * })
	 * ```
	 *
	 * @param listener Callback with store value and old value.
	 * @param changedKey Key that was changed. Will present only
	 *                   if `setKey` has been used to change a store.
	 * @returns Function to remove listener.
	 */
	subscribe(listener: (value: ReadonlyIfObject<Value>, oldValue: ReadonlyIfObject<Value> | undefined, changedKey: AllKeys<Value> | undefined) => void): () => void;
}
interface PreinitializedMapStore<Value extends object = any> extends MapStore<Value> {
	readonly value: Value;
}
declare function map<Value extends object, StoreExt extends object = {}>(value?: Value): PreinitializedMapStore<Value> & StoreExt;
interface Task<Value> extends Promise<Value> {
	t: true;
}
type StoreValues<Stores extends AnyStore[]> = {
	[Index in keyof Stores]: StoreValue<Stores[Index]>;
};
interface Computed {
	<Value extends any, OriginStore extends Store>(stores: OriginStore, cb: (value: StoreValue<OriginStore>) => Task<Value>): ReadableAtom<undefined | Value>;
	<Value extends any, OriginStores extends AnyStore[]>(stores: [
		...OriginStores
	], cb: (...values: StoreValues<OriginStores>) => Task<Value>): ReadableAtom<undefined | Value>;
	<Value extends any, OriginStore extends Store>(stores: OriginStore, cb: (value: StoreValue<OriginStore>) => Value): ReadableAtom<Value>;
	/**
	 * Create derived store, which use generates value from another stores.
	 *
	 * ```js
	 * import { computed } from 'nanostores'
	 *
	 * import { $users } from './users.js'
	 *
	 * export const $admins = computed($users, users => {
	 *   return users.filter(user => user.isAdmin)
	 * })
	 * ```
	 *
	 * An async function can be evaluated by using {@link task}.
	 *
	 * ```js
	 * import { computed, task } from 'nanostores'
	 *
	 * import { $userId } from './users.js'
	 *
	 * export const $user = computed($userId, userId => task(async () => {
	 *   const response = await fetch(`https://my-api/users/${userId}`)
	 *   return response.json()
	 * }))
	 * ```
	 */
	<Value extends any, OriginStores extends AnyStore[]>(stores: [
		...OriginStores
	], cb: (...values: StoreValues<OriginStores>) => Task<Value> | Value): ReadableAtom<Value>;
}
declare const computed: Computed;
type StoreKeys<T> = T extends {
	setKey: (k: infer K, v: any) => unknown;
} ? K : never;
interface UseStoreOptions<SomeStore> {
	/**
	 * @default
	 * ```ts
	 * [store, options.keys]
	 * ```
	 */
	deps?: DependencyList;
	/**
	 * Will re-render components only on specific key changes.
	 */
	keys?: StoreKeys<SomeStore>[];
}
declare function useStore<SomeStore extends Store>(store: SomeStore, options?: UseStoreOptions<SomeStore>): StoreValue<SomeStore>;
export declare const DefaultTheme: MantineThemeOverride;
export declare const BundledStyles: () => any;
export declare function useBundledStyleSheet(injectFontCss: boolean, styleNonce?: string | (() => string) | undefined): CSSStyleSheet[];
type ColorScheme = "light" | "dark";
export declare function useColorScheme(explicit?: ColorScheme): ColorScheme;
/**
 * We need this function to bundle LikeC4Model with `likec4/react'
 * Used by vite plugin to generate `virtual:likec4/model`
 */
export declare function createLikeC4Model(model: LayoutedLikeC4Model): LikeC4Model.Layouted;

declare namespace nano {
	export { atom, computed, map, useStore };
}

export {
	nano,
};

export {};
